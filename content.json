{"meta":{"title":"墨码山河","subtitle":"代码改变世界","description":"代码改变世界","author":"墨码山河","url":"https://momashanhe.com","root":"/"},"pages":[{"title":"分类","date":"2024-02-25T13:45:11.000Z","updated":"2024-03-10T03:45:36.241Z","comments":true,"path":"categories/index.html","permalink":"https://momashanhe.com/categories/index.html","excerpt":"","text":""},{"title":"专栏","date":"2024-02-29T02:12:36.000Z","updated":"2025-07-30T07:35:11.710Z","comments":true,"path":"groups/index.html","permalink":"https://momashanhe.com/groups/index.html","excerpt":"整理归纳，搭建系统。","text":"整理归纳，搭建系统。 建站技术:Hexo:搭建建站技术:Hexo:折腾前端:HTML:基础前端:CSS:基础前端:CSS:技巧前端:CSS:预处理前端:CSS:框架前端:JS:基础前端:JS:技巧前端:JS:扩展前端:Node:基础前端:Node:进阶前端:Node:数据库后端:Java:基础后端:Java:高级后端:Java:并发后端:Java:虚拟机后端:Java:数据库数据库:MongoDB:基础数据库:MongoDB:高级数据库:MySQL:基础数据库:MySQL:高级"},{"title":"生活记录:日记:2024","date":"2024-03-14T05:15:32.000Z","updated":"2025-06-21T08:44:46.286Z","comments":true,"path":"groups/A01001/index.html","permalink":"https://momashanhe.com/groups/A01001/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-02-25T13:53:29.000Z","updated":"2024-03-10T03:12:38.918Z","comments":true,"path":"tags/index.html","permalink":"https://momashanhe.com/tags/index.html","excerpt":"","text":""},{"title":"生活记录:日记:2025","date":"2024-03-16T04:27:18.000Z","updated":"2025-06-21T08:45:04.593Z","comments":true,"path":"groups/A01002/index.html","permalink":"https://momashanhe.com/groups/A01002/index.html","excerpt":"","text":""},{"title":"建站技术:Hexo:搭建","date":"2024-02-29T11:50:06.000Z","updated":"2025-06-21T08:49:48.937Z","comments":true,"path":"groups/B01001/index.html","permalink":"https://momashanhe.com/groups/B01001/index.html","excerpt":"","text":""},{"title":"建站技术:Hexo:折腾","date":"2024-02-29T12:52:36.000Z","updated":"2025-06-21T08:49:48.501Z","comments":true,"path":"groups/B01002/index.html","permalink":"https://momashanhe.com/groups/B01002/index.html","excerpt":"","text":""},{"title":"前端:HTML:基础","date":"2024-03-31T00:12:26.000Z","updated":"2025-06-21T08:57:43.043Z","comments":true,"path":"groups/C01001/index.html","permalink":"https://momashanhe.com/groups/C01001/index.html","excerpt":"","text":""},{"title":"前端:CSS:基础","date":"2024-04-02T03:53:12.000Z","updated":"2025-06-21T08:57:43.043Z","comments":true,"path":"groups/C02001/index.html","permalink":"https://momashanhe.com/groups/C02001/index.html","excerpt":"","text":""},{"title":"前端:CSS:技巧","date":"2024-04-07T00:12:31.000Z","updated":"2025-06-21T08:57:43.043Z","comments":true,"path":"groups/C02002/index.html","permalink":"https://momashanhe.com/groups/C02002/index.html","excerpt":"","text":""},{"title":"前端:CSS:预处理","date":"2024-05-19T00:46:13.000Z","updated":"2025-06-21T08:57:42.444Z","comments":true,"path":"groups/C02003/index.html","permalink":"https://momashanhe.com/groups/C02003/index.html","excerpt":"","text":""},{"title":"前端:CSS:框架","date":"2025-04-05T00:15:47.000Z","updated":"2025-06-21T08:57:43.043Z","comments":true,"path":"groups/C02004/index.html","permalink":"https://momashanhe.com/groups/C02004/index.html","excerpt":"","text":""},{"title":"前端:JS:基础","date":"2024-06-27T08:03:31.000Z","updated":"2025-06-21T08:57:43.043Z","comments":true,"path":"groups/C03001/index.html","permalink":"https://momashanhe.com/groups/C03001/index.html","excerpt":"","text":""},{"title":"前端:JS:技巧","date":"2024-08-02T07:02:44.000Z","updated":"2025-06-21T08:57:43.042Z","comments":true,"path":"groups/C03002/index.html","permalink":"https://momashanhe.com/groups/C03002/index.html","excerpt":"","text":""},{"title":"前端:JS:扩展","date":"2025-01-17T03:53:23.000Z","updated":"2025-06-21T08:57:43.042Z","comments":true,"path":"groups/C03003/index.html","permalink":"https://momashanhe.com/groups/C03003/index.html","excerpt":"","text":""},{"title":"前端:Node:进阶","date":"2025-03-12T06:06:39.000Z","updated":"2025-06-21T08:57:42.446Z","comments":true,"path":"groups/C04002/index.html","permalink":"https://momashanhe.com/groups/C04002/index.html","excerpt":"","text":""},{"title":"前端:Node:基础","date":"2025-02-14T06:41:25.000Z","updated":"2025-06-21T08:57:42.993Z","comments":true,"path":"groups/C04001/index.html","permalink":"https://momashanhe.com/groups/C04001/index.html","excerpt":"","text":""},{"title":"前端:Node:数据库","date":"2025-04-01T05:31:26.000Z","updated":"2025-06-21T08:57:42.446Z","comments":true,"path":"groups/C04003/index.html","permalink":"https://momashanhe.com/groups/C04003/index.html","excerpt":"","text":""},{"title":"后端:Java:基础","date":"2025-04-22T05:47:54.000Z","updated":"2025-06-21T08:58:50.857Z","comments":true,"path":"groups/D01001/index.html","permalink":"https://momashanhe.com/groups/D01001/index.html","excerpt":"","text":""},{"title":"后端:Java:高级","date":"2025-04-30T01:33:21.000Z","updated":"2025-06-21T08:58:50.857Z","comments":true,"path":"groups/D01002/index.html","permalink":"https://momashanhe.com/groups/D01002/index.html","excerpt":"","text":""},{"title":"后端:Java:并发","date":"2025-07-02T17:50:29.000Z","updated":"2025-07-02T17:50:57.535Z","comments":true,"path":"groups/D01003/index.html","permalink":"https://momashanhe.com/groups/D01003/index.html","excerpt":"","text":""},{"title":"后端:Java:数据库","date":"2025-07-01T01:06:51.000Z","updated":"2025-07-02T17:50:21.119Z","comments":true,"path":"groups/D01005/index.html","permalink":"https://momashanhe.com/groups/D01005/index.html","excerpt":"","text":""},{"title":"数据库:MongoDB:基础","date":"2025-03-17T05:10:55.000Z","updated":"2025-06-21T09:07:48.988Z","comments":true,"path":"groups/E01001/index.html","permalink":"https://momashanhe.com/groups/E01001/index.html","excerpt":"","text":""},{"title":"数据库:MongoDB:高级","date":"2025-03-24T01:49:35.000Z","updated":"2025-06-21T09:07:49.430Z","comments":true,"path":"groups/E01002/index.html","permalink":"https://momashanhe.com/groups/E01002/index.html","excerpt":"","text":""},{"title":"数据库:MySQL:基础","date":"2025-05-12T07:58:33.000Z","updated":"2025-06-21T09:07:48.984Z","comments":true,"path":"groups/E02001/index.html","permalink":"https://momashanhe.com/groups/E02001/index.html","excerpt":"","text":""},{"title":"数据库:MySQL:高级","date":"2025-05-30T23:56:28.000Z","updated":"2025-06-21T09:07:48.988Z","comments":true,"path":"groups/E02002/index.html","permalink":"https://momashanhe.com/groups/E02002/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-02-25T14:31:08.000Z","updated":"2024-03-10T03:12:17.376Z","comments":true,"path":"pages/about/index.html","permalink":"https://momashanhe.com/pages/about/index.html","excerpt":"简简单单，平平凡凡。","text":"简简单单，平平凡凡。"},{"title":"留言板","date":"2024-03-08T10:58:49.000Z","updated":"2024-03-10T03:12:22.265Z","comments":true,"path":"pages/board/index.html","permalink":"https://momashanhe.com/pages/board/index.html","excerpt":"遵纪守法，友善发言。","text":"遵纪守法，友善发言。"},{"title":"通讯录","date":"2024-02-25T14:23:13.000Z","updated":"2024-04-22T01:34:50.491Z","comments":true,"path":"pages/friend/index.html","permalink":"https://momashanhe.com/pages/friend/index.html","excerpt":"红尘漫漫，增减随缘。","text":"红尘漫漫，增减随缘。 名片夹大佬大佬的博客Akilarの糖果屋期待您的光临！安知鱼生活明朗，万物可爱xaoxuu风暴前夕BeaCoxOn the way to be a hacker.失联失联的博客测试测试友链测试测试友链测试测试友链测试测试友链 个人名片card12345title: 墨码山河avatar: url: https://momashanhe.com/screenshot: description: 代码改变世界 建议avatar使用分辨率为200px的图片。建议screenshot使用https://image.thum.io/get/width/400/crop/800/allowJPG/wait/20/noanimate/https://momashanhe.com/网站生成的图片。 用户须知 免责声明 本站作者遵守中华人民共和国相关法律，本页内容中的网站链接仅为方便学习而创建，均为其他网站。虽然本站作者会对绝大多数的网站内容进行鉴别，并取消存在风险的网站链接。但因本站作者能力有限，无法判断网站链接指向的网站内容是否存在安全问题，并且无法判断在收录后是否增加了违法内容。故而用户在通过本页内容中的网站链接访问其他网站时，仍然无法避免风险，包括但不限于：网站链接的网站作者更换了网站链接的指向，替换成了其他内容；网站链接的网站作者修改了文章内容，增加了钓鱼网站、广告等其他无效信息；网站链接的服务器被恶意攻击、劫持、注入了其他内容；网站链接的域名到期，被不法分子改做他用；网站链接的规则不完善，对用户的隐私造成了侵害、泄漏。本页内容中的文章链接均为机器自动抓取，本站作者未经过任何审核和筛选，不能保证文章内容的安全可靠。本页内容中的网站链接指向的网站内容如果给用户造成了损失，本站作者深表歉意，建议用户如果发现问题请及时和本站作者联系，避免给更多用户造成损失。"},{"title":"后端:Java:虚拟机","date":"2025-07-30T07:34:52.000Z","updated":"2025-07-30T07:34:58.638Z","comments":true,"path":"groups/D01004/index.html","permalink":"https://momashanhe.com/groups/D01004/index.html","excerpt":"","text":""}],"posts":[{"title":"垃圾回收","slug":"D00-后端/D01-Java/004-虚拟机/004-垃圾回收","date":"2025-08-03T11:48:43.000Z","updated":"2025-08-06T03:49:14.873Z","comments":true,"path":"posts/20250803/194843/","permalink":"https://momashanhe.com/posts/20250803/194843/","excerpt":"摘要：本文主要学习了虚拟机的垃圾回收机制。","text":"摘要：本文主要学习了虚拟机的垃圾回收机制。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 垃圾回收1.1 定义垃圾回收机制是由垃圾收集器GC（Garbage Collection）实现的，GC是后台的守护进程。 GC的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况调整优先级，在内存低到一定限度时会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。 1.2 发生位置JVM的内存结构包括五大区域：程序计数器、本地方法栈、虚拟机栈、堆区、方法区。 程序计数器、本地方法栈、虚拟机栈三个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。 1.3 内存泄漏内存泄漏指的是无法回收不再使用的对象，导致内存中没有空闲空间。 内存泄漏的八种情况： 单例模式，单例模式中的对象生命周期和应用程序是一样长的，如果单例程序中持有外部对象的引用，这个外部引用就不能被回收。 资源未被关闭，数据库连接和网络连接以及输入输出流都需要手动关闭，否则不能被回收。 静态集合类，如果这些容器为静态的，那么它们的生命周期与应用程序一致，容器中的对象在程序结束之前将不能被释放，不能被回收。 内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用也不能被回收。 改变哈希值，当对象被存入HashSet中后，就不能再修改这个对象的哈希值了，否则就会导致无法从HashSet中检索到该对象，这个对象就不能被回收。 不合理的作用域，变量定义的作用范围大于其使用范围，可能会导致内存泄漏，另外，如果没有及时将对象置空，这个对象就不能被回收。 缓存泄漏，一旦将对象放入到缓存中，就会很容易遗忘缓存对象，缓存对象就不能被回收。 监听器和回调，如果客户端在接口中注册回调，但没有显示取消，相关对象就不能被回收。 1.4 内存溢出内存溢出指的是定义的对象占用的内存过大，需要的内存溢出了内存空间。 1.5 STWSTW（Stop The World）指的是GC事件发生过程中，会产生应用程序的停顿，整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉。 1.6 安全点和安全区域1.6.1 安全点从线程角度看，安全点（Safe Point）可以理解成是在代码执行过程中的一些特殊位置，在线程执行到这些位置时，说明虚拟机当前的状态是安全的。 安全点的选择很重要，太少会导致等待进入安全点的时间过长，太多会导致性能问题，可以将执行时间较长的程序作为安全点，比如方法调用、循环跳转、异常跳转等。 对于一些需要暂停的操作，比如STW，需要等线程进入安全点才能执行，线程进入安全点的方式有两种： 抢先式中断：首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点。过时，目前没有虚拟机采用。 主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。 1.6.2 安全区域当需要暂停线程时，如果线程正在执行可以等待进入安全点，但如果线程处于休眠状态或者阻塞状态，等待时间就会变得很长。 为了解决这个问题，引入了安全区域的概念。 安全区域是指在一段代码片中，引用关系不会发生改变，在这个区域中的任何位置开始GC都是安全的，可以看做是安全点的扩展。 当线程进入安全区域时，会标识已经进入安全区域，此时发生GC会忽略进入安全区域的线程。 当线程离开安全区域时，会检查是否完成GC，只有完成GC线程才可以离开，否则需要等待GC完成才可以离开。 2 对象存活判断2.1 堆的存活判断2.1.1 引用计数算法每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。 此方法简单，但无法解决对象相互循环引用的问题： java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; DemoGC demoA = new DemoGC();// step 1 DemoGC demoB = new DemoGC();// step 2 // 相互引用 demoA.instance = demoB;// step 3 demoB.instance = demoA;// step 4 // 释放对象 demoA = null;// step 5 demoB = null;// step 6 // 发生CG System.gc(); &#125;&#125;class DemoGC &#123; public Object instance = null;&#125; 在第一步和第二步执行后，在堆中创建了两个实例对象： demoA引用实例对象A，引用数量变为1。 demoB引用实例对象B，引用数量变为1。 在第三步和第四步执行后： demoB的instance属性引用实例对象A，引用数量变为2。 demoA的instance属性引用实例对象B，引用数量变为2。 在第五步和第六步执行后： demoA不再引用实例对象A，引用数量变为1。 demoB不再引用实例对象B，引用数量变为1。 此时如果发生GC，虽然demoA和demoB均已经不再引用实例对象了，但是其内部的instance属性还在引用实例对象，所以此时实例对象的引用不为0，不能被GC回收。 2.1.2 可达性算法从GCRoots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的，可以回收，但不一定会被回收，原因在于虚拟机的二次标记机制。 可以作为GCRoots的对象： 虚拟机栈的栈帧中的局部变量表引用的对象，比如各个线程中被调用的参数和局部变量等。 本地方法栈中JNI（Native方法）引用的对象，比如线程中的start()方法中使用的对象。 静态属性引用的对象，比如引用类型的静态变量。 方法区中常量引用的对象，比如在方法区中使用字符串常量池中的对象。 被synchronized所持有的对象。 虚拟机内部的引用，比如基本类型对应的Class对象，常驻异常对象，系统类加载器等。 本地代码缓存。 除了固定的对象外，根据用户选用的垃圾回收器和当前回收的内存区域，还可以有临时对象加入，比如分代收集和局部收集。 再回到相互循环引用的问题上，demoA和demoB是方法中的局部变量，其存储位置是虚拟机栈的栈帧中的局部变量表，可以作为GCRoots对象。instance属性是类中的成员属性，其存储位置是堆，不可以作为GCRoots对象。当demoA和demoB不再引用实例对象后，从GCRoots向下搜索，会发现实例对象没有引用链相连，可以被GC回收。 2.1.3 二次标记Object类有一个finalize()方法，该方法会在该对象被回收之前调用，并且任何一个对象的fianlize()方法都只会被系统自动调用一次。 在被标记后，如果重写了finalize()方法，并且在方法里将该对象重新加入到了引用链中。此时虽然已经被标记了，但并不会被回收，原因在于虚拟机的二次标记机制： 第一次标记，标记不在引用链的对象，判断是否需要执行finalize()方法。如果已经被执行或者没有被重写，就表示不需要执行，否则表示需要执行。 将需要执行finalize()方法的对象放在F-Queue的队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程去执行。 第二次标记，遍历F-Queue队列中的对象，判断是否存在引用链。如果存在引用链，表示该对象不需要被回收，否则标记不存在引用链的对象，等待回收。 该机制在JDK1.9已被弃用。 2.2 方法区的存活判断方法区主要回收废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 3 对象的引用在JDK1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可达状态，程序才能使用它。 从JDK1.2版本开始，对象的引用被划分为四种级别： 强引用（StrongReference）：不会被垃圾回收器回收，即使以后也不会用到。 软引用（SoftReference）：比强引用弱，当系统内存不足时才会被回收。通常用在对内存敏感的程序中，比如高速缓存。 弱引用（WeakReference）：比软引用弱，生命周期更短，只要发生了垃圾回收，不管内存空间是否足够都会被回收。 虚引用（PhantomReference）：最弱，在任何时候都有可能被垃圾回收器回收。通常配和引用队列联合使用，在被回收前能够收到系统通知。 无论引用计数算法还是可达性分析算法都是基于强引用而言的。 如果对象是不可达的，不管是哪种引用都会被垃圾回收器回收。 3.1 强引用强引用是使用最普遍的引用。 如果强引用的对象可达，虚拟机宁愿抛出OutOfMemoryError错误使程序异常终止，也不会回收对象来解决内存不足的问题。 示例： java123456789101112131415161718192021222324public class Demo &#123; static String test; public static void main(String[] args) &#123; // 声明原引用 test = new String(&quot;test&quot;); // 声明强引用 String strongReference = test; // 打印强引用 System.out.println(strongReference); // 去除原引用 test = null; // 发生CG System.gc(); // 强制睡眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 打印强引用 System.out.println(strongReference); &#125;&#125; 结果： log123test// 等待1stest 3.2 软引用如果软引用的对象可达，只有当内存空间不足时才会被回收，当内存充足时不被回收。 软引用通常用来实现内存敏感的缓存。 示例： java12345678910111213141516171819202122232425262728293031323334public class Demo &#123; static String test; public static void main(String[] args) &#123; // 声明原引用 test = new String(&quot;test&quot;); // 声明软引用 SoftReference&lt;String&gt; softReference = new SoftReference&lt;&gt;(test); // 打印软引用 System.out.println(softReference.get()); // 去除原引用 test = null; // 发生CG System.gc(); // 强制睡眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 打印软引用，内存充足不被回收 System.out.println(softReference.get()); try &#123; // 分配大内存，强制抛出OOM byte[] bytes = new byte[1024 * 1024 * 7]; &#125; catch (Throwable e) &#123; // 内存不足抛出OOM e.printStackTrace(); &#125; finally &#123; // 打印软引用，内存不足会被回收 System.out.println(softReference.get()); &#125; &#125;&#125; 结果： log123456test// 等待1stestjava.lang.OutOfMemoryError: Java heap space at Demo.main(Demo.java:30)null 3.3 弱引用无论弱引用的对象是否可达，无论内存是否充足，在下一次垃圾回收时都会被回收。 弱引用通常用来保存可有可无的缓存数据。 示例： java123456789101112131415161718192021222324public class Demo &#123; static String test; public static void main(String[] args) &#123; // 声明原引用 test = new String(&quot;test&quot;); // 声明弱引用 WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(test); // 打印弱引用 System.out.println(weakReference.get()); // 去除原引用 test = null; // 发生CG System.gc(); // 强制睡眠 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 打印弱引用 System.out.println(weakReference.get()); &#125;&#125; 结果： log123test// 等待1snull 3.4 虚引用与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么随时都可能被垃圾回收器回收。 虚引用必须和引用队列联合使用，当垃圾回收器在回收有虚引用的对象之前，会加入到引用队列，以通知应用程序对象的回收情况。 虚引用通常用来跟踪对象被垃圾回收器回收的活动，也可以将一些资源释放操作放置在虚引用中执行和记录。 示例： java123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo &#123; static String test; static ReferenceQueue&lt;String&gt; referenceQueue = new ReferenceQueue&lt;&gt;(); public static void main(String[] args) &#123; // 设置守护线程 Thread t = new CheckRefQueue(); t.setDaemon(true); t.start(); // 声明原引用 test = new String(&quot;test&quot;); // 声明引用队列 referenceQueue = new ReferenceQueue&lt;&gt;(); // 声明虚引用 PhantomReference&lt;String&gt; phantomReference = new PhantomReference&lt;&gt;(test, referenceQueue); // 打印虚引用 System.out.println(phantomReference.get()); // 去除原引用 test = null; // 发生CG System.gc(); &#125; public static class CheckRefQueue extends Thread &#123; @Override public void run() &#123; while (true) &#123; if (referenceQueue != null) &#123; PhantomReference&lt;String&gt; str = null; try &#123; str = (PhantomReference&lt;String&gt;) referenceQueue.remove(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (str != null) &#123; System.out.println(&quot;发生GC&quot;); &#125; &#125; &#125; &#125; &#125;&#125; 结果： log12null发生GC 4 垃圾回收算法4.1 标记-清除算法标记-清除（Mark-Sweep）算法分为两个阶段： 标记阶段的任务是标记出所有需要被回收的对象. 清除阶段的任务是回收被标记的对象所占用的空间。 说明： 这种方法的标记和清除过程的效率都不高，并且在标记清除之后会产生大量不连续的内存碎片，当程序需要分配较大对象时，无法找到足够的连续内存，不得不提前触发另一次垃圾收集动作。 4.2 复制算法为了解决标记-清除算法的缺陷，复制（Copying）算法就被提了出来。 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。 很显然，复制算法的效率跟存活对象的多少有很大的关系，如果存活对象很多，那么复制算法的效率将大大降低。 说明： 这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。 4.3 标记-压缩算法为了解决复制算法的缺陷，充分利用内存空间，提出了标记-压缩（Mark-Compact）算法。 该算法标记阶段和标记-清除算法的标记阶段一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 说明： 这种方法的效率比较低，并且在移动过程中，需要全面暂停应用程序，即会触发STW。 4.4 分代收集算法分代收集（Generational Collection）算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域，根据不同区域的特点采取最适合的收集算法。 一般情况下将堆区划分为年轻代和老年代两个区域。 4.4.1 年轻代在年轻代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以选用复制算法。 分配： 因为大部分新生成的对象的生命周期都很短，所以将年轻代分为一块较大的Eden区和两块较小的Survivor区。 一块较大的Eden区用来存放新生成的对象，两块较小的Survivor区用来存放在多次GC存活下来的对象，一块称为S0区，另一块称为S1区。 年轻代发生的GC叫做MinorGC，也称为YoungGC，MinorGC发生频率比较高。 过程： 当第一次发生GC时，先将垃圾对象清除，然后将Eden区还存活的对象一次性复制到任意一个Survivor区，最后清空Eden区。为了区分方便，将使用的Survivor区称为From区，将空闲的Survivor区称为To区。 当再次发生GC时，先将垃圾对象清除，然后将Eden区和From区还存活的对象一次性复制到To区，最后清空Eden区和From区。每次GC完成之后，将正在使用的To区称为From区，将空闲的From区称为To区。 对象在放到Survivor区时都会设置一个年龄，并且每经过一次GC后都会将年龄加一，当对象的年龄超过虚拟机设置的阈值之后，会将对象放到老年代。 4.4.2 老年代因为老年代中对象存活率高、没有额外空间对它进行分配担保，所以使用标记清除算法或标记压缩算法来进行回收。 分配： 大对象直接进入老年代。 多次不被回收的对象，经过多次MinorGC后仍在Survivor区的对象进入老年代。 动态年龄判断，计算某个年龄的对象数量超过了Survivor区总数量的一半，大于或等于这个年龄的对象进入老年代。 空间分配担保，经过MinorGC后Survivor区不足以存放对象进入老年代。 老年代发生的GC也叫做MajorGC，也称为OldGC，MajorGC发生频率比较低。 5 垃圾收集器5.1 Serial系列Serial是年轻代垃圾收集器，串行运行，采用复制算法，响应速度优先，使用STW机制，停顿时间长。 SerialOld是老年代垃圾收集器，串行运行，采用标记-压缩算法，响应速度优先，使用STW机制，停顿时间长。 对于单个CPU环境而言，Serial系列的收集器由于没有线程交互开销，可以获取最高的单线程收集效率。 配置： Serial系列的收集器是Client模式下默认的垃圾收集器。 可以通过-XX:+UseSerialGC来指定年轻代和老年代都使用Serial系列的收集器。 5.2 ParNew年轻代垃圾收集器，并行运行，采用复制算法，响应速度优先，使用STW机制，停顿时间长。 ParNew是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。 配置： ParNew收集器是Server模式下默认的垃圾收集器。 可以通过-XX:+UseParNewGC来指定年轻代使用ParNew收集器。 可以通过-XX:ParallelGCThreads来限制垃圾收集的线程数，默认开启和CPU数据相同的线程数。 5.3 Parallel系列Parallel是年轻代垃圾收集器，并行运行，采用复制算法，吞吐量优先，使用STW机制，停顿时间长。 ParallelOld是老年代垃圾收集器，并行运行，采用标记-压缩算法，吞吐量优先，使用STW机制，停顿时间长。 追求高吞吐量，高效利用CPU，主要是为了达到可控的吞吐量，适合在后台运算而不需要太多交互的任务 配置： Parallel系列的收集器是JDK1.8默认的垃圾收集器。 可以通过-XX:+UseParallelGC来指定年轻代使用Parallel收集器。 可以通过-XX:+UseParallelOldGC来指定老年代使用ParallelOld收集器。 可以通过-XX:ParallelGCThreads来限制年轻代垃圾收集器的线程数。一般最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。 可以通过-XX:MaxGCPauseMillis来指定垃圾收集器的STW的时间，单位是毫秒。 5.4 CMSJDK1.5推出，JDK1.9废弃，JDK1.14移除。 CMS（Current Mark Sweep）是老年代垃圾收集器，并发运行，采用标记-清除算法，响应速度优先，使用STW机制，停顿时间长。 过程： 初始标记，标记GCRoots能直接关联到的对象，有STW现象，暂停时间非常短。 并发标记，进行可达性分析过程，时间很长，不需要暂停用户线程，可与其他垃圾收集线程并发运行。在这个阶段使用了三色标记。 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长，不需要暂停用户线程。 并发清除，回收内存空间，时间很长，不需要暂停用户线程。 其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。 优缺点： 优点是并发收集和低延迟。 缺点是会产生内存碎片，对CPU资源非常敏感，并且无法处理浮动垃圾。 5.5 G1JDK1.7推出，JDK1.9默认。 G1（Garbage First）是年轻代和老年代垃圾收集器，支持并发运行和并行运行，采用复制算法和标记-压缩算法，响应速度优先，同时注重吞吐量。 G1的目标是在延迟可控的情况下获得尽可能高的吞吐量。 使用G1收集器时，将整个堆划分为多个大小相等的独立区域（Region），分区如图： 说明： 每个独立区域都按照分代收集算法代表一种分区，分区有Eden区，S0区，S1区等分类。 所有的独立区域大小相同，且在JVM生命周期内不会被改变。 增加Humongous内存区域，主要用于存储大对象，如果超过0.5个独立区域就会放到H区域，如果一个H区装不下就会寻找连续的H区来存储。 过程： 当Eden空间耗尽时，启动年轻代GC，只回收Eden区和Survivor区： 首先停止应用程序的执行触发STW机制，创建回收集，包含Eden区和Survivor区所有的内存分段。 回收剩余存活的对象会被复制到新的S区，S区达到一定的阈值会被放到O区，或者S区空间不足也会被放到O区。 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程： 初始标记，标记GCRoots直接可达的对象，会触发年轻代GC，也会触发STW机制。 根区域标记，标记Survivor区引用老年代的对象，必须在下一次年轻代GC前完成，否则会阻塞年轻代GC。 并发标记，在整个堆中进行并发标记，支持与用户线程并发。 最终标记，由于应用程序持续进行，需要修正上一次的标记结果，使用SATB处理并发期间的引用变化，会触发STW机制。 清理，计算各个区域的存活对象和GC回收比例，并进行排序，识别并清理完全空闲的区域，会触发STW机制。 当老年代中的对象进一步增加时，会触发MixedGC混合回收，回收整个年轻代和部分老年代： 并发标记结束以后，老年代中完全空闲的区域被回收了，部分空闲的区域被计算了出来。默认情况下，每个区域都会分8次回收。 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。 如果上述方式不能正常工作，G1会执行兜底的FullGC回收，G1收集器退化为SerialOld收集器，性能会非常差，会触发STW机制，触发条件： 回收阶段没有足够的空间存放对象，解决办法是增加堆空间。 并发标记过程完成之前空间耗尽，解决办法是调小触发老年代并发标记的阈值，默认是45%。 最大GC停顿时间太短导致在规定的时间间隔内无法完成垃圾回收，解决办法是增加STW时间。 特点： 并行性：在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。 并发性：拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，不会在整个回收阶段发生完全阻塞应用程序的情况。 无需连续：从堆的结构上看，不要求整个年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。 分代收集：独立管理整个堆，但是能够采用不同的方式处理新对象和旧对象。 空间整合：独立区域之间是复制算法，整体上可以看作是标记-压缩算法，这两种算法都能避免产生内存碎片。 可预测的停顿：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 配置： G1收集器是JDK1.9默认的垃圾收集器。 可以通过-XX:+UseG1GC来指定使用G1收集器。 可以通过-XX:G1HeapRegionSize来指定每个独立区域的大小。值是2的幂，范围是1MB到32MB之间。默认为堆内存的1&#x2F;2000大小。 可以通过-XX:ParallelGCThread来指定工作线程数的值，最多设置为8。 可以通过-XX:ConcGCThreads来指定并发标记的线程数。默认为工作线程数（ParallelGcThreads）的1&#x2F;4左右。 可以通过-XX:InitiatingHeapOccupancyPercent来指定触发老年代并发标记的阈值，默认为45%。 可以通过-XX:G1MixedGCLiveThresholdPercent来指定是否要回收区域垃圾占用的比例，当垃圾占用的比例达到比例时才会被混合回收，默认为65%。 可以通过-XX:G1HeapWastePercent来指定允许垃圾占用的比例，当垃圾占用的比例低于比例时就不再进行混合回收，默认为10%。 可以通过-XX:MaxGCPauseMillis来指定垃圾收集器的STW的时间，单位是毫秒。 6 调优配置配置日志的打印信息： conf123456789101112131415161718# 输出日志-XX:+PrintGC# 输出详细日志-XX:+PrintGCDetails# 输出时间戳（以基准时间的形式）-XX:+PrintGCTimeStamps# 输出时间戳（以日期的形式）-XX:+PrintGCDateStamps# 输出GC发生前后的堆信息-XX:+PrintHeapAtGC# 输出STW时间-XX:+PrintGCApplicationStoppedTime# 输出强软弱虚信息-XX:+PrintReferenceGC# 输出安全点信息-XX:+PrintSafepointStatistics# 输出打印安全点信息的次数-XX:PrintSafepointStatisticsCount=1 配置日志文件： conf12345678# 设置日志文件的输出路径-Xloggc:../logs/gc-%t.log# 开启日志文件分割-XX:+UseGCLogFileRotation # 设置日志文件个数，超过就从头开始写-XX:NumberOfGCLogFiles=10# 设置日志文件上限大小，超过就触发分割-XX:GCLogFileSize=10M 配置内存大小： conf12345678910111213141516# 设置线程栈的大小，不建议修改-Xss128k# 设置堆内存的初始内存，默认为物理内存的1/64-Xms4096m# 设置堆内存的最大内存，默认为物理内存的1/4-Xmx4096m# 设置年轻代中Eden:S1:S0的比率，默认值为8，表示Eden:S1:S0=8:1:1-XX:SurvivorRatio=8# 设置年轻代:老年代的比率，默认值为2，表示年轻代:老年代=2:8-XX:NewRatio=2# 设置年轻代对象在经过多少次回收后能进入老年代，默认是15-XX:MaxTenuringThreshold=15# 设置元空间的初始内存，默认为21m-XX:MetaspaceSize=21m# 设置元空间的最大内存，默认没有限制-XX:MaxMetaspaceSize=-1 7 执行分析7.1 查看内存示例： java1234public static void main(String[] args) &#123; System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;);&#125; 结果： log12max memory: 7260MBtotal memory: 491MB 本机电脑是32G，去掉一些自身的占用后，堆内存的最大值约为物理内存的1&#x2F;4，堆内存的初始值为物理内存的1&#x2F;64。 7.2 修改内存配置VM参数： conf123-Xms5m-Xmx20m-XX:+PrintGC 示例： java1234public static void main(String[] args) &#123; System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;);&#125; 结果： log123[GC (Allocation Failure) 1012K-&gt;648K(5632K), 0.0005734 secs]max memory: 18MBtotal memory: 5MB 说明堆内存已经被修改了。 7.3 占用内存配置VM参数： conf123-Xms5m-Xmx20m-XX:+PrintGC 示例： java12345678910111213141516public static void main(String[] args) &#123; System.out.println(&quot;初始内存&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;); byte[] b1 = new byte[1 * 1024 * 1024]; System.out.println(&quot;分配内存&quot; + b1.length / 1024 / 1024 + &quot;M&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;); byte[] b2 = new byte[10 * 1024 * 1024]; System.out.println(&quot;分配内存&quot; + b2.length / 1024 / 1024 + &quot;M&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;);&#125; 结果： log12345678910111213[GC (Allocation Failure) 1012K-&gt;632K(5632K), 0.0009215 secs]初始内存max memory: 18MBfree memory: 4MBtotal memory: 5MB分配内存1Mmax memory: 18MBfree memory: 3MBtotal memory: 5MB分配内存10Mmax memory: 18MBfree memory: 2MBtotal memory: 15MB 初始，最大内存约为20M，空闲内存约为4M，总内存约为5M。 分配1M的内存，空闲内存足够，空闲内存约为3M，总内存约为5M。 继续分配10M的内存，空闲内存不足，自动增加内存，空闲内存约为2M，总内存约为15M。 7.4 内存溢出配置VM参数： conf123-Xms5m-Xmx20m-XX:+PrintGC 示例： java12345678910111213141516public static void main(String[] args) &#123; System.out.println(&quot;初始内存&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;); byte[] b1 = new byte[1 * 1024 * 1024]; System.out.println(&quot;分配内存&quot; + b1.length / 1024 / 1024 + &quot;M&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;); byte[] b2 = new byte[20 * 1024 * 1024]; System.out.println(&quot;分配内存&quot; + b2.length / 1024 / 1024 + &quot;M&quot;); System.out.println(&quot;max memory: &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;free memory: &quot; + Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;MB&quot;); System.out.println(&quot;total memory: &quot; + Runtime.getRuntime().totalMemory() / 1024 / 1024 + &quot;MB&quot;);&#125; 结果： log12345678910111213141516[GC (Allocation Failure) 1012K-&gt;652K(5632K), 0.0005981 secs]初始内存max memory: 18MBfree memory: 4MBtotal memory: 5MB分配内存1Mmax memory: 18MBfree memory: 3MBtotal memory: 5MB[GC (Allocation Failure) 2357K-&gt;1817K(15360K), 0.0006138 secs][GC (Allocation Failure) 1817K-&gt;1873K(15360K), 0.0004490 secs][Full GC (Allocation Failure) 1873K-&gt;1678K(5632K), 0.0042680 secs][GC (Allocation Failure) 1678K-&gt;1678K(16384K), 0.0002214 secs][Full GC (Allocation Failure) 1678K-&gt;1660K(7680K), 0.0044765 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at Demo.main(Demo.java:14) 当年轻代内存不足时，触发MinorGC，当老年代内存不足时，触发MajorGC，当内存仍不足时，触发FullGC，如果内存还不足则触发OOM异常。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"数据存储","slug":"D00-后端/D01-Java/004-虚拟机/003-数据存储","date":"2025-07-31T08:39:10.000Z","updated":"2025-08-06T02:39:56.939Z","comments":true,"path":"posts/20250731/163910/","permalink":"https://momashanhe.com/posts/20250731/163910/","excerpt":"摘要：本文主要学习了虚拟机如何管理对象。","text":"摘要：本文主要学习了虚拟机如何管理对象。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 内存区域模型虚拟机定义的内存区域模型： 图中绿色部分就是所有线程之间共享的内存区域，包括方法区和堆。而绿色部分则是线程运行时独享的数据区域，包括程序计数器、本地方法栈、虚拟机栈。 之所以要划分这么多区域出来是因为这些区域都有自己的用途，以及创建和销毁的时间。 有些区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而销毁和建立。 2 运行时数据区2.1 程序计数器2.1.1 作用存储指向下一条指令的地址，以便由执行引擎读取下一条指令。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 2.1.2 独享为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。 2.1.3 异常此内存区域是唯一不会出现OutOfMemoryError情况的区域。 2.2 本地方法栈2.2.1 作用本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 2.2.2 独享与程序计数器一样，本地方法栈也是线程私有的。 2.2.3 异常在虚拟机规范中，对这个区域规定了两种异常状况： StackOverflowError 递归太深。如果线程请求的栈深度大于虚拟机所允许的深度，即递归调用次数太多，将抛出StackOverflowError异常。 数据过大。局部数组过大，当函数内部定义的数组过大时，有可能导致内存溢出，抛出StackOverflowError异常。 OutOfMemoryError 内存不足。如果虚拟机栈无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那虚拟机将会抛出OutOfMemoryError异常。 2.2.4 本地方法Java诞生的时候是C&#x2F;C++横行的时候，要想立足，必须有调用C&#x2F;C++程序，于是使用native关键字标识调用了C&#x2F;C++程序的方法，把这种方法称为Native方法。 为了和用于处理Java方法的虚拟机栈区分开来，又在内存中专门开辟了一块区域用于处理Native方法，这块区域就被称为本地方法栈。 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机。 Object类中的hashCode()方法就是本地方法： java1public native int hashCode(); 2.3 虚拟机栈2.3.1 作用虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，这个过程遵循先进后出的规则。 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。 结构图： 2.3.2 独享与本地方法栈一样，虚拟机栈也是线程私有的，它的生命周期与线程相同，每创建一个线程时就会对应创建一个虚拟机栈，所以虚拟机栈也是线程私有的内存区域。 2.3.3 异常与本地方法栈一样，虚拟机栈也会抛出StackOverflowError异常和OutOfMemoryError异常。 2.3.4 栈帧一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 2.3.4.1 局部变量表局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，包括各种基本类型、引用类型和返回地址类型。 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小，具体大小可在编译后的class文件中看到。 局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽都可以存储32位长度的内存空间。 64位长度的long类型和double类型的数据会占用2个变量槽，其余的数据类型只占用1个变量槽。 2.3.4.2 操作数栈操作数栈（Operand Stack）同样也可以在编译期确定大小。 栈帧被创建时，操作栈是空的。方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。例如在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的。 2.3.4.3 动态链接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。 比较： 静态链接：当字节码文件被装载进JVM内部时，在类加载阶段中的解析阶段就将符号引用转为直接引用，这种过程被称为静态链接。 动态链接：如果在程序运行期才能将符号引用转为直接引用，这种过程被称为动态链接。 2.3.4.4 方法返回地址方法返回地址（Return Address）用于存放调用该方法的程序计数器的值，用于在退出方法后执行下一条命令。 方法有两种方式可以退出： 正常执行退出。 执行异常退出。 2.4 堆2.4.1 作用此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 2.4.2 共享堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存储的数据不是线程安全的。 2.4.3 异常在虚拟机规范中，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。 如果在养老区中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 一般出现异常的原因是： 堆内存设置不够。 代码中创建了大量对象，并且长时间不能被垃圾回收器收集。 2.4.4 分代堆是垃圾回收器管理的主要区域，因此很多时候也被称做GC堆（Garbage Collected Heap）。 为了优化垃圾回收的性能，虚拟机会将堆空间进行分代。 在JDK1.8以后，将堆空间分为年轻代和老年代。 2.4.4.1 年轻代年轻代（Young Generation Space）存放新生成的对象，年轻代对象朝生夕死，存活率很低。 在年轻代中进行垃圾回收一般可以回收70%到95%的空间，回收效率很高。 年轻代又可细分为Eden空间、From Survivor空间、To Survivor空间，默认比例为8:1:1。 2.4.4.2 老年代老年代（Old Generation Space）存放在年轻代多次回收长期存活的对象，也会将大对象直接存放到老年代中，老年代中的对象生命周期较长，存活率比较高。 在老年代中进行垃圾回收的频率较低，而且回收的速度也比较慢。 当老年代内存满了之后会触发垃圾回收，如果垃圾回收后内存空间仍不满足，则会触发OOM异常。 2.5 方法区2.5.1 作用在JDK1.8之前，方法区存储类元数据、运行时常量池、静态变量等数据，并在逻辑上将方法区划分为堆中的永久代，作为堆的逻辑部分。 在JDK1.8之后，方法区中的数据被拆分到了堆和元空间： 静态变量：存储在堆中。 字符串常量池：将字符串常量池从运行时常量池拆分，存储在堆中。 运行时常量池：存储在元空间中，但运行时常量池的符号引用解析后可能指向堆中的对象。 类元数据：存储在元空间中。 2.5.2 共享方法区与堆一样，是各个线程共享的内存区域。 2.5.3 异常在虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 一般出现异常的原因是： 内存设置不够。 加载大量第三方Jar包。 存在大量调用反射的代码。 2.5.4 永久代在JDK1.8之前，永久代参数设置不合理会产生问题，参数过小容易产生OOM，参数过大会导致空间浪费，因此在JDK1.8中使用元空间取代了永久代。 此外，移除永久代是为融合HotSpot与JRockit而做出的努力，JRockit没有永久代，不需要配置永久代。 2.5.5 垃圾回收这个区域垃圾回收的任务： 对废弃常量的回收。 对类型的卸载。 3 对象内存结构对象的内存结构： 对象内存结构分为对象头、实例数据、对齐填充。 3.1 对象头对象头分为对象标记和类型指针，如果是数组对象还有数组长度。 3.1.1 对象标记对象标记存储的数据会根据对象的锁状态进行复用，在运行期间，对象标记中的数据会随着锁标志位的变化而变化。 对象标记结构图： 在64位的HotSpot虚拟机下，对象标记占用8个字节。 3.1.2 类型指针对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 在开启压缩的情况下占用4个字节，否则占用8个字节，JDK1.8默认开启压缩。 3.1.3 数组长度如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据。 因为虚拟机可以通过普通对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。 数组长度占用4个字节。 3.2 实例数据用于存储对象的有效信息，包括程序代码中定义的各种类型的字段（包括继承自父类的和自身声明的），规则如下： 相同宽度的字段总被分配在一起。 父类中定义的变量会出现在子类之前。 如果虚拟机CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙。 3.3 对齐填充虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。 4 对象生命周期创建对象的几种方式： 使用new关键字，这是最常见的方式。 使用Class对象的newInstance()方法，通过反射的方式，只能调用空参的构造器，必须是public权限。 使用Constructor对象的newInstance()方法，通过反射的方式，可以调用任何定义的构造器，没有权限要求。 使用clone()方法，不调用任何构造器，当前类需要实现Cloneable接口，重写clone()方法。 使用反序列化，从文件和网络中获取对象的二进制流，然后反序列化为对象。 使用第三方库，例如通过Objenesis创建。 4.1 创建4.1.1 加载检查能否在常量池中定位到类的符号引用，并且检查这个符号引用代表的类是否已经被加载、链接和初始化。如果没有，那么必须先执行类的初始化过程。 4.1.2 分配内存类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，在堆中为对象分配内存。 分配方式： 指针碰撞法：内存是规整的，用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，在空闲的内存将指针挪动一段与对象大小相等的距离。 空闲列表法：内存不是规整的，已使用的内存和未使用的内存相互交错，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。 如果是在多线程环境下的为对象分配内存，需要使用TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）保证创建对象时的线程安全： 在堆中为每个线程创建创建一小块TLAB私有区域，线程分配对象时优先考虑分配在TLAB区域。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，直接在Eden空间中分配内存。 4.1.3 设置初始值内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。 这一步保证了对象的实例字段在代码中可以不用赋初始值就可以直接使用。 4.1.4 设置对象头设置对象的对象头信息。 这个过程的具体设置方式取决于JVM实现。 4.2 初始化初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 4.3 使用不同虚拟机实现的对象访问方式有所不同，主流的访问方式是句柄访问和直接指针。 4.3.1 句柄访问在堆中划分出一块内存作为句柄池，栈帧中的reference存储的是对象的句柄地址，句柄中包含： 存储在堆中的对象实例数据的地址。 存储在方法区中的对象类型数据的地址。 句柄访问： 4.3.2 直接指针访问栈帧中的reference存储的是对象实例数据的地址，对象实例数据中的类型指针存储指向方法区的对象类型数据的地址。 直接指针访问： 4.4 不可达当对象经过存活判断为不可达后，进入不可达阶段。 4.5 回收不可达对象会被垃圾回收器回收，释放其占用的堆内存。 4.6 销毁当对象的内存被完全释放，且无法再被任何方式访问，则对象彻底销毁，生命周期结束。 5 逃逸分析5.1 定义逃逸分析（Escape Analysis）是虚拟机可以分析新创建对象的使用范围，并决定是否在堆上分配内存的一项技术。 一个在方法中创建的对象，可能在方法结束后返回被外部方法所引用，也可能在方法中调用其他方法时作为参数传入，以上两种情况都称之为对象逃逸。 根据作用域可分为下面三种情况： GlobalEscape（全局逃逸）：对象的引用逃出了方法或者线程。例如： 将对象的引用赋值给类变量或者静态变量。 对象跟随方法返回。 ArgEscape（参数级逃逸）：在方法中调用其他方法时，对象的引用作为参数传递至其他方法。 NoEscape（没有逃逸）：对象的作用域范围就只在本方法中，随着方法栈帧的进栈而生、出栈而亡。这种情况下，对象可以分配在栈中，但不是一定分配在栈中。 5.2 使用逃逸分析的JVM参数： conf123456# 开启逃逸分析-XX:+DoEscapeAnalysis# 关闭逃逸分析-XX:-DoEscapeAnalysis# 显示分析结果-XX:+PrintEscapeAnalysis 逃逸分析技术在JDK1.7以后开始支持，并默认设置为启用状态，可以不用额外加这个参数。 5.3 优化如果使用逃逸分析判断一个对象没有逃逸，编译器可以对代码进行优化。 5.3.1 同步消除如果一个对象只能被一个线程访问到，那么将此对象作为锁，或者对于此对象的同步操作，在虚拟机优化后都可以忽略，这也就是多线程中的锁消除技术。 同步消除的JVM参数： conf1234# 开启锁消除-XX:+EliminateLocks# 关闭锁消除-XX:-EliminateLocks 同步消除在JDK1.8中是默认开启的，并且要建立在逃逸分析的基础上。 5.3.2 标量替换标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。 相对的，那些还可以分解的数据叫做聚合量（Aggregate）。Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。 在编译阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT编译器优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换。 标量替换的JVM参数： conf123456# 开启标量替换-XX:+EliminateAllocations# 关闭标量替换-XX:-EliminateAllocations# 显示标量替换详情-XX:+PrintEliminateAllocations 标量替换在JDK1.8中是默认开启的，并且要建立在逃逸分析的基础上。 5.3.3 栈上分配如果一个对象没有发生逃逸，那么这个对象可能会被优化存储在栈中，但也并不是绝对存储在栈中，也有可能还是存储在堆中。 需要说明的是，在现有的虚拟机中，并没有真正的实现栈上分配，其实是通过标量替换实现的。 当对象没有发生逃逸时，该对象就可以通过标量替换分解为成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了GC压力，提高了应用程序性能。 6 分析案例6.1 导包在pom.xml文件中引入依赖： pom.xml123456&lt;!-- JOL依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt; 也可以直接导入jol-core-0.9.jarJar包。 在读取对象信息时，虚拟机是按照8位一组，从高位向低位读取的。 6.2 压缩在64位的HotSpot虚拟机下，类型指针需要占8个字节。 从JDK1.6开始，64位的虚拟机可对OOP（Ordinary Object Pointer，普通对象指针）进行压缩，使其只占用4个字节，以达到节约内存的目的。 在JDK1.8下，该选项默认启用。 可以显式配置JVM参数： conf1234# 开启指针压缩-XX:+UseCompressedOops# 关闭指针压缩-XX:-UseCompressedOops 6.3 查看6.3.1 查看Object对象示例： java123public static void main(String[] args)&#123; System.out.println(ClassLayout.parseInstance(new Object()).toPrintable());&#125; 结果： log12345678java.lang.Object object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 00 1c 53 1c (00000000 00011100 01010011 00011100) (475208704) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total 参数： OFFSET：偏移量，表示从第几个字节开始。 SIZE：占用的字节大小。 TYPE：Class中定义的类型。 DESCRIPTION：对类型的描述。 VALUE：在内存中的值。 一个空的Object对象占用16字节，对象标记占用8个字节，类型指针在关闭压缩后占用8个字节。 6.3.2 查看Integer对象示例： java123public static void main(String[] args)&#123; System.out.println(ClassLayout.parseInstance(new Integer(1)).toPrintable());&#125; 结果： log12345678910java.lang.Integer object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) e0 71 5e 1c (11100000 01110001 01011110 00011100) (475951584) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 int Integer.value 1 20 4 (loss due to the next object alignment)Instance size: 24 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total 对比空的Object对象，总大小占用24个字节。其中，对象标记仍为8个字节并且内容相同，指针类型仍为8个字节但是内容有变化，增加了占用4个字节的实例数据，增加了占用4个字节的对齐填充。 因为int类型长度为32位，也就是4个字节，所以实例数据的大小也就是4个字节，为了保证总大小为8的倍数，额外增加了4个字节的对齐填充。 6.3.3 查看Long对象示例： java123public static void main(String[] args)&#123; System.out.println(ClassLayout.parseInstance(new Long(1)).toPrintable());&#125; 结果： log123456789java.lang.Long object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) f0 ac ba 1c (11110000 10101100 10111010 00011100) (481996016) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 8 long Long.value 1Instance size: 24 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total 对比Integer对象，总大小仍为24个字节。其中，对象标记和指针类型变化不大，但是实例数据占用的大小变为8个字节，并且没有对齐填充。 因为long类型长度为64位，也就是8个字节，所以实例数据就占用8个字节，并且不需要对齐填充。 6.3.4 查看数组对象示例： java123public static void main(String[] args) &#123; System.out.println(ClassLayout.parseInstance(new Integer[]&#123;1, 2, 3&#125;).toPrintable());&#125; 结果： log1234567891011[Ljava.lang.Integer; object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 00 42 e6 1c (00000000 01000010 11100110 00011100) (484852224) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 16 4 (object header) 03 00 00 00 (00000011 00000000 00000000 00000000) (3) 20 4 (alignment/padding gap) 24 24 java.lang.Integer Integer;.&lt;elements&gt; N/AInstance size: 48 bytesSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total 数组对象在对象头中会增加数组长度，占用4个字节并且值为3表示长度为3，另外在对象标记中还需要4个字节的对齐填充。 实例数据占用了24个字节。 6.3.5 查看分代信息示例： java123456public static void main(String[] args)&#123; Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); System.gc(); System.out.println(ClassLayout.parseInstance(o).toPrintable());&#125; 结果： log1234567891011121314151617java.lang.Object object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 00 1c a2 1c (00000000 00011100 10100010 00011100) (480386048) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes totaljava.lang.Object object internals:OFFSET SIZE TYPE DESCRIPTION VALUE 0 4 (object header) 09 00 00 00 (00001001 00000000 00000000 00000000) (9) 4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 8 4 (object header) 00 1c a2 1c (00000000 00011100 10100010 00011100) (480386048) 12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)Instance size: 16 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total 因为虚拟机在读取对象头时，是将每8位作为一组，从高往低读取的，所以在代表对象标记的8个字节中，首先打印的8位数字实际上是最后的8位数字。 对照对象头存储的信息，当没有被垃圾回收时，高8位表示如下：第1位是无效位，后4位表示分代年龄，后1位表示偏向锁，最后2位表示锁标志。 垃圾回收前，分代年龄是0，执行垃圾回收后，分代年龄变为1，4位的分代年龄表示最高年龄为15。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"加载过程","slug":"D00-后端/D01-Java/004-虚拟机/002-加载过程","date":"2025-07-30T08:53:26.000Z","updated":"2025-08-06T01:56:47.831Z","comments":true,"path":"posts/20250730/165326/","permalink":"https://momashanhe.com/posts/20250730/165326/","excerpt":"摘要：本文主要学习了如何将类加载到虚拟机。","text":"摘要：本文主要学习了如何将类加载到虚拟机。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 类生命周期类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括加载、连接、初始化、使用和卸载五个阶段。 如图： 其中，连接包括验证、准备、解析三个阶段。解析阶段在某些情况下可以在初始化后再开始，这是为了支持运行时绑定。 这几个阶段按顺序开始，相互交叉混合进行，通常在一个阶段执行的过程中调用或激活另一个阶段。 1.1 加载阶段1.1.1 做什么类的加载就是将class文件中的二进制数据读取到运行时内存中，将class文件中类的信息放在方法区中，然后在堆中创建一个Class对象，用于封装方法区中的数据结构。 在进行加载的时候，虚拟机需要完成三件事： 通过类的全类名获取该类的二进制字节流。 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。 在内存中创建一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口。 1.1.2 何时做虚拟机规范允许某个类在预料被使用的时候预先执行类的加载，不需要等到某个类首次被使用的时候才进行类的加载。 如果在进行类的加载时遇到class文件缺失，只有当使用到了该类的时候，类加载器才会报告错误，如果该类并没有被使用，那么类加载器是不会报告错误的。 1.1.3 文件的来源加载的class文件有种来源： 从本地硬盘直接加载，最为普通的场景。 通过网络下载class文件加载，常用于Applet应用程序。 从压缩文件中提取class文件加载，常用于Jar包和War包。 运行时计算生成，常用于动态代理。 由其他文件生成，常用于JSP应用。 从数据库中提取加载，比较少见。 将源文件编译成class文件加载，常用于防止反编译的保护措施。 1.1.4 补充说明相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义的类加载器来完成加载。 1.2 链接阶段1.2.1 验证阶段确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成四个阶段的检验动作： 文件格式验证：验证字节流是否符合class文件格式的规范。比如是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行分析，以保证其描述的信息符合Java语言规范的要求。比如这个类是否有除了Object之外的超类。 字节码验证：通过数据流和控制流分析，确定程序语义是安全法的、符合逻辑的，不会导致虚拟机崩溃。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，可以通过参数关闭验证以缩短虚拟机类加载的时间。 1.2.2 准备阶段为类变量（也就是静态成员变量，不包括实例变量）分配内存并设置初始值的阶段，这些变量所使用的内存都在方法区中进行分配。 这个阶段只是为静态成员变量设置初始值，并不是赋值，赋值是在初始化阶段的cinit()方法中完成的。 如果静态成员变量同时是常量，常量在编译时分配初始值，如果赋值不涉及方法调用（包括构造方法调用），会在这个阶段进行赋值。 赋值： 非static类型的变量，在初始化阶段的init()方法中赋值。 static类型的变量，在准备阶段设置初始值，在初始化阶段的cinit()方法中赋值。 static类型的变量，并且是final类型的变量，在编译阶段设置初始值。如果赋值不涉及方法调用，在准备阶段赋值，否则在初始化阶段的cinit()方法中赋值。 示例： java12345678910// 在准备阶段设置初始值为0，在初始化阶段的clinit方法中赋值public static int i = 1;// 在准备阶段赋值public static final int INT_CONSTANT = 1;// 在准备阶段设置初始值为null，在初始化阶段的clinit方法中赋值public static final Integer INTEGER_CONSTANT=Integer.valueOf(1);// 在准备阶段赋值public static final String STR = &quot;hello&quot;;// 在准备阶段设置初始值为null，在初始化阶段的clinit方法中赋值public static final String STR_CONSTANT = new String(&quot;hello&quot;); 1.2.3 解析阶段虚拟机将常量池内的符号引用替换为直接引用，会把该类所引用的其他类全部加载进来，类中的引用方式包括继承、实现接口、域变量、方法定义、方法中定义的本地变量等等。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这七类符号引用进行。 引用： 符号引用：在编译文件时，并不知道所引用的类的实际地址，因此只能使用符号引用来代替。 直接引用：直接指向目标的指针（指向方法区，Class对象）、指向相对偏移量（指向堆区，Class实例对象）或指向能间接定位到目标的句柄。 1.3 初始化阶段1.3.1 做什么为类的静态变量赋予正确的初始值，虚拟机负责对类进行初始化，主要对类变量进行初始化。 对类变量进行初始值设定有两种方式： 声明类变量时指定初始值。 使用静态代码块为类变量指定初始值。 换句话说，初始化阶段是执行cinit()方法的过程。 在执行子类的cinit()方法前，虚拟机会先执行父类的cinit()方法。 1.3.2 线程安全在执行cinit()方法时，虚拟机会保证在多线程环境中正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的cinit()方法。 如果一个类的cinit()方法中有耗时的操作，可能会造成多线程阻塞，从而导致产生死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。 赋值方法： init()方法是对象构造器方法，在new一个对象并调用该类的构造方法时才会执行，用于对非静态变量进行赋值。 clinit()方法是类构造器方法，在初始化阶段执行，用于对静态变量进行赋值。 示例： java12345678910class X &#123; static Log log = LogFactory.getLog(); // &lt;clinit&gt; private int x = 1; // &lt;init&gt; X () &#123; // &lt;init&gt; &#125; static &#123; // &lt;clinit&gt; &#125;&#125; 1.3.3 何时做只有当主动使用时才会进行初始化，类的主动使用包括以下六种： 创建类的实例，包括使用new的方式，也包括使用反射、克隆、序列化的方式，会触发初始化。 调用Class.forName()方法，将Class文件加载到内存并返回Class对象，会触发初始化。 访问某个类或接口的静态变量，或者对该静态变量赋值，会触发初始化。 调用类的静态方法，会触发初始化。 作为父类，初始化子类时，会触发初始化。 类中包含main()方法作为主类，虚拟机在启动时，会触发初始化 JDK1.7开始提供的动态语言支持，涉及解析相关方法句柄对应的类，虚拟机在启动时，会触发初始化。 除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用： 子类引用父类静态属性，不会触发初始化。 调用loadClass()方法，将Class文件加载到内存，不会触发初始化。 通过数组引用类，不会触发初始化。 引用类的常量，常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发初始化。 1.3.4 接口说明接口中不能使用静态代码块，但是允许有静态变量初始化的赋值操作，因此接口和类一样也会生成静态构造方法。 接口在执行静态构造方法时，不需要加载父接口，也不需要在准备阶段执行父接口的静态构造方法，只有在使用了父接口的静态变量才会加载父接口，并执行父接口的静态构造方法。 1.4 使用阶段调用成员变量或者成员方法执行业务逻辑。 1.5 卸载阶段虚拟机在进行垃圾收集的时候卸载类。 2 类加载器2.1 简介类加载器是通过类的全类名来加载类的二进制字节流的代码模块，其主要作用是将class文件二进制数据放入方法区内，然后在堆内创建一个Class类型的对象。 使用Class对象封装类在方法区内的数据结构，向开发者提供了访问方法区内数据结构的接口。 2.2 唯一对于任意一个类，都需要由类的类加载器和类本身共同确立其在虚拟机中的唯一性。 即使两个类来源于同一个Class文件，并且被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相同。 这里的相同包括equals()方法和isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。 2.3 分类从虚拟机的角度来看，只存在两种不同的类加载器： 启动类加载器：这个类加载器使用C++语言实现，是虚拟机自身的一部分。 其他类加载器：这些类加载器由Java语言实现，独立存在于虚拟机外部，继承自ClassLoader类。 站在开发人员的角度来看，可以将其他类加载器划分得更细致一些。 2.2.1 启动类加载器BootstrapClassLoader类负责加载存放在JDK安装目录中的lib目录中的类库，或被-Xbootclasspath参数指定路径中的类库（比如rt.jar和java开头的类）。 启动类加载器是无法被程序直接引用的，也就是说是无法直接获取的。 示例： java1234public static void main(String[] args) &#123; System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); System.out.println(String.class.getClassLoader());&#125; 结果： log12nullnull 2.2.2 扩展类加载器ExtensionClassLoader类由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK安装目录中的ext目录中的类库，或者被java.ext.dirs系统变量指定路径中的类库（比如javax开头的类）。 开发者可以直接使用扩展类加载器。 示例： java123public static void main(String[] args) &#123; System.out.println(ClassLoader.getSystemClassLoader().getParent());&#125; 结果： log1sun.misc.Launcher$ExtClassLoader@4b67cf4d 2.2.3 应用类加载器ApplicationClassLoader类由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径（ClassPath）所指定的类。 开发者可以直接使用应用类加载器，如果应用程序中没有自定义过自己的类加载器，默认使用这个类加载器。 示例： java12345public static void main(String[] args) &#123; System.out.println(ClassLoader.getSystemClassLoader()); System.out.println(Thread.currentThread().getContextClassLoader()); System.out.println(Demo.class.getClassLoader());&#125; 结果： log123sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$AppClassLoader@18b4aac2 2.2.4 自定义类加载器如果上述虚拟机自带的类加载器不能满足需求，就需要自定义类加载器。 比如应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样就需要自定义类加载器来实现。 自定义类加载器需要继承ClassLoader抽象类，并重写父类的findClass()方法，在所有父类加载器无法加载的时候调用findClass()方法加载类。 被加载的类： java1234567public class DemoBusiness &#123; public static void business() &#123; ClassLoader classLoader = DemoBusiness.class.getClassLoader(); System.out.println(&quot;ClassLoader &gt;&gt;&gt; &quot; + classLoader); System.out.println(&quot;ClassLoader.parent &gt;&gt;&gt; &quot; + classLoader.getParent()); &#125;&#125; 编译并生成class字节码文件： cmd1D:\\&gt;javac -encoding utf8 DemoBusiness.java 使用自定义类加载器： java1234567891011121314151617181920212223242526272829303132333435public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 指定类加载器加载调用 DemoClassLoader classLoader = new DemoClassLoader(); classLoader.loadClass(&quot;DemoBusiness&quot;).getMethod(&quot;business&quot;).invoke(null); &#125;&#125;class DemoClassLoader extends ClassLoader &#123; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // 加载指定类名的Class String classDir = &quot;D:\\\\&quot; + name.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;; byte[] classData = loadClassData(classDir); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String path) &#123; try (InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream()) &#123; int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 结果： log12ClassLoader &gt;&gt;&gt; DemoClassLoader@7ea987acClassLoader.parent &gt;&gt;&gt; sun.misc.Launcher$AppClassLoader@18b4aac2 2.4 关系类加载器的关系如图： 这里类加载器之间的父子关系一般不会以继承（Inheritance）关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 2.5 机制2.5.1 全盘负责机制当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 重要性： 保证一致性：确保一个类及其所有依赖项都由同一个类加载器加载。 命名空间隔离：这是沙箱机制和模块化的基础。不同类加载器加载的类属于不同的命名空间，即使类名相同也被视为不同的类。 2.5.2 双亲委派机制先让父类加载器加载该类，如果父类加载器之上还有加载器，则进一步向上委托，只有在父类加载器无法加载该类时才尝试自己加载该类。 重要性： 避免重复加载：确保一个类在JVM中只被加载一次，防止同一个类被不同加载器加载多次导致类型混乱和资源浪费。 保证核心库安全：保证程序安全稳定运行，防止核心类被随意篡改。 在某些特定场景下，类加载机制不遵循双亲委派的原则，而是由子加载器主动加载或选择特定的加载路径，破坏了双亲委派模型。 但是这种破坏并非设计缺陷，而是为满足特定需求而采取的必要手段： 历史原因核心类依赖应用类容器隔离需求动态更新在JDK1.2之前，尚未引入双亲委派模型，用户自定义类加载器需要重写loadClass()方法，可能未遵循委派模型。 在JDK1.2之后，引入了双亲委派模型，用户自定义类加载器需要重写findClass()方法，符合双亲委派模型。 总结： 如果想破坏双亲委派模型，就重写loadClass()方法。 如果想保持双亲委派模型，就重写findClass()方法。 在某些特殊场景中，接口由启动类加载器加载，实现类由应用类加载器加载，此时应当由应用类加载器负责接口的加载。 比如JNDI服务，接口由启动类加载器去加载，由独立厂商实现的接口提供者（SPI，Service Provider Interface）的代码属于实现类，启动类加载器无法加载用户自定义的实现类。 解决办法是使用线程上下文类加载器（Thread Context ClassLoader），支持设置和获取： 使用Thread.setContextClassLoaser()方法进行设置。 使用Thread.currentThread().getContextClassLoader()方法获取。 当启动类加载器加载核心类后，需要加载实现类时，启动类加载器尝试获取线程上下文类加载器加载实现类。如果创建线程时没有设置，将使用父线程的线程上下文类加载器，如果在全局范围内都没有设置，默认使用应用程序类加载器。 所有涉及SPI的加载动作基本上都采用这种逆向委派方式加载，例如JNDI和JDBC等。Tomcat需要部署多个Web应用，每个应用可能依赖不同版本的类库。若遵循双亲委派，这些类会被父加载器加载并共享，导致版本冲突。 Tomcat使用WebAppClassLoader加载，失败后再委托SharedClassLoader加载，而非默认双亲委派。 这么做可以让每个Web应用的类由自己的WebAppClassLoader加载，实现类隔离，避免版本冲突。为了追求程序的动态性，使用热替换（Hot Swap）和热部署（Hot Deployment）等技术，在不重启JVM的情况下更新类。 OSGi框架为每个模块创建独立的BundleClassLoader类加载器，当模块动态更新时，OSGi会销毁旧的类加载器，创建新的类加载器重新加载类，此时新类与旧类虽然全限定名相同，但属于不同类加载器加载的不同类，实现热部署。 这种模型完全打破了双亲委派的层级关系，类加载器之间可以平级委托甚至双向委托，灵活性极高。 2.5.3 缓存机制加载过的Class会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。 这就是为什么修改了Class后，必须重启虚拟机才会生效，这也是热部署需要解决的问题。 2.5.4 沙箱机制沙箱机制是将代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。 沙箱机制是对核心源代码的保护，在一定程度上可以保护程序安全，保护原生的JDK代码。 3 类加载顺序当加载类时： 加载同时被static和final修饰的基本类型（包括String类型）的常量并赋值。在准备阶段完成。 加载父类的静态代码，包括静态代码块和静态变量，优先加载写在前面的代码。在初始化阶段完成。 加载类的静态代码，包括静态代码块和静态变量，优先加载写在前面的代码。在初始化阶段完成。 加载父类的成员属性，包括构造代码块和成员变量，优先加载写在前面的代码。在初始化阶段完成。 加载父类的构造器方法。在初始化阶段完成。 加载类的成员属性，包括构造代码块和成员变量，优先加载写在前面的代码。在初始化阶段完成。 加载类的构造器方法。在初始化阶段完成。 示例： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Demo &#123; public static void main(String[] args) throws Exception &#123; new Person(); &#125;&#125;class Person extends Human &#123; public static PersonOtherStatic personOtherStatic = new PersonOtherStatic(); static &#123; System.out.println(&quot;Person 静态代码块 ...&quot;); &#125; public PersonOther personOther = new PersonOther(); &#123; System.out.println(&quot;Person 普通代码块 ...&quot;); &#125; public Person() &#123; super(); System.out.println(&quot;Person 构造器 ...&quot;); &#125;&#125;class Human &#123; public static HumanOtherStatic humanOtherStatic = new HumanOtherStatic(); static &#123; System.out.println(&quot;Human 静态代码块 ...&quot;); &#125; &#123; System.out.println(&quot;Human 普通代码块 ...&quot;); &#125; public Human() &#123; super(); System.out.println(&quot;Human 构造器 ...&quot;); &#125;&#125;class PersonOther &#123; static &#123; System.out.println(&quot;PersonOther 静态代码块 ...&quot;); &#125; &#123; System.out.println(&quot;PersonOther 普通代码块 ...&quot;); &#125; public PersonOther() &#123; super(); System.out.println(&quot;PersonOther 构造器 ...&quot;); &#125;&#125;class PersonOtherStatic &#123; static &#123; System.out.println(&quot;PersonOtherStatic 静态代码块 ...&quot;); &#125; &#123; System.out.println(&quot;PersonOtherStatic 普通代码块 ...&quot;); &#125; public PersonOtherStatic() &#123; super(); System.out.println(&quot;PersonOtherStatic 构造器 ...&quot;); &#125;&#125;class HumanOtherStatic &#123; static &#123; System.out.println(&quot;HumanOtherStatic 静态代码块 ...&quot;); &#125; &#123; System.out.println(&quot;HumanOtherStatic 普通代码块 ...&quot;); &#125; public HumanOtherStatic() &#123; super(); System.out.println(&quot;HumanOtherStatic 构造器 ...&quot;); &#125;&#125; 结果： log123456789101112131415HumanOtherStatic 静态代码块 ...HumanOtherStatic 普通代码块 ...HumanOtherStatic 构造器 ...Human 静态代码块 ...PersonOtherStatic 静态代码块 ...PersonOtherStatic 普通代码块 ...PersonOtherStatic 构造器 ...Person 静态代码块 ...Human 普通代码块 ...Human 构造器 ...PersonOther 静态代码块 ...PersonOther 普通代码块 ...PersonOther 构造器 ...Person 普通代码块 ...Person 构造器 ...","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"整体架构","slug":"D00-后端/D01-Java/004-虚拟机/001-整体架构","date":"2025-07-30T07:33:23.000Z","updated":"2025-08-06T01:44:18.760Z","comments":true,"path":"posts/20250730/153323/","permalink":"https://momashanhe.com/posts/20250730/153323/","excerpt":"摘要：本文主要学习了虚拟机的整体架构。","text":"摘要：本文主要学习了虚拟机的整体架构。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介1.1 定义虚拟机（Java Virtual Machine，JVM）是Java程序运行的核心环境，它负责将class文件解释或编译为本地机器指令，并管理内存、线程、垃圾回收等关键任务。 1.2 体系结构Java编译器输入的指令流有两种： 基于栈的指令集架构：特点是不需要硬件支持，可移植性更好，更好实现跨平台。 基于寄存器的指令集架构：特点是性能优秀和执行更高效。 由于跨平台性的设计，Java的指令集基于栈进行设计。 JVM模型如下： 模型包括类加载器、运行时数据区、执行引擎、本地接口、本地类库。 1.3 发展历史1.3.1 Sun Classic VM早在1996年JDK1.0版本的时候，Sun公司发布的Java虚拟机，是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。 这款虚拟机内部只提供解释器，还没有JIT编译器，效率比较低。 可以通过外挂使用JIT编译器，但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作。 现在HotSpot VM内置了此虚拟机。 1.3.2 Exact VM为了解决上一个虚拟机问题，在JDK1.2时Sun公司提供了此虚拟机。 这款虚拟机具备现代高性能虚拟机的维形，不仅支持热点探测，还支持编译器与解释器混合工作模式。 1.3.3 HotSpot VM最初由Longview Technologies公司设计。1997年，此公司被Sun公司收购。2009年，Sun公司被甲骨文公司收购。 在JDK1.3时，成为默认的虚拟机。 名称中的HotSpot指的就是它的热点代码探测技术： 通过计数器找到最具编译价值代码，触发即时编译或栈上替换。 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。 1.3.4 Taobao JVM由阿里JVM团队发布，基于Hotspot VM发布的国内第一个深度定制且开源的高性能服务器版Java虚拟机。 硬件严重依赖Intel的CPU，损失了兼容性，但提高了性能。 1.3.5 Graal VM2018年4月，Oracle Labs公开了Graal VM，号称“Run Programs Faster Anywhere”，野心勃勃。与1995年Java的“write once，run anywhere”遥相呼应。 是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用，包括Java、Scala、Groovy、Kotlin、C、C++、Javascript、Ruby、Python、R等。 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 2 组成部分2.1 类加载器类加载器的作用是读取编译后的class文件，寻找类并加载到JVM内存中。 2.2 运行时数据区运行时数据区的作用是在程序执行期间存储数据，包括类的信息，变量和常量，代码和指令，计算结果等数据。 在JDK1.8以前，运行时数据区是由程序计数器、本地方法栈、虚拟机栈、堆、方法区组成。 在JDK1.8以后，在本地内存增加了元空间的概念，将方法区从运行时数据区移除并作为元空间的实现放到了本地内存。 其中，方法区和堆是线程共享区域，虚拟机栈和本地方法栈以及程序计数器是线程私有区域。 2.3 执行引擎执行引擎的作用是对class文件中的字节码进行编译解释，转换为机器指令码并执行。 在执行指令码时，会将计算结果存储在运行时数据区中。 2.4 本地接口本地接口的作用是为执行引擎提供支持。 2.5 本地类库本地类库的作用是为执行引擎和本地接口提供支持。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"锁事","slug":"D00-后端/D01-Java/003-并发/014-锁事","date":"2025-07-30T06:32:23.000Z","updated":"2025-07-30T07:27:24.706Z","comments":true,"path":"posts/20250730/143223/","permalink":"https://momashanhe.com/posts/20250730/143223/","excerpt":"摘要：本文主要学习了多线程中有关锁的一些特性。","text":"摘要：本文主要学习了多线程中有关锁的一些特性。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 锁升级在JDK1.5之前，使用synchronized是操作系统级别的重量级操作。在JDK1.6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁。 在Java对象头里的MarkWord中存储了synchronized用到的锁，锁升级主要依赖占用1位的偏向锁标志位和占用2位的锁标志位。 1.1 无锁对象被实例化后，如果没有线程竞争锁，就是无锁状态。 偏向锁标志位为0，锁标志位为01。 1.2 偏向锁同步代码一直被同一个线程访问，在后续访问时会自动获得偏向锁。 偏向锁标志位为1，锁标志位为01。 1.3 轻量锁同步代码存在线程竞争，会升级为轻量锁，通过CAS自旋尝试获取锁。 偏向锁标志位为0，锁标志位为00。 1.4 重量锁同步代码存在线程竞争，并且通过CAS自旋尝试超过一定次数以后，仍未能获取锁，会升级为重量锁。 偏向锁标志位为0，锁标志位为10。 2 锁消除如果在同步代码块中锁的是局部对象，而不是共享对象，编译器就会无视同步代码块，相当于并没有对锁住的对象加锁，消除了锁的使用。 3 锁粗化如果前后同步代码块锁住的都是同一个对象，编译器就会把代码块合并成更大的代码块，加粗加大范围，一次申请锁使用即可，避免多次的申请和释放锁，提升了性能。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"ForkJoin","slug":"D00-后端/D01-Java/003-并发/013-ForkJoin","date":"2025-07-26T09:41:17.000Z","updated":"2025-07-30T06:34:04.496Z","comments":true,"path":"posts/20250726/174117/","permalink":"https://momashanhe.com/posts/20250726/174117/","excerpt":"摘要：本文主要学习了多线程的ForkJoin框架。","text":"摘要：本文主要学习了多线程的ForkJoin框架。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介在JDK1.7之后引入了ForkJoin框架，将一个大任务分解成多个子任务，子任务可以继续往下分解，将多个子任务的结果合并成一个大结果，最终合并成大任务的结果。 ForkJoin框架要完成两件事情： Fork：把大任务拆分成子任务。 Join：把子任务的结果合并成大任务的结果。 ForkJoin框架的实现非常复杂，内部大量运用了位操作和无锁算法，核心组件： ForkJoinPool：基于工作窃取算法的线程池，负责全局任务调度与负载均衡。 ForkJoinTask：可递归Fork和Join的任务单元，自带状态机驱动完成通知。 ForkJoinWorkerThread：拥有独立队列的线程，优先执行本地任务，空闲时窃取外部队列任务。 WorkQueue：无锁双端队列，支持FIFO先进先出和LIFO后进先出，实现高效任务分发与窃取。 2 类和接口2.1 ForkJoinPoolForkJoinPool是分支合并池，类似于线程池ThreadPoolExecutor类，同样是ExecutorService接口的一个实现类。 在ForkJoinPool类中提供了三个构造方法： java123public ForkJoinPool();public ForkJoinPool(int parallelism);public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode); 最终调用的是下面这个私有构造器： java1private ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, int mode, String workerNamePrefix); 参数含义： parallelism：并行级别，默认值为CPU核心数，ForkJoinPool里线程数量与该参数有关，但它不表示最大线程数。 factory：线程工厂，默认是DefaultForkJoinWorkerThreadFactory，其实就是用来创建ForkJoinWorkerThread线程对象。 handler：异常处理器。 mode：调度模式，FIFO_QUEUE表示本地队列先进先出，LIFO_QUEUE表示本地队列后进先出。 workerNamePrefix：线程的名称前缀。 成员变量： config：创建ForkJoinPool的配置，int类型的变量，占32位内存： 低16位表示parallelism。 第17位表示mode，0表示队列后进先出，1表示队列先进先出。 第32位表示是否共享模式，0表示普通模式，1表示共享模式，队列没有线程，只能被其他线程窃取任务。 ctl：ForkJoinPool的主要控制字段，long类型的变量，占64位内存： 第63~48位表示激活线程数量，值为激活线程数减去parallelism（补码表示），线程激活则加1，线程停用则减1。当累积增加parallelism时第63位翻转为0，则不允许再激活线程。 第47~32位表示所有线程数量，值为所有线程数减去parallelism（补码表示），创建线程则加1，终止线程则减1。当累积增加parallelism时第47位翻转为0，则不允许再创建线程。 第31～0位表示非激活线程链中top线程的本地队列的scanState属性： 第15~0位表示非激活线程链中top线程的本地队列在workQueues数组中的索引。 第31~16位表示非激活线程链中top线程的版本计数和线程状态。 workQueues：WorkQueue数组，奇数索引的队列可以关联线程并接收线程提交的本地任务，偶数索引的队列只能接收外部任务。 factory：创建线程的工厂。 2.2 ForkJoinTaskForkJoinTask是Future接口的抽象实现类，提供了用于分解任务的fork()方法和用于合并任务的join()方法。 在ThreadPoolExecutor类中，线程池执行任务调用的execute()方法中要求传入Runnable接口的实例。但是在ForkJoinPool类中，除了可以传入Runnable接口的实例外，还可以传入ForkJoinTask抽象类的实例，并且传入Runnable接口的实例也会被适配为ForkJoinTask抽象类的实例。 2.3 RecursiveTask通常情况下使用ForkJoinTask抽象类的实例，并不需要直接继承ForkJoinTask类，只需要继承其子类： RecursiveAction：用于没有返回结果的任务。 RecursiveTask：用于有返回结果的任务，最常用。 2.4 ForkJoinWorkerThreadForkJoinWorkerThread类是Thread的子类，作为线程池中的线程执行任务，其内部维护了一个WorkerQueue类型的双向任务队列。 线程在执行任务时，优先处理本地任务队列中的任务（支持FIFO和LIFO），当本地任务队列为空时，会窃取外部任务队列中的任务（FIFO）。 2.5 WorkerQueueWorkerQueue类是ForkJoinPool类的一个内部类，存储ForkJoinTask实例的双端队列。 3 源码3.1 提交任务调用ForkJoinPool类的submit()方法提交任务，将任务添加到外部队列，唤醒线程执行任务： java123456public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); externalPush(task); return task;&#125; 3.2 分解任务调用ForkJoinTask类的fork()方法分解任务，将任务添加到队列并唤醒线程执行任务： java1234567891011public final ForkJoinTask&lt;V&gt; fork() &#123; Thread t; // 判断调用线程是否为内部线程 if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) // 如果是内部线程，将任务添加到本地队列，唤醒线程执行任务 ((ForkJoinWorkerThread)t).workQueue.push(this); else // 如果不是内部线程，将任务添加到外部队列，唤醒线程执行任务 ForkJoinPool.common.externalPush(this); return this;&#125; 3.3 添加任务3.3.1 添加任务到本地队列调用WorkQueue类的push()方法，将任务添加到本地队列，唤醒线程执行任务： java123456789101112131415161718final void push(ForkJoinTask&lt;?&gt; task) &#123; ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p; int b = base, s = top, n; if ((a = array) != null) &#123; // ignore if queue removed int m = a.length - 1; // fenced write for task visibility // 将任务添加到本地队列 U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task); U.putOrderedInt(this, QTOP, s + 1); if ((n = s - b) &lt;= 1) &#123; if ((p = pool) != null) // 唤醒线程执行任务 p.signalWork(p.workQueues, this); &#125; else if (n &gt;= m) // 扩容 growArray(); &#125;&#125; 3.3.2 添加任务到外部队列调用ForkJoinPool类的externalPush()方法，将任务添加到外部队列，唤醒线程执行任务： java12345678910111213141516171819202122232425final void externalPush(ForkJoinTask&lt;?&gt; task) &#123; WorkQueue[] ws; WorkQueue q; int m; int r = ThreadLocalRandom.getProbe(); int rs = runState; // 计算偶数下标，尝试将任务添加到外部队列 if ((ws = workQueues) != null &amp;&amp; (m = (ws.length - 1)) &gt;= 0 &amp;&amp; (q = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp; r != 0 &amp;&amp; rs &gt; 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123; ForkJoinTask&lt;?&gt;[] a; int am, n, s; if ((a = q.array) != null &amp;&amp; (am = a.length - 1) &gt; (n = (s = q.top) - q.base)) &#123; int j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE; U.putOrderedObject(a, j, task); U.putOrderedInt(q, QTOP, s + 1); U.putIntVolatile(q, QLOCK, 0); if (n &lt;= 1) // 唤醒线程执行任务 signalWork(ws, q); return; &#125; U.compareAndSwapInt(q, QLOCK, 1, 0); &#125; // 添加任务失败，初始化外部队列，唤醒线程执行任务 externalSubmit(task);&#125; 调用ForkJoinPool类的externalSubmit()方法，初始化外部队列，唤醒线程执行任务： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void externalSubmit(ForkJoinTask&lt;?&gt; task) &#123; int r; // initialize caller&#x27;s probe if ((r = ThreadLocalRandom.getProbe()) == 0) &#123; ThreadLocalRandom.localInit(); r = ThreadLocalRandom.getProbe(); &#125; for (;;) &#123; WorkQueue[] ws; WorkQueue q; int rs, m, k; boolean move = false; // 如果runState为负数，则终止线程池并跳出循环 if ((rs = runState) &lt; 0) &#123; tryTerminate(false, false); // help terminate throw new RejectedExecutionException(); &#125; // 如果线程池未初始化，则初始化然后继续循环 else if ((rs &amp; STARTED) == 0 || // initialize ((ws = workQueues) == null || (m = ws.length - 1) &lt; 0)) &#123; int ns = 0; rs = lockRunState(); try &#123; if ((rs &amp; STARTED) == 0) &#123; U.compareAndSwapObject(this, STEALCOUNTER, null, new AtomicLong()); // create workQueues array with size a power of two int p = config &amp; SMASK; // ensure at least 2 slots int n = (p &gt; 1) ? p - 1 : 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n = (n + 1) &lt;&lt; 1; workQueues = new WorkQueue[n]; ns = STARTED; &#125; &#125; finally &#123; unlockRunState(rs, (rs &amp; ~RSLOCK) | ns); &#125; &#125; // 如果队列不为空，则加锁尝试添加任务唤醒工作线程并跳出循环 else if ((q = ws[k = r &amp; m &amp; SQMASK]) != null) &#123; if (q.qlock == 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) &#123; ForkJoinTask&lt;?&gt;[] a = q.array; int s = q.top; boolean submitted = false; // initial submission or resizing try &#123; // locked version of push if ((a != null &amp;&amp; a.length &gt; s + 1 - q.base) || (a = q.growArray()) != null) &#123; int j = (((a.length - 1) &amp; s) &lt;&lt; ASHIFT) + ABASE; U.putOrderedObject(a, j, task); U.putOrderedInt(q, QTOP, s + 1); submitted = true; &#125; &#125; finally &#123; U.compareAndSwapInt(q, QLOCK, 1, 0); &#125; if (submitted) &#123; // 唤醒线程执行任务 signalWork(ws, q); return; &#125; &#125; move = true; // move on failure &#125; // 如果队列为空，则创建队列并放到数组的偶数索引然后继续循环 else if (((rs = runState) &amp; RSLOCK) == 0) &#123; // create new queue q = new WorkQueue(this, null); q.hint = r; q.config = k | SHARED_QUEUE; q.scanState = INACTIVE; rs = lockRunState(); // publish index if (rs &gt; 0 &amp;&amp; (ws = workQueues) != null &amp;&amp; k &lt; ws.length &amp;&amp; ws[k] == null) ws[k] = q; // else terminated unlockRunState(rs, rs &amp; ~RSLOCK); &#125; // 重新获取下标并进行新的循环 else move = true; // move if busy if (move) r = ThreadLocalRandom.advanceProbe(r); &#125;&#125; 3.4 唤醒线程调用ForkJoinPool类的signalWork()方法唤醒线程： java123456789101112131415161718192021222324252627282930313233final void signalWork(WorkQueue[] ws, WorkQueue q) &#123; long c; int sp, i; WorkQueue v; Thread p; // 最高位为1表示可以激活线程 while ((c = ctl) &lt; 0L) &#123; // too few active // 低16位为0表示没有非激活线程 if ((sp = (int)c) == 0) &#123; // no idle workers // 第47位不为0表示可以创建线程 if ((c &amp; ADD_WORKER) != 0L) // too few workers // 创建线程 tryAddWorker(c); break; &#125; if (ws == null) // unstarted/terminated break; if (ws.length &lt;= (i = sp &amp; SMASK)) // terminated break; if ((v = ws[i]) == null) // terminating break; // 获取非激活线程链的top线程然后激活，将下一个非激活线程作为top线程 int vs = (sp + SS_SEQ) &amp; ~INACTIVE; // next scanState int d = sp - v.scanState; // screen CAS long nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred); if (d == 0 &amp;&amp; U.compareAndSwapLong(this, CTL, c, nc)) &#123; v.scanState = vs; // activate v if ((p = v.parker) != null) // 唤醒线程执行任务 U.unpark(p); break; &#125; if (q != null &amp;&amp; q.base == q.top) // no more work break; &#125;&#125; 调用ForkJoinPool类的tryAddWorker()方法： java123456789101112131415161718192021private void tryAddWorker(long c) &#123; boolean add = false; do &#123; // 设置活跃线程数和总线程数 long nc = ((AC_MASK &amp; (c + AC_UNIT)) | (TC_MASK &amp; (c + TC_UNIT))); if (ctl == c) &#123; int rs, stop; // check if terminating if ((stop = (rs = lockRunState()) &amp; STOP) == 0) add = U.compareAndSwapLong(this, CTL, c, nc); unlockRunState(rs, rs &amp; ~RSLOCK); if (stop != 0) break; if (add) &#123; // 创建线程 createWorker(); break; &#125; &#125; &#125; while (((c = ctl) &amp; ADD_WORKER) != 0L &amp;&amp; (int)c == 0);&#125; 调用ForkJoinPool类的createWorker()方法： java123456789101112131415161718private boolean createWorker() &#123; ForkJoinWorkerThreadFactory fac = factory; Throwable ex = null; ForkJoinWorkerThread wt = null; try &#123; // 创建线程 if (fac != null &amp;&amp; (wt = fac.newThread(this)) != null) &#123; // 启动线程 wt.start(); return true; &#125; &#125; catch (Throwable rex) &#123; ex = rex; &#125; // 注销线程 deregisterWorker(wt, ex); return false;&#125; 3.5 管理线程3.5.1 创建线程调用ForkJoinPool类的newThread()方法创建线程： java123public final ForkJoinWorkerThread newThread(ForkJoinPool pool) &#123; return new ForkJoinWorkerThread(pool);&#125; 调用ForkJoinWorkerThread类的构造方法创建线程： java123456protected ForkJoinWorkerThread(ForkJoinPool pool) &#123; // Use a placeholder until a useful name can be set in registerWorker super(&quot;aForkJoinWorkerThread&quot;); this.pool = pool; this.workQueue = pool.registerWorker(this);&#125; 调用ForkJoinPool类的registerWorker()方法创建线程： java123456789101112131415161718192021222324252627282930313233343536373839final WorkQueue registerWorker(ForkJoinWorkerThread wt) &#123; UncaughtExceptionHandler handler; wt.setDaemon(true); // configure thread if ((handler = ueh) != null) wt.setUncaughtExceptionHandler(handler); WorkQueue w = new WorkQueue(this, wt); int i = 0; // assign a pool index int mode = config &amp; MODE_MASK; int rs = lockRunState(); try &#123; WorkQueue[] ws; int n; // skip if no array if ((ws = workQueues) != null &amp;&amp; (n = ws.length) &gt; 0) &#123; int s = indexSeed += SEED_INCREMENT; // unlikely to collide int m = n - 1; // 保证i是奇数 i = ((s &lt;&lt; 1) | 1) &amp; m; // odd-numbered indices if (ws[i] != null) &#123; // collision int probes = 0; // step by approx half n int step = (n &lt;= 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2; // 保证线程的本地队列在workQueues数组中的索引是奇数 while (ws[i = (i + step) &amp; m] != null) &#123; if (++probes &gt;= n) &#123; workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= 1); m = n - 1; probes = 0; &#125; &#125; &#125; w.hint = s; // use as random seed w.config = i | mode; w.scanState = i; // publication fence ws[i] = w; &#125; &#125; finally &#123; unlockRunState(rs, rs &amp; ~RSLOCK); &#125; wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; 1))); return w;&#125; 3.5.2 启动线程调用Thread类的start()方法创建线程，逐步调用ForkJoinWorkerThread类run()方法： java12345678910111213141516171819202122public void run() &#123; if (workQueue.array == null) &#123; // only run once Throwable exception = null; try &#123; onStart(); // 启动线程 pool.runWorker(workQueue); &#125; catch (Throwable ex) &#123; exception = ex; &#125; finally &#123; try &#123; onTermination(exception); &#125; catch (Throwable ex) &#123; if (exception == null) exception = ex; &#125; finally &#123; // 注销线程 pool.deregisterWorker(this, exception); &#125; &#125; &#125;&#125; 调用ForkJoinPool类的runWorker()方法： java1234567891011121314151617final void runWorker(WorkQueue w) &#123; // 初始化任务队列 w.growArray(); // allocate queue int seed = w.hint; // initially holds randomization hint int r = (seed == 0) ? 1 : seed; // avoid 0 for xorShift for (ForkJoinTask&lt;?&gt; t;;) &#123; // 尝试窃取任务 if ((t = scan(w, r)) != null) // 执行任务 w.runTask(t); // 窃取失败，加入等待队列，继续循环 else if (!awaitWork(w, r)) // 加入等待队列失败，跳出循环 break; r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // xorshift &#125;&#125; 3.5.3 注销线程调用ForkJoinPool类的deregisterWorker()方法： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) &#123; WorkQueue w = null; // 移除队列 if (wt != null &amp;&amp; (w = wt.workQueue) != null) &#123; WorkQueue[] ws; // remove index from array int idx = w.config &amp; SMASK; int rs = lockRunState(); if ((ws = workQueues) != null &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w) ws[idx] = null; unlockRunState(rs, rs &amp; ~RSLOCK); &#125; // 减少CTL long c; // decrement counts do &#123;&#125; while (!U.compareAndSwapLong (this, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) | (TC_MASK &amp; (c - TC_UNIT)) | (SP_MASK &amp; c)))); // 处理队列相关参数 if (w != null) &#123; w.qlock = -1; // ensure set w.transferStealCount(this); w.cancelAll(); // cancel remaining tasks &#125; // 处理未终止的线程 for (;;) &#123; // possibly replace WorkQueue[] ws; int m, sp; // 尝试终止线程 if (tryTerminate(false, false) || w == null || w.array == null || (runState &amp; STOP) != 0 || (ws = workQueues) == null || (m = ws.length - 1) &lt; 0) // already terminating break; // 终止线程失败，存在空闲线程，尝试激活空闲线程 if ((sp = (int)(c = ctl)) != 0) &#123; // wake up replacement if (tryRelease(c, ws[sp &amp; m], AC_UNIT)) break; &#125; // 终止线程失败，并且不存在空闲线程，但CTL不为0，创建替换线程执行 else if (ex != null &amp;&amp; (c &amp; ADD_WORKER) != 0L) &#123; tryAddWorker(c); // create replacement break; &#125; // 符合条件，跳出循环 else // don&#x27;t need replacement break; &#125; if (ex == null) // help clean on way out // 处理异常 ForkJoinTask.helpExpungeStaleExceptions(); else // 抛出异常 // rethrow ForkJoinTask.rethrow(ex);&#125; 3.6 管理任务3.6.1 窃取任务调用ForkJoinPool类的scan()方法窃取任务： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private ForkJoinTask&lt;?&gt; scan(WorkQueue w, int r) &#123; WorkQueue[] ws; int m; if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt; 0 &amp;&amp; w != null) &#123; int ss = w.scanState; // initially non-negative for (int origin = r &amp; m, k = origin, oldSum = 0, checkSum = 0;;) &#123; WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; int b, n; long c; // 定位任务队列 if ((q = ws[k]) != null) &#123; if ((n = (b = q.base) - q.top) &lt; 0 &amp;&amp; (a = q.array) != null) &#123; // non-empty long i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE; if ((t = ((ForkJoinTask&lt;?&gt;) U.getObjectVolatile(a, i))) != null &amp;&amp; q.base == b) &#123; if (ss &gt;= 0) &#123; if (U.compareAndSwapObject(a, i, t, null)) &#123; q.base = b + 1; if (n &lt; -1) // signal others // 创建线程执行任务 signalWork(ws, q); return t; &#125; &#125; else if (oldSum == 0 &amp;&amp; // try to activate w.scanState &lt; 0) // 激活栈顶线程 tryRelease(c = ctl, ws[m &amp; (int)c], AC_UNIT); &#125; if (ss &lt; 0) // refresh ss = w.scanState; r ^= r &lt;&lt; 1; r ^= r &gt;&gt;&gt; 3; r ^= r &lt;&lt; 10; origin = k = r &amp; m; // move and rescan oldSum = checkSum = 0; continue; &#125; checkSum += b; &#125; // 已扫描全部线程，但并未找到任务 if ((k = (k + 1) &amp; m) == origin) &#123; // continue until stable if ((ss &gt;= 0 || (ss == (ss = w.scanState))) &amp;&amp; oldSum == (oldSum = checkSum)) &#123; if (ss &lt; 0 || w.qlock &lt; 0) // already inactive break; // 尝试对当前线程灭活 int ns = ss | INACTIVE; // try to inactivate long nc = ((SP_MASK &amp; ns) | (UC_MASK &amp; ((c = ctl) - AC_UNIT))); w.stackPred = (int)c; // hold prev stack top U.putInt(w, QSCANSTATE, ns); if (U.compareAndSwapLong(this, CTL, c, nc)) ss = ns; else w.scanState = ss; // back out &#125; checkSum = 0; &#125; &#125; &#125; return null;&#125; 3.6.2 执行任务调用WorkQueue类的runTask()方法执行任务： java1234567891011121314151617final void runTask(ForkJoinTask&lt;?&gt; task) &#123; if (task != null) &#123; scanState &amp;= ~SCANNING; // mark as busy // 执行外部任务 (currentSteal = task).doExec(); U.putOrderedObject(this, QCURRENTSTEAL, null); // release for GC // 执行本地任务 execLocalTasks(); ForkJoinWorkerThread thread = owner; if (++nsteals &lt; 0) // collect on overflow // 增加窃取任务数 transferStealCount(pool); scanState |= SCANNING; if (thread != null) thread.afterTopLevelExec(); &#125;&#125; 3.6.3 阻塞任务调用ForkJoinPool类的awaitWork()方法阻塞任务： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private boolean awaitWork(WorkQueue w, int r) &#123; if (w == null || w.qlock &lt; 0) // w is terminating return false; for (int pred = w.stackPred, spins = SPINS, ss;;) &#123; if ((ss = w.scanState) &gt;= 0) break; else if (spins &gt; 0) &#123; r ^= r &lt;&lt; 6; r ^= r &gt;&gt;&gt; 21; r ^= r &lt;&lt; 7; if (r &gt;= 0 &amp;&amp; --spins == 0) &#123; // randomize spins WorkQueue v; WorkQueue[] ws; int s, j; AtomicLong sc; if (pred != 0 &amp;&amp; (ws = workQueues) != null &amp;&amp; (j = pred &amp; SMASK) &lt; ws.length &amp;&amp; (v = ws[j]) != null &amp;&amp; // see if pred parking (v.parker == null || v.scanState &gt;= 0)) spins = SPINS; // continue spinning &#125; &#125; else if (w.qlock &lt; 0) // recheck after spins return false; else if (!Thread.interrupted()) &#123; long c, prevctl, parkTime, deadline; int ac = (int)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK); if ((ac &lt;= 0 &amp;&amp; tryTerminate(false, false)) || (runState &amp; STOP) != 0) // pool terminating return false; if (ac &lt;= 0 &amp;&amp; ss == (int)c) &#123; // is last waiter prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred); int t = (short)(c &gt;&gt;&gt; TC_SHIFT); // shrink excess spares if (t &gt; 2 &amp;&amp; U.compareAndSwapLong(this, CTL, c, prevctl)) return false; // else use timed wait parkTime = IDLE_TIMEOUT * ((t &gt;= 0) ? 1 : 1 - t); deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP; &#125; else prevctl = parkTime = deadline = 0L; Thread wt = Thread.currentThread(); U.putObject(wt, PARKBLOCKER, this); // emulate LockSupport w.parker = wt; if (w.scanState &lt; 0 &amp;&amp; ctl == c) // recheck before park U.park(false, parkTime); U.putOrderedObject(w, QPARKER, null); U.putObject(wt, PARKBLOCKER, null); if (w.scanState &gt;= 0) break; if (parkTime != 0L &amp;&amp; ctl == c &amp;&amp; deadline - System.nanoTime() &lt;= 0L &amp;&amp; U.compareAndSwapLong(this, CTL, c, prevctl)) return false; // shrink pool &#125; &#125; return true;&#125; 3.7 合并任务调用ForkJoinTask类的join()方法获取任务执行结果： java123456public final V join() &#123; int s; if ((s = doJoin() &amp; DONE_MASK) != NORMAL) reportException(s); return getRawResult();&#125; 调用ForkJoinTask类的doJoin()方法： java123456789private int doJoin() &#123; int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w; return (s = status) &lt; 0 ? s : ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? (w = (wt = (ForkJoinWorkerThread)t).workQueue). tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s : wt.pool.awaitJoin(w, this, 0L) : externalAwaitDone();&#125; 4 使用任务类定义，因为需要返回结果，所以继承RecursiveTask，并覆写compute方法。 任务的拆分通过ForkJoinTask的fork方法执行，join方法用于等待任务执行后返回。 示例： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Demo &#123; public static void main(String[] args) &#123; SumTask sumTask = new SumTask(1, 100); ForkJoinPool pool = new ForkJoinPool(); try &#123; ForkJoinTask&lt;Integer&gt; task = pool.submit(sumTask); System.out.println(task.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; pool.shutdown(); &#125; &#125;&#125;class SumTask extends RecursiveTask&lt;Integer&gt; &#123; // 拆分阈值 private static final int THRESHOLD = 10; // 拆分开始值 private int begin; // 拆分结束值 private int end; public SumTask(int begin, int end) &#123; this.begin = begin; this.end = end; &#125; @Override protected Integer compute() &#123; Integer value = 0; if (end - begin &lt;= THRESHOLD) &#123; // 小于阈值，直接计算 for (int i = begin; i &lt;= end; i++) &#123; value += i; &#125; &#125; else &#123; // 大于阈值，递归计算 int middle = (begin + end) / 2; SumTask beginTask = new SumTask(begin, middle); SumTask endTask = new SumTask(middle + 1, end); beginTask.fork(); endTask.fork(); value = beginTask.join() + endTask.join(); &#125; return value; &#125;&#125; 结果： log15050","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"辅助类","slug":"D00-后端/D01-Java/003-并发/012-辅助类","date":"2025-07-25T01:14:34.000Z","updated":"2025-07-26T09:35:05.671Z","comments":true,"path":"posts/20250725/091434/","permalink":"https://momashanhe.com/posts/20250725/091434/","excerpt":"摘要：本文主要学习了JUC提供的三个常用的辅助类。","text":"摘要：本文主要学习了JUC提供的三个常用的辅助类。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 CountDownLatch1.1 简介用于将线程阻塞某段时间，等其他线程完成后，唤醒被阻塞的线程继续执行。 CountDownLatch在内部维护了一个计数器，需要在构造方法中传入一个非负整数。 当线程调用await()方法后，判断计数器是否为0，如果为0则继续执行，如果不为0则阻塞线程。 当其他线程调用countDown()方法后，将计数器减1，并判断计数器是否为0，如果计数器不为0则无事发生，如果计数器为0则唤醒被阻塞的线程继续执行。 计数器无法被重置，只能使用一次，不能重复使用。 1.2 源码1.2.1 构造方法构造方法需要传入一个非负整数，否则会抛出异常： java1234567891011121314151617181920// CountDownLatch的构造方法public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); this.sync = new Sync(count);&#125;...// Sync继承自AQSprivate static final class Sync extends AbstractQueuedSynchronizer &#123; ... // Sync的构造方法 Sync(int count) &#123; setState(count); &#125; ...&#125;...// AQS类的setState()方法protected final void setState(int newState) &#123; state = newState;&#125; 1.2.2 阻塞方法调用await()方法后，判断计数器是否为0，如果为0则继续执行，如果不为0则阻塞线程： java123456789101112131415161718// CountDownLatch的await()方法public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;...// AQS的acquireSharedInterruptibly()方法public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;...// Sync的tryAcquireShared()方法protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; 1.2.3 减少计数调用countDown()方法将计数器减1，在执行会对进行双层判断： 在减少计数前，判断计数器是否为0，为0则返回false，不为0则减少计数。 在减少计数后，判断计数器是否为0，为0则返回true，不为0则返回false。 只有在减少后判断等于0的时候才会唤醒等待线程： java123456789101112131415161718192021222324// CountDownLatch的countDown()方法public void countDown() &#123; sync.releaseShared(1);&#125;// AQS的releaseShared()方法public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;// Sync的tryReleaseShared()方法protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 1.3 使用示例： java1234567891011public static void main(String[] args) throws InterruptedException &#123; CountDownLatch cdl = new CountDownLatch(2); for (int i = 1; i &lt;= cdl.getCount(); i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;离开课堂&quot;); cdl.countDown(); &#125;, i + &quot;号&quot;).start(); &#125; cdl.await(); System.out.println(&quot;所有学生都已离开课堂&quot;);&#125; 结果： log1231号离开课堂2号离开课堂所有学生都已离开课堂 2 CyclicBarrier2.1 简介用于将线程阻塞某段时间，等其他线程也被阻塞后，唤醒被阻塞的线程继续执行。 CyclicBarrier在内部维护了一个计数器和一个屏障操作，需要在构造方法中传入一个正整数和一个屏障方法。 当线程调用await()方法后，将计数器减1，并判断计数器是否为0，如果计数器不为0则阻塞线程，如果计数器为0则唤醒被阻塞的线程继续执行，并由当前线程执行屏障方法。 2.2 源码2.2.1 构造方法构造方法有两个，最终调用的是同一个。 要求传入一个正整数和一个屏障方法： java1234567891011// CyclicBarrier的构造方法，指定计数器和屏障方法public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;// CyclicBarrier的构造方法，指定计数器，默认屏障方法为空public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 2.2.2 阻塞方法调用await()方法后，线程会被阻塞，直到达到指定数量后，唤醒阻塞线程，并由当前线程执行屏障操作： java1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; 2.3 使用示例： java123456789101112131415public static void main(String[] args) &#123; CyclicBarrier cb = new CyclicBarrier(7, () -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;龙珠是最后一颗，龙珠集齐，召唤神龙&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;龙珠被收集&quot;); cb.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, String.valueOf(i)).start(); &#125;&#125; 结果： log123456781龙珠被收集4龙珠被收集5龙珠被收集7龙珠被收集3龙珠被收集2龙珠被收集6龙珠被收集4龙珠是最后一颗，龙珠集齐，召唤神龙 3 Semaphore3.1 简介用于控制同时访问许可证的线程数量。 Semaphore在内部维护了一个许可证数量，需要在构造方法中传入一个非负整数。 当线程调用acquire()方法后，尝试将许可证数量减1并判断是否大于等于0，如果为true则继续执行，如果为false则阻塞并等待，直到有许可证释放重新尝试获取许可证。 当线程调用release()方法后，释放许可证，唤醒被阻塞的线程抢占许可证。 3.2 源码3.2.1 构造方法构造方法有两个，都需要传入整型的许可证数量。 第一个使用非公平的锁： java1234// Semaphore类的非公平锁的构造方法public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125; 第二个可以传入参数指定使用公平锁还是非公平锁： java1234// Semaphore类的公平锁的构造方法public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 3.2.2 获取许可证调用acquire()方法后，线程尝试获取许可证，获取失败会被阻塞，当有许可证被释放时重新抢占许可证： java123public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125; 3.2.3 释放许可证调用release()方法后，线程释放许可证，唤醒被阻塞的线程抢占许可证： java123public void release() &#123; sync.releaseShared(1);&#125; 3.3 使用示例： java1234567891011121314151617public static void main(String[] args) &#123; Semaphore s = new Semaphore(2); for (int i = 1; i &lt;= 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; s.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到了&quot;); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + &quot;释放了&quot;); s.release(); &#125; &#125;, String.valueOf(i)).start(); &#125;&#125; 结果： log123456789101112132抢到了1抢到了// 等待1s1释放了2释放了4抢到了3抢到了// 等待1s3释放了4释放了5抢到了// 等待1s5释放了","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"AQS","slug":"D00-后端/D01-Java/003-并发/011-AQS","date":"2025-07-24T08:07:37.000Z","updated":"2025-07-26T14:22:50.204Z","comments":true,"path":"posts/20250724/160737/","permalink":"https://momashanhe.com/posts/20250724/160737/","excerpt":"摘要：本文主要了解了JUC中的AQS抽象类。","text":"摘要：本文主要了解了JUC中的AQS抽象类。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介1.1 定义AQS（AbstractQueuedSynchronizer，抽象的队列同步器）定义了一套多线程访问共享资源的同步器框架，是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石。 1.2 抽象AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 1.3 原理AQS最重要的组成部分是FIFO队列和state变量，通过FIFO队列来完成资源获取线程的排队工作，通过state整型变量表示持有锁的状态： 抢到资源的线程直接处理业务逻辑，抢不到资源的线程进入等待队列，这个队列是CLH队列的变体。队列将请求共享资源的线程封装成队列的Node结点，通过CAS自旋以及LockSupport的凭证机制，维护state变量的状态，使并发达到同步的控制效果。 CLH（Craig Landin Hagersten，三个科学家名字）队列的原版是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO，头节点在初始化后变为空节点。 2 架构源码： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; ... // 内部封装Node节点 static final class Node &#123; // 标记线程以共享的模式等待锁 static final Node SHARED = new Node(); // 标记线程以独占的模式等待锁 static final Node EXCLUSIVE = null; // waitStatus取值为1表示线程取消，即超时和中断，被取消的节点不会阻塞 static final int CANCELLED = 1; // waitStatus取值为-1表示后继节点已经准备完成，等待线程释放资源 static final int SIGNAL = -1; // waitStatus取值为-2表示线程在Condition队列中阻塞，当其他线程调用了Condition中的唤醒方法后，将节点从Condition队列转移到CLH等待队列 static final int CONDITION = -2; // waitStatus取值为-3表示线程及后续线程无条件传播 static final int PROPAGATE = -3; // 线程的等待状态，初始值为0 volatile int waitStatus; // 前驱节点 volatile Node prev // 后继节点 volatile Node next; // 线程对象 volatile Thread thread; ... &#125; // 头节点 private transient volatile Node head // 尾节点 private transient volatile Node tail; // 资源状态，等于0表示可获取，大于等于1表示已占用 private volatile int state; // 获取资源状态 protected final int getState() &#123; return state; &#125; // 设置资源状态 protected final void setState(int newState) &#123; state = newState; &#125; // CAS设置资源状态 protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; ...&#125; AQS使用volatile修饰的state整型变量表示同步状态，通过CLH同步队列来完成线程的排队工作。 对state值的修改是通过CAS完成的，当前线程根据state的值判断能否获取资源。如果获取失败，AQS会将当前线程thread以及等待状态waitStatus等信息封装成Node节点，并将其加CLH入同步队列，同时阻塞当前线程。当state的值变为可获取资源后，会把Node节点中的线程唤醒，再次尝试获取资源。 3 逻辑3.1 原理Lock接口的实现类基本都是通过聚合队列同步器的子类完成线程访问控制。 源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ReentrantLock implements Lock, java.io.Serializable &#123; ... abstract static class Sync extends AbstractQueuedSynchronizer &#123; ... final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; ... &#125; static final class NonfairSync extends Sync &#123; ... final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; static final class FairSync extends Sync &#123; ... final void lock() &#123; acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125; public ReentrantLock() &#123; sync = new NonfairSync(); &#125; public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; ...&#125; ReentrantLock类的内部聚合了Sync类，Sync类继承自AQS类，并且非公平锁NonfairSync和公平锁FairSync都继承自Sync，默认创建的是非公平锁NonfairSync。 3.2 阶段整个ReentrantLock的加锁过程，可以分为三个阶段： 尝试加锁。 加锁失败，线程入队列。 线程入队列后，进入阻赛状态。 3.3 举例三个客户在银行办理业务，使用默认的非公平锁： java123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;办理业务&quot;); try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;离开&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;办理业务&quot;); try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;离开&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;办理业务&quot;); try &#123; TimeUnit.SECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;离开&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;, &quot;C&quot;).start();&#125; 3.4 分析3.4.1 线程A获取资源线程A进入，调用lock()方法： java123456789final void lock() &#123; // 使用CAS设置state为1 if (compareAndSetState(0, 1)) // 表示获取资源成功，将当前线程设为占用线程 setExclusiveOwnerThread(Thread.currentThread()); else // 表示获取资源失败，继续抢占资源 acquire(1);&#125; 因为线程A是第一个获取资源的线程，所以获取资源成功，将当前线程设为占用线程，执行业务。 3.4.2 线程B获取资源线程B进入，调用lock()方法。 因为线程B是第二个获取资源的线程，线程A已经将state从0改为了1，所以使用compareAndSetState()方法设置失败。 3.4.3 线程B抢占资源线程B获取失败，调用acquire()方法抢占资源： java12345678public final void acquire(int arg) &#123; // 抢占资源 if (!tryAcquire(arg) &amp;&amp; // 加入等待队列 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 线程阻塞 selfInterrupt();&#125; 调用tryAcquire()方法抢占资源： java1234protected final boolean tryAcquire(int acquires) &#123; // 调用非公平锁的尝试抢占方法 return nonfairTryAcquire(acquires);&#125; 调用非公平锁的nonfairTryAcquire()方法，返回false表示占用失败： java123456789101112131415161718192021222324252627final boolean nonfairTryAcquire(int acquires) &#123; // 记录当前线程 final Thread current = Thread.currentThread(); // 记录当前资源状态 int c = getState(); // 0表示当前资源可用 if (c == 0) &#123; // 使用CAS设置state为请求数 if (compareAndSetState(0, acquires)) &#123; // 表示获取资源成功，将当前线程设为占用线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 大于等于1表示当前资源被占用，判断当前线程是否为占用线程（可重入锁的情况） else if (current == getExclusiveOwnerThread()) &#123; // 当前线程为占用线程，记录资源状态 int nextc = c + acquires // 判断是否溢出 if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); // 设置state为新的资源状态 setState(nextc); return true; &#125; return false;&#125; 因为线程B是第二个获取资源的线程，线程A已经将state从0改为了1，所以使用nonfairTryAcquire()方法占用失败。 3.4.4 线程B等待线程B抢占失败，调用addWaiter()方法将当前线程加入等待队列： java1234567891011121314151617private Node addWaiter(Node mode) &#123; // 将当前线程和传入的独占模式封装为节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; // 尾节点不为空，表示CLH队列已经初始化，CAS操作将当前节点设为尾节点 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 尾节点为空，表示CLH队列还未初始化，初始化队列 enq(node); return node;&#125; 因为线程B是第一个进入等待的线程，尾节点为空，所以使用enq()方法初始化队列： java1234567891011121314151617private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 尾节点为空，通过CAS设置头节点和尾节点为空节点 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 尾节点不为空，通过CAS将当前节点作为新的尾节点 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 初始化CLH队列后，头节点为空节点，尾节点为当前节点。 3.4.5 线程B阻塞线程B得到当前节点后，作为参数传入acquireQueued()方法加入CLH队列： java123456789101112131415161718192021222324252627282930313233final boolean acquireQueued(final Node node, int arg) &#123; // 记录当前节点是否取消，默认为true，表示取消 boolean failed = true; try &#123; // 标记当前节点是否中断，默认为false，表示当前节点没有中断 boolean interrupted = false // 自旋 for (;;) &#123; // 获取当前节点的上一节点 final Node p = node.predecessor(); // 如果上一节点是头节点，表示当前节点即将被唤醒，尝试抢占资源 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 将当前节点设为新头节点，置空当前节点的上一节点，并取消当前节点同当前线程的绑定 setHead(node); // 将原头节点的下一节点置空，方便GC回收 p.next = null; // help GC // 标记当前节点为false，表示没有取消 failed = false; // 返回false，表示当前节点没有中断 return interrupted; &#125; // 如果上一节点不是头节点，或者抢占资源失败，处理上一节点并阻塞当前节点 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 标记为true，表示当前节点中断 interrupted = true; &#125; &#125; finally &#123; // 当前节点如果被取消，执行取消操作 if (failed) cancelAcquire(node); &#125;&#125; 因为线程B是第一个进入等待的线程，上一节点为头节点，调用tryAcquire()方法尝试获取资源。获取成功则将当前节点作为头节点并移除上一节点，获取失败则阻塞。 获取资源失败调用shouldParkAfterFailedAcquire()方法处理上一节点： java12345678910111213141516171819private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 记录上一节点的等待状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 如果上一节点的等待状态为-1，表示当前线程可以被阻塞，返回true，继续判断 return true; if (ws &gt; 0) &#123; // 如果上一节点的等待状态为1，表示上一节点被取消，循环移除被取消的上一节点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 上述条件不满足，表示上一节点的等待状态为0或者-3，通过CAS将等待状态设置为-1 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; // 返回false，重新进入自旋 return false;&#125; 因为线程B是第一个进入等待的线程，上一节点为头节点，头节点为空节点，等待状态为0，所以两次进入shouldParkAfterFailedAcquire()方法： 第一次进入将上一节点的等待状态设置为-1后返回false，条件判断为false重新进入自旋。 第二次进入检测到上一节点的等待状态为-1，返回true，调用parkAndCheckInterrupt()方法。 调用parkAndCheckInterrupt()方法阻塞当前节点： java123456private final boolean parkAndCheckInterrupt() &#123; // 阻塞当前节点 LockSupport.park(this); // 返回线程的中断状态 return Thread.interrupted();&#125; 3.4.6 线程C获取资源线程C进入，调用lock()方法。 因为线程C是第三个获取资源的线程，线程A已经将state从0改为了1，所以使用compareAndSetState()方法设置失败。 3.4.7 线程C抢占资源线程C获取失败，调用acquire()方法抢占资源，源码同上。 调用tryAcquire()方法抢占资源，源码同上。 调用非公平锁的nonfairTryAcquire()方法，返回false表示占用失败，源码同上。 因为线程C是第三个获取资源的线程，线程A已经将state从0改为了1，所以使用nonfairTryAcquire()方法占用失败。 3.4.8 线程C等待线程C抢占失败，调用addWaiter()方法将当前线程加入等待队列，源码同上。 因为线程C是第二个进入等待的线程，线程B已经完成了队列初始化，尾节点不为空，使用CAS将当前节点作为新的尾节点。 3.4.9 线程C阻塞线程C得到当前节点后，作为参数传入acquireQueued()方法加入CLH队列，源码同上。 因为线程C是第二个进入等待的线程，上一节点为B节点，B节点不是头节点，不能获取资源。 调用shouldParkAfterFailedAcquire()方法处理上一节点，源码同上。 因为线程C是第二个进入等待的线程，上一节点为B节点，等待状态为-1，返回true，调用parkAndCheckInterrupt()方法。 调用parkAndCheckInterrupt()方法阻塞当前节点，源码同上。 3.4.10 线程A执行完毕线程A执行完毕，调用unlock()方法： java123public void unlock() &#123; sync.release(1);&#125; 调用release()方法： java1234567891011121314public final boolean release(int arg) &#123; // 调用tryRelease()方法尝试释放资源 if (tryRelease(arg)) &#123; // 获取头节点 Node h = head; // 如果头节点不为空，并且等待状态不为0，表示需要唤醒其他线程 if (h != null &amp;&amp; h.waitStatus != 0) // 唤醒线程 unparkSuccessor(h); return true; &#125; // 释放失败返回false return false;&#125; 3.4.11 线程A释放资源调用tryRelease()方法释放资源： java123456789101112131415161718protected final boolean tryRelease(int releases) &#123; // 记录资源状态 int c = getState() - releases; // 如果当前线程不为占用线程则抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 标记资源空闲，默认为false boolean free = false // 资源状态为0则标记资源空闲为true，并将占用线程置空 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; // 设置资源状态 setState(c); // 返回资源空闲 return free;&#125; 3.4.12 线程A唤醒线程线程B和线程C已经进入等待队列，调用unparkSuccessor()方法唤醒线程： java1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; // 记录头节点的等待状态 int ws = node.waitStatus; // 如果头节点的等待状态小于0，则将头节点的等待状态设为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 记录头节点的下一节点 Node s = node.next; // 判断下一节点是否为空或者下一节点的等待状态是否大于0 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 遍历下一节点，找到不为空并且等待状态小于等于0的节点，将其设为下一节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 如果下一节点不为空，则唤醒下一节点中的线程 if (s != null) LockSupport.unpark(s.thread);&#125; 头节点的下一节点为B节点，线程B被唤醒。 3.4.13 线程B抢占资源线程B在parkAndCheckInterrupt()方法中被唤醒后，返回中断状态为false，重新进入自旋。 线程B的上一节点为头节点，进入tryAcquire()方法抢占资源。 抢占资源成功后，将当前线程设为占用线程，将当前节点设为头节点，同时解除同线程B的绑定，执行业务。 3.4.14 线程B执行完毕线程B执行完毕，调用unlock()方法释放资源并唤醒线程。 头节点的下一节点为C节点，线程C被唤醒。 3.4.15 线程C抢占资源线程C在parkAndCheckInterrupt()方法中被唤醒后，返回中断状态为false，重新进入自旋。 线程C的上一节点为头节点，进入tryAcquire()方法抢占资源。 抢占资源成功后，将当前线程设为占用线程，将当前节点设为头节点，同时解除同线程C的绑定，执行业务。 3.4.16 线程C执行完毕线程B执行完毕，调用unlock()方法释放资源并唤醒线程。 头节点的下一节点为空，不会有任何线程被唤醒。 4 公平锁与非公平锁4.1 非公平锁非公平锁在资源可用时不会判断当前队列是否有线程在等待，刚加入的线程可以与被唤醒的线程一起竞争资源。 源码： java1234567891011121314151617181920212223242526272829303132333435final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;...public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;...protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;...final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 4.2 公平锁公平锁在资源可用时会判断当前队列是否有线程在等待，刚加入的线程不可以与被唤醒的线程一起竞争资源。 源码： java1234567891011121314151617181920212223242526272829final void lock() &#123; acquire(1);&#125;...public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;...protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 在tryAcquire()方法中使用hasQueuedPredecessors()方法判断等待队列中是否存在有效节点： 返回false表示没有，取反后为true表示当前节点不需要排队，需要执行占用资源的操作。 返回true表示有，取反后为false表示当前节点需要排队，需要执行加入等待队列的操作。 源码： java12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 说明： 判断头节点和尾节点是否相同，如果相同，说明队列未初始化或者当前队列只有一个空节点，返回false，取反后为true，尝试占用资源。 判断头节点和尾节点是否相同，如果不相同，说明存在两个不同节点。 继续判断下一节点是否为空节点，如果成立，说明下一节点为空，可能上个线程刚刚将头节点初始化，尚未给尾节点赋值，返回true，取反后为false，需要排队。 继续判断下一节点是否为空节点，如果不成立，说明下一节点不为空。 继续判断下一节点封装的线程是否不等于当前线程，如果成立，说明下一线程不为当前线程，返回true，取反后为false，需要排队。 继续判断下一节点封装的线程是否不等于当前线程，如果不成立，说明下一线程为当前线程，返回false，取反后为true，尝试占用资源。 5 自定义同步器5.1 实现方法不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需要实现共享资源state的获取与释放即可，至于具体线程等待队列的维护（如获取资源失败入队和唤醒出队等），AQS已经在底层实现好了。 自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease和tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 5.2 举例说明以ReentrantLock为例，state初始化为0，表示未锁定状态。 线程A调用lock()方法获取资源，同时调用tryAcquire()占用资源，并将state的值加1。 其他线程再调用tryAcquire()方法占用资源就会失败，直到线程A调用unlock()方法释放资源，并将state的值减0，其它线程才有机会获取该锁。 在释放锁之前，A线程可以重复获取资源，state的值会累加，这就是可重入锁。获取多少次就要释放多少次，这样才能保证state最后的值是0。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"LockSupport","slug":"D00-后端/D01-Java/003-并发/010-LockSupport","date":"2025-07-24T06:23:13.000Z","updated":"2025-07-24T08:06:07.689Z","comments":true,"path":"posts/20250724/142313/","permalink":"https://momashanhe.com/posts/20250724/142313/","excerpt":"摘要：本文学习了ThreadLocal的用法和原理。","text":"摘要：本文学习了ThreadLocal的用法和原理。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，在内部使用凭证的概念来实现阻塞和唤醒，每个线程都有一个凭证，只有1和0两个值，默认是0。 LockSupport中提供了两个方法： park()方法会在凭证可用时执行，将凭证从1变成0，用于阻塞线程。 unpark()方法会在凭证不可用时执行，将凭证从0变成1，用于唤醒线程。 LockSupport中的方法调用的是Unsafe类中的native代码。 2 比较比较三种阻塞唤醒线程的方式： 使用Object的wait()方法和notify()方法： 使用wait()方法阻塞线程，使用notify()方法唤醒线程。 必须在synchronized代码块内部执行，否则抛出IllegalMonitorStateException。 必须先执行wait()方法再执行notify()方法，否则线程会一直等待无法被唤醒。 使用Condition的await()方法和signal()方法： 使用await()方法阻塞线程，使用signal()方法唤醒线程。 必须和Lock组队使用，否则抛出IllegalMonitorStateException。 必须先执行await()方法再执行signal()方法，否则线程会一直等待无法被唤醒。 使用LockSupport的park()方法和uppark()方法： 使用park()方法阻塞线程，使用uppark()方法唤醒线程。 不需要在任何代码块内执行，可以在任何地方执行。 使用顺序无要求，即使先执行uppark()方法再执行park()方法，也能唤醒线程。 3 使用示例： java12345678910111213141516171819public static void main(String[] args) &#123; Thread a = new Thread(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;进入&quot;); LockSupport.park(); System.out.println(Thread.currentThread().getName() + &quot;执行&quot;); &#125;, &quot;a&quot;); a.start(); Thread b = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;进入&quot;); LockSupport.unpark(a); System.out.println(Thread.currentThread().getName() + &quot;执行&quot;); &#125;, &quot;b&quot;); b.start();&#125; 结果： log12345b进入b执行// 等待1sa进入a执行 4 总结LockSuport是一个线程阻塞工具类，底层调用的Unsafe中的native代码，所有的方法都是静态方法，可以让线程在任意位置阻塞和唤醒。 两个方法： 调用park()方法，将凭证从1变成0，立即返回并继续执行。如果凭证为0则会阻塞，直到unpark()方法将凭证从0变为1。 调用unpark()方法，将凭证从0变成1，立即返回并继续执行，多次调用unpark()方法不会累加凭证。如果凭证为1则会阻塞，直到park()方法将凭证从1变为0。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"ThreadLocal","slug":"D00-后端/D01-Java/003-并发/009-ThreadLocal","date":"2025-07-23T05:43:33.000Z","updated":"2025-07-24T06:20:05.085Z","comments":true,"path":"posts/20250723/134333/","permalink":"https://momashanhe.com/posts/20250723/134333/","excerpt":"摘要：本文学习了ThreadLocal的用法和原理。","text":"摘要：本文学习了ThreadLocal的用法和原理。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介ThreadLocal是一个本地线程副本变量工具类，主要用于将本地线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。 2 用法2.1 常用方法2.1.1 设置设置当前线程对应的局部变量的值。 源码： java1234567891011public void set(T value) &#123; Thread t = Thread.currentThread(); // 取出当前线程对应的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); if (map != null) // 如果存在，将当前ThreadLocal对象作为key，将传入的值作为value，放到map里 map.set(this, value); else // 如果不存在，通过线程创建ThreadLocalMap对象 createMap(t, value);&#125; 2.1.2 获取返回当前线程对应的局部变量的值。 源码： java12345678910111213141516public T get() &#123; Thread t = Thread.currentThread(); // 取出当前线程对应的ThreadLocalMap对象 ThreadLocalMap map = getMap(t); if (map != null) &#123; // 如果存在，直接从map取出ThreadLocal对应的value返回 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; // 如果不存在，创建ThreadLocalMap对象，设置并返回初始值 return setInitialValue();&#125; 2.1.3 删除删除当前线程对应的局部变量的值，目的是为了减少内存的占用。 当线程结束后，线程对应的局部变量将自动被回收，所以显式调用该方法并不是必须的操作，但它可以加快内存回收的速度。 如果在调用了remove()方法后又调用了get()方法，会进行重新初始化。 源码： java1234public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 2.1.3 初始化返回当前线程对应的局部变量的初始值。 特点： 覆盖：该方法是protected方法，显然是为了让子类覆盖而设计的。 延迟：在线程首次调用get()方法或set()方法时执行，并且仅执行一次。 源码： java123protected T initialValue() &#123; return null;&#125; 2.2 使用场景在一个线程中，需要共享某个资源，希望不管是在哪个类中使用该资源，都能保证该资源都是同一个，只会被创建一次，这就需要使用TheadLocal来实现。 在项目中有时会在一个线程内调用多个方法，并且在有的方法中需要传递上下文信息，比如用户信息等。 不使用TheadLocal，那就要给每一个方法增加参数，就会存在过渡传参问题，造成代码冗余： java123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; Demo test = new Demo(); test.func1(&quot;user&quot;); test.func2(&quot;user&quot;); &#125; public void func1(String user) &#123; System.out.println(user); &#125; public void func2(String user) &#123; System.out.println(user); &#125;&#125; 使用TheadLocal，那么只需要设置一次参数的绑定，在其他方法中就可以通过TheadLocal直接获取，不需要传参： java123456789101112131415161718192021public class Demo &#123; private static ThreadLocal&lt;String&gt; threadLocalUser = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; threadLocalUser.set(&quot;user&quot;); Demo test = new Demo(); test.func1(); test.func2(); threadLocalUser.remove(); &#125; public void func1() &#123; String user = threadLocalUser.get(); System.out.println(user); &#125; public void func2() &#123; String user = threadLocalUser.get(); System.out.println(user); &#125;&#125; 3 原理3.1 内部结构在ThreadLocal类内部定义了ThreadLocalMap类，该类是一个类似HashMap的类，key存储对ThreadLocal实例的弱引用，value存储引用变量。 在Thread类内部有ThreadLocalMap类型的属性，通过Thread类内部的ThreadLocalMap对象对变量进行维护。 ThreadLocal不能解决线程之间的资源共享问题，ThreadLocal解决的是一个线程内部的资源共享问题。 3.2 线性探测ThreadLocalMap结构非常简单，没有实现Map接口，其数据存储结构不是链表而是数组，解决哈希冲突的方式并非链表的拉链法方式，而是采用线性探测方式。 根据初始key的哈希值确定元素在table数组中的位置，如果已被占用，检查通过算法得到的下一个位置，如果检查到末尾没有空位置，则从开头继续检查，直至找到空位置。 如果在ThreadLocalMap中存储了大量的ThreadLocal会导致出现聚集，严重影响解决哈希冲突的性能，建议使用Map作为变量管理不同类型的参数。 3.4 数据共享如果在当前线程创建了子线程，在子线程中想要获取父线程中的变量，就不能使用ThreadLocal类，需要使用InheritableThreadLocal类。 InheritableThreadLocal类继承于ThreadLocal类，会自动为子线程复制继承自父线程的本地变量。 在创建子线程时，子线程会接收所有可继承的线程本地变量的初始值，当必须将本地线程变量自动传送给所有创建的子线程时，应尽可能的使用InheritableThreadLocal，而非ThreadLocal。 示例： java1234567891011public static void main(String[] args) &#123; final ThreadLocal threadLocal = new InheritableThreadLocal(); threadLocal.set(&quot;hello&quot;); new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(threadLocal.get()); &#125; &#125;.start();&#125; 4 内存泄漏4.1 定义虚拟机会在达到触发条件时，对内存中不被使用的对象和变量进行回收，以便合理利用内存空间。 当不被使用的对象或者变量占用的内存不能被回收时，就会产生内存泄漏。 由ThreadLocal引发的内存泄露分为两种情况： 由ThreadLocalMap中的key引起的，也就是ThreadLocal对象内存泄露。 由ThreadLocalMap中的value引起的，也就是ThreadLocal对象绑定的对象内存泄露。 4.2 引用类型根据引用类型可以分为强软弱虚四种：强引用（StrongReference）：不会被垃圾回收器回收，即使以后也不会用到。软引用（SoftReference）：比强引用弱，当系统内存不足时才会被回收。通常用在对内存敏感的程序中，比如高速缓存。弱引用（WeakReference）：比软引用弱，生命周期更短，只要发生了垃圾回收，不管内存空间是否足够都会被回收。虚引用（PhantomReference）：最弱，在任何时候都有可能被垃圾回收器回收。通常配和引用队列联合使用，在被回收前能够收到系统通知。 当需要操作共享变量时，需要先声明ThreadLocal对象，然后通过ThreadLocal对象的方法操作共享变量，这个操作实际上是通过Thread类里的ThreadLocalMap集合实现的。 4.3 解决办法4.3.1 key引起的内存泄漏在ThreadLocalMap集合中，key存储了ThreadLocal对象的弱引用，这么做是为了避免强引用导致的内存泄漏： 如果在ThreadLocalMap集合中使用强引用，加上声明ThreadLocal对象使用的默认是强引用，此时ThreadLocal对象就同时拥有两个强引用，即使将声明ThreadLocal的变量置空后，因为存在另一个强引用，就会导致ThreadLocal对象不能被回收，进而导致内存泄露。 如果在ThreadLocalMap集合中使用弱引用，此时ThreadLocal对象就只有一个强引用，在将声明ThreadLocal对象的变量置空后，没有强引用指向ThreadLocal对象，能够保证在ThreadLocal对象在下一次垃圾回收时被回收。 4.3.2 value引起的内存泄漏在ThreadLocalMap集合中，value存储了变量的强引用。 当声明ThreadLocal对象的变量置空后，因为弱引用导致出现了key为null但value不为null的键值对，于是value存储的变量无法被获取也不能被回收，产生内存泄漏。 解决办法是及时调用remove()方法将用过的value对象移除。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"线程创建方式","slug":"D00-后端/D01-Java/003-并发/008-线程创建方式","date":"2025-07-16T05:14:00.000Z","updated":"2025-07-23T03:49:40.176Z","comments":true,"path":"posts/20250716/131400/","permalink":"https://momashanhe.com/posts/20250716/131400/","excerpt":"摘要：本文整理了创建线程的几种方式。","text":"摘要：本文整理了创建线程的几种方式。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 继承Thread类步骤： 创建继承Thread类的子类，重写run()方法。 创建子类的Thread对象。 调用Thread对象的start()方法。 示例： java123456789101112131415161718192021public class Demo &#123; public static void main(String[] args) &#123; Thread t1 = new DemoThread(&quot;线程一&quot;); Thread t2 = new DemoThread(&quot;线程二&quot;); t1.start(); t2.start(); &#125;&#125;class DemoThread extends Thread &#123; public DemoThread(String name) &#123; this.setName(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; &#125;&#125; 2 实现Runnable接口步骤： 创建实现Runnable接口的类，实现run()方法。 创建实现类的Runnable对象。 将Runnable对象传入Thread类的构造方法中，创建Thread对象。 调用Thread对象的start()方法。 示例： java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; DemoRunnable runnable = new DemoRunnable(); Thread t1 = new Thread(runnable, &quot;线程一&quot;); Thread t2 = new Thread(runnable, &quot;线程二&quot;); t1.start(); t2.start(); &#125;&#125;class DemoRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; &#125;&#125; 开发中优先选择实现Runnable接口的方式，没有单继承的局限性，更适合处理多个线程共享数据的情况。 3 实现Callable接口步骤： 创建实现Callable接口的类，实现call()方法。 创建实现类的Callable对象。 将Callable对象传入FutureTask类的构造方法中，创建FutureTask对象。 将FutureTask对象传入Thread类的构造方法中，创建Thread对象。 调用Thread对象的start()方法。 调用FutureTask对象的get()方法，获取执行结果。 示例： java12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; DemoCallable callable = new DemoCallable(); FutureTask&lt;Integer&gt; f1 = new FutureTask&lt;&gt;(callable); FutureTask&lt;Integer&gt; f2 = new FutureTask&lt;&gt;(callable); Thread t1 = new Thread(f1, &quot;线程一&quot;); Thread t2 = new Thread(f2, &quot;线程二&quot;); t1.start(); t2.start(); try &#123; System.out.println(f1.get() + f2.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class DemoCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; return 1000; &#125;&#125; FutureTask类间接实现了Runnable接口和Future接口，所以既可以作为Runnable被线程执行，又可以作为Future获取线程执行的结果。 4 使用线程池步骤： 创建实现Runnable接口的类，实现run()方法。 创建线程池的ThreadPoolExecutor对象。 创建实现类的Runnable对象。 将Runnable对象传入ThreadPoolExecutor对象的execute()方法中，提交任务。 调用ThreadPoolExecutor对象的shutdown()方法关闭线程池。 示例： java1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(3)); for (int i = 1; i &lt;= 7; i++) &#123; Runnable runnable = new DemoThread(i); executor.execute(runnable); System.out.println(&quot;线程编号：&quot; + i + &quot;，线程池：&quot; + executor.getPoolSize() + &quot;，队列：&quot; + executor.getQueue().size()); &#125; executor.shutdown(); &#125;&#125;class DemoThread implements Runnable &#123; int taskNo = 0; public DemoThread(int taskNo) &#123; this.taskNo = taskNo; &#125; @SuppressWarnings(&quot;static-access&quot;) public void run() &#123; try &#123; System.out.println(&quot;task &quot; + taskNo); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"线程池","slug":"D00-后端/D01-Java/003-并发/007-线程池","date":"2025-07-16T01:38:20.000Z","updated":"2025-07-23T03:47:41.892Z","comments":true,"path":"posts/20250716/093820/","permalink":"https://momashanhe.com/posts/20250716/093820/","excerpt":"摘要：本文学习了如何在高并发场景下使用线程池创建线程。","text":"摘要：本文学习了如何在高并发场景下使用线程池创建线程。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 类和接口1.1 ExecutorExecutor是一个顶层接口，在它里面只声明了一个execute()方法，用来在接下来的某个时刻执行提交的任务。 常用方法： java1void execute(Runnable command); 1.2 ExecutorServiceExecutorService接口继承了Executor接口，并声明了一些方法。 常用方法： java12345678910111213141516// 用来关闭线程池，此时线程池不能够接受新的任务，它会等待所有任务执行完毕void shutdown();// 用来关闭线程池，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务List&lt;Runnable&gt; shutdownNow();// 当调用shutdown或shutdownNow方法后返回为trueboolean isShutdown();// 若关闭后所有任务都已完成，则返回true。注意除非首先调用shutdown或shutdownNow，否则isTerminated永不为true// 当调用shutdown方法后，如果所有提交的任务都已完成，返回为true// 当调用shutdownNow方法后，成功停止，返回为trueboolean isTerminated();// 用来向线程池提交任务，并返回任务执行的结果&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);// 用来向线程池提交任务，并返回任务执行的结果&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);// 用来向线程池提交任务，并返回任务执行的结果Future&lt;?&gt; submit(Runnable task); 1.3 ThreadPoolExecutorThreadPoolExecutor是线程池中最核心的一个类，通过间接的方式实现了ExecutorService接口。 构造方法： java1234public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue);public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory);public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler);public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); 参数： corePoolSize：核心池的大小。当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。 maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程。 keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize。 unit：参数keepAliveTime的时间单位，有7种取值。在TimeUnit类中有7种静态属性： TimeUnit.DAYS;&#x2F;&#x2F; 天 TimeUnit.HOURS;&#x2F;&#x2F; 小时 TimeUnit.MINUTES;&#x2F;&#x2F; 分钟 TimeUnit.SECONDS;&#x2F;&#x2F; 秒 TimeUnit.MILLISECONDS;&#x2F;&#x2F; 毫秒 TimeUnit.MICROSECONDS;&#x2F;&#x2F; 微妙 TimeUnit.NANOSECONDS;&#x2F;&#x2F; 纳秒 workQueue：一个阻塞队列，用来存储等待执行的任务。一般来说，这里的阻塞队列有以下几种选择： ArrayBlockingQueue：有界阻塞队列。 LinkedBlockingQueue：无界阻塞队列。 SynchronousQueue：不存储元素阻塞队列，即单个元素阻塞队列。 DelayQueue：延时阻塞队列。 threadFactory：线程工厂，主要用来创建线程。 handler：表示当拒绝处理任务时的策略，有以下四种取值： ThreadPoolExecutor.AbortPolicy：抛异常，默认策略。 ThreadPoolExecutor.CallerRunsPolicy：调用线程处理新任务。 ThreadPoolExecutor.DiscardPolicy：丢弃新任务。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久任务，将新任务加入队列。 2 使用2.1 线程池状态常用属性： java12345678910111213141516// 状态：RUNNING。工作线程数量：0private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 使用32位的高3位表示状态，余下29位表示容量private static final int COUNT_BITS = Integer.SIZE - 3;// 最大容量为：^29-1private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// 运行状态用32位整型的高3位表示private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;// 封装和解析ctl值private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 状态的转换： RUNNING -&gt; SHUTDOWN：调用了shutdown()方法。 RUNNING &#x2F; SHUTDOWN -&gt; STOP：调用了shutdownNow()方法。 SHUTDOWN -&gt; TIDYING：当队列中任务都被取出执行完成，并且所有工作线程都结束了任务，再没有未被执行的任务。 STOP -&gt; TIDYING：线程池中没有正在运行的线程，任务队列中任务都被取消。 TIDYING -&gt; TERMINATED：钩子方法terminated()执行完毕后。 状态说明： RUNNING：运行态，可处理新任务并执行队列中的任务。 SHUTDOW：关闭态，不接受新任务，但处理队列中的任务。 STOP：停止态，不接受新任务，不处理队列中任务，且打断运行中任务。 TIDYING：整理态，所有任务已经结束，将执行terminated()方法。 TERMINATED：结束态，terminated()方法已完成。 创建线程池之后不会马上创建线程，在提交任务后才会创建线程，可以手动设置创建线程池后马上创建线程： prestartCoreThread()：初始化一个核心线程。 prestartAllCoreThreads()：初始化所有核心线程。 关闭线程池： shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。 动态调整线程池容量： setCorePoolSize()：设置核心池大小。 setMaximumPoolSize()：设置线程池最大能创建的线程数目大小。 2.2 按需创建线程池Executors类中提供了几个静态方法创建线程池： java12345678910111213141516171819// 创建容量为1的缓冲池public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;// 创建指定容量的缓冲池public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;// 创建容量可变的缓冲池public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;// 创建指定容量的定时缓冲池public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125;： 它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了： newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue。 newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue。 newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 newScheduledThreadPool将corePoolSize设置为入参，将maximumPoolSize设置为Integer.MAX_VALUE，使用的DelayQueue。 不建议直接使用这几个静态方法创建线程池： SingleThreadPool和FixedThreadPool允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 建议通过ThreadPoolExecutor的方式创建线程池，这样的处理方式能更加明确线程池的运行规则，规避资源耗尽的风险。 另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。 2.3 线程创建策略如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务。 如果当前线程池中的线程数目大于等于corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中： 若添加成功，则该任务会等待空闲线程将其取出去执行。 若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务。 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理。 如果线程池中的线程数量大于corePoolSize时，当某线程空闲时间超过keepAliveTime时，线程将被终止，直至线程池中的线程数目不大于corePoolSize。 如果允许为核心池中的线程设置存活时间，当核心池中的线程空闲时间超过keepAliveTime时，核心线程也会被终止。 2.4 缓存队列超出一定数量的任务会转移队列中，队列与池里的线程大小的关联表现在： 如果运行的线程数小于corePoolSize，会创建线程执行任务。 如果运行的线程已大于corePoolSize，会把新的任务放于队列中。如果队列已到最大时，会继续创建线程，直到超过maximumPoolSize。如果线程超过maximumPoolSize，将拒绝接收新的任务。 而添加任务到队列时，有几种常规的策略： 有界队列。如ArrayBlockingQueue，当定义了maximumPoolSizes时，使用有界队列可以预防资源的耗尽，但是增加了调整和控制队列的难度，队列的大小和线程池的大小是相互影响的，使用很大的队列和较小的线程池会减少CPU消耗、操作系统资源以及线程上下文开销，但却人为的降低了吞吐量。如果任务是频繁阻塞型的（I&#x2F;O），系统是可以把时间片分给多个线程的。而采用较小的队列和较大的线程池，虽会造成CPU繁忙，但却会遇到调度开销，这也会降低吞吐量。 无界队列。如LinkedBlockingQueue，当核心线程正在工作时，使用不用预先定义大小的无界队列，使新任务等待，所以如果线程数是小于corePoolSize时，将不会有入队操作。这种策略将很适合那些相互独立的任务，如Web服务器。无界队列可能会堆积大量的请求，从而导致OOM。 直接传递。如SynchronousQueue，不存储元素的阻塞队列，将任务直接交给线程。每一个入队操作必须等待另一个线程移除操作，否则入队将一直阻塞。当处理一些可能有内部依赖的任务时，这种策略避免了加锁操作。直接传递一般不能限制maximumPoolSizes以避免拒绝接收新的任务，可能会造成增加无限多的线程导致OOM。 延时队列。如DelayQueue，队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。延时队列也是一个无界队列，因此往队列中插入数据的操作永远不会被阻塞，而只有获取数据的操作才会被阻塞。延时队列的maximumPoolSizes没有限制，可能会造成增加无限多的线程导致OOM。 2.5 拒绝策略当线程数量达到缓存队列的最大容量时，线程池则已经饱和了，此时则不会接收新的任务。会调用RejectedExecutionHandler的rejectedExecution()方法执行饱和策略。 在线程池内部预定义了几种处理策略： 终止执行（AbortPolicy）。默认策略，会抛出一个RejectedExecutionException运行异常到调用者线程来阻止系统运行。 调用者线程来运行任务（CallerRunsPolicy）。这种策略会由调用execute()方法的线程来执行任务，它提供了一个简单的反馈机制并能降低新任务的提交频率。 丢弃策略（DiscardPolicy）。丢弃提交的任务。 丢弃队列里最老的一个任务（DiscardOldestPolicy）。丢弃工作队列中等待最久一个任务，并将提交的任务加入队列。 2.6 合理配置一般需要根据任务的类型来配置线程池大小。 如果是CPU密集型任务，即需要执行大量运算且没有阻塞的任务，就需要设置尽量少的线程数，减少线程上下文切换，参考值可以设为NCPU+1。 如果是IO密集型任务，即线程存在阻塞或等待，并不是一直再执行，就需要设置尽量多的线程数，参考值可以设置为2*NCPU。 另外，如果是IO密集型任务，也可以根据NCPU/(1-阻塞系数)这个公式计算，阻塞系数是在0.8到0.9之间的一个值。 当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。 3 实现原理3.1 属性常用属性： java123456789101112131415161718192021222324// 任务缓存队列，用来存放等待执行的任务private final BlockingQueue&lt;Runnable&gt; workQueue;// 线程池的主要状态锁，控制线程池状态和线程池大小的改变private final ReentrantLock mainLock = new ReentrantLock();// 用来存放工作集private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();// 用于延时的条件队列private final Condition termination = mainLock.newCondition();// 线程池中曾经出现过的最大线程数private int largestPoolSize;// 已经执行完毕的任务个数private long completedTaskCount;// 线程工厂，用来创建线程private volatile ThreadFactory threadFactory;// 任务拒绝策略private volatile RejectedExecutionHandler handler;// 线程存活时间private volatile long keepAliveTime;// 是否允许为核心线程设置存活时间private volatile boolean allowCoreThreadTimeOut;// 核心池的大小，即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列private volatile int corePoolSize;// 线程池最大能容忍的线程数private volatile int maximumPoolSize; 3.2 源码3.2.1 内部类内部类： java12345678910111213141516171819202122232425private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; // 维护了自己的一个Thread对象 final Thread thread; // 维护了自己的一个Runnable对象 Runnable firstTask; // 记录完成的任务数 volatile long completedTasks; // 使用传入的Runnable对象和ThreadFactory产生的Thread对象生成Worker对象 Worker(Runnable firstTask) &#123; setState(-1); this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; // 重写了Runnable里的run()方法 public void run() &#123; runWorker(this); &#125; // ...&#125; 3.2.2 提交任务最核心的任务提交方法是execute()方法，虽然通过submit()方法也可以提交任务，但是实际上submit()方法里面最终调用的还是execute()方法。 提交任务： java123456789101112131415161718192021222324252627282930313233343536// 在接下来的某个时刻执行任务public void execute(Runnable command) &#123; // 如果是空任务则抛出异常 if (command == null) throw new NullPointerException(); // 获取ctl的值 int c = ctl.get(); // 1 如果工作线程数小于核心线程数 if (workerCountOf(c) &lt; corePoolSize) &#123; // 尝试添加线程 if (addWorker(command, true)) return; // 添加线程失败则重新获取ctl的值 c = ctl.get(); &#125; // 2 如果工作线程数大于或者等于核心线程数 // 2.1 如果线程池正在运行，则尝试将任务放入缓存队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 重新根据ctl检查状态，因为可能在这段时间进程死掉了 int recheck = ctl.get(); // 2.1.1 如果线程池不处于运行状态，则尝试删除刚刚放入缓存队列的任务 if (! isRunning(recheck) &amp;&amp; remove(command)) // 拒绝任务 reject(command); // 2.1.2 如果线程池在运行状态 // 如果工作线程数是0 else if (workerCountOf(recheck) == 0) // 添加无初始任务的线程 addWorker(null, false); &#125; // 2.2 如果线程池不在运行状态，或者缓存队列已满 // 尝试添加线程 else if (!addWorker(command, false)) // 添加失败则拒绝任务 reject(command);&#125; 3.2.3 添加线程添加线程： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 添加线程，第一个参数是要添加的任务，第二个参数是是否核心线程，返回是否插入成功private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; // 获取ctl的值 int c = ctl.get(); // 获取运行状态 int rs = runStateOf(c); // 如果线程还未SHUTDOWN，此时是可以添加新线程的 // 如果线程是SHUTDOWN状态，而且传进来的任务为空，并且任务队列不为空的时候，此时是可以添加新线程的 // 将这两个条件取反，如果满足，则返回插入失败 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; // 获取线程数 int wc = workerCountOf(c); // 如果线程数大于最大值，或者当core为true时大于核心线程数，当core为false时大于最大线程数，返回失败 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 尝试通过CAS添加线程数目，成功则跳出retry循环 if (compareAndIncrementWorkerCount(c)) break retry; // 添加失败则重新获取ctl的值 c = ctl.get(); // 如果状态改变则重新进行retry循环，如果没有改变则重新尝试添加线程数 if (runStateOf(c) != rs) continue retry; &#125; &#125; // 线程运行标志位 boolean workerStarted = false; // 线程添加标志位 boolean workerAdded = false; // 封装了任务的Worker对象 Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; // 使用全局锁添加线程 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 获取线程池状态 int rs = runStateOf(ctl.get()); // 如果处于运行状态，或者是SHUTDOWN状态并且添加的任务为空 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; // 如果线程已经在运行，则抛出异常 if (t.isAlive()) throw new IllegalThreadStateException(); // 添加线程 workers.add(w); // 更新线程数量的历史最大值 int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; // 更新线程添加标志位 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 如果添加成功，则运行线程，并更新线程运行标志位 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; // 如果线程运行标志位是false，则线程添加失败进行回滚 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 失败回滚： java1234567891011121314151617// 线程添加失败进行回滚private void addWorkerFailed(Worker w) &#123; // 使用全局锁回滚线程个数的添加 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 移除线程 if (w != null) workers.remove(w); // 减少线程数 decrementWorkerCount(); // 尝试终止线程 tryTerminate(); &#125; finally &#123; mainLock.unlock(); &#125;&#125; 3.2.4 启动线程启动线程： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 启动线程最终调用的还是runWorker()方法final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); // 获取初始Runnable对象 Runnable task = w.firstTask; // 置空初始Runnable对象 w.firstTask = null; // 释放锁，允许被中断 w.unlock(); // 因为运行异常导致线程突然终止的标志 boolean completedAbruptly = true; try &#123; // 获取任务，如果没有任务可以获取，则此循环终止 while (task != null || (task = getTask()) != null) &#123; // 获取工作线程锁 w.lock(); // 如果线程池关闭，则确保线程被中断 // 如果线程池没有关闭，则确保线程不会被中断。这就要求进行重新获取ctl，以便在清除中断时处理shutdownNow竞争 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 回调方法，给子类具体实现 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 调用Runnable对象的run()方法 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // 回调方法，给子类具体实现 afterExecute(task, thrown); &#125; &#125; finally &#123; // 置空，如果进入下一个循环可以继续取任务 task = null; // 完成数累加 w.completedTasks++; // 释放工作线程锁 w.unlock(); &#125; &#125; // 说明不是用户任务异常引起的 completedAbruptly = false; &#125; finally &#123; // 程序退出 processWorkerExit(w, completedAbruptly); &#125;&#125; 3.2.5 获取任务获取任务： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取任务，控制线程池线程数量private Runnable getTask() &#123; // 获取任务超时标志位 boolean timedOut = false; for (;;) &#123; // 获取ctl的值 int c = ctl.get(); // 获取线程池的状态 int rs = runStateOf(c); // 如果是STOP状态之后，或者在SHUTDOWN状态之后并且任务队列是空的 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; // 使用CAS让线程数量减一 decrementWorkerCount(); // 返回并使一个线程退出 return null; &#125; // 获取线程数 int wc = workerCountOf(c); // 如果允许为核心线程设置存活时间，或者线程数大于核心线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 如果任务数大于最大线程数，或者超时并且允许为核心线程设置存活时间，或者超时并且任务数大于核心线程数 // 而且，线程数大于1，或者任务队列是空的 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; // 使用CAS让线程数量减一 if (compareAndDecrementWorkerCount(c)) // 线程数量减一成功，返回并使一个线程退出 return null; // 线程数量减一失败，说明线程数量已被抢先改变，继续循环 continue; &#125; try &#123; // 超时获取任务 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); // 如果在生效时间内获取到任务则返回 if (r != null) return r; // 否则将超时标志设置为true timedOut = true; &#125; catch (InterruptedException retry) &#123; // 如果有异常，则将超时标志设置为false timedOut = false; &#125; &#125;&#125; 3.3.6 程序退出程序退出： java12345678910111213141516171819202122232425262728293031323334353637// 处理线程退出，第一个参数是要处理的Worker，第二个参数用来判断是否异常导致退出private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; // 如果是异常退出，需要减少线程数。如果是正常退出，则不需要调整 if (completedAbruptly) decrementWorkerCount(); // 获取全局锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 完成任务数自增 completedTaskCount += w.completedTasks; // 移除线程 workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; // 尝试终结线程 tryTerminate(); // 获取ctl的值 int c = ctl.get(); // 如果线程池关闭了 if (runStateLessThan(c, STOP)) &#123; // 如果线程正常退出 if (!completedAbruptly) &#123; // 如果允许超时关闭核心线程，那就是0，否则就取核心线程数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 如果没有核心线程，并且队列中的任务不为空，则设置最少线程为1 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; // 如果线程数量大于等于正常工作的数量则不再添加新的线程 if (workerCountOf(c) &gt;= min) return; &#125; // 添加线程 addWorker(null, false); &#125;&#125; 4 使用创建线程池，核心线程数为2，最大线程数为4，任务队列大小为3，启动7个线程。 示例： java1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(3)); for (int i = 1; i &lt;= 7; i++) &#123; Runnable runnable = new DemoThread(i); executor.execute(runnable); System.out.println(&quot;线程编号：&quot; + i + &quot;，线程池：&quot; + executor.getPoolSize() + &quot;，队列：&quot; + executor.getQueue().size()); &#125; executor.shutdown(); &#125;&#125;class DemoThread implements Runnable &#123; int taskNo = 0; public DemoThread(int taskNo) &#123; this.taskNo = taskNo; &#125; @SuppressWarnings(&quot;static-access&quot;) public void run() &#123; try &#123; System.out.println(&quot;task &quot; + taskNo); Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果： log123456789101112131415线程编号：1，线程池：1，队列：0task 1线程编号：2，线程池：2，队列：0线程编号：3，线程池：2，队列：1线程编号：4，线程池：2，队列：2task 2线程编号：5，线程池：2，队列：3线程编号：6，线程池：3，队列：3线程编号：7，线程池：4，队列：3task 6task 7// 等待1stask 3task 4task 5 说明： 在前2个任务放到线程池里时，没有超过核心线程数，所以创建新的线程，执行任务。 在第3个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。 在第4个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。 在第5个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。 在第6个任务放到线程池里时，超过了核心线程数，超过了缓存队列长度，线程池的线程数量小于线程池的最大容量，所以创建新的线程，执行任务。 在第7个任务放到线程池里时，超过了核心线程数，超过了缓存队列长度，线程池的线程数量小于线程池的最大容量，所以创建新的线程，执行任务。 等待任务执行完毕，释放线程，获取任务缓存队列里的任务，执行任务。 如果有第8个任务放到线程池里，超过了核心线程数，超过了缓存队列长度，线程池的线程数量大于线程池的最大容量，所以产生RejectedExecutionException拒绝任务异常。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"异步调用","slug":"D00-后端/D01-Java/003-并发/006-异步调用","date":"2025-07-15T09:59:15.000Z","updated":"2025-07-22T09:31:06.527Z","comments":true,"path":"posts/20250715/175915/","permalink":"https://momashanhe.com/posts/20250715/175915/","excerpt":"摘要：本文学习了如何使用Future相关接口实现异步调用。","text":"摘要：本文学习了如何使用Future相关接口实现异步调用。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 Callable之前学习多线程的时候，可以通过继承Thread类和实现Runnable接口创建线程。 由于单继承的原因建议使用Runnable接口，需要重写run()方法，因为返回值为void类型，所以在执行完任务之后无法返回任何结果。 Callable接口是JDK1.5新增的函数式接口，位于java.util.concurrent包下： java1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 相比较使用Runnable接口，使用Callable接口能获取返回值，并且还可以处理异常。 如果要使用Callable接口，还需要配合支持异步调用的Future相关类。 2 FutureFuture接口是JDK1.5新增的函数式接口，位于java.util.concurrent包下，用于表示异步计算的结果： java1234567891011121314151617181920public interface Future&lt;V&gt; &#123; // 用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false // 参数mayInterruptIfRunning表示是否允许取消正在执行的任务，如果设置true，则表示可以取消正在执行过程中的任务 // 如果任务已经完成，返回false // 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false // 如果任务还没有执行，返回true boolean cancel(boolean mayInterruptIfRunning); // 表示正在执行的任务是否被取消成功，如果在完成前被取消成功，返回true boolean isCancelled(); // 表示任务是否已经完成，若任务完成，则返回true boolean isDone(); // 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回 V get() throws InterruptedException, ExecutionException; // 用来获取执行结果，如果在指定时间内，还没获取到结果，就抛出TimeoutException异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 3 FutureTaskFutureTask类间接实现了Runnable接口和Future接口，所以既可以作为Runnable被线程执行，又可以作为Future获取线程执行的结果。 多个线程创建时，如果使用了相同的FutureTask类，那么只会有一个线程执行call()方法。 构造方法： java12public FutureTask(Callable&lt;V&gt; callable);public FutureTask(Runnable runnable, V result); 通过实现Callable接口创建： java12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; DemoCallable callable = new DemoCallable(); FutureTask&lt;Integer&gt; f1 = new FutureTask&lt;&gt;(callable); FutureTask&lt;Integer&gt; f2 = new FutureTask&lt;&gt;(callable); Thread t1 = new Thread(f1, &quot;线程一&quot;); Thread t2 = new Thread(f2, &quot;线程二&quot;); t1.start(); t2.start(); try &#123; System.out.println(f1.get() + f2.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class DemoCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; return 1000; &#125;&#125; 4 CompletableFuture4.1 简介由于Future接口在获取结果时只能通过阻塞或者轮询的方式，阻塞的方式和异步编程的初衷相违背，轮询的方式会耗费无谓的CPU资源并且不能及时得到结果，因此迫切需要新的方式。 在JDK1.8中，提供了更加强大的CompletableFuture类，简化了异步编程的复杂性，提供了函数式编程的能力，还可以通过回调的方式处理结果。 CompletableFuture类实现了Future接口和CompletionStage接口。Future接口代表异步获取结果，CompletionStage接口代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。 使用CompletableFuture支持使用自定义的线程池，默认使用ForkJoinPool类的commonPool()方法创建的线程池。 4.2 使用4.2.1 创建任务4.2.1.1 runAsync使用runAsync()方法创建无返回值的异步任务，默认使用ForkJoinPool线程池里的线程。 示例： java12345678910public static void main(String[] args) &#123; CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;-runAsync&quot;); &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-result-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log12ForkJoinPool.commonPool-worker-9-runAsyncmain-result-null 4.2.1.2 supplyAsync使用supplyAsync()方法创建带返回值的异步任务，默认使用ForkJoinPool线程池里的线程。 示例： java1234567891011public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success&quot;; &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-result-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log12ForkJoinPool.commonPool-worker-9-supplyAsyncmain-result-success 4.2.1.3 比较比较： 维度 runAsync supplyAsync 是否有返回值 无 有 4.2.2 立即返回4.2.2.1 complete使用complete()方法将入参设置为任务执行结果，将任务标记为成功完成。 示例： java12345678910111213public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;-start&quot;); future.complete(&quot;success&quot;); System.out.println(Thread.currentThread().getName() + &quot;-end&quot;); &#125;).start(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123Thread-0-startThread-0-endmain-return-success 4.2.2.2 completeExceptionally使用completeExceptionally()方法将入参设置为任务抛出异常，将任务标记为异常完成。 示例： java12345678910111213public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;-start&quot;); future.completeExceptionally(new NullPointerException(&quot;exception&quot;)); System.out.println(Thread.currentThread().getName() + &quot;-end&quot;); &#125;).start(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123456Thread-0-startThread-0-endjava.util.concurrent.ExecutionException: java.lang.NullPointerException: exception at ...Caused by: java.lang.NullPointerException: exception at ... 4.2.2.3 比较比较： 维度 complete completeExceptionally 后续状态 isDone() == true isCompletedExceptionally() == false isDone() == true isCompletedExceptionally() == true 对回调链的影响 触发thenApply和thenAccept等正常回调，跳过exceptionally和handle等异常回调。 触发exceptionally和handle等异常回调，跳过thenApply和thenAccept等正常回调。 返回值 首次调用返回true，重复调用返回false，且不会覆盖已有结果。 首次调用返回true，重复调用返回false，且不会覆盖已有结果。 4.2.3 回调处理4.2.3.1 thenRun使用thenRun()方法在上一个任务结束后，继续执行下一个任务。 示例： java12345678910111213141516171819202122public static void main(String[] args) &#123; CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-runAsync&quot;); &#125;).thenRun(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-thenRun&quot;); &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log12345// 等待1sForkJoinPool.commonPool-worker-9-runAsync// 等待1sForkJoinPool.commonPool-worker-9-thenRunmain-return-null 4.2.3.2 thenAccept使用thenApply()方法在上一个任务结束后，接收上一个任务的结果，继续执行下一个任务，不返回结果。 示例： java123456789101112131415161718192021222324public static void main(String[] args) &#123; CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success-first&quot;; &#125;).thenAccept((result) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-thenAccept&quot;); System.out.println(Thread.currentThread().getName() + &quot;-result-&quot; + result); &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123456// 等待1sForkJoinPool.commonPool-worker-9-supplyAsync// 等待1sForkJoinPool.commonPool-worker-9-thenAcceptForkJoinPool.commonPool-worker-9-result-success-firstmain-return-null 4.2.3.3 thenApply使用thenApply()方法在上一个任务结束后，接收上一个任务的结果，继续执行下一个任务，返回下一个任务的结果。 示例： java12345678910111213141516171819202122232425public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success-first&quot;; &#125;).thenApply((result) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-thenApply&quot;); System.out.println(Thread.currentThread().getName() + &quot;-param-&quot; + result); return &quot;success-second&quot;; &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123456// 等待1sForkJoinPool.commonPool-worker-9-supplyAsync// 等待1sForkJoinPool.commonPool-worker-9-thenApplyForkJoinPool.commonPool-worker-9-param-success-firstmain-return-success-second 4.2.3.4 whenComplete使用whenComplete()方法在上一个任务结束后，接收上一个任务的结果和异常，继续执行下一个任务，返回上一个任务的结果。 示例： java12345678910111213141516171819202122232425public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success-first&quot;; &#125;).whenComplete((result, exception) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-whenComplete&quot;); System.out.println(Thread.currentThread().getName() + &quot;-result-&quot; + result); System.out.println(Thread.currentThread().getName() + &quot;-exception-&quot; + exception); &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log1234567// 等待1sForkJoinPool.commonPool-worker-9-supplyAsync// 等待1sForkJoinPool.commonPool-worker-9-whenCompleteForkJoinPool.commonPool-worker-9-result-success-firstForkJoinPool.commonPool-worker-9-exception-nullmain-return-success-first 4.2.3.5 handle使用handle()方法在上一个任务结束后，接收上一个任务的结果和异常，继续执行下一个任务，返回下一个任务的结果。 示例： java1234567891011121314151617181920212223242526public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success-first&quot;; &#125;).handle((result, exception) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-handle&quot;); System.out.println(Thread.currentThread().getName() + &quot;-result-&quot; + result); System.out.println(Thread.currentThread().getName() + &quot;-exception-&quot; + exception); return &quot;success-second&quot;; &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log1234567// 等待1sForkJoinPool.commonPool-worker-9-supplyAsync// 等待1sForkJoinPool.commonPool-worker-9-handleForkJoinPool.commonPool-worker-9-result-success-firstForkJoinPool.commonPool-worker-9-exception-nullmain-return-success-second 4.2.3.6 exceptionally使用exceptionally()方法在上一个任务结束后，接收上一个任务的异常，继续执行下一个任务，返回下一个任务的结果。 示例： java12345678910111213141516171819202122232425public static void main(String[] args) &#123; CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-supplyAsync&quot;); return &quot;success-first&quot; + 10 / 0; &#125;).exceptionally((exception) -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + &quot;-exceptionally&quot;); System.out.println(Thread.currentThread().getName() + &quot;-exception-&quot; + exception); return &quot;success-second&quot;; &#125;); try &#123; System.out.println(Thread.currentThread().getName() + &quot;-return-&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123456// 等待1sForkJoinPool.commonPool-worker-9-supplyAsync// 等待1sForkJoinPool.commonPool-worker-9-exceptionallyForkJoinPool.commonPool-worker-9-exception-java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zeromain-return-success-second 4.2.3.7 比较比较： 维度 thenRun thenAccept thenApply whenComplete handle exceptionally 接收 无 仅结果 仅结果 结果和异常 结果和异常 仅异常 返回 null null 回调函数 前置结果 回调函数 回调函数 前置 仅正常 仅正常 仅正常 正常和异常 正常和异常 仅异常 用途 不接收结果，不返回结果。 接收结果，不返回结果。 接收结果，返回新结果。 接收结果和异常，返回原结果。 接收结果和异常，返回新结果。 接收异常，返回新结果。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"线程安全集合","slug":"D00-后端/D01-Java/003-并发/005-线程安全集合","date":"2025-07-15T07:59:21.000Z","updated":"2025-07-22T01:27:14.286Z","comments":true,"path":"posts/20250715/155921/","permalink":"https://momashanhe.com/posts/20250715/155921/","excerpt":"摘要：本文学习了能在高并发场景下使用的线程安全集合。","text":"摘要：本文学习了能在高并发场景下使用的线程安全集合。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 集合中的线程安全问题1.1 List示例： java123456789public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125;&#125; 结果： log1Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException 说明出现了并发修改异常。 1.2 Set示例： java123456789public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; set.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(set); &#125;, String.valueOf(i)).start(); &#125;&#125; 结果： log1Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException 说明出现了并发修改异常。 1.3 Map示例： java12345678910public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; String key = String.valueOf(i); new Thread(() -&gt; &#123; map.put(key, UUID.randomUUID().toString().substring(0, 8)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125;&#125; 结果： log1Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException 说明出现了并发修改异常。 2 线程安全的集合JUC下有关Collection的类： CopyOnWriteArrayList：实现了List接口，相当于线程安全的ArrayList。 CopyOnWriteArraySet：继承于AbstractSet类，实现了Set接口，相当于线程安全的HashSet。通过CopyOnWriteArrayList实现。 ConcurrentSkipListSet：继承于AbstractSet类，实现了NavigableSet接口，相当于线程安全的TreeSet。通过ConcurrentSkipListMap实现。 ConcurrentLinkedQueue：继承于AbstractQueue类，实现了Queue接口，是单向链表实现的线程安全的无界队列，该队列支持FIFO方式操作元素。 ConcurrentLinkedDeque：继承于AbstractCollection类，实现了Deque接口，是双向链表实现的线程安全的无界队列，该队列支持FIFO和FILO方式操作元素，相当于线程安全的LinkedList。 ArrayBlockingQueue：实现了BlockingQueue接口，是数组实现的线程安全的有界阻塞队列。 LinkedBlockingQueue：实现了BlockingQueue接口，是单向链表实现的线程安全的无界阻塞队列，该队列支持FIFO方式操作元素。 LinkedBlockingDeque：实现了BlockingDeque接口，是双向链表实现的线程安全的无界阻塞队列，该队列支持FIFO和FILO方式操作元素。 SynchronousQueue：实现了BlockingQueue接口，是不存储元素的阻塞队列，put操作必须等待take操作，否则不能添加元素并产生中断抛出异常。 DelayQueue：实现了BlockingQueue接口，是支持延迟获取的阻塞队列。 JUC下有关Map的类： ConcurrentHashMap：继承于AbstractMap类，相当于线程安全的HashMap，是线程安全的哈希表。使用数组加链表加红黑树结构和CAS操作实现。 ConcurrentSkipListMap：继承于AbstractMap类，相当于线程安全的TreeMap，是线程安全的有序的哈希表。通过跳表实现的。 Collections工具类下的方法： synchronizedList()方法：将普通的List转换为线程安全的List，通过synchronized同步锁保证对集合的访问是线程安全的。 synchronizedSet()方法：将普通的Set转换为线程安全的Set，通过synchronized同步锁保证对集合的访问是线程安全的。 synchronizedMap()方法：将普通的Map转换为线程安全的Map，通过synchronized同步锁保证对集合的访问是线程安全的。 3 典型分析2.1 CopyOnWriteArrayList2.1.1 说明CopyOnWriteArrayList使用写时复制技术，其内部有个volatile修饰的数组用于保存数据，在操作数据时会创建新数组，并将更新后的数据拷贝到新数组中，最后再将该数组赋值给原数组。 通过volatile关键字保证数据修改时的可见性，通过在操作数据前使用Lock互斥锁来保护数据。所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。迭代器支持hasNext()方法和next()方法等不可变操作，但不支持add()方法和remove()方法等可变操作。 2.1.2 源码2.1.2.1 设置元素设置元素： java1234567891011121314151617181920212223242526public E set(int index, E element) &#123; // 使用锁来保证线程安全 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获得array指向的引用地址 Object[] elements = getArray(); // 获取指定位置的旧元素 E oldValue = get(elements, index); // 如果旧元素的引用和新元素的引用不同 if (oldValue != element) &#123; // 创建新的数组并拷贝array数组的值，替换新数组指定位置的元素 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; // 将array的引用地址指向新的数组 setArray(newElements); &#125; else &#123; // 为了确保volatile的语义，任何读操作都应该是写操作的结构，可以去掉 setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 2.1.2.2 添加元素添加元素： java1234567891011121314151617181920212223242526272829303132public void add(int index, E element) &#123; // 使用锁来保证线程安全 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获得array指向的引用地址 Object[] elements = getArray(); int len = elements.length; // 如果指定位置越界，则抛出异常 if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+len); Object[] newElements; // 如果插入位置是末尾 int numMoved = len - index; if (numMoved == 0) // 将原数组进行拷贝并扩大一个容量 newElements = Arrays.copyOf(elements, len + 1); else &#123; // 如果不是插入到末尾，则创建扩大一个容量的数组 newElements = new Object[len + 1]; // 分段复制原数组，并空出指定位置 System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; // 设置指定位置的指定元素 newElements[index] = element; // 将array引用的地址指向新的数组 setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125; 2.1.2.3 删除元素删除元素： java123456789101112131415161718192021222324252627282930public E remove(int index) &#123; // 使用锁来保证线程安全 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获得array指向的引用地址 Object[] elements = getArray(); int len = elements.length; // 根据指定的位置获取元素 E oldValue = get(elements, index); // 如果指定的元素是最后一个元素 int numMoved = len - index - 1; if (numMoved == 0) // 将原数组进行拷贝截取并将array的引用地址指向新的数组 setArray(Arrays.copyOf(elements, len - 1)); else &#123; // 如果不是最后一个元素，则创建减少一个容量的数组 Object[] newElements = new Object[len - 1]; // 分段复制原数组，并空出指定位置 System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); // 将array的引用地址指向新的数组 setArray(newElements); &#125; // 返回该位置上的元素 return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 2.2 ConcurrentHashMap2.2.1 说明在JDK1.8之前，ConcurrentHashMap使用分段锁机制实现，其最大并发度受Segment的个数限制。 在JDK1.8之后，ConcurrentHashMap使用与HashMap类似的数组配合链表或红黑树的方式实现，加锁采用CAS自旋锁和synchronized可重入锁等机制实现。 2.2.2 属性使用sizeCtl属性表示标志控制符，这个参数非常重要，出现在ConcurrentHashMap的各个阶段，不同取值的含义： 负数：表示正在进行初始化或扩容操作： -1表示正在进行初始化操作。 -N表示正在进行扩容操作：高16位是扩容标识，与数组长度有关，最高位固定为1，低16位减1表示扩容线程数。 0：表示数组还未初始化。 正数：表示下一次进行扩容的大小，类似于扩容阈值。它的值始终是当前容量的0.75倍，如果数组节点个数大于等于sizeCtl，则进行扩容。 内部类Node中的hash属性： 负数：-1表示该节点为转发节点，-2表示该节点为红黑树节点。 正数：表示根据key计算得到的hash值。 2.2.3 源码2.2.3.1 构造方法需要说明的是，在构造方法里并没有对集合进行初始化操作，而是等到了添加节点的时候才进行初始化，属于懒汉式的加载方式。 另外，loadFactor参数在JDK1.8中不再有加载因子的意义，仅为了兼容以前的版本，加载因子默认为0.75并通过移位运算计算，不支持修改。 同样，concurrencyLevel参数在JDK1.8中不再有多线程运行的并发度的意义，仅为了兼容以前的版本。 构造方法： java123456789101112131415161718192021222324252627282930313233343536373839404142434445// 空参构造器public ConcurrentHashMap() &#123;&#125;// 指定初始容量的构造器public ConcurrentHashMap(int initialCapacity) &#123; // 参数有效性判断 if (initialCapacity &lt; 0) throw new IllegalArgumentException(); // 提供多余空间，避免初始化后马上扩容，防止初始容量为0，保证最小容量为2 int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); // 设置标志控制符 this.sizeCtl = cap;&#125;// 指定初始容量，加载因子的构造器public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, 1);&#125;// 指定初始容量，加载因子，并发度的构造器public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; // 参数有效性判断 if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); // 比较初始容量和并发度的大小，取最大值作为初始容量 if (initialCapacity &lt; concurrencyLevel) initialCapacity = concurrencyLevel; // 计算最大容量 long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); // 设置标志控制符 this.sizeCtl = cap;&#125;// 包含指定Map集合的构造器public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 设置标志控制符 this.sizeCtl = DEFAULT_CAPACITY; // 放置指定的集合 putAll(m);&#125; 2.2.3.2 初始化方法集合并不会在构造方法里进行初始化，而是在用到集合的时候才进行初始化，在初始化的同时会设置集合的阈值sizeCtl。 在初始化的过程中为了保证线程安全，总共使用了两步操作： 通过CAS原子更新方法将sizeCtl设置为-1，保证只有一个线程执行初始化。 线程获取初始化权限后内部进行二次判断，保证只有在未初始化的情况下才能执行初始化。 初始化集合数组，使用CAS原子更新保证线程安全，使用volatile保证顺序和可见性： java12345678910111213141516171819202122232425262728293031private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; // 死循环以完成初始化 while ((tab = table) == null || tab.length == 0) &#123; // 如果sizeCtl小于0则表示正在初始化，当前线程让出CPU if ((sc = sizeCtl) &lt; 0) Thread.yield(); // 如果需要初始化，并且使用CAS原子更新成功 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; // 第一个线程初始化之后，第二个线程还会进来所以需要重新判断，类似于线程同步的二次判断 if ((tab = table) == null || tab.length == 0) &#123; // 如果没有指定容量则使用默认容量16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; // 初始化一个指定容量的节点数组 @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; // 将节点数组指向集合数组 table = tab = nt; // 扩容阀值，获取容量的0.75倍的值，写法更高端比直接乘高效 sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 将sizeCtl的值设为阈值 sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; 2.2.3.3 添加节点添加节点的代码逻辑： 校验数据，判断传入一个key和value是否为空，如果为空就直接报错。ConcurrentHashMap是不可为空的，HashMap是可以为空的。 初始化数组，判断数组是否为空，如果为空就执行初始化方法。 插入或更新节点，如果数组插入位置的节点为空就通过CAS操作插入节点，如果数组正在扩容就执行协助扩容方法，如果产生哈希碰撞就找到节点并更新节点或者插入节点。 插入节点后，链表节点判断是否要转为红黑树节点，并且需要增加容量并判断是否需要扩容。 添加节点： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // 排除null的数据 if (key == null || value == null) throw new NullPointerException(); // 计算hash，右移16位并同自身异或，高16位不变，低16位增加高16位数据，最后还要保证返回正数 int hash = spread(key.hashCode()); // 节点个数。0表示未加入新结点，2表示树节点或链表节点的节点数，其它值表示链表节点的节点数。主要用于加入节点后，判断是否要由链表转为红黑树 int binCount = 0; // CAS自旋 for (Node&lt;K,V&gt;[] tab = table;;) &#123; // 声明节点、数组长度、对应的数组下标、节点的hash值 Node&lt;K,V&gt; f; int n, i, fh; // 如果没有初始化则进行初始化。除非构造时指定集合，否则默认构造不初始化，添加时检查是否初始化，属于懒汉式初始化 if (tab == null || (n = tab.length) == 0) // 初始化数组 tab = initTable(); // 如果已经初始化了，并且位置上的节点为null else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 使用CAS操作插入节点 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // 添加成功，跳出循环 break; &#125; // 如果位置上的节点不为null，并且节点的hash为-1，表示转发节点，说明数组正在扩容 else if ((fh = f.hash) == MOVED) // 协助扩容 tab = helpTransfer(tab, f); // 产生哈希碰撞，并且没有扩容 else &#123; V oldVal = null; // 锁住节点 synchronized (f) &#123; // 获取节点，判断节点是否发生了变化 if (tabAt(tab, i) == f) &#123; // 判断是否是链表节点，大于等于0表示链表节点，-1表示转发节点，-2表示红黑树节点 if (fh &gt;= 0) &#123; // 标记链表节点，表示链表节点个数 binCount = 1; // 循环添加节点到链表，同时节点个数自增 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; // 传入参数onlyIfAbsent为false表示找到节点则进行替换 if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; // 遍历到尾节点，没有找到节点，添加并作为尾节点 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 如果是红黑树节点 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; // 标记红黑树节点 binCount = 2; // 尝试添加，如果返回原值非空 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; // 替换节点 if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // 如果添加到了链表节点，需要进一步判断是否需要转为红黑树 if (binCount != 0) &#123; // 如果链表上的节点数大于等于8 if (binCount &gt;= TREEIFY_THRESHOLD) // 尝试转为红黑树 treeifyBin(tab, i); if (oldVal != null) // 返回原值 return oldVal; break; &#125; &#125; &#125; // 数组增加容量并判断是否要扩容 addCount(1L, binCount); return null;&#125; 2.2.3.4 修改容量修改容量时，使用的是分散热点机制，借鉴了LongAdder类的add()方法以及Striped64类的longAccumulato()方法。 修改容量后需要判断是否要执行扩容方法，支持多个线程同时扩容。 修改容量： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private final void addCount(long x, int check) &#123; // x是要增加的容量。check是插入前节点个数，0表示未加入新结点，2表示树节点或链表节点的节点数，其它值表示链表节点的节点数 CounterCell[] as; long b, s; // 如果counterCells不为null，说明产生了并发，继续更新容量 // 如果counterCells为null，使用baseCount增加容量，如果对baseCount增加失败，说明产生了并发，继续更新容量 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; // 如果counterCells为null，说明对baseCount增加失败，继续通过fullAddCount()方法更新容量 // 如果counterCells不为null，但是counterCells的个数小于1，说明需要初始化counterCells数组，继续通过fullAddCount()方法更新容量 // 如果counterCells不为null，并且counterCells的个数大于等于1，但是通过线程的probe值和counterCells数组长度减一相与得到的counterCell为空，说明线程对应counterCells数组上的位置没有counterCell，继续通过fullAddCount()方法更新容量 // 如果counterCells不为null，并且counterCells的个数大于等于1，并且线程对应counterCells数组上的位置有counterCell，但是用counterCell位置中的值增加容量失败，表示更新容量失败，继续通过fullAddCount()方法更新容量 if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; // 继续更新容量，原理是热点分散机制，类似Striped64类的longAccumulato()方法 fullAddCount(x, uncontended); return; &#125; // 执行到这一步，说明通过counterCell位置中的值增加容量成功，如果插入前节点个数小于等于1则不考虑扩容直接返回 if (check &lt;= 1) return; // 计算数组节点个数 s = sumCount(); &#125; // 说明通过baseCount增加容量成功，如果check的值大于等于0，需要检查是否要扩容 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; // 如果节点个数大于等于阈值，并且数组不为空，并且数组长度小于最大值，执行扩容方法。循环判断，防止多线程同时扩容跳过if判断 while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; // 将长度的二进制位左边连续0的个数同1左移15位进行或运算 int rs = resizeStamp(n); // 如果sizeCtl小于0说明有其他线程正在扩容 // 这里数组已经完成了初始化，每个线程首次判断后都先进入else语句 if (sc &lt; 0) &#123; // 如果sizeCtl右移16位后不等于rs，说明已经扩容完成 // 如果sizeCtl右移16位后等于rs加1，说明已经扩容完成 // 如果sizeCtl右移16位后等于rs加低16位全为1的数字，说明已经扩容完成 // 如果扩容数组是null，说明已经扩容完成 // 如果转移索引小于等于0，说明已经扩容完成，无法再分配任务 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1 sc == rs + MAX_RESIZERS ||// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS (nt = nextTable) == null || transferIndex &lt;= 0) // 跳出循环 break; // 协助扩容，协助扩容时增加sizeCtl的值，结束扩容时减少sizeCtl的值 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) // 扩容 transfer(tab, nt); &#125; // 如果sizeCtl大于或等于0，说明第一次扩容，使用CAS设置sizeCtl为rs左移16位后加2的数字，此时sizeCtl为负数 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) // 进行扩容操作 transfer(tab, null); // 计算数组节点个数 s = sumCount(); &#125; &#125;&#125; 2.2.3.5 协助扩容协助扩容的代码逻辑： 判断集合数组不为空，并且节点是转发节点，并且转发节点的子节点不为空，如果不成立则不需要扩容。 循环判断是否扩容成功，如果没有就进行协助扩容，并增加sizeCtl的值，扩容结束后会减少sizeCtrl的值。 协助扩容： java1234567891011121314151617181920212223242526272829final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; // 如果数组不为null，并且节点是转发节点，并且转发节点的子节点不为null if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; // 将长度的二进制位左边连续0的个数同1左移15位进行或运算 int rs = resizeStamp(tab.length); // 如果新数组没有被修改，并且原数组也没有被修改，并且sizeCtl小于0说明还在扩容 while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; // 如果sizeCtl右移16位后不等于rs，说明已经扩容完成 // 如果sizeCtl右移16位后等于rs加1，说明已经扩容完成 // 如果sizeCtl右移16位后等于rs加低16位全为1的数字，说明已经扩容完成 // 如果转移索引小于等于0，说明已经扩容完成，无法再分配任务 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1 sc == rs + MAX_RESIZERS ||// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS transferIndex &lt;= 0) // 跳出循环 break; // 协助扩容，协助扩容时增加sizeCtl的值，结束扩容时减少sizeCtl的值 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; // 扩容 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125; 2.2.3.6 扩容方法扩容方法的核心思路是根据CPU内核数将原数组分成多个区间，每个线程都领取一个区间，对区间内的每个根节点进行扩容： 计算区间长度，根据CPU核心数平均分配给每个CPU相同大小的区间，如果不够16个，默认就是16个。 创建扩容后数组，有且只能由一个线程构建一个新数组。 双层循环完成扩容，外层for循环处理区间节点，内层使用while循环处理扩容区间。 处理区间节点时，判断如果完成扩容则返回跳出for循环，否则判断节点状态。如果是空节点和处理过的节点则设置为转发节点，否则对要扩容的节点使用高低节点进行拆分。 处理扩容区间时，线程会循环获取所有待处理区间，直至完成扩容，修改while循环标志位跳出循环。 当线程完成扩容后，会返回线程并减少sizeCtl的值，但最后一个线程返回时，更新数组和阈值。 扩容方法： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; // 根据CPU个数找出扩容时的每个线程处理的区间长度，最小是16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // 表示第一次扩容，因为在addCount()方法中，第一次扩容的时候传入的nextTab的值是null if (nextTab == null) &#123; try &#123; // 创建扩容后的节点数组 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; // 将创建的数组赋值给新数组 nextTab = nt; &#125; catch (Throwable ex) &#123; // 扩容失败，设置sizeCtl为最大值 sizeCtl = Integer.MAX_VALUE; return; &#125; // 将新数组赋值给扩容数组 nextTable = nextTab; // 转移索引为数组长度，说明区间是逆序迁移，从高位向低位迁移 transferIndex = n; &#125; // 设置扩容后的容量 int nextn = nextTab.length; // 创建一个转发节点，表示节点已处理，转发节点的hash默认为-1 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); // 如果是false，需要已获取区间，如果是true，说明需要重新获取区间 boolean advance = true; // 如果是true，完成扩容，如果是false，继续扩容 boolean finishing = false; // for循环处理区间节点，i表示上界，bound表示下界 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; // while循环获取扩容区间 while (advance) &#123; int nextIndex, nextBound; // 如果上界自减后大于等于下界，说明当前区间还未处理完，跳出while循环，继续处理当前区间 // 如果上界自减后小于下界，并且已完成扩容，跳出while循环，扩容结束 // 如果上界自减后小于下界，并且未完成扩容，继续获取下个区间 if (--i &gt;= bound || finishing) // 跳出while循环 advance = false; // 继续获取下个区间，如果下个区间的上界小于等于0，跳出while循环，扩容结束 else if ((nextIndex = transferIndex) &lt;= 0) &#123; // 设置区间上界为-1 i = -1; // 跳出while循环 advance = false; &#125; // 如果将转移索引修改为下个区间的下界成功，跳出while循环，继续处理下个区间 else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; // 设置处理区间的下界 bound = nextBound; // 设置处理区间的上届 i = nextIndex - 1; // 跳出while循环 advance = false; &#125; &#125; // while循环结束，判读是否完成扩容 // 如果上界小于0，说明扩容结束 // 如果上界大于等于原容量，表示超过下标最大值，说明扩容结束 // 如果上界加上原容量大于等于新容量，表示超过下标最大值，说明扩容结束 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; // 如果完成扩容，执行操作 if (finishing) &#123; // 删除成员变量 nextTable = null; // 更新集合数组 table = nextTab; // 更新阈值 sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; // 执行到此，说明完成扩容，将sizeCtl减1，线程会在协助扩容前将sizeCtl加1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; // 如果不是最后一个扩容线程，当前线程返回 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; // 如果是最后一个扩容线程，扩容结束，但是会再次进入while循环检查一次 finishing = advance = true; // 再次while循环检查一下整张表，并更新数组和阈值 i = n; &#125; &#125; // 判断节点是否存在，如果节点是null，则设为转发节点并进入while循环 else if ((f = tabAt(tab, i)) == null) // 设为转发节点并进入while循环，判断区间是否完成扩容 advance = casTabAt(tab, i, null, fwd); // 判断节点是否需要扩容，如果节点是转发节点，则进入while循环 else if ((fh = f.hash) == MOVED) // 进入while循环，判断区间是否完成扩容 advance = true; // 对节点扩容，节点不是转发节点 else &#123; // 对这个节点上锁，防止扩容节点时其他线程对该节点修改 synchronized (f) &#123; // 二次校验上界下标处的节点 if (tabAt(tab, i) == f) &#123; // 声明高位节点和低位节点 Node&lt;K,V&gt; ln, hn; // 判断是否是链表节点，大于等于0表示链表节点，-1表示转发节点，-2表示红黑树节点 if (fh &gt;= 0) &#123; // 计算数组节点高低值，将原容量同节点的hash值进行与运算，判断将该节点放到高位还是低位 int runBit = fh &amp; n; // 定义尾节点 Node&lt;K,V&gt; lastRun = f; // 遍历这个节点 for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; // 计算节点高低值，判断将该节点放到高位还是低位 int b = p.hash &amp; n; // 如果该节点的高低值和数组节点的高低值不同 if (b != runBit) &#123; // 更新高低值 runBit = b; // 更新尾节点 lastRun = p; &#125; &#125; // 如果最后更新的高低值是0，设置低位节点 if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; // 如果最后更新的高低值是1，设置高位节点 else &#123; hn = lastRun; ln = null; &#125; // 再次循环，生成两个链表，尾节点作为停止条件，避免无谓的循环 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; // 如果与运算结果是0，那么创建低位节点，倒序插入 if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); // 如果与运算结果是1，那么创建高位节点，倒序插入 else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; // 设置低位链表，放在新数组的上界位置 setTabAt(nextTab, i, ln); // 设置高位链表，放在新数组的上界加原长度位置 setTabAt(nextTab, i + n, hn); // 将旧的链表设置成转发节点 setTabAt(tab, i, fwd); // 继续处理区间的下一个节点 advance = true; &#125; // 如果是红黑树节点 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; // 遍历 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(h, e.key, e.val, null, null); // 与运算结果为0的放在低位 if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; // 与运算结果为1的放在高位 else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; // 如果树的节点数小于等于6，那么转成链表，反之，创建一个新的树 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; // 如果树的节点数小于等于6，那么转成链表，反之，创建一个新的树 hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; // 设置低位树，放在新数组的i位置 setTabAt(nextTab, i, ln); // 设置高位数，放在新数组的i+n位置 setTabAt(nextTab, i + n, hn); // 将旧的树设置成转发节点 setTabAt(tab, i, fwd); // 继续处理区间的下一个节点 advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 2.2.3.7 获取方法根据指定的键，返回对应的键值对，由于是读操作，所以不涉及到并发问题，步骤如下： 判断key对应数组位置上的节点是否为空，为空则返回空表示没有找到，不为空则继续判断。 如果位置节点是转发节点或者红黑树节点，执行相应节点的查询方法，如果位置节点是链表节点，遍历链表节点并查询。 获取节点： java123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; // 计算hash值 int h = spread(key.hashCode()); // 如果数组不为空，并且数组长度大于0，并且数组位置上的节点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 如果hash相等，继续判断 if ((eh = e.hash) == h) &#123; // 如果找到了节点则返回值 if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; // 如果正在扩容或者是树节点，执行各自节点的查询方法 else if (eh &lt; 0) // 尝试查找节点 return (p = e.find(h, key)) != null ? p.val : null; // 如果位置节点的子节点不为空，则遍历节点查找 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; 2.2.3.8 删除节点删除节点可以看成是替换操作。 删除节点： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990final V replaceNode(Object key, V value, Object cv) &#123; // 计算hash int hash = spread(key.hashCode()); // CAS自旋 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果数组是空，或者数组长度是0，或者数组位置上的节点是空 if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) // 跳出循环 break; // 如果位置上的节点不为null，并且节点的hash为-1，表示转发节点，说明数组正在扩容 else if ((fh = f.hash) == MOVED) // 协助扩容 tab = helpTransfer(tab, f); // 产生哈希碰撞，并且没有扩容 else &#123; V oldVal = null; // 是否进入了同步代码 boolean validated = false; // 锁住节点 synchronized (f) &#123; // 保证位置节点没有被修改 if (tabAt(tab, i) == f) &#123; // 如果是链表节点 if (fh &gt;= 0) &#123; validated = true; // 循环查找指定节点 for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; // 找到节点 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; // 如果传入的原值为空，或者原值和位置节点的值相同，更新或者删除节点 if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; // 如果新值不为空表示替换 if (value != null) e.val = value; // 新值是空表示删除，如果上一节点为空，表示删除位置节点 else if (pred != null) pred.next = e.next; // 新值是空表示删除，如果上一节点不为空，表示删除非位置节点 else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; // 如果没有找到 if ((e = e.next) == null) // 跳出循环 break; &#125; &#125; // 如果是红黑树节点 else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; // 找到节点 if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; // 如果传入的原值为空，或者原值和位置节点的值相同，更新或者删除节点 if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; // 如果进入了同步代码 if (validated) &#123; // 如果更新或者删除了节点 if (oldVal != null) &#123; // 如果是删除操作 if (value == null) // 将数组长度减一 addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null;&#125; 2.2.3.9 统计容量ConcurrentHashMap中baseCount用于保存数组中节点个数，但是并不准确，因为多线程同时增删改，会导致baseCount修改失败，此时会将节点个数存储于counterCells数组内。 当需要统计节点个数的时候，除了要统计baseCount之外，还需要加上counterCells中的每个counterCell的值。 值得一提的是即使如此，统计出来的依旧不是当前数组中节点的准确值，在多线程环境下统计前后并不能暂停线程操作，因此无法保证准确性。 统计集合容量： java1234public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125; 统计节点数量，即baseCount和counterCells元素个数的总和： java1234567891011final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"Atomic","slug":"D00-后端/D01-Java/003-并发/004-Atomic","date":"2025-07-15T02:34:41.000Z","updated":"2025-07-23T05:42:02.663Z","comments":true,"path":"posts/20250715/103441/","permalink":"https://momashanhe.com/posts/20250715/103441/","excerpt":"摘要：本文学习了Atomic原子操作类常用的类和方法。","text":"摘要：本文学习了Atomic原子操作类常用的类和方法。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 原子操作类原子操作类指的是java.util.concurrent.atomic包中的类，可以分成六种： 普通类型原子类：AtomicInteger，AtomicBoolean，AtomicLong，AtomicReference。 数组类型原子类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray。 复合类型原子类：AtomicStampedReference，AtomicMarkableReference。 对象属性原子类：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater。 累加操作原子类：DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder。 累加操作基础类：Striped64，Number。 1.1 普通类型原子类AtomicInteger，AtomicBoolean，AtomicLong，AtomicReference是操作标量类型的原子类，其内部实现使用volatile关键字和native方法，从而避免了synchronized的高开销。 场景： AtomicInteger和AtomicLong用于保证整数类型操作的线程安全。 AtomicBoolean可以作为中断标识，用于停止线程。 AtomicReference用于保证引用类型操作的线程安全，也可以封装多个共享变量，保证多个共享变量操作的线程安全。 使用AtomicInteger完成多线程自增操作： java1234567891011121314151617181920212223242526272829303132public class Demo &#123; public AtomicInteger atomicInteger = new AtomicInteger(); public static void main(String[] args) throws InterruptedException &#123; Demo demo = new Demo(); // 使用CountDownLatch计数10个线程，等待线程执行结束 CountDownLatch countDownLatch = new CountDownLatch(10); // 10个线程进行循环累加100次 for (int i = 1; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; for (int j = 1; j &lt;= 100; j++) &#123; demo.addPlusPlus(); &#125; &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;, String.valueOf(i)).start(); &#125; countDownLatch.await(); // main获取到的result:1000 System.out.println(Thread.currentThread().getName() + &quot;获取到的result:&quot; + demo.get()); &#125; public void addPlusPlus() &#123; atomicInteger.incrementAndGet(); &#125; public int get() &#123; return atomicInteger.get(); &#125;&#125; 1.2 数组类型原子类AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray是操作数组类型的原子类，对数组提供了支持，其内部没有维持volatile变量，而是全部由native方法实现。 场景： AtomicIntegerArray和AtomicLongArray用于保证整数类型数组操作的线程安全。 AtomicReferenceArray用于保证引用类型数组操作的不安全问题。 1.3 复合类型原子类AtomicStampedReference，AtomicMarkableReference是复合类型的原子类，将某种值和引用关联起来。 场景： AtomicMarkableReference将单个布尔值与引用关联起来，维护带有标记位的对象引用，可以原子更新带有标记位的引用类型。 AtomicStampedReference将整数值与引用关联起来，维护带有版本号的对象引用，可以原子更新带有版本号的引用类型，可以解决使用CAS出现的ABA问题。 使用AtomicStampedReference类进行更新： java1234567891011121314151617181920212223242526272829303132333435363738public class Demo &#123; public static void main(String[] args) &#123; AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(0, 0); new Thread(() -&gt; &#123; // 线程1进入 System.out.println(Thread.currentThread().getName() + &quot;进入&quot;); // 线程1记录时间戳 int stamp = atomicStampedReference.getStamp(); // 线程1被挂起，等待其他线程执行 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 线程1更新时发现时间戳不一致，更新失败 System.out.println(Thread.currentThread().getName() + &quot;将0更新为1:&quot; + atomicStampedReference.compareAndSet(0, 1, stamp, stamp + 1)); &#125;, &quot;t1&quot;).start(); new Thread(() -&gt; &#123; // 线程2进入 System.out.println(Thread.currentThread().getName() + &quot;进入&quot;); // 线程2记录时间戳 int stamp = atomicStampedReference.getStamp(); // 线程2更新成功 System.out.println(Thread.currentThread().getName() + &quot;将0更新为1:&quot; + atomicStampedReference.compareAndSet(0, 1, stamp, stamp + 1)); &#125;, &quot;t2&quot;).start(); new Thread(() -&gt; &#123; // 线程3进入 System.out.println(Thread.currentThread().getName() + &quot;进入&quot;); // 线程3记录时间戳 int stamp = atomicStampedReference.getStamp(); // 线程3更新成功 System.out.println(Thread.currentThread().getName() + &quot;将1更新为0:&quot; + atomicStampedReference.compareAndSet(1, 0, stamp, stamp + 1)); &#125;, &quot;t3&quot;).start(); &#125;&#125; 1.4 对象属性原子类AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater是操作对象属性的原子类，基于反射的原理，可以提供对关联字段类型的访问，用于对类中的volatile字段进行原子操作。 场景： AtomicIntegerFieldUpdater和AtomicLongFieldUpdater用于解决多线程环境下整数类型属性操作的不安全问题。 AtomicReferenceArray用于解决多线程环境下引用类型属性操作的不安全问题。 要求： 更新的属性必须使用volatile修饰符。 因为操作对象属性的原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置类和属性。 优势： 使用AtomicInteger获取结果值需要调用get()方法，但是AtomicIntegerFieldUpdater获取属性值可以通过对象获取，减少性能消耗。 使用AtomicIntegerFieldUpdater作为类的静态成员，多个对象可以共同使用，但是AtomicInteger对象不允许多个对象共同使用，造成资源浪费。 使用AtomicIntegerFieldUpdater完成多线程自增操作： java1234567891011121314151617181920212223242526272829303132333435public class Demo &#123; public static AtomicIntegerFieldUpdater atomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Demo.class, &quot;count&quot;); // 使用volatile关键字修饰属性 public volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; Demo demo = new Demo(); // 使用CountDownLatch计数10个线程，等待线程执行结束 CountDownLatch countDownLatch = new CountDownLatch(10); // 10个线程进行循环累加100次 for (int i = 1; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; for (int j = 1; j &lt;= 100; j++) &#123; demo.addPlusPlus(); &#125; &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;, String.valueOf(i)).start(); &#125; countDownLatch.await(); // main获取到的result:1000 System.out.println(Thread.currentThread().getName() + &quot;获取到的result:&quot; + demo.get()); &#125; public void addPlusPlus() &#123; atomicIntegerFieldUpdater.incrementAndGet(this); &#125; public int get() &#123; return count; &#125;&#125; 1.5 累加操作相关类DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder是累加操作的原子类，是JDK1.8引进的并发新技术，可以看做AtomicLong和AtomicDouble的部分加强类型。 Striped64，Number是累加操作的基础类，是JDK1.8引进的并发新技术，是累加操作原子类的父类。 对比： 在低并发的场景下，AtomicLong和LongAdder的性能相似，并且AtomicLong提供了更加丰富的功能。 在高并发的场景下，多个线程同时进行自旋操作，会出现大量失败并不断自旋的场景，此时AtomicLong的自旋会成为瓶颈，所以LongAdder具有更好的性能，但是代价是消耗更多的内存空间。 缺点： LongAdder只提供了加减法操作，功能过于单一，更多地用于收集统计数据，而不是细粒度的同步控制。 LongAdder的sum()方法并不精确，所以不能保证强一致性（在任何时刻查询到的都是最近更新的数据），只能保证最终一致性（最终更新的数据都会被查询到）。 原理： LongAdder类和DoubleAdder类都继承自Striped64类，其底层代码调用来自于Striped64类的longAccumulate()方法和doubleAccumulate()方法。 Striped64类的基本思路是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样发生冲突的概率就小很多。如果要获取整体的value值，只要将各个槽中的变量值累加返回即可。 2 分散热点在多线程高并发的情况下，为了避免自旋锁带来极大的性能开销，在Striped64类中使用了分散热点机制。 多线程自旋争抢的是value值的修改权，可以将value值看做热点，通过将value值分散到数组中实现热点分散，使用类似于哈希碰撞的机制，让每个线程通过计算得到数组中的位置，各个线程只对自己位置的value值进行CAS操作，降低了自旋发生争抢的概率。 Striped64类的计数方法在ConcurrentHashMap中也有使用，ConcurrentHashMap中的baseCount对应着Striped64中的base变量，而counterCells则对应着Striped64中的cells数组，他们的实现是一样的。 3 生产者消费者使用原子操作类实现生产者消费者： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Demo &#123; public static void main(String[] args) throws InterruptedException &#123; Resource r = new Resource(new ArrayBlockingQueue&lt;&gt;(3)); new Thread(() -&gt; &#123; try &#123; r.product(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;生产者&quot;).start(); new Thread(() -&gt; &#123; try &#123; r.consume(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;消费者&quot;).start(); Thread.sleep(5000); r.stop(); &#125;&#125;class Resource &#123; private volatile boolean state = true; private AtomicInteger count = new AtomicInteger(0); private BlockingQueue&lt;String&gt; queue; public Resource(BlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; public void product() throws InterruptedException &#123; String data; while (state) &#123; data = count.incrementAndGet() + &quot;&quot;; boolean result = queue.offer(data, 2L, TimeUnit.SECONDS); if (result) &#123; System.out.println(Thread.currentThread().getName() + &quot; product &quot; + data); &#125; else &#123; System.out.println(Thread.currentThread().getName() + &quot; product 超时&quot;); &#125; Thread.sleep(1000); &#125; System.out.println(Thread.currentThread().getName() + &quot;停止&quot;); &#125; public void consume() throws InterruptedException &#123; String data; while (state) &#123; data = queue.poll(2L, TimeUnit.SECONDS); if (data == null || data.equals(&quot;&quot;)) &#123; System.out.println(Thread.currentThread().getName() + &quot; consume 超时&quot;); &#125; else &#123; System.out.println(Thread.currentThread().getName() + &quot; consume &quot; + data); &#125; Thread.sleep(1000); &#125; System.out.println(Thread.currentThread().getName() + &quot;停止&quot;); &#125; public void stop() &#123; state = false; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"CAS","slug":"D00-后端/D01-Java/003-并发/003-CAS","date":"2025-07-14T05:12:15.000Z","updated":"2025-07-15T02:37:45.769Z","comments":true,"path":"posts/20250714/131215/","permalink":"https://momashanhe.com/posts/20250714/131215/","excerpt":"摘要：本文学习了CAS相关的原理和操作。","text":"摘要：本文学习了CAS相关的原理和操作。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 背景1.1 线程安全在并发编程中很容易出现并发安全的问题，比如多个线程执行i++操作。 最常用的方法是通过加锁操作，但是由于加锁操作采用的是悲观锁策略，并不是特别高效的一种解决方案。 除此之外，也可以使用java.util.concurrent.atomic包提供的原子类，使用CAS采用类似乐观锁的策略去更新数据，解决并发安全问题。 1.1 乐观锁和悲观锁悲观锁假设对共享资源的访问都会发生冲突，当有一个线程访问资源，其他线程就必须等待，所以采用了加锁的方式解决冲突。 乐观锁假设对共享资源的访问是没有冲突的，线程可以同时访问资源。如果遇到冲突的话，就使用CAS技术重复检测冲突，直到没有冲突才能访问资源。 2 简介CAS（Compare and Swap，比较并交换）技术属于乐观锁技术（又称为无锁技术），指当多个线程同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试更新。 3 原理CAS包含了三个参数： V：表示要读写的内存位置。 A：表示旧的预期值。 B：表示新值。 在更新时比较V中存储的值和A的值： 如果二者不同，说明可能是其他线程做了更新，那么当前线程什么都不做，执行返回或者重试。 如果二者相同，将V中存储的值设为B的值，并返回A的值。 当多个线程同时使用CAS更新变量时，只有一个线程会成功，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试，这个过程也称为自旋。 正是基于这样的原理，CAS即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。而且因为没有使用锁，也就不会造成死锁。 4 核心Unsafe类是特殊的类，位于sun.misc包中，其内部方法可以像C的指针一样直接操作内存，CAS依赖Unsafe类的方法。 Unsafe类是CAS的核心类，基于该类可以直接操作特定的内存数据，该类的所有方法都是native修饰的，并且该类提供了底层的CAS机制。 5 缺点5.1 CPU开销较大在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。 解决办法目前没有，只能通过让JVM支持处理器提供的PAUSE指令来减轻CPU的压力。 5.2 多个共享变量不能保证原子性CAS所保证的只是一个变量的原子性操作，而不能保证多个共享变量的原子性。 解决办法是使用锁机制或者使用AtomicReference类封装多个共享变量。 5.3 ABA问题CAS判断变量操作成功的条件是V中存储的值和A的值是一致的，如果V中存储的值原来是A，被改成了B，又被改回为A，经过了两次的修改，但是CAS还是认为该变量从来没被修改过。 解决办法是使用AtomicStampedReference类通过追加版本号或时间戳同时判断原值是否改变。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"内存模型","slug":"D00-后端/D01-Java/003-并发/002-内存模型","date":"2025-07-10T01:18:31.000Z","updated":"2025-07-22T01:27:10.760Z","comments":true,"path":"posts/20250710/091831/","permalink":"https://momashanhe.com/posts/20250710/091831/","excerpt":"摘要：本文学习了内存模型及其相关的知识。","text":"摘要：本文学习了内存模型及其相关的知识。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 内存模型1.1 简介Java内存模型（Java Memory Model，JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过规范定制了程序中各个变量的访问方式。 内存模型规定： 所有的变量都存储在主内存（内存条），每条线程都有着自己独立的工作内存（寄存器，L1、L2、L3缓存）。 线程的工作内存中保存了被该线程使用的变量的主内存副本，简单来说就是把变量从主内存拷到自己的工作内存中。 线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的变量。 不同线程之间无法访问对方的工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成。 内存模型示例图如下： 这里假定一个CPU有多核，一个线程使用一个内核。 1.2 意义在一个计算机系统中，数据存储的位置主要有硬盘和内存，以及多级缓存。因为访问速度的问题，CPU的运行并不是直接操作内存，而是先将内存中的数据读取到缓存，内存的读操作和写操作产生的时间差异就会造成不一致的问题。 内存模型的主要目的，就是定义程序中各种变量的访问规则，来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 1.3 八种操作内存模型定义了八种操作来实现变量在主内存和工作内存之间的拷贝和同步： lock（锁定）：作用于主内存的变量，把变量标识为锁定状态。 unlock（解锁）：作用于主内存的变量，把锁定状态的变量释放，释放的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，把变量值从主内存传输到工作内存，以便随后load操作使用。 load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存。 use（使用）：作用于工作内存的变量，把工作内存的变量值传递给执行引擎，执行使用变量的字节码指令时执行这个操作。 assign（赋值）：作用于工作内存的变量，把从执行引擎接收到的值赋给工作内存的变量，执行赋值变量的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把变量值从工作内存传输到主内存，以便随后write操作使用。 write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存。 除此之外，内存模型还规定了在执行上诉八种操作时必须满足的规则： 如果要把变量从主内存中复制到工作内存中，就需要按顺序执行read操作和load操作，必须成对使用read操作和load操作。 如果要把变量从工作内存中同步到主内存中，就需要按顺序执行store操作和write操作，必须成对使用store操作和write操作。 不能丢弃最近的assign操作，变量在工作内存中改变之后必须同步回主内存。 变量在发生assign操作才可以从工作内存同步回主内存。 新的变量只能在主内存中诞生。 不允许在工作内存中直接使用未被初始化的变量，执行use操作前必须先执行load操作，执行store操作前必须先执行assign操作。 变量在同一个时刻只允许一条线程对其进行lock操作，lock操作可以被执行多次，解锁需要执行相同次数的unlock操作，lock操作和unlock操作必须成对出现。 执行lock操作会清空工作内存中的变量值，在使用变量前需要重新初始化变量值。 执行unlock操作前必须先同步到主内存中，即执行unlock操作前必须先执行store操作和write操作。 1.4 三大特性1.4.1 可见性可见性是指在多线程坏境下，线程在工作内存中修改了某一个共享变量的值，其他线程能够立即获取该共享变量变更后的值。 一般情况下，共享变量不能保证可见性，因为数据修改后被写入内存的时机是不确定的，而线程间变量值的传递均需要通过主内存来完成。 可以使用volatile关键字保证共享变量的可见性，也可以使用同步锁。 1.4.2 原子性原子性是指在多线程坏境下，线程对数据的操作要保证全部成功或者全部失败，并且不能被其他线程干扰。 线程在读取主内存变量、操作变量、写回主内存变量的一系列过程中，其他线程不能对该内存变量进行修改，或者在发现变量被修改后应重新读取该变量。 一般情况下，共享变量不能保证原子性，因为存在多个线程同时写入共享变量到主内存的情况，这就会导致前一个线程写入的值会被后一个线程写入的值覆盖。 可以使用自旋锁保证共享变量的原子性，也可以使用同步锁。 1.4.3 有序性有序性是指在多线程环境下，禁止指令重排序，保证结果的一致性。 指令重排序指的是计算机在执行程序时，为了提高性能，会对指令的执行顺序进行调整，并不是按照代码编写顺序执行。 指令重排序图示： 指令重排序分为以下三种： 编译器优化重排序：编译器在不改变程序执行结果的情况下，为了提升效率，会重新安排指令的执行顺序。 指令级并行重排序：处理器在不影响程序执行结果的情况下，为了提升效率，使用指令级并行技术，将多条机器指令重叠执行。 内存系统重排序：为了提升性能，在CPU和主内存之间设置了高速缓存，得加载和存储操作看上去可能是在乱序执行。 指令重排序需要遵守的规则： 在进行重排序时，必须要考虑指令之间的数据依赖性，即有依赖关系的程序不会发生重排序。 在进行重排序后，可以保证在单线程环境中执行的结果一致，不能保证在多线程环境中一致。 可以使用volatile关键字保证共享变量的有序性，也可以使用同步锁。 2 缓存一致性2.1 背景计算机核心组件：CPU、内存、IO设备（硬盘）。三者在处理速度上存在巨大差异，CPU速度最快，其次是内存，硬盘速度最慢。 为了提升计算性能，CPU从单核提升到了多核，甚至用到了超线程技术最大化提高CPU处理性能，然而内存和硬盘的发展速度远远不及CPU。 为了平衡三者之间的速度差异，最大化的利用CPU提升性能，做出了很多优化： 硬件层面优化：CPU增加高速缓存。 操作系统层面优化：增加了进程和线程，通过CPU时间片切换最大化提升CPU的使用率。 编译器层面优化：优化指令，更合理的利用CPU高速缓存。 2.2 高速缓存使用高速缓存作为内存和处理器之间的缓冲，可以很好的解决处理器与内存的速度矛盾。 高速缓存的工作原理如下： 加载程序及数据到主内存。 加载程序及数据到高速缓存。 处理器执行程序，将结果存储在高速缓存。 高速缓存将数据写回主内存。 带有高速缓存的CPU执行流程如下： 由于CPU运算速度超过了普通高速缓存的处理能力，CPU厂商又引入了多级缓存： 2.3 缓存一致性问题高速缓存很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，如果CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会产生缓存一致性问题。 2.4 总线锁和缓存锁2.4.1 总线锁（总线控制协议）为了解决缓存一致性的问题，操作系统提供了总线锁定的机制。 总线（Bus）是一组信号线，用来在计算机各种功能部件之间传送信息。 按照所传输的信息种类，计算机的总线可以划分： 数据总线（Data Bus）用来在处理器和内存之间传输数据。 地址总线（Address Bus）用于在内存中存储数据的地址。 控制总线（Control Bus）用二进制信号对所有连接在系统总线上设备的行为进行同步。 在多线程环境下，当线程要对共享内存进行操作的时候，在总线上发出一个LOCK#信号，这个信号会使其他线程无法通过总线来访问共享内存中的数据。 总线锁定把处理器和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，这种机制显然是不合适的，后来的处理器都提供了缓存一致性协议。 2.4.2 缓存锁（缓存一致性协议）相比总线锁，缓存锁即降低了锁的力度，其核心机制是基于缓存一致性协议来实现的。 常用的缓存一致性协议都是属于窥探协议，各个核能够时刻监控自己和其他核的状态，从而统一管理协调。 最常见的协议是MESI协议，MESI表示缓存行（缓存存储数据的单元）的四种状态： M（Modify）表示缓存行是被修改状态，只在当前CPU中有缓存，并且被修改了，还没有更新到主内存中。 E（Exclusive）表示缓存行是独占状态，只在当前CPU中有缓存，并且没有被修改。 S（Shared）表示缓存行是共享状态，在多个CPU中有缓存，并且没有被修改。 I（Invalid）表示缓存行是无效状态，当前CPU中缓存的数据是无效的。 在MESI协议中，每个缓存行都需要监听其它缓存行对共享数据的读写操作。 在多线程环境下，MESI协议的流程如下： 当线程1读取共享数据到缓存行中存储，会将状态设为E。 当线程2读取该共享数据到缓存行中存储，会将状态设为S。线程1监听到线程2读取该共享数据后，会将状态由E改为S。 当线程1修改该共享数据后，会将状态由S改为M，在其他线程读取该共享数据前写回到主内存。线程2监听到线程1修改该共享数据后，会将状态由S改为I。 当线程2修改该共享数据时，发现状态为I，会重新读取共享数据到缓存行，并将状态由I改为E，修改该共享数据后，会将状态由E改为M，在其他线程读取该共享数据前写回到主内存。 如果被操作的数据不能被缓存在处理器内部，或者操作的数据跨越多个缓存行（状态无法标识），处理器会使用总线锁。 另外，当处理器不支持缓存锁时，自然也只能用总线锁了，比如说奔腾486以及更老的处理器。 2.5 内存操作的原子性原子操作是指不可被中断的一个或者一组操作。 处理器会自动保证基本的内存操作的原子性，也就是一个处理器从内存中读取或者写入一个字节时，其他内存是不能访问这个字节的内存地址。但处理器不能自动保证复杂的内存操作的原子性，比如跨总线宽度、跨多个缓存行或者跨页表的操作。 总线锁和缓存锁是处理器保证复杂内存操作原子性的两个机制。 2.6 存储缓存和无效队列2.6.1 MESI协议的缺陷虽然MESI协议保证了缓存的强一致性，但是实现强一致性还需要对CPU提出两点要求： CPU缓存要及时响应总线事件。 CPU严格按照程序顺序执行内存操作指令。 只要保证了以上两点，缓存一致性就能得到绝对的保证。但是由于效率的原因，CPU不可能保证以上两点： 总线事件到来之际，缓存可能正在执行其他的指令，例如向CPU传输数据，那么缓存就无法马上响应总线事件了。 CPU如果严格按照程序顺序执行内存操作指令，意味着回写数据之前，必须要等到所有其他缓存的失效确认，这个等待的过程严重影响CPU的计算效率。 2.6.2 存储缓存为了在写回数据时，避免等待其他缓存的失效确认，对每个线程都维护了一个存储缓存（Store Buffer）来暂时缓存要回写的数据。 CPU在将数据写入存储缓存之后就认为写操作已完成，不等待其他缓存返回失效确认继续执行其他指令，等所有的失效确认完成之后，再向存储缓存的数据写回到内存中。 正是因为使用了存储缓存，导致一些数据的内存写入操作可能会晚于程序中的顺序，也就是重排序。 2.6.3 无效队列因为存储缓存大小是有限制的，并且失效操作比较耗时，于是对每个线程维护了一个失效队列（Invalidation Queue）来存储失效操作。 对于到来的失效请求，失效确认消息马上发出，同时将失效操作放入失效队列，但并不马上执行。 由于使用了失效队列，失效操作不会立即执行，读操作就会读取到过时的数据，导致可见性的问题。 2.7 伪共享2.7.1 说明伪共享指的是多个线程同时读写同一个缓存行的不同变量时，会导致CPU缓存失效。看起来是并发执行的，但实际在CPU处理的时候，是串行执行的，并发的性能大打折扣。 伪共享的原因就是CPU在处理失效的时候，是直接废除整个缓存行的操作。 比如： 如果变量A和变量B都在同一个缓存行上，线程1和线程2都缓存了这两个变量。 假如线程1修改了变量A，那么线程2的缓存行就失效了，如果线程2需要修改变量B，就需要等待该缓存行失效后，重新读取主内存中的数据。 这就意味着对变量A和变量B的操作只能是串行的，频繁的多线程操作会导致CPU缓存彻底失效，降级为CPU和主内存直接交互。 2.7.2 解决办法增大共享变量的内存大小，使得不同线程存取的变量位于不同的缓存行上，典型的空间换时间。 在JDK1.8中，新增了@sun.misc.Contended注解，来使各个变量在缓存行中分隔开，避免伪共享问题，但使用该注解会增加目标实例大小。 默认情况下使用注解无效，需要在JVM中添加参数-XX:-RestrictContended才能开启此功能。 该注解在Thread类、ConcurrentHashMap类、LongAddr类中均有使用。 3 内存屏障3.1 乱序访问程序在运行时，为了提升程序运行时的性能，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。 乱序访问主要发生在两个阶段： 运行时，多处理器间交互引起内存乱序访问（MESI协议）。 编译时，编译器优化导致内存乱序访问（指令重排）。 3.2 内存屏障内存屏障能够让处理器或编译器在内存访问上有序，一个内存屏障之前的内存访问操作必定先于其之后的完成。 3.2.1 处理器内存屏障处理器内存屏障分为两种： Store Memory Barrier（ST, SMB, SMP_WMB）：写屏障，CPU在执行屏障之后的指令之前，先执行所有已经在存储缓存中保存的指令。 Load Memory Barrier（LD, RMB, SMP_RMB）：读屏障，CPU在执行任何的加载指令之前，先执行所有已经在失效队列中的指令。 3.2.2 编译器内存屏障为了提高性能，编译器会对指令重排序，通过插入内存屏障，可以避免编译器对指令进行重排序。 编译器内存屏障分为四种： LoadLoad（LL）屏障：对于语句Load1; LoadLoad; Load2，保证Load1的读操作在Load2的读操作之前执行。 StoreStore（SS）屏障：对于语句Store1; StoreStore; Store2，保证Load1的写操作在Store2的写操作之前执行。 LoadStore（LS）屏障：对于语句Load1; LoadStore; Store2，保证Load1的读操作在Load2的写操作之前执行。 StoreLoad（SL）屏障：对于语句Store1; StoreLoad; Load2，保证Load1的写操作在Store2的读操作之前执行。 需要注意的是，StoreLoad（SL）屏障同时具备其他三个屏障的效果，因此也称之为全能屏障，是目前大多数处理器所支持的，但是相对其他屏障，该屏障的开销相对昂贵。 3.3 使用场景3.3.1 volatilevolatile的内存屏障策略非常严格保守： 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。 由于内存屏障的作用，避免了volatile变量和其它指令重排序，并且在多线程之间实现了通信，使得volatile表现出了轻量锁的特性。 3.3.2 final对于final域，必需保证一个对象的所有final域被写入完毕后才能引用和读取。 4 先行发生原则（Happen-Before）HappenBefor解决的是可见性问题，即前一个操作的结果对于后续操作是可见的。 在内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在HappenBefor关系。 这两个操作可以是同一个线程，也可以是不同的线程。 八条规则： 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支和循环等结构。 管程锁定规则（Monitor Lock Rule）：一个解锁操作先行发生于后面对同一个锁的加锁操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的其他方法。 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法。 传递性规则（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 5 volatile5.1 可见性可见性是指在多线程坏境下，线程在工作内存中修改了某一个共享变量的值，其他线程能够立即获取该共享变量变更后的值。 示例： java12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; try &#123; DemoThread thread = new DemoThread(); thread.start(); Thread.sleep(100); thread.setRunning(false); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class DemoThread extends Thread &#123; private boolean isRunning = true; public void setRunning(boolean isRunning) &#123; this.isRunning = isRunning; &#125; @Override public void run() &#123; System.out.println(&quot;进入方法&quot;); while (isRunning) &#123; &#125; System.out.println(&quot;执行完毕&quot;); &#125;&#125; 结果： log1进入方法 线程一直在运行，并没有因为调用了setRunning()方法就停止。 现在有两个线程，分别是main线程和thread线程，它们都在访问isRunning变量。 按照内存模型，main线程将isRunning变量读取到本地线程内存空间，修改后再刷新回主内存。 但是main线程在修改后，还没来得及写入主内存就去做其他事情了，thread线程无法读到main线程改变的isRunning变量，从而出现了死循环，导致thread线程无法终止。 解决办法就是在isRunning变量上加上volatile关键字修饰，强制main线程将修改后的值写回主内存，强制thread线程从主内存中取值。 示例： java1private volatile boolean isRunning = true; 结果： log12进入方法执行完毕 5.2 原子性原子性是指在多线程坏境下，线程对数据的操作要保证全部成功或者全部失败，并且不能被其他线程干扰。 使用volatile关键字只能保证对单次读写的原子性，不能保证复合操作的原子性。 示例： java123456789101112131415161718192021222324252627282930313233343536public class Demo &#123; public static void main(String[] args) &#123; DemoThread thread = new DemoThread(); Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(thread); threads[i].start(); &#125; try &#123; Thread.sleep(1000); System.out.println(thread.count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class DemoThread extends Thread &#123; public volatile int count = 0; @Override public void run() &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; add(); &#125; private void add() &#123; for (int i = 0; i &lt; 100; i++) &#123; count++; &#125; &#125;&#125; 结果： log1972 在多线程环境下，有两个线程分别将count读取到本地内存。 线程1抢到CPU执行权，执行自增操作后，在尚未写回到主内存前，线程2抢到CPU执行权，执行自增操作后将结果写回到主存，并通知线程1读取的count失效。 线程1再次抢到CPU执行权，将自增操作后的结果写回到主内存，此时覆盖了线程2的写操作，最终导致了count的结果不合预期，并非是1000。 自增操作是由三个指令构成的操作，所以在这三个指令执行期间，线程只会读取一次主内存的数据。 如果想要在复合类的操作中保证原子性，可用使用synchronized关键字来实现，还可以通过并发包中的循环CAS的方式来实现。 5.3 有序性有序性是指在多线程环境下，禁止指令重排序，保证结果的一致性。 重排序在单线程模式下是一定会保证最终结果的正确性，不能保证多线程环境下结果的正确性。 示例： java12345678910111213141516171819202122232425public class Demo &#123; private int count = 1; private boolean flag = false; public void write() &#123; count = 2; flag = true; &#125; public void read() &#123; if (flag) &#123; System.out.println(count); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; Demo demo = new Demo(); Thread write = new Thread(() -&gt; &#123;demo.write();&#125;); Thread read = new Thread(() -&gt; &#123;demo.read();&#125;); write.start(); read.start(); &#125; &#125;&#125; 运行代码后，控制台打印的数据中应该有1出现，但实际情况却只有2出现，并不能看出程序作了重排序，所以这个地方以后还需要补充。 预测的结果是有1出现，原因是指令进行了重排序，而在write()方法中由于第一步count = 2;和第二步flag = true;不存在数据依赖关系，有可能会被重排序。 使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"线程协作","slug":"D00-后端/D01-Java/003-并发/001-线程协作","date":"2025-07-02T17:48:54.000Z","updated":"2025-07-22T01:27:05.626Z","comments":true,"path":"posts/20250703/014854/","permalink":"https://momashanhe.com/posts/20250703/014854/","excerpt":"摘要：本文学习了并发场景下线程协作的新方式。","text":"摘要：本文学习了并发场景下线程协作的新方式。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 背景1.1 回顾之前了解到，在涉及得到线程同步的问题时，可以使用synchronized关键字保证线程安全，还可以使用Object类提供的wait()方法和notify()方法进行线程通信。 在JDK1.5之后，可以使用Lock相关接口来实现类似的功能，以及其他新增的功能。在1.6之后，JDK对synchronized做了优化，两种方式在性能上的差距就很小了，可以根据场景灵活选择。 1.2 缺陷在使用synchronized关键字时，如果一个线程获取了对应的锁，其他线程便只能一直等待释放锁，如果没有释放则需要无限的等待下去。 线程只会在两种情况下释放锁： 线程执行完了代码块，线程释放锁。 线程执行发生异常，JVM会让线程释放锁。 由此可以看出以往的方式在释放锁的时候比较笨重，不够灵活，不能满足更加灵活的使用场景。 如果想更加灵活的控制释放锁的时机，就需要使用新增的并发功能。 从JDK1.5之后，由Doug Lea大牛编写了JUC模块，将代码放在java.util.concurrent包中，新增了许多在并发场景下使用的工具，用于解决并发场景下的线程安全问题。 2 Lock2.1 简介Lock是JUC新增的接口，ReentrantLock类实现了Lock接口，也是Lock接口的主要实现类。 常用方法： java123456789101112// 等待获取锁，获取失败则进行等待void lock();// 等待获取锁，允许在等待时由其它线程调用中断方法结束等待，此时会抛出InterruptedException异常void lockInterruptibly() throws InterruptedException;// 尝试获取锁，如果获取成功则返回true，如果获取失败则返回falseboolean tryLock();// 尝试获取锁，如果在等待期间内获取成功则返回true，如果在等待期间内获取失败则返回falseboolean tryLock(long time, TimeUnit unit) throws InterruptedException;// 释放锁void unlock();// 获取Condition对象，用于线程通信Condition newCondition(); 2.2 比较关于synchronized和Lock的比较： 原始构成：synchronized是关键字，属于JVM层面。Lock是接口，属于API层面。 是否公平：synchronized是非公平锁，不支持公平锁。Lock支持公平锁和非公平锁，可以在构造方法中指定。 异常处理：synchronized在发生异常时，自动释放锁，因此不会产生死锁。Lock在发生异常时，需要手动释放锁，否则会产生死锁，因此使用Lock时需要在finally块中释放锁。 中断处理：synchronized不能响应中断，除非抛出异常或者运行完成。Lock可以响应中断，通过设置超时方法tryLock()以及调用中断方法interrupt()。 互斥共享：synchronized是互斥锁，不支持共享锁。Lock的子类ReentrantReadWriteLock支持互斥锁WriteLock和共享锁ReadLock。 精确唤醒：synchronized不支持精确唤醒，只能唤醒一个或者唤醒全部。Lock通过Condition支持精确唤醒，能够对某个线程或者某一种线程进行唤醒。 2.3 使用2.3.1 等待获取锁使用lock()方法等待获取锁，这是使用得最多的一个方法。 获取锁以后必须显示释放锁，即使出现异常时也不会自动释放，因此需要将业务逻辑写在try-catch代码块中，并且将释放逻辑写在finally代码块中，保证锁一定被被释放，防止死锁。 使用规范： java123456789101112131415public void method() &#123; // 创建锁对象 Lock lock = new ReentrantLock(); // 等待获取锁 lock.lock(); try &#123; // 业务逻辑 &#125; catch (Exception e) &#123; // 处理异常 e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 2.3.2 尝试获取锁使用tryLock()方法尝试获取锁，无论是否获取成功都会立即返回结果。 使用规范： java123456789101112131415161718public void method() &#123; // 创建锁对象 Lock lock = new ReentrantLock(); // 等待获取锁 if (lock.tryLock()) &#123; try &#123; // 业务逻辑 &#125; catch (Exception e) &#123; // 处理异常 e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; else &#123; // 获取失败业务逻辑 &#125;&#125; 2.3.3 中断获取锁使用lock()方法在等待期间是不能被中断的，但使用lockInterruptibly()方法在等待期间是可以被中断的。 如果当前线程在获取锁的等待期间被其他线程中断，当前线程会抛出InterruptedException异常，因此需要处理异常。 使用规范： java123456789101112131415public void method() throws InterruptedException &#123; // 创建锁对象 Lock lock = new ReentrantLock(); // 等待获取锁，但可以在等待期间被中断，需要处理异常 lock.lockInterruptibly(); try &#123; // 业务逻辑 &#125; catch (Exception e) &#123; // 处理异常 e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 调用interrupt()方法不能中断正在运行的线程，只能中断等待的线程。 2.3.4 互斥锁ReentrantLock类实现了Lock接口，并且ReentrantLock提供了更多的方法。 模拟窗口买票示例： java1234567891011121314151617181920212223242526272829303132333435363738public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;窗口1&quot;).start(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;窗口2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 5; // 创建锁对象，需要注意避免重复创建 Lock lock = new ReentrantLock(); public void sale() &#123; while (num &gt; 0) &#123; // 强制当前线程放弃时间片，允许其他线程竞争时间片 try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 等待获取锁 lock.lock(); try &#123; // 业务逻辑 if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125; catch (Exception e) &#123; // 处理异常 e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; &#125;&#125; 结果： log12345窗口1 sale 5窗口1 sale 4窗口2 sale 3窗口1 sale 2窗口2 sale 1 2.3.5 读写锁使用ReadWriteLock接口定义读写锁，接口里包含读锁和写锁： java1234public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; ReentrantReadWriteLock类实现了ReadWriteLock接口，支持多个线程同时进行读操作。 模拟窗口买票，同一时间只能有一个窗口售卖，允许多个窗口查看： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(() -&gt; &#123;ticket.show();&#125;, &quot;窗口1&quot;).start(); new Thread(() -&gt; &#123;ticket.show();&#125;, &quot;窗口2&quot;).start(); new Thread(() -&gt; &#123;ticket.show();&#125;, &quot;窗口3&quot;).start(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;窗口4&quot;).start(); &#125;&#125;class Ticket &#123; ReadWriteLock lock = new ReentrantReadWriteLock(); private int num = 5; public void show() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.readLock().lock(); try &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; show &quot; + num); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.readLock().unlock(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot; end&quot;); &#125; public void sale() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.writeLock().lock(); try &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot; end&quot;); &#125;&#125; 结果： log123456789101112131415161718192021222324窗口2 show 5窗口3 show 5窗口1 show 5窗口4 sale 5窗口2 show 4窗口3 show 4窗口1 show 4窗口4 sale 4窗口2 show 3窗口1 show 3窗口3 show 3窗口4 sale 3窗口1 show 2窗口3 show 2窗口4 sale 2窗口2 show 1窗口1 show 1窗口2 show 1窗口3 show 1窗口4 sale 1窗口4 end窗口1 end窗口2 end窗口3 end 从运行的结果来看，最多有三个线程在同时读，提高了读操作的效率。 线程占用读写锁的规则： 当前线程占用读锁后，当前线程占用写锁需要等待，其他线程占用读锁无需等待，其他线程占用写锁需要等待。 当前线程占用写锁后，当前线程占用读锁无需等待，其他线程占用读锁和写锁需要等待。 对于当前线程来说，写锁可以降级为读锁，但是读锁不能升级为写锁。 写锁可以降级为读锁，程序可以正常执行： java12345678910111213141516171819public static void main(String[] args) &#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock(); ReentrantReadWriteLock.ReadLock readLock = lock.readLock(); // 锁降级 try &#123; writeLock.lock(); System.out.println(&quot;获取写锁&quot;); readLock.lock(); System.out.println(&quot;获取读锁&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; writeLock.unlock(); System.out.println(&quot;释放写锁&quot;); readLock.unlock(); System.out.println(&quot;释放读锁&quot;); &#125;&#125; 读锁不能升级为写锁，程序会等待获取写锁： java12345678910111213141516171819public static void main(String[] args) &#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock(); ReentrantReadWriteLock.ReadLock readLock = lock.readLock(); // 锁升级 try &#123; readLock.lock(); System.out.println(&quot;获取读锁&quot;); writeLock.lock(); System.out.println(&quot;获取写锁&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readLock.unlock(); System.out.println(&quot;释放读锁&quot;); writeLock.unlock(); System.out.println(&quot;释放写锁&quot;); &#125;&#125; 3 Condition3.1 简介之前在使用synchronized关键字时，可以使用Object对象的wait()方法和notify()方法进行线程通信。 在使用Lock时，通过newCondition()方法获取Condition对象，可以使用Condition对象的await()方法和signal()方法进行通信，对锁进行更精确的控制。 同一个Lock对象可以获取多个Condition对象，支持多路控制。 常用方法： java1234567891011121314// 使当前线程加入等待队列中并释放当锁，线程可以被唤醒和被中断void await() throws InterruptedException;// 同await()类似，只是该方法不会被中断void awaitUninterruptibly();// 同await()类似，如果在指定时间之内没有被通知或者被中断，该方法会返回falseboolean await(long time, TimeUnit unit) throws InterruptedException;// 当前线程进入等待状态，被通知、中断或者超时之后被唤醒。返回值就是表示剩余的时间，超时返回值是0或者负数long awaitNanos(long nanosTimeout) throws InterruptedException;// 同awaitNanos(long nanosTimeout)类似，只是参数变成了指定日期boolean awaitUntil(Date deadline) throws InterruptedException;// 唤醒一个在等待队列中的线程void signal();// 唤醒所有在等待队列中的线程void signalAll(); 3.2 比较使用方式类似： Condition中的await()方法相当于Object的wait()方法。 Condition中的signal()方法相当于Object的notify()方法。 Condition中的signalAll()相当于Object的notifyAll()方法。 Condition中的方法需要与Lock捆绑使用，Object中的方法需要与synchronized捆绑使用。 使用Condition的优势是能够更加精细的控制多线程的休眠与唤醒，同一个Lock可以创建多个Condition，使用不同的Condition管理不同线程的等待与唤醒，实现对线程的精细控制。 3.3 使用3.3.1 使用synchronized实现两个线程交替打印使用synchronized和Object类的方法实现两个线程交替打印： java1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;线程1&quot;).start(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;线程2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 8; public void sale() &#123; while (num &gt; 0) &#123; synchronized (Ticket.class) &#123; Ticket.class.notify(); if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); &#125; if (num &gt; 0) &#123; try &#123; Ticket.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 结果： log12345678线程1 &gt;&gt;&gt; 8线程2 &gt;&gt;&gt; 7线程1 &gt;&gt;&gt; 6线程2 &gt;&gt;&gt; 5线程1 &gt;&gt;&gt; 4线程2 &gt;&gt;&gt; 3线程1 &gt;&gt;&gt; 2线程2 &gt;&gt;&gt; 1 3.3.2 使用Lock实现两个线程交替打印使用Lock和Condition类的方法实现两个线程交替打印： java1234567891011121314151617181920212223242526272829303132public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;线程1&quot;).start(); new Thread(() -&gt; &#123;ticket.sale();&#125;, &quot;线程2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 8; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void sale() &#123; while (num &gt; 0) &#123; lock.lock(); try &#123; condition.signal(); if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); &#125; if (num &gt; 0) &#123; condition.await(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 结果： log12345678线程1 &gt;&gt;&gt; 8线程2 &gt;&gt;&gt; 7线程1 &gt;&gt;&gt; 6线程2 &gt;&gt;&gt; 5线程1 &gt;&gt;&gt; 4线程2 &gt;&gt;&gt; 3线程1 &gt;&gt;&gt; 2线程2 &gt;&gt;&gt; 1 3.3.3 使用Lock实现三个线程循环打印使用Lock和Condition类的方法实现三个线程按循环打印： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(() -&gt; &#123;ticket.sale1();&#125;, &quot;线程1&quot;).start(); new Thread(() -&gt; &#123;ticket.sale2();&#125;, &quot;线程2&quot;).start(); new Thread(() -&gt; &#123;ticket.sale3();&#125;, &quot;线程3&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 8; Lock lock = new ReentrantLock(); Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); Condition c3 = lock.newCondition(); public void sale1() &#123; lock.lock(); try &#123; while (num &gt; 0) &#123; c2.signal(); System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); c1.await(); if (num &lt;= 0) &#123; c3.signal(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void sale2() &#123; lock.lock(); try &#123; while (num &gt; 0) &#123; c3.signal(); System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); c2.await(); if (num &lt;= 0) &#123; c1.signal(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void sale3() &#123; lock.lock(); try &#123; while (num &gt; 0) &#123; c1.signal(); System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); c3.await(); if (num &lt;= 0) &#123; c2.signal(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 结果： log12345678线程1 &gt;&gt;&gt; 8线程2 &gt;&gt;&gt; 7线程3 &gt;&gt;&gt; 6线程1 &gt;&gt;&gt; 5线程2 &gt;&gt;&gt; 4线程3 &gt;&gt;&gt; 3线程1 &gt;&gt;&gt; 2线程2 &gt;&gt;&gt; 1 3.3.4 使用Lock实现生产者消费者生产者消费者交替执行： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Demo &#123; public static void main(String[] args) &#123; Resource r = new Resource(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; r.product(); &#125; &#125;, &quot;生产者1&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; r.product(); &#125; &#125;, &quot;生产者2&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; r.consume(); &#125; &#125;, &quot;消费者1&quot;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; r.consume(); &#125; &#125;, &quot;消费者2&quot;).start(); &#125;&#125;class Resource &#123; private int count = 0; private Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void product() &#123; lock.lock(); try &#123; while (count != 0) &#123; condition.await(); &#125; count++; System.out.println(Thread.currentThread().getName() + &quot; product ...&quot;); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume() &#123; lock.lock(); try &#123; while (count == 0) &#123; condition.await(); &#125; count--; System.out.println(Thread.currentThread().getName() + &quot; consume ...&quot;); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 结果： log123456789101112生产者1 product ...消费者1 consume ...生产者1 product ...消费者1 consume ...生产者1 product ...消费者1 consume ...生产者2 product ...消费者2 consume ...生产者2 product ...消费者2 consume ...生产者2 product ...消费者2 consume ...","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"使用连接池","slug":"D00-后端/D01-Java/005-数据库/002-使用连接池","date":"2025-07-02T06:17:55.000Z","updated":"2025-08-03T11:32:46.547Z","comments":true,"path":"posts/20250702/141755/","permalink":"https://momashanhe.com/posts/20250702/141755/","excerpt":"摘要：本文学习了如何使用连接池管理连接。","text":"摘要：本文学习了如何使用连接池管理连接。 环境 Windows 10 企业版 LTSC 21H2Java 1.8MySQL 5.7.40 1 背景1.1 现有问题每次操作数据库都要建立连接，并将得到的Connection对象加载到内存中，如果短时间有大量建立连接的操作，会导致占用很多系统资源，甚至会导致服务器崩溃。 每次使用结束都需要手动释放连接，如果忘记释放连接或者程序出现异常未能成功释放，会导致内存泄露。 不能控制连接的数量，如果连接的人数过多，会导致无限制的创建连接对象，导致内存开销过大，服务器崩溃。 1.2 简介连接池就是数据库连接对象的缓冲区，负责创建连接、管理连接、释放连接等操作。 每次需要连接数据库时，不需要建立连接，而是通过连接池获取。 在使用完连接后，不需要手动释放连接，而是交由连接池释放。 可以通过连接池控制连接的数量，在连接池里的连接可多次重复使用，避免了无限制创建连接的问题。 2 选用2.1 使用Druid连接池2.1.1 介绍Druid是阿里巴巴开发的一个高性能、可扩展、可监控的开源JDBC连接池。 2.1.2 使用下载Jar包： Maven仓库地址 将下载的druid-1.2.20.jar文件复制到lib目录。 配置文件内容： jdbc.properties123456789driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8username=rootpassword=123456# 初始化连接数initialSize=10# 最大连接数maxActive=20 示例： java1234567891011121314151617181920212223242526// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 创建连接池 DataSource dataSource = DruidDataSourceFactory.createDataSource(pros); // 获取连接 Connection conn = dataSource.getConnection(); // 获取预编译执行器 String sql = &quot;select * from user where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 1); // 执行查询，获取结果集 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(&quot;id&quot;) + &quot;-&quot; + rs.getString(2) + &quot;-&quot; + rs.getString(3)); &#125; // 关闭结果集 rs.close(); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 2.2 使用HikariCP连接池2.2.1 介绍HikariCP是一个轻量级、高效的JDBC连接池，具有快速启动和低延迟的特点。 2.2.2 使用下载Jar包： Maven仓库地址 将下载的HikariCP-4.0.3.jar文件复制到lib目录。 因为HikariCP依赖了SLF4J日志，所以还需要下载日志文件并复制到lib目录： slf4j-api-1.7.26.jar logback-classic-1.2.3.jar logback-core-1.2.3.jar 配置文件内容： jdbc.properties123456789driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8username=rootpassword=123456# 最小空闲连接数minimumIdle=10# 最大连接数maximumPoolSize=20 示例： java12345678910111213141516171819202122232425262728// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 创建连接池配置对象 HikariConfig hikariConfig = new HikariConfig(pros); // 创建连接池 HikariDataSource dataSource = new HikariDataSource(hikariConfig); // 获取连接 Connection conn = dataSource.getConnection(); // 获取预编译执行器 String sql = &quot;select * from user where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 1); // 执行查询，获取结果集 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(&quot;id&quot;) + &quot;-&quot; + rs.getString(2) + &quot;-&quot; + rs.getString(3)); &#125; // 关闭结果集 rs.close(); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://momashanhe.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"连接数据库","slug":"D00-后端/D01-Java/005-数据库/001-连接数据库","date":"2025-07-01T00:59:02.000Z","updated":"2025-08-03T11:32:46.447Z","comments":true,"path":"posts/20250701/085902/","permalink":"https://momashanhe.com/posts/20250701/085902/","excerpt":"摘要：本文学习了如何使用JDBC连接数据库。","text":"摘要：本文学习了如何使用JDBC连接数据库。 环境 Windows 10 企业版 LTSC 21H2Java 1.8MySQL 5.7.40 1 持久化数据持久化就是把数据保存到可掉电式存储设备中以供之后使用，大多数情况下，数据持久化意味着将内存中的数据保存到硬盘上进行存储。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件中，比如XML文件和Excel文件等等。 持久化的实现主要有两种： 通过IO流技术将数据存储在本地磁盘，优点是比较简单，缺点是不方便管理和维护。 通过各种数据库将数据存储在关系型数据库，优点是方便管理和维护，缺点是需要学习相关的方法。 2 简介2.1 概念JDBC的全称是Java Database Connectivity，意为Java和数据库的连接，其定义了用来访问数据库的标准Java类库，使用这个类库可以更加方便地访问数据库资源。 在最开始的时候，程序员使用数据库需要安装数据库驱动，不同厂商的数据库有其各自的驱动程序。 为了方便开发，Sun公司提供了JDBC接口，让数据库厂商实现JDBC接口，程序员通过JDBC接口就可以操作不同的数据库，不需要关注底层数据库驱动的安装，从而大大简化和加快了开发过程。 2.2 架构JDBC接口包括两个层次： JDBC API：即面向应用的API，这是一个抽象的接口，用于给程序员使用，提供了程序到JDBC管理器的连接。 JDBC Driver API：即面向数据库驱动的API，数据库厂商需要实现这个接口，提供了JDBC管理器到数据库驱动程序的连接。 架构图： 2.3 规范JDBC相关的接口在java.sql包下。 主要有四个核心对象： DriverManager类：用于加载驱动，创建连接对象。 Connection接口：表示与数据库创建的连接。 Statement接口：执行数据库SQL语句，并返回相应结果的对象。 ResultSet接口：结果集或一张虚拟表，用于存储表数据的对象。 其中，Statement接口还有两个子接口： PreparedStatement接口：预编译对象，是Statement接口的子接口，用于解决SQL注入问题。 CallableStatement接口：支持带参数的SQL操作，支持调用存储过程，是PreparedStatement接口的子接口。 3 建立连接下面的说明以连接MySQL数据库为例。 3.1 准备工作安装MySQL数据库，保证配置文件包含如下配置： my.ini123456[mysql]# 客户端默认字符集default-character-set=utf8mb4[client]# 客户端连接服务端时默认字符集default-character-set=utf8mb4 创建数据库，字符集和配置文件保持一致： sql1CREATE DATABASE `test` CHARACTER SET &#x27;utf8mb4&#x27; COLLATE &#x27;utf8mb4_general_ci&#x27;; 创建数据表并插入数据，字符集和配置文件保持一致： sql123456789CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `username` varchar(255) COMMENT &#x27;用户名称&#x27;, `password` varchar(255) COMMENT &#x27;用户密码&#x27;, `create_time` datetime COMMENT &#x27;创建时间&#x27;, `update_time` datetime COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB COMMENT = &#x27;用户表&#x27;;INSERT INTO `user` VALUES (1, &#x27;张三&#x27;, &#x27;123456&#x27;, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;); 使用IDEA创建Java项目，然后在File | Settings | Editor | File Encodings里修改编码： 在Java项目中创建src目录，在src目录创建JDBCTest类，在类中创建main()方法。 3.2 导入Jar包下载用于连接数据库的驱动Jar包，下载地址： 官网下载地址 Maven仓库地址 本地安装的数据库是5.7.40版本，对应下载5.1.49版本的驱动Jar包即可，将下载后的文件解压，目录中的mysql-connector-java-5.1.49.jar文件就是所需的驱动Jar包。 创建lib目录，需要先将下载的mysql-connector-java-5.1.49.jar文件复制到lib目录，然后才能在lib目录右键找到Add as Library...选项，将lib目录设置为Project Library并保存。 3.3 编写代码示例： java123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // 加载驱动 try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 建立连接 String url = &quot;jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, password); // 执行增删改查操作 // ... &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 释放连接 conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 步骤： 加载驱动，使用数据库对应的驱动名称注册驱动。 建立连接，通过用户名和密码以及URL协议连接数据库。 执行增删改查，获取查询的结果集和增删改的更新记录数。 释放连接，主动关闭连接资源，避免内存泄漏。 3.4 配置文件如果不想将配置文件写在代码中，可以在src目录下创建jdbc.properties配置文件： jdbc.properties1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8user=rootpassword=123456 通过配置文件建立连接： java12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; // 读取配置文件 Properties pros = new Properties(); try &#123; pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; // 加载驱动 try &#123; Class.forName(pros.getProperty(&quot;driverClass&quot;)); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 建立连接 Connection conn = null; String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); try &#123; conn = DriverManager.getConnection(url, user, password); // 执行增删改查操作 // ... &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 释放连接 conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4 核心接口4.1 加载驱动加载驱动程序的目的是为了注册驱动程序，使得JDBC能够识别并与特定的数据库进行交互。 在加载驱动时，不同数据库对应不同驱动名称： MySQL驱动：com.mysql.jdbc.Drive Oracle驱动：oracle.jdbc.driver.OracleDriver SQLServer驱动：com.microsoft.sqlserver.jdbc.SQLServerDriver PostgreSQL驱动：org.postgresql.Driver DB2驱动：com.ibm.db2.jdbc.net.DB2Driver Sybase驱动：com.sybase.jdbc.SybDriver 从1.6开始，不再需要显式地调用加载驱动，只要在类路径中集成了数据库对应的Jar文件，程序会自动在初始化时注册驱动程序。 4.2 建立连接Connection接口是JDBC的重要接口，用于建立与数据库的通信通道。 在建立连接时，不同的数据库对应不同URL协议： MySQL格式：jdbc:mysql:&#x2F;&#x2F;地址或主机名:端口号&#x2F;数据库名 Oracle格式：jdbc:oracle:thin:@地址或主机名:端口号:数据库名 SQLServer格式：jdbc:sqlserver:&#x2F;&#x2F;地址或主机名:端口号;databaseName&#x3D;数据库名 PostgreSQL格式：jdbc:postgresql:&#x2F;&#x2F;地址或主机名:端口号&#x2F;数据库名 DB2格式：jdbc:db2:地址或主机名:端口号&#x2F;数据库名 Sybase格式：jdbc:sybase:Tds:地址或主机名:端口号&#x2F;数据库名 连接MySQL数据库： 在使用5.x版本的数据库时，需要在URL协议后追加useSSL=false配置，否则会报错。 在URL协议后追加serverTimezone=GMT%2B8配置将时区设置为东八区，保证时间与当前时间一致。 Connection接口的作用： 数据库交互，Connection接口可以创建Statement对象或者PreparedStatement对象，用于执行SQL语句。 管理事务，Connection接口提供了commit()方法和rollback()方法，用于提交事务和回滚事务。 在连接使用完毕后，需要手动释放资源和关闭连接，避免资源占用导致内存泄漏。 4.3 执行SQL语句4.3.1 说明Statement接口用于执行SQL语句并获取执行结果。 获取的结果可以是一个或多个： 查询：返回的是ResultSet结果集。 增删改：返回的是受影响的行数。 使用后需要手动关闭。 4.3.2 增删改查执行增删改查示例： java12345678910111213141516171819202122232425262728293031323334// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取执行器 Statement st = conn.createStatement(); // 执行新增 int insert = st.executeUpdate(&quot;insert into user values (2, &#x27;李四&#x27;, &#x27;123456&#x27;, now(), now())&quot;); System.out.println(&quot;insert=&quot; + insert); // 执行修改 int update = st.executeUpdate(&quot;update user set password = &#x27;666666&#x27; where id = 2&quot;); System.out.println(&quot;update=&quot; + update); // 执行删除 int delete = st.executeUpdate(&quot;delete from user where id = 2&quot;); System.out.println(&quot;delete=&quot; + delete); // 执行查询，获取结果集 ResultSet rs = st.executeQuery(&quot;select * from user where id = 1&quot;); while (rs.next()) &#123; System.out.println(rs.getInt(&quot;id&quot;) + &quot;-&quot; + rs.getString(2) + &quot;-&quot; + rs.getString(3)); &#125; // 关闭结果集 rs.close(); // 关闭执行器 st.close(); // 释放连接 conn.close();&#125; 4.3.3 理解SQL注入问题正常情况下，如果用户名和密码输入错误，会查不到数据，返回密码错误。 假设输入的密码为123456，拼接后的SQL示例： sql1select * from user where username = &#x27;张三&#x27; and password = &#x27;123456&#x27; 在恶意登录的场景下，可以通过SQL注入规避验证用户名和密码的逻辑，保证始终都能查到数据，不会返回密码错误。 假设输入的密码为张三&#39; or &#39;1&#39; = &#39;1，拼接后的SQL示例： sql1select * from user where username = &#x27;张三&#x27; and password = &#x27;张三&#x27; or &#x27;1&#x27; = &#x27;1&#x27; 4.4 执行预编译SQL语句4.4.1 说明PreparedStatement是Statement接口的子接口，用于执行预编译的SQL查询，作用如下： 预编译SQL语句：在创建PreparedStatement时，会根据模板预编译SQL语句，后续只能填充参数，不能拼接。 防止SQL注入：在使用PreparedStatement时，会通过?占位符将传入的参数使用单引号包裹起来，有效防止SQL注入问题。 性能提升：预编译SQL语句在多次执行的情况下可以复用，不必每次重新编译和解析。 使用后需要手动关闭。 4.4.2 增删改查使用参数新增示例： java12345678910111213141516171819202122232425// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取预编译执行器 String sql = &quot;insert into user values (null, ?, ?, now(), now())&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setString(1, &quot;李四&quot;); ps.setString(2, &quot;123456&quot;); // 执行新增 int insert = ps.executeUpdate(); System.out.println(&quot;insert=&quot; + insert); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 使用参数新增并返回自增主键示例： java1234567891011121314151617181920212223242526272829303132// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取预编译执行器，设置需要获取自增主键 String sql = &quot;insert into user values (null, ?, ?, now(), now())&quot;; PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); // 设置参数 ps.setString(1, &quot;李四&quot;); ps.setString(2, &quot;123456&quot;); // 执行新增 int insert = ps.executeUpdate(); System.out.println(&quot;insert=&quot; + insert); // 获取主键结果集 ResultSet rs = ps.getGeneratedKeys(); while (rs.next()) &#123; System.out.println(&quot;id=&quot; + rs.getInt(1)); &#125; // 关闭结果集 rs.close(); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 使用参数修改示例： java12345678910111213141516171819202122232425// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取预编译执行器 String sql = &quot;update user set password = ? where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setString(1, &quot;666666&quot;); ps.setInt(2, 2); // 执行修改 int update = ps.executeUpdate(); System.out.println(&quot;update=&quot; + update); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 使用参数删除示例： java123456789101112131415161718192021222324// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取预编译执行器 String sql = &quot;delete from user where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 2); // 执行删除 int delete = ps.executeUpdate(); System.out.println(&quot;delete=&quot; + delete); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 使用参数查询示例： java12345678910111213141516171819202122232425262728// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 获取预编译执行器 String sql = &quot;select * from user where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setInt(1, 1); // 执行查询，获取结果集 ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(&quot;id&quot;) + &quot;-&quot; + rs.getString(2) + &quot;-&quot; + rs.getString(3)); &#125; // 关闭结果集 rs.close(); // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125; 4.4.3 解决SQL注入问题假设输入的密码为张三&#39; or &#39;1&#39; = &#39;1，经过预编译后的SQL示例： sql1select * from user where username = &#x27;张三&#x27; and password = &#x27;张三\\&#x27; or \\&#x27;1\\&#x27; = \\&#x27;1&#x27; 在替换参数前会自动对单引号进行转义，从而解决SQL注入的问题。 4.5 获取结果集ResultSet接口用于表示从数据库中执行查询语句所返回的结果集。 使用后需要手动关闭。 5 使用事务5.1 基础知识事务有四种特性： 原子性（Atomicity）：指事务包含的所有操作要么全部成功提交，要么全部失败回滚。 一致性（Consistency）：指事务必须使数据库的数据和资源从一个一致性状态变换到另一个一致性状态。 隔离性（Isolation）：指当多个用户并发访问数据库并且操作同一张表时，数据库为每一个用户开启事务，不会被其他事务的操作干扰，多个并发事务之间相互隔离。 持久性（Durability）：指一个事务一旦被提交了，对数据的改变就是永久性的，哪怕数据库遇到故障也不会丢失提交的改动。 涉及事务的几个术语： 保存点（Savepoint）：指在事务执行前或者事务执行后，数据在数据库里的存储情况，有时也称为状态。 回退（Rollback）：指撤销事务的操作，事务期间执行的操作都将失效，事务恢复到上个状态。 提交（Commit）：指提交事务的操作，事务期间执行的操作全部生效，事务进入新的状态。 5.2 操作事务常用方法： java1234567891011121314151617181920// 查询事务隔离级别int getTransactionIsolation();// 设置事务隔离级别void setTransactionIsolation(int level);// 查询自动提交状态boolean getAutoCommit();// 设置自动提交状态void setAutoCommit(boolean autoCommit);// 创建还原点Savepoint setSavepoint();// 创建指定名称的还原点Savepoint setSavepoint(String name);// 删除指定名称的还原点void releaseSavepoint(Savepoint savepoint);// 提交void commit();// 回滚void rollback();// 回滚到指定名称的还原点void rollback(Savepoint savepoint); 示例： java12345678910111213141516171819202122232425262728293031323334// 为了代码阅读简洁，直接抛出异常public static void main(String[] args) throws Exception &#123; // 读取配置文件 Properties pros = new Properties(); pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); // 加载驱动，可以省略 // 建立连接 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); Connection conn = DriverManager.getConnection(url, user, password); // 取消自动提交 conn.setAutoCommit(false); // 获取预编译执行器 String sql = &quot;update user set password = ? where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 设置参数 ps.setString(1, &quot;666666&quot;); ps.setInt(2, 2); // 执行修改 int update = ps.executeUpdate(); System.out.println(&quot;update=&quot; + update); if (update == 1) &#123; // 提交事务 conn.commit(); &#125; else &#123; // 回滚事务 conn.rollback(); &#125; // 关闭执行器 ps.close(); // 释放连接 conn.close();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://momashanhe.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"备份和还原","slug":"E00-数据库/E02-MySQL/002-高级/009-备份和还原","date":"2025-06-21T07:04:30.000Z","updated":"2025-06-22T09:13:24.857Z","comments":true,"path":"posts/20250621/150430/","permalink":"https://momashanhe.com/posts/20250621/150430/","excerpt":"摘要：本文学习了数据库的备份和还原。","text":"摘要：本文学习了数据库的备份和还原。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 分类按备份类型可以分为两种： 完全备份：完全备份指的是备份整个数据集，即整个数据库。 部分备份：部分备份指的是备份部分数据集，支持指定表。部分备份可以细分两种： 增量备份：增量备份指的是备份自上一次增量备份或完全备份以来变化的数据。其特点是节约空间，但是还原麻烦。 差异备份：差异备份指的是备份自上一次完全备份以来变化的数据。其特点是浪费空间，但是还原比增量备份简单。 按备份方式可以分为三种： 热备份：热备份指的是当数据库进行备份时，数据库的读写操作均不是受影响。MyISAM引擎不支持，InnoDB引擎支持。 温备份：温备份指的是当数据库进行备份时，数据库的读操作可以执行，但是不能执行写操作。MyISAM引擎和InnoDB引擎都支持。 冷备份：冷备份指的是当数据库进行备份时，数据库不能进行读写操作，即数据库要下线。MyISAM引擎和InnoDB引擎都支持。 2 策略针对不同的场景，应该制定不同的备份策略： 使用cp命令或者tar命令复制数据库文件，适用于数据量较小的环境。 使用mysqldump命令和二进制日志文件备份，适用于数据量一般的环境。 使用lvm2快照和二进制日志文件备份，适用于数据量较大的环境。 使用xtrabackup工具进行备份，适用于数据量很大的环境。 3 使用mysqldump命令3.1 导出使用mysqldump命令导出全部数据库： bash1mysqldump [连接选项] [导出选项] 连接选项： –user, -u：用户名。登录数据库的用户名，当前用户可省略该配置。 –password, -p：密码。登录数据库的密码。 –host, -h：主机地址。设置数据库所在的主机地址。 –port, -P：端口号。设置用于连接的端口号。 –protocol：连接协议。设置使用的连接协议，取值有TCP、SOCKET、PIPE、MEMORY四种。 导出选项： –all-databases, -A：导出全部数据库。不指定数据库，导出所有数据库。 –databases, -B：导出指定数据库。导出指定的数据库。 –tables：导出指定表。只能针对一个数据库进行导出，并且导出的内容中没有创建数据库的判断语句。 –ignore-table：不导出指定表。指定忽略多个表时，需要重复多次，每个表都要指定数据库和表名。 –no-create-db：不添加创建数据库语句。默认添加。 –add-drop-database：添加删除数据库语句。默认不添加。 –no-create-info：不添加创建表语句。默认添加。 –skip-add-drop-table：不添加删除表语句。默认添加。 –skip-extended-insert：不合并多个插入语句，一个插入语句插入一行数据。默认开启。 –no-data：不导出数据只导出表结构。 –default-character-set：设置默认的字符集。默认是utf8。 –where：只导出符合指定条件的记录。如果条件包含命令解释符专用空格或字符，将条件引用起来。 –complete-insert：使用包含列名称的完整插入语句。默认不使用列名插入。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。 –max_allowed_packet：服务器发送和接受的最大包长度。通信的缓存区最大为1GB。 –insert-ignore：忽略插入错误。在插入语句中添加忽略错误语句，默认不添加。 –force, -f：强制插入。在表转储过程中，即使出现SQL错误也继续。 导出全部数据库： bash1mysqldump -u root -p --all-databases &gt; db_back.sql 导出指定数据库： bash1mysqldump -u root -p --databases test demo &gt; db_back.sql 导出指定表： bash1mysqldump -u root -p --databases test --tables user bill &gt; db_back.sql 不导出指定表： bash1mysqldump -u root -p --databases test --ignore-table=test.user &gt; db_back.sql 设置默认字符集： bash1mysqldump -u root -p --all-databases --default-character-set=utf8mb4 &gt; db_back.sql 使用完整的插入语句： bash1mysqldump -u root -p --all-databases --complete-insert 3.2 导入导入数据有两种方式，一种是在Linux系统使用&lt;命令导入，另一种是在MySQL数据库使用source命令导入。 3.2.1 在Linux系统导入语法： bash1mysql [连接选项] 数据库名 &lt; 文件位置 示例： bash1mysql -u root -p test &lt; db_back.sql 3.2.2 在MySQL数据库导入语法： sql1source 文件位置 示例： sql1source /home/db_back.sql","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"多版本并发控制","slug":"E00-数据库/E02-MySQL/002-高级/008-多版本并发控制","date":"2025-06-20T01:16:32.000Z","updated":"2025-07-01T01:22:37.595Z","comments":true,"path":"posts/20250620/091632/","permalink":"https://momashanhe.com/posts/20250620/091632/","excerpt":"摘要：本文学习了InnoBD存储引擎独有的多版本并发控制机制。","text":"摘要：本文学习了InnoBD存储引擎独有的多版本并发控制机制。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 简介1.1 说明在使用锁机制的情况下，只有读读支持并发，读写、写读、写写都会被阻塞，虽然解决了并发问题，但会导致性能严重下降。 为了在解决并发问题的同时兼顾数据库的性能，引入了MVCC机制，在不使用锁机制的情况下，也能解决读写和写读的并发问题。 MVCC机制的全称为Multi-Version Concurrency Control，即多版本并发控制，主要是为了提升数据库的并发性能，使用比锁机制更好的方式解决了读写和写读的并发问题，从而确保了任何时刻的读操作都是非阻塞的。 在MySQL数据库中只有InnoDB引擎实现了MVCC机制。 1.2 作用在RC读已提交中，MVCC机制解决了写读的并发问题，即解决了脏读的问题。 在RR可重复读中，MVCC机制解决了读写的并发问题，即解决了不可重复读的问题。 2 原理2.1 说明在InnoDB引擎中，MVCC机制的实现主要靠表中的三个隐藏字段，以及Undo日志和Read视图实现的。 当前事务在执行查询语句时，会生成Read视图，根据Read视图判断查询当前表还是查询Undo日志，不同的事务生成不同的Read视图，可能查询当前表也可能查询Undo日志。 快照读和当前读： 把通过Undo日志进行的查询操作称为快照读，无锁的查询操作有可能会执行快照读。 把通过当前表进行的查询操作称为当前读，有锁的操作都会执行当前读。 2.2 概念2.2.1 隐藏字段在创建表时，除了创建显示定义的字段，还会默认创建隐藏字段： trx_id：事务ID，记录最近修改和插入这条记录的事务ID，事务ID遵循递增机制。 roll_pointer：回滚指针，记录最近修改这条记录的上一版本，通过这个字段可以在Undo日志中找到最近的历史版本。 row_id：隐藏主键，如果数据表没有主键，InnoDB会在这个字段创建聚簇索引。 deleted_bit：删除标识，删除时将其标记为删除，事务提交后会有线程将标记为删除的数据彻底删除，事务回滚后恢复原值，避免频繁修改索引树的结构。 2.2.2 Undo日志Undo日志可以看做一个版本链，用于保存修改和插入的历史版本，节点可以看做表中记录的拷贝，通过roll_pointer字段行成链式结构。 在执行快照读时，会根据roll_pointer遍历版本链，直到找到符合要求的历史版本。 2.2.3 Read视图在执行查询操作时，MVCC会生成一个Read视图，可以看做一个事务快照，当前系统中活跃的事务对应的Read视图组成一个快照列表。 因为事务ID是按先后顺序生成的，所以比较要查询的记录的trx_id字段上的事务ID和Read视图列表中的事务ID即可判断数据的来源： 如果trx_id小于Read视图列表的最小值，说明最近更新这条记录的事务发生在过去已提交，执行当前读。 如果trx_id在Read视图列表范围中，需要进一步判断： 如果在Read视图列表中能找到trx_id则表示事务未提交，执行快照读。 如果在Read视图列表中找不到trx_id则表示事务已提交，执行当前读。 如果trx_id大于Read视图列表的最小值，说明最近更新这条记录的事务发生在未来未提交，执行快照读。 2.3 分析2.3.1 查询操作执行查询操作时，生成Read视图，对比数据行上的trx_id字段，进行当前读或者快照读。 在快照读时，如果找到的历史版本的删除标志字段不为空，并且删除事务已提交，说明记录已被删除，不需要返回数据。 对于RC读已提交，同一个事务中的每次查询都会创建Read视图，解决更新时读取产生的脏读的问题，不能解决读取时更新产生的不可重复读的问题。 对于RR可重复读，同一个事务中只有第一次查询会创建Read视图，以后的查询都会使用已有的Read视图，解决读取时更新产生的不可重复读的问题。 2.3.2 插入操作复制新纪录到Undo日志，当事务提交时删除此条Undo日志，当事务回滚时反向操作然后删除和事务有关的Undo日志。 插入记录，trx_id字段保存当前事务ID，roll_pointer字段为空。 2.3.3 修改操作复制原记录到Undo日志。 修改记录，trx_id字段保存当前事务ID，roll_pointer字段保存Undo日志。 2.3.4 删除操作复制原记录到Undo日志。 修改记录，trx_id字段保存当前事务ID，roll_pointer字段保存Undo日志，删除标志设为true。 2.4 总结当一个事务尝试修改数据时，会将旧数据放入Undo日志中，用于实现多版本控制。 当一个事务尝试查询数据时，会创建Read视图，用于查看历史数据。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"},{"name":"MVCC","slug":"MVCC","permalink":"https://momashanhe.com/tags/MVCC/"}]},{"title":"锁机制","slug":"E00-数据库/E02-MySQL/002-高级/007-锁机制","date":"2025-06-17T03:32:10.000Z","updated":"2025-06-29T14:59:22.434Z","comments":true,"path":"posts/20250617/113210/","permalink":"https://momashanhe.com/posts/20250617/113210/","excerpt":"摘要：本文学习了数据库常见的锁。","text":"摘要：本文学习了数据库常见的锁。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 简介1.1 概述数据库中的锁是为了在并发场景下保证一致性而设计的规则。 不同的存储引擎支持不同的锁机制，InnoDB支持行锁和表锁，MyISAM支持表锁。 1.2 说明1.2.1 共享锁和排他锁按锁的互斥程度来分，可以分为共享锁和排他锁。 1.2.1.1 共享锁共享锁（Share Locks），记为S锁，InnoDB和MyISAM都有，MyISAM只能加在表上，InnoDB可以加在表上和行上。 共享锁也称为读锁，多个读操作可以同时进行，其他写操作会被阻断。 1.2.1.2 排他锁排他锁（Exclusive Locks），记为X锁，InnoDB和MyISAM都有，MyISAM只能加在表上，InnoDB可以加在表上和行上。 排他锁也称为写锁，其他读操作和写操作会被阻断。 1.2.2 表锁和行锁按锁的粒度来分，可以分为表锁和行锁。 1.2.2.1 表锁表锁是粒度最大的锁，表示当前操作对整张表加锁，资源开销小，不会出现死锁，锁冲突概率大。InnoDB和MyISAM都支持。 MyISAM在执行查询语句前，会给涉及的表加读锁，在执行增删改操作前，会给涉及的表加写锁。 InnoDB存储引擎不会为表添加表级别的读锁或者写锁。在对表进行DDL操作时其他事务对表的增删改查操作会被阻塞，在对表进行增删改查操作时，其他事务对表进行DDL操作也会被阻塞，这个过程其实是通过在Server层使用一种称之为元数据锁（Meta Data Locks，简称MDL锁）结构来实现的。 1.2.2.2 行锁行锁是粒度最小的锁，表示当前操作对操作的行加锁，资源开销大，会出现死锁，锁冲突概率小。只有InnoDB支持。 1.3 优先级当锁被释放时，优先执行写锁队列中的请求，写锁队列为空时，执行读锁队列中的请求。 所以，如果有大量更新操作，可能会导致查询操作很难获得锁，从而长久阻塞，使程序响应超时。 2 使用2.1 表锁2.1.1 逻辑当前线程给当前表加S锁，当前线程只能读取当前表，当前线程更新当前表失败，当前线程查询其他表失败，其他线程只能读取当前表，其他线程更新当前表阻塞。 当前线程给当前表加X锁，当前线程可以读取和更新当前表，当前线程查询其他表失败，其他线程读取当前表阻塞。 2.1.2 操作查看表上的锁： sql1show open tables where in_use &gt; 0; 在执行查询语句时会自动给表加读锁，也可以显示加锁： sql1lock tables 表名 read; 在执行更新语句时会自动给表加写锁，也可以显示加锁： sql1lock tables 表名 write; 释放锁： sql1unlock tables; 2.2 意向锁2.2.1 说明InnoDB为了支持多粒度锁机制，即为了支持表锁和行锁共存，引入了意向锁（Intention Locks）。 意向锁属于表级锁，主要是为了处理行锁和表锁之间的冲突，事务在请求读锁和写锁之前，需要先获得对应的意向共享锁和意向排他锁。 使用意向锁提高了在多粒度锁并存时判断某行数据是否存在行锁的性能： 在没有使用意向锁的情况下，线程直接使用行锁后，其他线程在使用表锁前，需要判断每行数据是否有行锁。 在使用意向锁的情况下，线程在使用行锁前需要先给表加IS锁或IX锁，其他线程在使用表锁前，只需要判断IS锁和IX锁即可，不需要判断每行数据。 意向锁分为IS锁和IX锁： 意向共享锁（Intention Share Locks），记为IS锁，表示事务有意向对表中的某行加共享S锁。 意向排他锁（Intention Exclusive Lock），记为IX锁，表示事务有意向对表中的某行加排他X锁。 2.2.2 逻辑当前线程加IS锁并且给当前行加行锁，其他线程可以加IS锁并且给当前行加行锁，其他线程可以加IX锁并且给其他行加行锁，其他线程可以加S锁，其他线程不能加X锁。 当前线程加IX锁并且给当前行加行锁，其他线程可以加IS锁并且给当前行加行锁，其他线程可以加IX锁并且给其他行加行锁，其他线程不能加S锁，其他线程不能加X锁。 2.2.3 操作查询时加意向共享锁： sql1select * from 表名 lock in share mode; 查询时加意向排他锁： sql1select * from 表名 for update; 2.2.4 注意InnoDB行锁是针对索引加的意向锁，不是针对记录加的意向锁。 意向锁在某些情况下不会加行锁： 查询语句没有使用索引，此时会使用表锁。 查询语句使用范围条件导致索引失效，此时会使用表锁。 查询语句使用索引但没有查到数据，此时不会使用任何锁。 2.3 元数据锁2.3.1 说明元数据锁（Meta Data Lock，简称MDL锁），表锁，在5.5版本后引入，目的是为了保证读写的正确性。 2.3.2 逻辑当前线程对表做增删改查操作时加MDL读锁 当前线程对表做结构变更操作时加MDL写锁。 2.4 自增锁2.4.1 说明自增锁（Auto-inc Locks），表锁，特殊的表锁，发生在AUTO_INCREMENT主键自增的列。 2.4.2 逻辑多事务同时插入时会阻塞，保证主键的连续。 2.5 记录锁2.5.1 说明记录锁（Record Locks），行锁，索引记录锁，建立在索引记录上的锁，为某行记录加锁，索引基于唯一索引（包括主键索引）。 2.5.2 逻辑当前线程给当前行加S锁后，其他事务也可以对当前行加S锁，但不可以对当前行加X锁。 当前线程给当前行加X锁后，其他事务不可以对当前行加S锁，也不可以对当前行加X锁。 2.5.3 操作查询时加共享记录锁： sql1select * from 表名 where id = 1 lock in share mode; 查询时加排他记录锁： sql1select * from 表名 where id = 1 for update; 2.6 间隙锁2.6.1 说明间隙锁（Gap Locks），行锁，索引区间锁，建立在索引区间上的锁，为某个开区间加锁，开区间不包括端点。 使用间隙锁可以防止幻读，保证索引区间上的数据不会被更改，只在默认RR可重复读级别有效，降级后自动失效。 2.6.2 操作查询时加共享间隙锁： sql1select * from 表名 where id &gt; 1 lock in share mode; 查询时加排他间隙锁： sql1select * from 表名 where id &gt; 1 for update; 2.7 临键锁2.7.1 说明临键锁（Next-key Locks），行锁，记录锁和间隙锁的组合，索引区间是一个开区间，索引基于非唯一索引。临键锁是InnoDB默认的锁。 每个数据行都可以看做一个记录锁，数据行上下相邻两边的间隙可以看做两个间隙锁。使用临建锁也可以防止幻读，保证索引区间上的数据不会被更改，也只在默认RR可重复读级别有效。 2.7.2 逻辑临键锁在使用唯一索引的不同场景中会变化： 使用唯一索引，使用精确匹配，记录存在，变化为记录锁。 使用唯一索引，使用精确匹配，记录不存在，变化为间隙锁。 使用唯一索引，使用范围匹配，变化为临键锁，左开右闭。 没有使用索引，变化为表锁。 2.8 插入意向锁2.8.1 说明插入意向锁（Insert Intention Locks），行锁，特殊的间隙锁。 多个事务同时在同一个间隙中插入记录时，获取各自的插入意向锁，不同行的插入不会冲突。 2.8.2 逻辑插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。 3 死锁3.1 说明死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。 3.2 解决3.2.1 等待超时当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。 可以通过如下命令查询阈值： sql123456789mysql&gt; show variables like &#x27;innodb_lock_wait_timeout&#x27;;+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| innodb_lock_wait_timeout | 50 |+--------------------------+-------+1 row in set (0.00 sec)mysql&gt; 默认情况下，超过50秒未获取到锁的事务，会自动回滚并返回错误，同时会释放自己占有的锁资源。 在高并发场景中，等待50秒的时间太长了，会导致越来越多的事务阻塞。但是如果将等待阈值设置的过小，会导致正常等待锁资源但未发生死锁的事务超时报错。 3.2.2 死锁检测因为等待超时具有缺陷，因此InnoDB提供了一种死锁检测机制，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 死锁检测机制被启用后，会收集两个信息： 锁的信息链表：目前持有每个锁的事务。 事务等待链表：阻塞的事务要等待的锁。 死锁检测流程： 每当一个事务需要阻塞等待某个锁时，就会触发一次死锁检测算法，该算法会以当前事务作为起点，然后从锁的信息链表中找到持有目标锁的事务。 根据持有目标锁的事务，在事务等待链表中查找，看看这个事务是否在等待获取其他锁。 如果这个事务还在等待获取其他锁，则根据锁的信息链表找到持有其他锁的事务。 根据持有其他锁的事务，在事务等待链表中查找，看看这个事务是否在等待获取其他锁。 经过一系列的判断后，判断是否出现闭环，出现的话则证明出现了死锁现象，然后强制回滚其中的一个事务，来达到解除死锁的目的。 在选择事务回滚时，会根据回滚日志找到回滚量最小的事务进行回滚。 可以通过命令查看是否开启死锁检测机制： sql123456789mysql&gt; show variables like &#x27;innodb_deadlock_detect&#x27;;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| innodb_deadlock_detect | ON |+------------------------+-------+1 row in set (0.01 sec)mysql&gt; 虽然死锁检测机制能够更合理的解决死锁问题，但实际上死锁检测的开销不小，当阻塞的并发事务越来越多时，检测的效率会呈线性增长。 3.3 监控使用命令监控数据库中锁的等待信息： sql12345678910111213mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 0 || Innodb_row_lock_time_avg | 0 || Innodb_row_lock_time_max | 0 || Innodb_row_lock_waits | 0 |+-------------------------------+-------+5 rows in set (0.00 sec)mysql&gt; 说明： Innodb_row_lock_current_waits：当前正在等待锁的个数。 Innodb_row_lock_time：从系统启动到现在等待锁的总时长。 Innodb_row_lock_time_avg：从系统启动到现在等待锁的平均时长。 Innodb_row_lock_time_max：从系统启动到现在等待锁的最久时长。 Innodb_row_lock_waits：从系统启动到现在等待锁的总个数。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"主从复制","slug":"E00-数据库/E02-MySQL/002-高级/006-主从复制","date":"2025-06-14T13:53:37.000Z","updated":"2025-06-21T18:17:46.280Z","comments":true,"path":"posts/20250614/215337/","permalink":"https://momashanhe.com/posts/20250614/215337/","excerpt":"摘要：本文学习了数据库的主从复制。","text":"摘要：本文学习了数据库的主从复制。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 简介1.1 背景一般应用对数据库而言都是读多写少，想要提升数据库的并发能力： 首先考虑的是如何优化SQL和索引，这种方式简单有效。 其次采用缓存的策略，比如将热点数据保存在类似Redis的内存数据库中，提升读取的效率。 最后采用数据库集群的方案，配置主从架构，进行读写分离，这样同样可以提升数据库的并发处理能力。 并不是所有的应用都需要对数据库配置主从架构，毕竟设置架构本身是有成本的。 1.2 作用主从复制主要有三种作用： 读写分离：将数据库的读写操作分配到不同的服务器上，提高数据库的整体性能和可用性。 数据备份：创建数据库数据的副本，以便在某些情况下能够恢复数据。 高可用性：确保数据库系统能够持续运行，当主服务器故障时切换到从服务器提供服务，尽可能减少停机时间。 2 原理主库称为Master服务器，从库称为Slave服务器。每个Slave只有一个Master，每个Master可以有多个Slave。 主从复制是基于二进制日志和中继日志实现的，涉及三个线程操作，一个主库线程，两个从库线程。 过程： 当主库上的数据发生改变时，会将改变写入二进制日志中，这个过程称为二进制日志事件。 当从库建立和主库的连接时，从库会请求与主库进行复制。 主库会创建二进制日志转储线程，读取二进制日志并对日志加锁，当读取结束后释放锁，然后将二进制日志内容发送给从库。 从库会创建IO线程，用于接收主库发送的二进制日志内容，然后存储到中继日志。 从库会创建SQL线程，读取中继日志的内容，在数据库中执行操作，完成数据复制。 在此后二进制日志转储线程监听二进制日志，当发生改变时会通知从库开启新一轮主从复制。 如图： 3 步骤3.1 修改主库配置文件配置主库二进制日志： my.cnf123456789[mysqld]# 集群唯一IDserver-id=1# 是否只读，0表示读写，1表示只读read-only=0# 设置二进制日志的位置，会在名称后附加数字扩展名log_bin=/var/log/mysql/mysql-bin# 设置二进制日志索引文件的位置，会在名称后附加.index扩展名log_bin_index=/var/log/mysql/mysql-bin 重启主库服务。 3.2 修改从库配置文件配置从库二进制日志： my.cnf12345678# 集群唯一IDserver-id=2# 是否只读，0表示读写，1表示只读read-only=1# 设置二进制日志的位置，会在名称后附加数字扩展名log_bin=/var/log/mysql/mysql-bin# 设置二进制日志索引文件的位置，会在名称后附加.index扩展名log_bin_index=/var/log/mysql/mysql-bin 配置从库中继日志： my.cnf12345678# 设置中继日志的位置relay_log=/var/log/mysql/relay-bin# 设置中继日志索引文件的位置，会在名称后附加.index扩展名relay_log_index=/var/log/mysql/relay-bin# 设置主库二进制日志进度信息，file表示存储在文件，table表示存储在mysql.slave_master_info表，支持同时设置两种master_info_repository=table# 设置从库中继日志进度信息，file表示存储在文件，table表示存储在mysql.slave_relay_log_info表，支持同时设置两种relay_log_info_repository=table 重启从库服务。 3.3 配置主库从库需要访问主库，所以还要在主库创建用于主从复制的用户，并对用户进行授权。 创建用户： sql1create user &#x27;doSlave&#x27; identified by &#x27;123456&#x27;; 访问授权： sql1grant replication slave on *.* to &#x27;doSlave&#x27; identified by &#x27;123456&#x27;; 刷新授权： sql1flush privileges; 查看主库状态： sql123456789mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000002 | 840 | | | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)mysql&gt; 记录下File和Position的值。 3.4 配置从库配置主库： sql1234567change master tomaster_host=主库地址,master_port=主库端口号,master_user=主库授权用户,master_password=主库授权用户密码,master_log_file=主库二进制日志,master_log_pos=主库二进制日志的Pos点; 示例： sql12345678910mysql&gt; change master to -&gt; master_host=&#x27;localhost&#x27;, -&gt; master_port=3306, -&gt; master_user=&#x27;doSlave&#x27;, -&gt; master_password=&#x27;123456&#x27;, -&gt; master_log_file=&#x27;mysql-bin.000002&#x27;, -&gt; master_log_pos=840;Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; 3.5 执行复制登录从库。 停止复制： sql1stop slave; 相当于： sql12stop slave io_thread;stop slave sql_thread; 执行复制： sql1start slave; 相当于： sql12start slave io_thread;start slave sql_thread; 查看状态： sql1show slave status\\G 说明： Slave_IO_Running：从库IO线程是否正常运行，Yes表示正常运行。 Slave_SQL_Running：从库SQL线程是否正常运行，Yes表示正常运行。 Seconds_Behind_Master：从库同步的延迟时间，从库当前的时间戳与从库正在执行的事件时间戳的差值，单位是秒。 SQL_Delay：从库延迟复制的时间，单位是秒。 3.6 测试在主库执行SQL语句，在从库查看是否进行了复制。 4 复制方式主从复制是通过日志实现的，因为从库执行中继日志是在主库执行SQL命令之后，所以即使在网络正常的情况下，从库执行中继日志的时间也会导致延迟，进而产生数据不一致的问题。 数据不一致问题可以通过更换复制方式解决。 4.1 异步复制主库执行SQL命令，记录二进制日志，向客户端返回执行结果，从库在间隔一段时间探测到二进制日志有改动后进行复制。 异步复制是默认的复制方式，提供了最佳性能，但没有考虑数据不一致问题。 4.2 同步复制主库执行SQL命令，记录二进制日志，通知从库复制数据，在收到所有从库复制成功的消息后，向客户端返回执行结果。 同步复制解决了数据不一致问题，但牺牲了很大的性能。 4.3 半同步复制主库执行SQL命令，记录二进制日志，通知从库复制数据，在收到任意一个从库写入中继日志成功的消息后，向客户端返回执行结果。 半同步复制是在异步复制和同步复制折中的一个方案，也是最佳性能和最佳安全的折中。 在5.5版本之后才支持半同步复制，需要安装插件才能开启。 4.4 增强半同步复制（无损复制）主库执行SQL命令但并不提交事务，记录二进制日志，通知从库复制数据，在收到任意一个从库写入中继日志成功的消息后，提交事务并向客户端返回执行结果。 增强半同步复制是对半同步复制的优化，在主库执行SQL命令后并不提交事务，等到任意一个从库写入中继日志后在提交事务，进一步提高了安全性，但因为没有及时提交事务，也会影响一些性能。 在5.7版本之后取代了半同步复制。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"性能分析","slug":"E00-数据库/E02-MySQL/002-高级/005-性能分析","date":"2025-06-11T08:54:59.000Z","updated":"2025-06-21T18:17:34.133Z","comments":true,"path":"posts/20250611/165459/","permalink":"https://momashanhe.com/posts/20250611/165459/","excerpt":"摘要：本文学习了如何对数据库进行性能分析。","text":"摘要：本文学习了如何对数据库进行性能分析。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 慢查询1.1 配置修改MySQL配置文件，开启并配置慢查询日志，重启MySQL服务器。 1.2 查看使用mysqldumpslow工具查看记录的慢查询SQL。 1.3 分析使用explain语句分析慢查询SQL的执行情况，根据结果进行相应的优化。 2 profile2.1 说明使用profile命令可以分析当前会话中语句执行的资源消耗情况，常与explain命令配合使用。 注意，在5.7之后的版本中不建议使用profile命令，建议使用performance pchema工具。 2.2 配置查看配置： sql1show variables like &#x27;profiling%&#x27;; 手动开启，仅在当前会话有效： sql1set profiling=on; 2.3 使用默认记录最近15条使用的SQL语句，正常执行SQL语句后查看执行情况： sql12345678910mysql&gt; show profiles;+----------+------------+--------------------+| Query_ID | Duration | Query |+----------+------------+--------------------+| 1 | 0.00026175 | select * from bill || 2 | 0.00083425 | select * from user |+----------+------------+--------------------+2 rows in set (0.07 sec)mysql&gt; 根据查询编号查看指定SQL的执行情况： sql1show profile [选项] for query [查询编号]; 说明： all：显示所有的开销信息。 block io：显示块IO相关开销。 context switches：上下文切换相关开销。 cpu：显示CPU相关开销信息。 ipc：显示发送和接收相关开销信息。 memory：显示内存相关开销信息。 page faults：显示页面错误相关开销信息。 source：显示和Source相关的开销信息。 swaps：显示交换次数相关开销的信息。 示例： sql1234567891011121314151617181920212223mysql&gt; show profile cpu, block io for query 1;+----------------------+----------+----------+------------+--------------+---------------+| Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |+----------------------+----------+----------+------------+--------------+---------------+| starting | 0.000050 | 0.000000 | 0.000000 | NULL | NULL || checking permissions | 0.000011 | 0.000000 | 0.000000 | NULL | NULL || Opening tables | 0.000018 | 0.000000 | 0.000000 | NULL | NULL || init | 0.000015 | 0.000000 | 0.000000 | NULL | NULL || System lock | 0.000005 | 0.000000 | 0.000000 | NULL | NULL || optimizing | 0.000002 | 0.000000 | 0.000000 | NULL | NULL || statistics | 0.000009 | 0.000000 | 0.000000 | NULL | NULL || preparing | 0.000008 | 0.000000 | 0.000000 | NULL | NULL || executing | 0.000001 | 0.000000 | 0.000000 | NULL | NULL || Sending data | 0.000055 | 0.000000 | 0.000000 | NULL | NULL || end | 0.000002 | 0.000000 | 0.000000 | NULL | NULL || query end | 0.000006 | 0.000000 | 0.000000 | NULL | NULL || closing tables | 0.000004 | 0.000000 | 0.000000 | NULL | NULL || freeing items | 0.000071 | 0.000000 | 0.000000 | NULL | NULL || cleaning up | 0.000007 | 0.000000 | 0.000000 | NULL | NULL |+----------------------+----------+----------+------------+--------------+---------------+15 rows in set (0.07 sec)mysql&gt; 需要注意的Status字段取值： converting HEAP to MyISAM：查询结果太大，内存都不够用，存放到了磁盘上。 Creating tmp table：创建临时表，后面还要删除临时表。 Copying to tmp table on disk：把内存中临时表复制到磁盘上。 locked：发生了锁表操作。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"日志管理","slug":"E00-数据库/E02-MySQL/002-高级/004-日志管理","date":"2025-06-10T16:42:03.000Z","updated":"2025-06-29T15:45:59.264Z","comments":true,"path":"posts/20250611/004203/","permalink":"https://momashanhe.com/posts/20250611/004203/","excerpt":"摘要：本文学习了数据库常见的日志类型及其作用。","text":"摘要：本文学习了数据库常见的日志类型及其作用。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 日志类型1.1 错误日志（Error log）1.1.1 说明错误日志主要记录服务器的启动和关闭，以及在运行过程中发生的错误和警告相关信息。 默认开启，将主机名作为错误日志文件名保存在数据目录。 1.1.2 配置修改配置文件： my.cnf123[mysqld]# 设置错误日志的位置log_error=/var/log/mysql/error.log 1.2 一般查询日志（General query log）1.2.1 说明一般查询日志又称为通用查询日志，是记录最详细的日志，当客户端建立连接或断开连接时，服务器将信息写入此日志，并记录客户端执行的每个SQL语句。 默认关闭，开启通用查询日志会增加很多磁盘IO，所以不建议开启，当需要调试排错时才会开启。 1.2.2 配置修改配置文件： my.cnf12345[mysqld]# 设置为1启用一般查询日志，设置为0禁用一般查询日志，默认禁用general_log=1# 设置一般查询日志的位置general_log_file=/var/log/mysql/query.log 临时修改，不支持会话修改，只能全局修改： sql1set global general_log=off; 查看配置： sql1show variables like &#x27;general_log%&#x27;; 1.3 慢查询日志（Slow query log）1.3.1 说明慢查询日志用来记录执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。 默认关闭，一般建议开启，它对服务器性能的影响微乎其微，但是可以记录服务器上的慢查询语句，帮助定位性能问题。 1.3.2 配置修改配置文件： my.cnf123456789[mysqld]# 设置为1启用慢查询日志，设置为0禁用慢查询日志，默认禁用slow_query_log=1# 设置慢查询日志的方式，file表示存储在文件，table表示存储在mysql.slow_log表，支持同时设置两种，默认是filelog_output=file,table# 设置慢查询日志的位置slow_query_log_file=/var/log/mysql/slow.log# 设置超时时间，单位是秒，默认值是10秒long_query_time=10 临时修改，不支持会话修改，只能全局修改： sql1set global slow_query_log=off; 查看配置： sql1show variables like &#x27;slow_query_log%&#x27;; 1.4 二进制日志（Binary log）1.4.1 说明二进制日志也叫作变更日志，主要用于记录修改数据或有可能引起数据改变的SQL语句，以事件形式记录并保存在二进制文件中。 默认关闭，通常用于数据恢复和主从复制。 1.4.2 配置修改配置文件： my.cnf123456789101112131415[mysqld]# 设置服务器唯一标识，每台服务器必须不同server-id=1# 设置二进制日志的位置，会在名称后附加数字扩展名log_bin=/var/log/mysql/mysql-bin# 设置二进制日志索引文件的位置，会在名称后附加.index扩展名log_bin_index=/var/log/mysql/mysql-bin# 设置忽略的数据库binlog-ignore-db=mysql# 设置同步的数据库binlog-do-db=test# 设置二进制日志的最大值，默认值是1GB，并不能严格控制日志的大小，最后的事务可能超出max_binlog_size=1G# 设置二进制日志自动删除的过期天数，默认值为0，表示不会自动删除，取值范围是0到99expire_logs_days=0 临时修改，不支持全局修改，只能会话修改： sql1set sql_log_bin=off; 查看配置： sql1show variables like &#x27;log_bin%&#x27;; 查看二进制日志列表： sql1show master logs; 创建二进制日志： 在日志内容超过最大值或者重启服务器后，自动滚动生成新的日志文件，并将数字扩展名累加。 也可以通过命令手动滚动生成新的日志文件：sql1flush logs; 清除二进制日志： sql12purge master logs to &#x27;文件名称&#x27;;purge master logs before &#x27;日期&#x27;; 重置主库，清除二进制日志并重置序号，如果已经存在从库，会导致从库同步报错： sql1reset master; 1.4.3 日志格式支持三种格式： statment：基于sql语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。优缺点： 优点：不需要记录每一行的变化，减少了日志量，节约了IO，从而提高了性能。 缺点：在某些情况下的数据不一致，比如将now()等函数得到的结果插入数据库。 row：基于行的日志记录，记录的是数据变更，不记录每条SQL语句的上下文信息。优缺点： 优点：不会出现某些情况下的数据不一致的问题。 缺点：会产生大量的日志。 mixed：基于statment和row两种模式的混合，一般的复制使用statement模式，对于statement模式无法复制的操作使用row模式。 默认使用ROW格式。 修改配置文件： my.cnf123[mysqld]# 设置二进制日志格式binlog_format=row 临时修改： sql12set binlog_format=&#x27;row&#x27;;set global binlog_format=&#x27;row&#x27;; 查看配置： sql1show variables like &#x27;binlog_format&#x27;; 1.4.4 刷盘策略系统会为每个线程分配一块内存作为缓存，在执行SQL命令时，将日志写入缓存，在提交事务时，将缓存里的日志写入磁盘文件。 刷盘的时机可以通过sync_binlog参数控制： 0：事务提交只写缓存，由系统自行判断什么时候刷盘。 1：事务提交会执行刷盘。 N：事务提交只写缓存，当累计N个事务后才刷盘。 修改配置文件： my.cnf123[mysqld]# 设置刷盘策略sync_binlog=0 临时修改，不支持会话修改，只能全局修改： sql1set global sync_binlog=0; 查看配置： sql1show variables like &#x27;sync_binlog&#x27;; 1.5 中继日志（Relay log）1.5.1 说明中继日志保存了主服务器的二进制日志，SQL线程会根据中继日志的内容进行同步，从而使从服务器和主服务器的数据保持一致。 默认关闭，主要用于主从复制，需要联合使用二进制日志和中继日志。 1.5.2 配置修改配置文件： my.cnf123456789101112131415[mysqld]# 设置中继日志的位置relay_log=/var/log/mysql/relay-bin# 设置中继日志索引文件的位置，会在名称后附加.index扩展名relay_log_index=/var/log/mysql/relay-bin# 设置主库二进制日志同步的数据，file表示存储在文件，table表示存储在mysql.slave_master_info表，支持同时设置两种master_info_repository=table# 设置从库中继日志同步的数据，file表示存储在文件，table表示存储在mysql.slave_relay_log_info表，支持同时设置两种relay_log_info_repository=table# 设置中继日志的最大值，默认值是1GBmax_relay_log_size=1G# 设置是否自动清空中继日志，设置为1表示启用，默认启用relay_log_purge=1# 设置是否放弃未执行的中继日志，设置为0表示当从库宕机后重新从主库获取日志，保证完整性，默认关闭relay_log_recovery=0 重置从库，清除中继日志，如果已经存在从库，会删除主库关联： sql1reset slave; 1.6 DDL日志（DDL log）DDL日志记录由DDL语句执行的元数据操作，使用此日志从元数据操作中间发生的崩溃中恢复。 DDL日志最多可容纳4GB的条目，超过此限制后必须先重命名或删除文件，然后才能执行DDL语句。 1.7 回滚日志（Undo log）1.7.1 说明回滚日志是InnoDB存储引擎在执行增删改的SQL命令时产生的逻辑日志，用来保证事务的原子性，主要用于事务回滚和多版本并发控制。 回滚日志是逻辑日志，记录数据被修改前的值。 回滚日志主要分为两种： insert undo log：当执行insert的时候，产生的回滚日志只在回滚时需要，在事务提交后，可被立即删除。因为insert操作只是对本事务可见，其他事务不可见，所以当事务提交后，对应的回滚日志就会被系统直接删除回收，占用的链表也被释放。 update undo log：当执行update和delete的时候，产生的回滚日志不仅在事务回滚时需要，在多版本并发控制的快照读时也需要，所以不能在事务提交后马上删除，只在提交后放入链表，等待purge线程进行最后的删除。 1.7.2 原理在执行增删改的SQL命令前，会在回滚日志中记录操作前的数据，并且会在对应的行中使用roll_pointer隐藏字段记录最近修改这条记录的上一版本。 在对同一条记录进行增删改操作时，会在回滚日志中生成一系列这条记录的版本链，链表的头部是最新的旧记录，链表尾部是最早的旧记录。 当发生回滚时，根据记录的操作前的数据进行回滚。 1.8 重做日志（Redo log）1.8.1 说明重做日志是InnoDB存储引擎在执行增删改的SQL命令时产生的物理日志，用来保证事务的持久性，主要用于掉电等故障恢复。 重做日志是物理日志，记录的是物理数据页修改后的信息。 1.8.2 原理在执行增删改的SQL命令后，会将重做日志写入到缓存中，记录数据被修改后的值。在提交事务前，会将缓存中的重做日志写入到磁盘上的日志文件，然后将提交事务并将改动保存到数据库。 重做日志采用循环写入机制，写满一个文件后就自动切换到下一个文件，直到所有文件都写满后又回到第一个文件，覆盖之前的内容。 1.8.3 两阶段提交在提交事务时，需要记录重做日志和二进制日志，为了解决日志之间的逻辑一致问题，使用了两阶段提交的方案。 提交事务前的两阶段提交流程： 将缓存里的重做日志写入到磁盘文件，并标记为prepare阶段。 将缓存里的二进制日志写入到磁盘文件。 将重做日志中的状态改为commit阶段。 如果没有使用两阶段提交，在宕机时会出现数据不一致问题： 假设先写入重做日志，在写入二进制日志前发生宕机，重启后根据重做日志执行操作并提交事务，此时二进制日志没有记录该事务，数据不一致。 假如先写入二进制日志，在写入重做日志前发生宕机，重启后根据重做日志没有执行操作，此时二进制日志已经记录该事务，数据不一致。 如果使用了两阶段提交，在宕机时就能避免数据不一致问题： 假设在写入二进制日志前发生宕机，重启后根据重做日志执行操作，在二进制日志找不到对应记录，回滚事务，数据一致。 假如在写入二进制日志后发生宕机，重启后根据重做日志执行操作，在二进制日志能找到对应记录，提交事务，数据一致。 1.8.4 刷盘策略在将缓存的重做日志写入到磁盘上时，先将重做日志写入到操作系统的缓存中，然后由操作系统将重做日志写到日志文件。 刷盘的时机可以通过innodb_flush_log_at_trx_commit参数控制： 0（延迟写）：事务提交不会写入系统缓存，而是每隔1秒写入系统缓存并调用操作系统刷盘。当系统崩溃时会丢失数据。 1（实时写并且实时刷盘）：事务提交会写入系统缓存并调用操作系统刷盘。当系统崩溃时不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能差。 2（实时写但是延时刷盘）：事务提交只写入系统缓存，每隔1秒调用操作系统刷盘。当系统崩溃时会丢失数据。 修改配置文件： my.cnf123[mysqld]# 设置刷盘策略innodb_flush_log_at_trx_commit=0 临时修改，不支持会话修改，只能全局修改： sql1set global innodb_flush_log_at_trx_commit=0; 查看配置： sql1show variables like &#x27;innodb_flush_log_at_trx_commit&#x27;; 2 慢查询分析2.1 配置慢查询分析是通过分析慢查询日志，结合explain进行全面分析。 查看慢查询日志的配置： sql1show variables like &#x27;slow_query_log%&#x27;; 2.2 查看进入MySQL安装目录的bin目录。 语法： bash1mysqldumpslow [选项] 日志位置 选项： -s 参数：表示按照何种方式排序。 -s c：表示按照访问次数排序。 -s l：表示按照锁定时间排序。 -s r：表示按照返回时间排序。 -s t：表示按照查询时间排序。 -s al：表示按照平均访问次数排序。 -s ar：表示按照平均返回时间排序。 -s at：表示按照平均查询时间排序。 -t n：表示返回前面n条的数据。 -g 表达式：后边搭配一个正则匹配模式，大小写不敏感。 查询返回结果最慢的10个SQL： bash1mysqldumpslow -s t -t 10 /var/log/mysql/slow.log 查询访问次数最多的10个SQL： bash1mysqldumpslow -s c -t 10 /var/log/mysql/slow.log 得到按照时间排序的前10条里面含有左连接的查询语句： bash1mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/log/mysql/slow.log 另外建议在使用这些命令时结合more使用，否则有可能出现爆屏情况： bash1mysqldumpslow -s r -t 10 /var/log/mysql/slow.log | more 2.3 分析使用explain工具分析慢查询SQL的索引使用情况，根据结果优化查询，缩短查询时间。 3 误操作恢复3.1 配置查看二进制日志的配置： sql1show variables like &#x27;log_bin%&#x27;; 查看日志列表： sql1show master logs; 3.2 查看内容3.2.1 使用命令查看使用SQL命令查看日志内容： sql1234show binlog eventsin &#x27;文件名&#x27;[from 位置][limit 起始编号, 查询条数]; 示例： sql1234show binlog eventsin &#x27;mysql-bin.000001&#x27;from 123limit 10; 结果中每条记录的Pos字段就是该记录的位置。 3.2.2 使用工具查看使用mysqlbinlog工具查看日志内容： bash1mysqlbinlog [选项] 文件位置 选项： –no-defaults：不要读取任何选项文件，如果使用时有如下报错mysqlbinlog: [ERROR] unknown variable可以使用该选项绕过。 –base64-output&#x3D;decode-rows -v：将BINLOG语句解码为SQL语句进行显示。 –base64-output&#x3D;decode-rows -vv：将BINLOG语句解码为SQL语句进行显示，同时显示字段数据类型和某些元数据的注释。 –start-position：设置开始位置。 –stop-position：设置结束位置。 –start-datetime：设置开始日期，优先级比位置低。 –stop-datetime：设置结束日期，优先级比位置低。 –database：设置数据库。 示例： bash1mysqlbinlog --no-defaults --base64-output=decode-rows -v /var/log/mysql/mysql-bin.000001 结果中每行以# at开头的数字就是该条记录的位置。 3.3 恢复数据使用mysqlbinlog工具恢复数据： bash1mysqlbinlog [选项] 文件位置 | mysql –u用户名 -p[密码]; 示例： bash1mysqlbinlog --no-defaults --stop-position=1038 /var/log/mysql/mysql-bin.000001 | mysql -uroot -p 设置结束时间和结束位置时，需要选择事务提交之后的记录，才能保证最后执行的SQL命令被提交到了服务器。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"索引详解","slug":"E00-数据库/E02-MySQL/002-高级/003-索引详解","date":"2025-06-05T02:07:52.000Z","updated":"2025-06-21T18:17:15.024Z","comments":true,"path":"posts/20250605/100752/","permalink":"https://momashanhe.com/posts/20250605/100752/","excerpt":"摘要：本文学习了索引的数据结构和相关的概念，以及如何使用工具分析和优化。","text":"摘要：本文学习了索引的数据结构和相关的概念，以及如何使用工具分析和优化。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 数据结构1.1 分类索引是在存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。 常见的索引有四种结构类型： B树索引：最常见的索引类型，大部分索引都支持该类型的索引。 Hash索引：基于Hash表实现，只有Memory引擎支持，使用场景简单。 R树索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。 FullText（全文索引）：全文索引也是MyISAM的一个特殊索引类型，主要用于全文检索。InnoDB从5.6版本开始支持全文索引，但并不直接支持中文，需要使用插件辅助。 1.2 说明1.2.1 B树B树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树。相对于二叉树，B树每个内结点有多个分支，所以是多叉树。 一颗m叉的B树特性如下： 树中每个节点最多有m个孩子节点，如果根节点不是叶子节点，则至少有2个孩子节点。 除根节点与叶子节点外，每个节点由n个key与n+1个point组成，其中n的取值在ceil(m&#x2F;2)-1和m-1之间，ceil是一个取上限的函数。 节点的key包含索引的键值和键值所在行的数据，节点的point指向孩子节点，如果是叶子节点，其point指向null节点，并且所有的叶子节点都在同层。 当孩子节点的数量超过m-1时，中间节点会成为父节点，孩子节点分裂为左右两块孩子节点。 以一个3叉B树为例，当m为3时，n的取值在1和2之间，当key的个数大于2时，中间节点分裂到父节点，两边节点分裂。 插入ACGBNMQW的演变过程如下： 插入AC 插入G，n&gt;2，中间C向上分裂到新节点 插入BN，不需要分裂 插入M，中间M向上分裂到父节点 插入Q，不需要分裂 插入W，中间Q向上分裂到父节点，父节点中间M向上分裂到新节点 和二叉树相比，B树有如下优点：： 查询效率更高。在相同的数据量情况下，B树查询数据的时间复杂度更低。 搜索速度更快。B树层级结构小，查询效率更高。 1.2.2 B+树B+树是B树的一个变种，但也同样属于多叉平衡查找树。 一颗m叉的B+树特性如下： 树中每个节点最多有m个孩子。 如果根节点不是叶子节点，则至少有2个孩子。 除根节点与叶子节点外，每个节点由n个key与n个point组成，其中ceil(m&#x2F;2)&lt;&#x3D;n&lt;&#x3D;m，ceil是一个取上限的函数。 叶子节点都在同一层，叶子节点没有point，叶子节点的key包含全部索引的键值和键值所在行的数据。 非叶子节点的point指向孩子节点，非叶子节点的key包含孩子节点中最大（或最小）的key。 以一个3叉B+树为例，2&lt;&#x3D;n&lt;&#x3D;3，当key的个数大于3时，中间节点分裂到父节点，两边节点分裂。 插入ACGBNMQW的演变过程如下： 插入ACG 插入B，n&gt;3，分裂 插入N，不需要分裂 插入M，分裂 插入Q，不需要分裂 插入W，分裂 和B树相比，B+树有如下优点： 扫表能力更强。B树需要遍历整棵树，B+树只需要遍历所有叶子节点。 磁盘读写能力更强。在同样大小的情况下，B+树只有叶子节点保存数据，保存的关键字和数据更多。 查询性能稳定。B+树数据只保存在叶子节点，每次查询数据，查询IO次数一定是稳定的。 查询效率高。B树在遍历时如果命中直接返回，B+树需要遍历到叶子节点。 2 相关定义2.1 聚簇索引2.1.1 定义索引中的键值顺序就是表中相应行的物理存储顺序。对于经常要搜索范围值的列特别有效，表中排序经常用到的列可以使用聚簇索引节省成本。 在聚簇索引中，叶子节点存储的是真实数据，不再有另外单独的数据页。 优点是查询速度快，一旦具有第一个索引值的数据行被找到，具有连续索引值的数据行也会紧随其后。 缺点是修改速度慢，为了保证数据行的顺序和索引的顺序一致，需要进行数据重排，不适用于频繁更新的列。 2.1.2 使用如果定义了主键，InnoDB会将这个主键索引作为聚簇索引。 如果没有定义主键，InnoDB会将第一个非空唯一索引作为聚簇索引。 如果没有主键索引并且没有非空唯一索引，InnoDB会自动创建一个隐藏的名字为GEN_CLUST_INDEX的聚簇索引。 因此，每个InnoDB表都有且仅有一个聚簇索引。 2.2 非聚簇索引2.2.1 定义索引中的键值顺序与表中相应行的物理存储顺序无关。 在非聚簇索引中，叶子节点存储的是索引节点，有一个指向对应数据页上的真实数据的指针。 2.2.2 使用所有不是聚簇索引的索引都叫非聚簇索引或者辅助索引。 在InnDB存储引擎中，非聚簇索引的每条记录会包含对应的主键，InnoDB会使用这个主键来检索聚簇索引。 因此应该尽可能将主键缩短，否则辅助索引占用空间会更大。 2.2.3 回表查询当要查询的列不属于主索引和辅助索引，并且在查询条件中使用了辅助索引而且没有使用主索引。 此时，如果要的到查询结果，首先根据查询条件搜索辅助索引，找到符合的叶子节点，因为辅助索引没有索引覆盖查询的列，通过叶子节点上的主键搜索主索引，从而得到查询结果。 这个过程就是回表查询。 3 索引下推索引下推（Index Condition Pushdown）简称ICP，在5.6的版本中推出。 ICP主要用于优化使用非聚簇索引的查询语句，可以减少回表次数。对于使用聚簇索引的查询语句，因为不需要回表，所以ICP并没有起到提示性能的效果。 使用ICP可以减少存储引擎回表的次数，也可以减少服务器从存储引擎接收数据的次数： 在不使用ICP的情况下，存储引擎通过索引检索到数据，然后返回给服务器，服务器判断数据是否符合条件 。 在使用ICP的情况下，存储引擎通过索引判断数据是否符合条件，然后返回给服务器。 4 索引优化4.1 创建规则建议创建索引的场景： 主键自动建立唯一索引。 经常作为查询条件的列要建立索引。 经常作为排序的列要建立索引。 在聚合函数中使用的列需要建立索引。 查询中与其他表关联的字段，以及外键关系要建立索引。 高并发条件下倾向使用组合索引。 不建议创建索引的场景： 经常增删改的列不要建立索引。 有大量重复的列不建立索引。 表记录太少不要建立索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，使用索引才有意义。 4.2 利用索引4.2.1 全词匹配最推荐的方式是使用全词匹配，也就是使用等号去查询数据，即便字段没有按照组合索引的顺序查询，优化器也能自动进行顺序优化。 4.2.2 范围匹配不太推荐使用范围匹配的方式查询数据，因为这种方式可能会导致索引失效。 凡是表示有多个查询条件的方式都可以看做范围匹配，有可能使用范围级别的索引，也有可能不使用索引，但都会导致组合索引后面的字段失效。 说明： 使用不等于号不会使用索引。 使用大于号和小于号会使用范围级别的索引。 使用大于等于号和小于等于号会根据实际查询数据判断，如果全盘扫描速度快则不使用索引。 使用IN和EXISTS会导致索引失效。 使用LIKE关键字时，如果不是通配符开头会用到范围级别的索引，否则通配符开头不会使用索引。 使用IS NULL和IS NOT NULL同样会导致索引失效。 使用OR也会导致索引失效。 4.2.3 最佳左前缀主要针对组合索引的情况。 如果查询语句正确使用了索引中定义的第一个字段，那么查询语句才能用到索引，索引才会对查询语句有效。 只有当前一个字段用到了索引，后一个字段才有可能用到索引。换句话说，如果组合索引的中间字段没有用到索引，那么后面的字段也不可能用到索引。 4.2.4 精确查找尽量使用哪些字段就查询哪些字段，避免使用通配符。 4.2.5 覆盖索引覆盖索引指的是只要查询字段都在索引中，查询就会使用到索引，和查询条件无关。 覆盖索引的原理是查询字段在索引中就能查到记录，不需要再次查询主索引中的记录，避免了回表，从而提高了性能。 在查询语句中，如果使用了范围查询条件，可能会导致索引失效，此时可以通过优化查询字段实现覆盖索引，使索引生效。 4.2.6 小表驱动大表判断小表和大表可以根据MySQL优化器先加载哪个数据集，优先加载的被看做小表，相当于双层循环的外循环。 保证被驱动表上的条件字段已经被索引，换句话说，在大的数据集上优先建立索引。 说明： 连接查询使用JOIN时，优先加载ON后面连接条件等号左边的部分，所以将等号左边的部分看做小表，等号左边的小表驱动等号右边的大表，需要给右边的字段建立索引。 子查询使用IN时，优先加载子查询，所以将子查询看做小表，子查询驱动主查询，需要给主查询建立索引。 子查询使用EXISTS时，优先加载主查询，所以将主查询看做小表，主查询驱动子查询，需要给子查询建立索引。 4.2.7 避免操作尽量避免在索引列上进行任何操作，包括但不限于计算、函数、类型转换，都会导致索引失效。 需要注意的是，误加和漏加单引号属于类型转换，也会导致索引失效。 4.2.8 排序功能主要是针对排序操作。 索引的作用除了可以用来查找之外，还可以用来排序。 如果索引能用来排序则使用Index方式排序，如果索引不能用来排序则使用FileSort方式排序。 4.2.8.1 Index方式排序尽量使用索引中的字段排序，并且保持索引中字段的顺序。 需要注意的是，排序是在查找之后，如果排序的字段在查找中出现过，即便顺序颠倒，也可以使用索引的排序功能。 4.2.8.2 FileSort方式排序如果不能通过Index方式排序，则会使用FileSort方式排序。 FileSort方式有两种策略： 双路排序：第一次扫描磁盘读取行指针和要排序的字段，然后在缓冲区进行排序，第二次读取缓冲区排好序的列表，根据行指针重新扫描磁盘得到数据输出。 单路排序：扫描磁盘读取所有需要的列，然后在缓冲区进行排序，读取缓冲区排好序的列表输出。 在4.1之前使用双路排序，在4.1之后使用单路排序。 单路排序的效率更快一点，避免二次读取，但单路排序也存在问题。当取出的数据超出了缓冲区容量，就回导致每次只能读取缓冲区大小的数据进行排序，然后重复读取导致多次IO操作。 优化单路排序的思路： 增大sort_buffer_size参数：不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。 增大max_length_for_sort_data参数：提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大。 4.2.9 分组功能主要是针对分组操作。 分组的操作是在查找和排序之后，建议安装查找和排序的顺序进行分组。 WHERE优先于HAVING，能在WHERE中实现的筛选就不要放在HAVING中。 4.3 查询分析4.3.1 准备数据创建user表并插入数据： sql12345678910CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `username` varchar(255) COMMENT &#x27;用户名称&#x27;, `password` varchar(255) COMMENT &#x27;用户密码&#x27;, `create_time` datetime COMMENT &#x27;创建时间&#x27;, `update_time` datetime COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB COMMENT = &#x27;用户表&#x27;;INSERT INTO `user` VALUES (1, &#x27;张三&#x27;, &#x27;123456&#x27;, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `user` VALUES (2, &#x27;李四&#x27;, &#x27;123456&#x27;, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;); 创建bill表并插入数据： sql12345678910111213141516171819202122CREATE TABLE `bill` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `user_id` int(11) COMMENT &#x27;用户表id&#x27;, `bill_no` varchar(32) COMMENT &#x27;订单号&#x27;, `address` varchar(255) COMMENT &#x27;收货地址&#x27;, `post` varchar(6) COMMENT &#x27;邮编&#x27;, `receiver` varchar(255) COMMENT &#x27;收货人姓名&#x27;, `mobile` varchar(11) COMMENT &#x27;手机号码&#x27;, `user_note` varchar(255) COMMENT &#x27;用户备注的信息&#x27;, `status` varchar(10) COMMENT &#x27;订单状态&#x27;, `bill_time` datetime COMMENT &#x27;下单时间&#x27;, `payment_time` datetime COMMENT &#x27;支付时间&#x27;, `deliver_time` datetime COMMENT &#x27;发货时间&#x27;, `confirm_time` datetime COMMENT &#x27;收货时间&#x27;, `create_time` datetime COMMENT &#x27;创建时间&#x27;, `update_time` datetime COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), KEY `idx_user_id` (user_id)) ENGINE = InnoDB COMMENT = &#x27;订单表&#x27;;INSERT INTO `bill` VALUES (1, 1, &#x27;20180503117625298&#x27;, &#x27;山东省烟台市&#x27;, &#x27;264000&#x27;, &#x27;张三&#x27;, &#x27;12345678933&#x27;, &#x27;&#x27;, &#x27;finish&#x27;, &#x27;2018-04-29 00:00:00&#x27;, &#x27;2018-04-29 00:00:00&#x27;, &#x27;2018-04-29 00:00:00&#x27;, &#x27;2018-04-29 00:00:00&#x27;, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `bill` VALUES (2, 1, &#x27;20180506143826504&#x27;, &#x27;山东省烟台市&#x27;, &#x27;264000&#x27;, &#x27;张三&#x27;, &#x27;12345678933&#x27;, &#x27;&#x27;, &#x27;delete&#x27;, &#x27;2018-05-06 00:00:00&#x27;, NULL, NULL, NULL, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `bill` VALUES (3, 2, &#x27;20180507180327444&#x27;, &#x27;河南省开封市&#x27;, &#x27;475000&#x27;, &#x27;李四&#x27;, &#x27;12345678944&#x27;, &#x27;&#x27;, &#x27;finish&#x27;, &#x27;2018-05-07 00:00:00&#x27;, &#x27;2018-05-07 00:00:00&#x27;, &#x27;2018-05-07 00:00:00&#x27;, &#x27;2018-05-07 00:00:00&#x27;, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;); 创建bill_detail表并插入数据： sql12345678910111213141516CREATE TABLE `bill_detail` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `bill_id` int(11) COMMENT &#x27;订单表id&#x27;, `user_id` int(11) COMMENT &#x27;用户表id&#x27;, `product` varchar(255) COMMENT &#x27;购买产品&#x27;, `quantity` int(11) COMMENT &#x27;购买数量&#x27;, `create_time` datetime COMMENT &#x27;创建时间&#x27;, `update_time` datetime COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), KEY `idx_bill_id` (bill_id), KEY `idx_user_id` (user_id)) ENGINE = InnoDB COMMENT = &#x27;订单明细表&#x27;;INSERT INTO `bill_detail` VALUES (1, 1, 1, &#x27;手机&#x27;, 1, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `bill_detail` VALUES (2, 1, 1, &#x27;电视&#x27;, 1, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `bill_detail` VALUES (3, 2, 1, &#x27;电脑&#x27;, 2, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;);INSERT INTO `bill_detail` VALUES (4, 3, 2, &#x27;电脑&#x27;, 1, &#x27;2020-12-17 16:35:23&#x27;, &#x27;2020-12-17 16:35:23&#x27;); 4.3.2 优化器MySQL中有专门负责优化查询语句的优化器，主要功能是通过计算分析系统中收集到的统计信息，为客户端请求的SQL提供最优的执行计划。 但优化器认为的最优的数据检索方式，不一定是DBA认为的最优的数据检索方式，这部分最耗费时间。 4.3.3 分析工具使用explain可以查看优化器将如何执行SQL语句。 示例： sql123456789mysql&gt; explain select * from user;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set (0.02 sec)mysql&gt; 4.3.4 字段说明4.3.4.1 id查询的序列号，表示查询中操作表的顺序，一行对应一个查询语句。 结果包含四种情况： 相同执行顺序从上到下：sql12345678910mysql&gt; explain select b.* from bill b, bill_detail bd where b.id = bd.bill_id;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+| 1 | SIMPLE | bd | NULL | index | idx_bill_id | idx_bill_id | 5 | NULL | 4 | 100.00 | Using index || 1 | SIMPLE | b | NULL | ALL | PRIMARY | NULL | NULL | NULL | 3 | 50.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+2 rows in set (0.02 sec)mysql&gt; 不同执行顺序由大到小，子查询递增：sql12345678910mysql&gt; explain select b.* from bill b where b.user_id = (select u.id from user u where u.username = &#x27;张三&#x27;);+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+| 1 | PRIMARY | b | NULL | ref | idx_user_id | idx_user_id | 5 | const | 2 | 100.00 | Using where || 2 | SUBQUERY | u | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 50.00 | Using where |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+2 rows in set (0.02 sec)mysql&gt; 同时存在先按照从大到小的顺序排列，然后按照从上到下的顺序执行：sql1234567891011mysql&gt; explain select b.* from bill b, bill_detail bd where b.id = bd.bill_id and b.user_id = (select u.id from user u where u.username = &#x27;张三&#x27;);+----+-------------+-------+------------+------+---------------------+-------------+---------+-----------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------------+-------------+---------+-----------+------+----------+-------------+| 1 | PRIMARY | b | NULL | ref | PRIMARY,idx_user_id | idx_user_id | 5 | const | 2 | 100.00 | Using where || 1 | PRIMARY | bd | NULL | ref | idx_bill_id | idx_bill_id | 5 | test.b.id | 1 | 100.00 | Using index || 2 | SUBQUERY | u | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 50.00 | Using where |+----+-------------+-------+------------+------+---------------------+-------------+---------+-----------+------+----------+-------------+3 rows in set (0.02 sec)mysql&gt; NULL最后执行NULL查询：sql1234567891011mysql&gt; explain select u.* from user u where u.username = &#x27;张三&#x27; union select u.* from user u where u.username = &#x27;李四&#x27;;+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+| 1 | PRIMARY | u | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 50.00 | Using where || 2 | UNION | u | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 50.00 | Using where || NULL | UNION RESULT | &lt;union1,2&gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary |+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+3 rows in set (0.02 sec)mysql&gt; 4.3.4.2 select_type查询的类型，主要是用于区别普通查询、联合查询、子查询等复杂查询。 常见类型： SIMPLE表示简单查询，当前查询中不包含子查询和UNION查询： PRIMARY表示查询中包含子查询，当前查询是最外层查询。 SUBQUERY表示在SELECT语句或WHERE语句中包含子查询。 UNION表示被UNION的查询，即处于UNION之后的查询。 UNION RESULT表示将UNION的结果作为表进行查询。 特殊类型： DEPENDENT SUBQUERY表示在子查询内部依赖外部进行查询：sql12345678910mysql&gt; explain select b.* from bill b where exists (select u.id from user u where b.user_id = u.id);+----+--------------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+--------------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+| 1 | PRIMARY | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | Using where || 2 | DEPENDENT SUBQUERY | u | NULL | eq_ref | PRIMARY | PRIMARY | 4 | test.b.user_id | 1 | 100.00 | Using index |+----+--------------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+2 rows in set (0.04 sec)mysql&gt; DEPENDENT UNION表示在UNION查询内部依赖外部进行查询：sql123456789101112mysql&gt; explain select b.* from bill b where exists (select u.id from user u where b.user_id = u.id union select u.id from user u where b.user_id = u.id);+------+--------------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+------+--------------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+| 1 | PRIMARY | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | Using where || 2 | DEPENDENT SUBQUERY | u | NULL | eq_ref | PRIMARY | PRIMARY | 4 | test.b.user_id | 1 | 100.00 | Using index || 3 | DEPENDENT UNION | u | NULL | eq_ref | PRIMARY | PRIMARY | 4 | test.b.user_id | 1 | 100.00 | Using index || NULL | UNION RESULT | &lt;union2,3&gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary |+------+--------------------+------------+------------+--------+---------------+---------+---------+----------------+------+----------+-----------------+4 rows in set (0.04 sec)mysql&gt; DERIVED表示在FROM语句中包含子查询，递归执行这些子查询并将结果放在临时表里：sql12345678910mysql&gt; explain select * from (select b.user_id, count(1) from bill b group by b.user_id) as b;+----+-------------+------------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| 1 | PRIMARY | &lt;derived2&gt; | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | NULL || 2 | DERIVED | b | NULL | index | idx_user_id | idx_user_id | 5 | NULL | 3 | 100.00 | Using index |+----+-------------+------------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+2 rows in set (0.04 sec)mysql&gt; 4.3.4.3 table表示查询用到的表是哪个。 4.3.4.4 partitions匹配的分区信息，表示存在哪个分区，使用NULL表示没有分区。 4.3.4.5 type查询使用的访问类型，是比较重要的一个指标。 结果从最优到最差的分别为：systen,const,eq_ref,ref,ref_or_null,index_merge,unique_subquery,index_subquery,range,index,ALL。 一般来说，至少需要保证查询达到range级别，最好达到ref。 常见的几种类型： system表只有一行记录，这是const类型的特列。 const当通过主键索引或唯一索引进行等值查询时出现：sql123456789mysql&gt; explain select b.* from bill b where b.id = 1;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | b | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+1 row in set (0.02 sec)mysql&gt; eq_ref当通过主键索引或唯一索引进行关联查询时出现：sql12345678910mysql&gt; explain select b.* from bill b left join user u on u.id = b.user_id;+----+-------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+| 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | NULL || 1 | SIMPLE | u | NULL | eq_ref | PRIMARY | PRIMARY | 4 | test.b.user_id | 1 | 100.00 | Using index |+----+-------------+-------+------------+--------+---------------+---------+---------+----------------+------+----------+-------------+2 rows in set (0.02 sec)mysql&gt; ref当通过非唯一性索引进行等值查询或关联查询时出现：sql123456789mysql&gt; explain select b.* from bill b where b.user_id = 1;+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+| 1 | SIMPLE | b | NULL | ref | idx_user_id | idx_user_id | 5 | const | 2 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+------+----------+-------+1 row in set (0.02 sec)mysql&gt; range当通过索引进行范围查询时出现：sql123456789mysql&gt; explain select b.* from bill b where b.user_id &gt; 1;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | b | NULL | range | idx_user_id | idx_user_id | 5 | NULL | 1 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+1 row in set (0.02 sec)mysql&gt; index当通过遍历索引查询时出现：sql123456789mysql&gt; explain select b.id from bill b;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| 1 | SIMPLE | b | NULL | index | NULL | idx_user_id | 5 | NULL | 3 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+1 row in set (0.02 sec)mysql&gt; ALL当通过遍历全表查询时出现：sql123456789mysql&gt; explain select b.* from bill b;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set (0.02 sec)mysql&gt; 4.3.4.6 possible_keys可能使用的索引，一个或多个。 查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。 4.3.4.7 key实际使用的索引。如果为NULL，则没有使用索引。 4.3.4.8 key_len查询使用的索引字节数，可通过该列检查使用的索引长度，取值越大越好。 4.3.4.9 ref显示索引的哪些列或常量被用于查找。 4.3.4.10 rows根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，取值越小越好。 4.3.4.11 filtered经过搜索条件过滤后剩余记录条数的百分比。 4.3.4.12 Extra包含不适合在其他列中显示但十分重要的额外信息。 常见取值： No tables used查询没有使用FROM指定表：sql123456789mysql&gt; explain select 1 + 1;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | No tables used |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set (0.05 sec)mysql&gt; Zero limit查询使用LIMIT指定0进行查询：sql123456789mysql&gt; explain select b.* from bill b limit 0;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+| 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | Zero limit |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+1 row in set (0.01 sec)mysql&gt; Using index查询的列被索引覆盖，不需要回表查询：sql123456789mysql&gt; explain select b.id from bill b;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+| 1 | SIMPLE | b | NULL | index | NULL | idx_user_id | 5 | NULL | 3 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+1 row in set (0.02 sec)mysql&gt; Using index condition查询的列没有被索引覆盖，需要回表查询，不能完全使用索引：sql123456789mysql&gt; explain select b.* from bill b where b.user_id &gt; 1;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | b | NULL | range | idx_user_id | idx_user_id | 5 | NULL | 1 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+-----------------------+1 row in set (0.02 sec)mysql&gt; Using where查询的WHERE条件没有使用索引，需要进行全表扫描：sql123456789mysql&gt; explain select b.* from bill b where b.receiver = &#x27;张三&#x27;;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set (0.04 sec)mysql&gt; Impossible WHERE查询的WHERE条件总是失败，永远不可能获取到数据：sql123456789mysql&gt; explain select b.* from bill b where b.id = 1 and b.id = 2;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+| 1 | SIMPLE | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL | Impossible WHERE |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+1 row in set (0.05 sec)mysql&gt; Using filesort出现文件排序，无法利用索引完成排序，比如没有通过索引字段排序或者出现了回表查询：sql123456789mysql&gt; explain select b.* from bill b order by b.bill_no;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+1 row in set (0.02 sec)mysql&gt; Using temporary使了用临时表保存中间结果：sql123456789mysql&gt; explain select distinct b.receiver from bill b;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+| 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 2 | 100.00 | Using temporary |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+1 row in set (0.02 sec)mysql&gt; Using join buffer (Block Nested Loop)使用连接查询时，被驱动表不能使用索引，借用了连接缓冲区，发生了嵌套循环：sql12345678910mysql&gt; explain select b.* from bill b, bill_detail bd where b.id = bd.bill_id;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+| 1 | SIMPLE | bd | NULL | index | idx_bill_id | idx_bill_id | 5 | NULL | 4 | 100.00 | Using index || 1 | SIMPLE | b | NULL | ALL | PRIMARY | NULL | NULL | NULL | 3 | 50.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+------+----------+----------------------------------------------------+2 rows in set (0.02 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"逻辑架构","slug":"E00-数据库/E02-MySQL/002-高级/002-逻辑架构","date":"2025-06-04T05:33:41.000Z","updated":"2025-06-21T18:17:08.195Z","comments":true,"path":"posts/20250604/133341/","permalink":"https://momashanhe.com/posts/20250604/133341/","excerpt":"摘要：本文了解了数据库相关的逻辑架构。","text":"摘要：本文了解了数据库相关的逻辑架构。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 架构图架构图如下： 2 分层2.1 连接层最上层是与客户端连接相关的服务： 连接管理：负责接收客户端的连接请求，处理客户端的认证信息，验证用户是否有权限连接到数据库服务器。同时，还负责管理连接的生命周期，包括连接的建立以及最终的断开。 线程管理：为每个客户端连接创建一个专用线程来处理该连接的所有请求和响应。这些线程负责读取客户端发送的查询请求，将查询请求传递给后续的处理层，并将结果返回给客户端。 2.2 服务层第二层架构主要完成大多数的核心服务功能： 查询解析与优化：解析器会将SQL语句进行词法和语法解析，检查语句是否符合MySQL的语法规则，并将其转换为内部的解析树结构。预处理器则对解析树进行进一步的处理，包括检查语句的语义是否正确，用户是否有足够的权限等。优化器会根据一些规则和算法，对查询语句进行优化，选择最合适的数据访问路径，以提高查询的执行效率。 缓存机制：包含查询缓存和结果集缓存。查询缓存会存储之前执行的查询语句及其对应的查询结果，当收到新的查询请求时，会先检查查询缓存中是否有相同的查询语句，如果有且其对应的表数据未发生变化，则直接返回缓存中的结果，从而提高查询效率。结果集缓存则是在存储过程和函数等执行时缓存结果集，以供后续调用时快速返回结果。 2.3 引擎层存储引擎层负责数据的存储和提取： 事务处理：负责处理事务相关的操作，包括事务的提交和回滚。不同的存储引擎对事务的支持程度不同，例如InnoDB引擎支持事务的完整特性，而MyISAM引擎则不支持事务。 索引管理：负责创建、维护和使用索引，索引是数据库中用于快速检索数据的结构。不同的存储引擎支持不同类型的索引。 数据缓存：对频繁访问的数据进行缓存，以减少对磁盘的访问次数。当读取数据时，优先从缓存中获取，如果缓存中不存在，则从磁盘读取数据并将其放入缓存中，同时会根据策略管理缓存空间。 2.4 存储层数据存储层主要将数据存储在文件系统上，并完成与存储引擎的交互： 数据存储与管理：负责将数据以特定的格式持久化存储在磁盘上，并负责数据的物理读写操作。不同的存储引擎有不同的数据存储格式和结构，例如InnoDB引擎采用聚簇索引的存储方式将数据和索引存储在一起，而MyISAM引擎则将数据和索引分开存储在不同的文件中。 文件系统交互：与底层的文件系统进行交互，处理数据文件的创建、打开、读写和关闭等操作。还会根据数据库的配置和存储引擎的要求，对文件的大小、增长方式等进行管理。 3 模块3.1 Connectors连接器支持多种编程语言与SQL建立连接和交互。 3.2 Management Serveices &amp; Utilities管理工具包含多种系统管理和控制工具。 3.3 Connection Pool连接池用于接收客户端请求，验证客户端的连接，分配客户端线程，并将处理结果响应客户端，以及使用缓存优化查询性能。 3.4 SQL Interface接口可以接收客户端SQL命令，返回客户端查询结果。 3.5 Parser解析器可以验证和解析SQL命令，按照不同的操作类型进行分类，做出针对性的转发到后续步骤。 3.6 Optimizer查询优化器可以对查询SQL进行优化，得出最优的策略，告诉后面的程序如何取得查询语句的结果。 3.7 Cache &amp; Buffer查询缓存可以将结果集缓存到内存中，与查询语句的哈希值对应，以后的查询如果命中缓存则直接返回缓存的结果。 3.8 Pluggable Storage Engines插件式存储引擎提供了一系列标准的管理和服务支持，每个存储引擎都可以按照其需要开发不同的功能。存储引擎是基于表的，而不是基于数据库的。 3.9 File System文件存储系统可以将数据永久保存到本地磁盘。 3.10 Files &amp; Logs文件和日志保存了执行的改动，用于进行数据恢复等操作。 4 执行流程执行图示： 4.1 缓存服务器先检查SQL语句是否命中了查询缓存，如果命中了缓存，立即返回缓存中的数据。如果没有命中缓存，则进入下一阶段。 注意： 只有相同的查询操作才会命中查询缓存。 如果查询请求中包含某些系统函数、用户自定义变量和函数、某些系统表，那这个请求就不会被缓存。 缓存系统会监测涉及到的每张表，如果该表的结构或者数据被修改，就会导致缓存失效并被删除。对于经常更新的数据库来说，查询缓存的命中率非常低。 4.2 解析在解析阶段，数据库首先会检查SQL语句的语法和语义，然后将SQL语句转换为抽象语法树（AST），为后续的优化和执行做准备。 解析器对SQL语句进行语法分析和语义分析，并最终构建内部表示： 语法分析：检查SQL语句的语法是否正确，如果发现语法错误，解析器会立即返回错误信息，停止执行。 词法分析：将输入的SQL语句分解成单独的词法单元（Token），例如关键字、标识符、操作符等。 语法分析：根据词法单元构建抽象语法树（AST），表示SQL语句的结构。 语义分析：进一步检查SQL语句的逻辑正确性。 对象验证：确保所有引用的数据库对象（表、列、视图等）存在。 权限检查：验证用户是否有权限访问或操作这些对象。 数据类型检查：确保操作符和函数的使用符合数据类型的要求。 构建内部表示：在完成语法和语义分析后，解析器会将SQL语句转换为抽象语法树（AST）用于后续的优化和执行。 4.3 优化优化器对SQL语句进行优化，目标是选择最佳的执行计划，以提高查询性能。 优化过程可以分为逻辑优化和物理优化： 逻辑优化：包括重新排列查询操作、消除冗余操作等。 谓词下推：将过滤条件尽可能先行应用，以减少处理的数据量。 连接重排：调整表连接的顺序，以优化查询性能。 物理优化：选择具体的执行策略，优化器会评估多个执行计划，选择代价最低的一个。 索引选择：选择最合适的索引，以加速数据检索。 连接算法选择：选择最优的连接算法（嵌套循环、哈希连接、合并连接等）。 4.4 执行执行阶段是数据库实际运行优化后的执行计划的过程，最终生成查询结果。 可以分为三个阶段： 生成步骤：根据优化阶段选定的执行计划，数据库会生成具体的执行步骤。这些步骤通常包括扫描表、应用过滤条件、执行连接操作等。 执行步骤：数据库按照执行计划的步骤，逐步执行查询操作。每个操作都会生成中间结果，最终合并成查询结果返回给用户。 结果返回：执行完成后，数据库会将查询结果返回给用户。对于查询操作，数据库会以表格形式返回查询的结果集。对于修改操作，数据库会返回受影响的行数。 5 存储引擎5.1 定义数据库存储引擎是数据库底层软件组件，不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 5.2 查看MySQL提供了多个不同的存储引擎，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 查看可用的数据库引擎和默认引擎： sql1234567891011121314151617mysql&gt; show engines;+--------------------+---------+---------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+---------+--------------+------+------------+| InnoDB | DEFAULT | ... | YES | YES | YES || MRG_MYISAM | YES | ... | NO | NO | NO || MEMORY | YES | ... | NO | NO | NO || BLACKHOLE | YES | ... | NO | NO | NO || MyISAM | YES | ... | NO | NO | NO || CSV | YES | ... | NO | NO | NO || ARCHIVE | YES | ... | NO | NO | NO || PERFORMANCE_SCHEMA | YES | ... | NO | NO | NO || FEDERATED | NO | ... | NULL | NULL | NULL |+--------------------+---------+---------+--------------+------+------------+9 rows in set (0.00 sec)mysql&gt; Support列的值表示引擎是否能使用： YES表示可以使用。 NO表示不能使用。 DEFAULT表示该引擎为当前默认的存储引擎。 5.3 种类5.3.1 InnoDB存储引擎InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期事务。此外，InnoDB还支持行级锁，适合高并发情况。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 5.3.2 MyISAM存储引擎MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行级锁。 MyISAM拥有较高的插入和查询速度，是在数据仓储和其他应用环境下最常使用的存储引擎之一。 5.3.3 Memory存储引擎Memory将数据存储到内存中，可以快速地访问数据，但不支持修改，并且重启以后数据会丢失。 Memory至少比MyISAM要快一个数量级，使用专业的内存数据库更快，如Redis数据库。 5.3.4 Archive存储引擎Archive只支持插入和查询操作，在MySQL 5.1之前不支持索引。 Archive适合低访问量大数据等情况，比如日志和数据采集类应用。 5.4 选择不同的存储引擎都有各自的特点，如表所示： 特点 InnoDB MyISAM Memory Archive 存储机制 64TB 256TB RAM None 锁机制 行锁 表锁 表锁 行锁 事务安全 支持 B树索引 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 数据缓存 支持 支持 支持外键 支持 数据可压缩 支持 支持 批量插入速度 低 高 高 非常高 可以根据以下的原则来选择MySQL存储引擎： 如果要提供提交和回滚，以及事务安全（ACID）能力，并要求实现并发控制，可以使用InnoDB引擎。 如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中，使用Memory引擎作为临时表，存放查询的中间结果。 如果只有插入和查询操作，可以选择Archive引擎，支持高并发的插入操作，但是本身并不是事务安全的。 使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求，使用合适的存储引擎将会提高整个数据库的性能。 5.5 对比对比InnoDB引擎和MyISAM引擎： 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，操作一条记录也会锁整个表，不适合高并发 行锁，操作时只锁某一行，不对其它行有影响，适合高并发 缓存 缓存索引，不缓存真实数据 缓存索引和真实数据，内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y 存储方式 使用.MYD格式存储数据，使用.MYI格式存储索引 使用.FRM格式存储数据和索引","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"范式","slug":"E00-数据库/E02-MySQL/002-高级/001-范式","date":"2025-05-30T23:40:50.000Z","updated":"2025-06-21T18:17:00.973Z","comments":true,"path":"posts/20250531/074050/","permalink":"https://momashanhe.com/posts/20250531/074050/","excerpt":"摘要：本文学习了关系数据库中涉及范式的相关知识。","text":"摘要：本文学习了关系数据库中涉及范式的相关知识。 环境 CentOS Linux release 7.6.1810MySQL 5.7.40 1 定义设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 但是有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。 2 名词想要正确理解范式的知识，必须先对涉及到的概念名词有一定的了解。 假设有如下两张表： 学生表：编号，姓名，身份证号，教师编号 教师表：编号，姓名 定义： 实体：可以理解为表，一张表可以看做是一种实体。 属性：可以理解为表的字段，一个字段可以看做是一个属性。 元组：可以理解为表的记录，一条记录可以看做是一个元组。 超键：能唯一标识元组的属性集。对于学生表来说，超键包括（编号），（编号，姓名），（编号，姓名，身份证号）等等。 候选键：能唯一标识元组的最小属性集，是超键的精简。对于学生表来说，候选键就是（编号）和（身份证号）。 主键：从候选键选择一个属性集作为主键。对于学生表来说，主键一般是（编号）。 外键：在其他实体中作为主键的属性集。对于学生表来说，外键是（教师编号）。对于教师表来说，主键是（编号）。 主属性：所有候选键中的属性。 非主属性：不在候选键中的属性。 3 说明目前关系数据库有六种范式： 第一范式（1NF） 第二范式（2NF） 第三范式（3NF） 巴斯-科德范式（BCNF，又称为修正的第三范式） 第四范式（4NF） 第五范式（5NF，又称完美范式） 满足最低要求的范式是第一范式（1NF），在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。 一般说来，数据库只需满足第三范式（3NF）就行了。 3.1 第一范式（1NF）要求每个属性都是原子数据项，即每个属性只包含一个值，并且不能有重复的属性。 第一范式确保表中的每个属性都是不可分割的基本数据项。 违背第一范式的数据： 编号 姓名 课程 201010 张三 语文;数学 201011 李四 语文 在课程中存在多个值的情况，违背了第一范式。 修改后的数据： 编号 姓名 课程 201010 张三 语文 201010 张三 数学 201011 李四 语文 3.2 第二范式（2NF）要求在满足第一范式的基础上，非主属性完全依赖候选键，不能部分依赖候选键。 第二范式确保在候选键为属性组的情况下，表中没有部分依赖问题。 违背第二范式的数据： 编号 姓名 课程 成绩 201010 张三 语文 97 201010 张三 数学 99 201011 李四 语文 94 将编号和课程作为候选键，共同决定成绩，但姓名只依赖编号，存在部分依赖的情况，违背了第二范式。 修改后的数据： 编号 课程 成绩 201010 语文 97 201010 数学 99 201011 语文 94 将编号和姓名单独拆分出来： 编号 姓名 201010 张三 201011 李四 3.3 第三范式（3NF）要求在满足第二范式的基础上，非主属性只能依赖主属性，不能依赖其他非主属性。 第三范式确保表中没有传递依赖问题。 违背第三范式的数据： 编号 姓名 目标 省市 201010 张三 山东大学 山东省 201011 李四 北京大学 北京市 将编号作为主键，编号决定报考的目标，报考的目标决定所在的省市，存在传递依赖的情况，违背了第三范式。 修改后的数据： 编号 姓名 目标 201010 张三 山东大学 201011 李四 北京大学 将目标和省市单独拆分出来： 目标 省市 山东大学 山东省 北京大学 北京市 3.4 巴斯-科德范式（BCNF）要求在满足第三范式的基础上，主属性完全依赖候选键，不能部分依赖候选键。 巴斯-科德范式确保在候选键为属性组的情况下，表中没有部分依赖和传递依赖问题。 违背巴斯-科德范式的数据： 编号 课程 教师 成绩 201010 语文 语文老师 93 201010 数学 数学老师 96 201011 语文 语文老师 91 将编号和课程作为主键，同时编号和教师作为候选键，都能决定成绩，但是课程也能决定教师，存在主属性部分依赖候选键的情况，违背了巴斯-科德范式。 修改后的数据： 编号 课程 成绩 201010 语文 93 201010 数学 96 201011 语文 91 将课程和教师单独拆分出来： 课程 教师 语文 语文老师 数学 数学老师 3.5 第四范式（4NF）要求在满足巴斯-科德范式的基础上，当某个属性的值确定时，只能有一条记录与之对应。 第四范式确保表中没有多值依赖问题。 违背第四范式的数据： 编号 课程 爱好 201010 语文 跑步 201010 数学 游泳 201011 语文 游泳 将编号作为主键，同时对应多个课程和多个爱好，并且课程和爱好之间没有关联，存在多值依赖的情况，违背了第四范式。 修改后的数据： 编号 课程 201010 语文 201010 数学 201011 语文 将编号和爱好单独拆分出来： 编号 爱好 201010 跑步 201010 游泳 201011 游泳 3.6 第五范式（5NF）又称为完美范式，要求在满足第四范式的基础上，不存在任何通过连接操作生成的冗余数据，即不存在多对多关系。 第五范式确保表中没有连接依赖问题。 违背第五范式的数据： 编号 课程 考试 201010 语文 期中 201010 数学 期末 201011 语文 期末 将编号作为主键，同时对应多个课程和多种考试，并且课程和考试之间存在多对多的关系，存在连接依赖的情况，违背了第五范式。 修改后的数据： 编号 课程 201010 语文 201010 数学 201011 语文 将编号和考试单独拆分出来： 编号 考试 201010 期中 201010 期末 201011 期末 4 反范式化在某些业务场景下，为了更方便快速的查询数据，往往会打破范式的规范。 反范式化最常见的场景是字段冗余，通过冗余字段可以避免多表联查，大幅提高查询效率。 冗余字段的特点： 通常很少修改。 经常需要查询。 5 设计原则创建数据库的建议： 库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。 库名中英文一律小写，不同单词采用下划线分割。须见名知意。 创建数据库时必须指定字符集，并且字符集只能是utf8或者utf8mb4。 对于程序连接数据库账号，遵循权限最小原则。使用数据库账号只能在一个DB下使用，不准跨库。 临时库以tmp_为前缀，并以日期为后缀。备份库以bak_为前缀，并以日期为后缀。 创建表的建议： 表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以英文字母开头。 表名、列名一律小写，不同单词采用下划线分割。须见名知意。 表名要求有模块名强相关，同一模块的表名尽量使用统一前缀。 创建表时必须指定字符集，并且字符集只能是utf8或者utf8mb4。 创建表时必须指定表存储引擎类型。如无特殊需求，一律为InnoDB。 创建表时必须说明表的comment内容，说明表的作用。 字段命名应尽可能使用表达实际含义的英文单词或缩写。 字段为布尔值类型时，命名建议为is_描述格式。 字段禁止存储图片和文件等大型二进制数据。建议将文件储存在服务器上，数据库只存储文件地址信息。 表中必须有主键，强制要求主键为id，并设置为int或bigint类型，并且auto_increment自增。 表中必须有行数据的创建时间字段和最后更新时间字段，便于查问题，特别是核心业务相关的表。 表中字段尽量都是NOT NULL属性，业务可以根据需要定义DEFAULT值。因为使用NULL值会占用额外存储空间，会导致数据迁移出错和聚合函数计算结果偏差等问题。 表中存储相同数据的列名和列类型必须一致。相同的字段一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低。 临时表用于保留临时结果集，名称以tmp_开头。备份表用于备份或抓取源表快照，名称以bak_开头。临时表和备份表定期清理。 创建索引的建议： 主键的名称以pk_开头，唯一键以uni_或uk_开头，普通索引以idx_开头，一律使用小写格式，以字段的名称或缩写作为后缀。 单个表上的索引个数不能超过6个。 多考虑建立联合索引，并把区分度最高的字段放在最前面。 表里不能存在冗余索引。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理事务","slug":"E00-数据库/E02-MySQL/001-基础/015-管理事务","date":"2025-05-25T01:31:23.000Z","updated":"2025-07-02T07:31:14.401Z","comments":true,"path":"posts/20250525/093123/","permalink":"https://momashanhe.com/posts/20250525/093123/","excerpt":"摘要：本文学习了如何使用DCL语句管理事务。","text":"摘要：本文学习了如何使用DCL语句管理事务。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义事务是一组逻辑处理单位，可以是执行一条SQL语句，也可以是执行几个SQL语句。 事务用来保证数据由一种存储情况变为另一种存储情况，组成事务的各个单元要么都执行成功，要么都执行失败。 1.2 作用如果只是简单的一条SQL语句的执行，那么是不需要事务的，但在一些复杂的情况下，一个操作会涉及到多条SQL语句的执行，这种情况下就有必要保证所有的操作全部成功或者全部失败。 比如小明给小红转账的操作，就会涉及到从小明账户扣钱和给小红账户充钱的两个操作： 只有两个操作都成功执行了整个操作才算成功，这时就可以提交整个事务，状态由转账前变为转账后。 如果任何一个操作执行失败的话整个操作都要算做失败，这时就需要恢复事务，保证两个账户上的金额和转账前是一样的，状态恢复到转账前。 事务保证了一组操作的完整性和安全性。 1.3 存储引擎默认使用InnoDB引擎，支持事务。 使用命令查看数据库支持的存储引擎，以及存储引擎是否支持事务： sql1234567891011121314151617mysql&gt; show engines;+--------------------+---------+---------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+---------+--------------+------+------------+| InnoDB | DEFAULT | ... | YES | YES | YES || MRG_MYISAM | YES | ... | NO | NO | NO || MEMORY | YES | ... | NO | NO | NO || BLACKHOLE | YES | ... | NO | NO | NO || MyISAM | YES | ... | NO | NO | NO || CSV | YES | ... | NO | NO | NO || ARCHIVE | YES | ... | NO | NO | NO || PERFORMANCE_SCHEMA | YES | ... | NO | NO | NO || FEDERATED | NO | ... | NULL | NULL | NULL |+--------------------+---------+---------+--------------+------+------------+9 rows in set (0.00 sec)mysql&gt; 在Transactions列中显示YES表示支持事务。 1.4 事务特性事务有四种特性： 原子性（Atomicity）：指事务包含的所有操作要么全部成功提交，要么全部失败回滚。 一致性（Consistency）：指事务必须使数据库的数据和资源从一个一致性状态变换到另一个一致性状态。 隔离性（Isolation）：指当多个用户并发访问数据库并且操作同一张表时，数据库为每一个用户开启事务，不会被其他事务的操作干扰，多个并发事务之间相互隔离。 持久性（Durability）：指一个事务一旦被提交了，对数据的改变就是永久性的，哪怕数据库遇到故障也不会丢失提交的改动。 1.5 基本术语涉及事务的几个术语： 保存点（Savepoint）：指在事务执行前或者事务执行后，数据在数据库里的存储情况，有时也称为状态。 回退（Rollback）：指撤销事务的操作，事务期间执行的操作都将失效，事务恢复到上个状态。 提交（Commit）：指提交事务的操作，事务期间执行的操作全部生效，事务进入新的状态。 1.6 并发问题对事务的操作分为两类：一种是读取事务（查），另一种是修改事务（增删改）。 单个事务的情况下，不会产生并发问题。如果多个事务在同一时刻操作同一数据可能会影响最终期望的结果，产生并发问题。 常见的并发问题： 脏写：更新时更新。事务一更新数据未提交，事务二更新相同数据并提交，事务一回滚，事务二提交的更新数据无效。 脏读：更新时读取。事务一更新数据未提交，事务二读取数据，事务一回滚，事务二读取的数据无效。 不可重复读：读取时更新或者删除。事务一读取数据，事务二修改数据或者删除数据，在事务二提交，事务一读取到不同的数据。 幻读：读取时插入。事务一读取数据，事务二插入数据，在事务二提交，事务一读取到插入的数据。 更新丢失： 第一类更新丢失：更新时更新。事务一更新数据并提交，事务二更新相同数据并回滚，事务一提交的更新数据无效。 第二类更新丢失：更新时更新。事务一更新数据并提交，事务二更新相同数据并提交，事务一提交的更新数据无效。 数据库不允许第一类更新丢失问题，第二类更新丢失问题无法通过隔离级别解决，一般使用锁解决。 1.7 隔离级别为了解决不同程度的并发问题，SQL标准定义了隔离级别，每个级别都有各自的具体规则。 主要的隔离级别有四种： 读未提交（RU，Read Uncommitted）：最低的隔离级别，可以看到未提交事务的执行结果，同时更新相同数据会阻塞。可避免脏写。 读已提交（RC，Read Committed）：大多数系统的默认隔离级别，但不是MySQL默认隔离级别，只能看到已提交事务的执行结果。可避免脏写、脏读。 可重复读（RR，Repeatable Read）：MySQL默认隔离级别，在事务执行期间，读取的都是相同的数据。可避免脏写、脏读、不可重复读。 串行化（S，Serializable）：最高的隔离级别，通过强制事务排序解决并发问题。在每个读操作的数据行增加共享锁，可能导致大量超时和竞争。可避免脏写、脏读、不可重复读、幻读。 MySQL的默认隔离级别是RR级别，InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了幻读的问题。 2 操作2.1 自动提交查询事务自动提交： sql1select @@autocommit; 开启自动提交： sql1set autocommit = 1; 关闭自动提交： sql1set autocommit = 0; 2.2 开启事务语法： sql1start transaction; 也可以使用begin;或者begin work;开启事务。 2.3 提交事务语法： sql1commit; 也可以使用commit work;提交事务。 示例： sql1234567891011mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update student set sex = &#x27;女&#x27; where id = 904;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; commit;Query OK, 0 rows affected (0.01 sec)mysql&gt; 2.4 回滚事务语法： sql1rollback; 也可以使用rollback work;回滚事务。 示例： sql1234567891011mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update student set sex = &#x27;女&#x27; where id = 904;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.5 设置还原点还原点必须要在事务内才能使用，否则会产生错误。 创建还原点： sql1savepoint 名称; 回滚还原点： sql1rollback to 名称; 删除还原点： sql1release savepoint 名称; 2.6 设置隔离级别查看当前事务的隔离级别： sql1select @@tx_isolation; 设置隔离级别： sql1set tx_isolation = &quot;隔离级别名称&quot;; 隔离级别名称： Read-Uncommitted：读未提交。 Read-Committed：读已提交。 Repeatable-Read：可重复读。 Serializable：串行化。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理用户权限","slug":"E00-数据库/E02-MySQL/001-基础/014-管理用户权限","date":"2025-05-24T13:23:05.000Z","updated":"2025-06-21T09:07:51.662Z","comments":true,"path":"posts/20250524/212305/","permalink":"https://momashanhe.com/posts/20250524/212305/","excerpt":"摘要：本文学习了如何使用DCL语句管理用户权限。","text":"摘要：本文学习了如何使用DCL语句管理用户权限。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 用户用户指的是操作和使用数据库的人，使用数据库需要用户先通过用户名和密码进行连接，然后才能进行操作，不同的用户可以设置不同的权限。 在MySQL数据库中，所有的用户信息都保存在user表中。 1.2 权限权限用来控制用户对数据库的操作，可以限制用户只能访问特定的数据，或者只能执行特定的操作。 2 操作2.1 查看用户查看user表的结构： sql1234567891011mysql&gt; desc user;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| Host | char(60) | NO | PRI | | || User | char(32) | NO | PRI | | || ... | ... | ... | ... | | |+-------+----------+------+-----+---------+-------+45 rows in set (0.00 sec) mysql&gt; 在MySQL数据库中，对用户的管理是通过对应的Host和User共同组成的主键来区分的。 其中，User代表用户的用户名，Host代表允许访问的客户端地址（IP地址或者是主机地址），使用*表示所有的客户端都可以访问。 查询user表数据： sql12345678910mysql&gt; select host, user, password from user;+-----------+------+| host | user |+-----------+------+| localhost | root || ... | ... |+-----------+------+3 rows in set (0.00 sec)mysql&gt; 在安装MySQL数据库的时候，如果没有创建匿名用户，那么在user表里只有一个root用户。 在创建新用户或更改密码后需要使用flush privileges;命令刷新权限相关表，否则会出现拒绝访问。也可以重新启动数据库使新设置生效。 2.2 创建用户语法： sql1create user 用户名@主机地址 identified by 明文密码; 说明： 省略@主机地址表示任何IP地址都可以使用这个用户。 省略identified by 明文密码表示不需要密码就可以登录。 示例： sql1234mysql&gt; create user &#x27;test&#x27; identified by &#x27;123456&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.3 删除用户语法： sql1drop user 用户名@主机地址; 示例： sql1234mysql&gt; drop user &#x27;test&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.4 修改密码语法： sql1alter user 用户名@主机地址 identified by 明文密码; 示例： sql1234mysql&gt; alter user &#x27;test&#x27; identified by &#x27;123456&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.5 用户授权语法： sql1grant 权限列表 on 库名.表名 to 用户名@主机地址 indentified by 明文密码 [with grant option] [with admin option] 说明： 使用with grant option授权，在取消时会撤销连带的权限。 使用with admin option授权，在取消时会保留连带的权限。 示例： sql12grant all on *.* to &#x27;test&#x27; identified by &#x27;123456&#x27; with grant option;grant select (id, name) on demo.test to &#x27;test&#x27;; 2.6 取消授权语法： sql1revoke 权限列表 on 库名.表名 from 用户名@主机地址 示例： sql1234mysql&gt; revoke all on *.* from &#x27;test&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理触发器","slug":"E00-数据库/E02-MySQL/001-基础/013-管理触发器","date":"2025-05-24T08:25:41.000Z","updated":"2025-06-21T09:07:51.758Z","comments":true,"path":"posts/20250524/162541/","permalink":"https://momashanhe.com/posts/20250524/162541/","excerpt":"摘要：本文学习了如何使用DDL语句管理触发器。","text":"摘要：本文学习了如何使用DDL语句管理触发器。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义触发器与存储过程和函数一样，都是由SQL语句和过程式语句组成的代码片段。 触发器需要由某个事件触发某个操作，这些事件包括增删改的DML操作。当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。 1.2 比较与存储过程和函数相比，触发器有以下几个特点： 触发器不需要显示调用，当事件触发时会自动调用。 触发器没有返回值，其执行结果是直接对表中的数据进行修改或对触发事件进行处理。 触发器主要用于维护数据的一致性和完整性。 2 操作2.1 创建语法： sql1234create trigger 触发器名称 触发时间 触发事件 on 表名 for each row 触发器主体; 说明： 触发器名称：指定触发器的名称。 触发时间：before表示在事件之前触发，after表示在事件之后触发。 触发事件：insert表示插入记录时触发，update表示更新记录时触发，delete表示删除记录时触发。 表名：表示触发器监控的对象。 触发器主体：触发器的主体部分，可以是单条SQL语句，也可以是被begin和end包裹的复合语句块。 示例： sql1234create trigger scoreBeforeInsertbefore insert on scorefor each row insert into score_log (action) values (&#x27;insert&#x27;); 2.2 查看查看所有触发器： sql1show triggers; 查看触发器的创建： sql1show create trigger 触发器名称; 2.3 修改可以通过先删除触发器，然后重新创建触发器的方法实现修改的操作。 2.4 删除语法： sql1drop trigger 触发器名称; 示例： sql1234mysql&gt; drop trigger scoreBeforeInsert;Query OK, 0 rows affected (0.00 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理函数","slug":"E00-数据库/E02-MySQL/001-基础/012-管理函数","date":"2025-05-23T02:08:41.000Z","updated":"2025-06-21T09:07:51.567Z","comments":true,"path":"posts/20250523/100841/","permalink":"https://momashanhe.com/posts/20250523/100841/","excerpt":"摘要：本文学习了如何使用DDL语句管理函数。","text":"摘要：本文学习了如何使用DDL语句管理函数。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义函数是一种与存储过程十分相似的过程式数据库对象。它与存储过程一样，都是由SQL语句和过程式语句组成的代码片段，但函数可以在SQL语句中直接调用。 1.2 函数与存储过程的区别函数不能拥有输出参数，因为函数自身就是输出参数，存储过程可以拥有输出参数。 函数中必须有返回值，存储过程没有返回值。 可以直接对函数进行调用而不需要使用call语句，对存储过程的调用需要使用call语句。 2 操作2.1 创建语法： sql123create function 函数名称([参数])returns 类型函数主体 说明： 函数名称：指定函数的名称。注意，函数不能与存储过程具有相同的名称。 参数：指定函数的参数。这里的参数只有名称和类型，不能指定参数类型。 类型：声明函数返回值的数据类型。 函数主体：函数的主体部分，和存储主体类似，函数主体还必须包含返回值。在返回值中包含select语句时，只能是一行且只能有一列值。 创建不带参数的函数： sql123create function showMaxGrade()returns int(10)return (select max(grade) from score); 创建带有参数的函数： sql123create function showStuGrade(stu varchar(45))returns int(10)return (select grade from score where student = stu); 创建带有多个语句的函数： sql123456789delimiter $$create function showRandGrade()returns int(5) begin declare i int default 0; set i = floor(rand() * 10); return i; end $$delimiter ; 2.2 使用语法： sql1select 函数名称([参数]); 示例： sql123456789mysql&gt; select showMaxGrade();+----------------+| showMaxGrade() |+----------------+| 98 |+----------------+1 row in set (0.00 sec)mysql&gt; 2.3 查看查看所有函数： sql1show function status; 查看函数的创建： sql1show create function 函数名称; 2.4 修改可以通过先删除函数，然后重新创建函数的方法实现修改的操作。 2.5 删除语法： sql1drop function 函数名称; 示例： sql1234mysql&gt; drop function showMaxGrade;Query OK, 0 rows affected (0.00 sec)mysql&gt; 3 单行函数处理字符串： 函数 用法 LENGTH(s) 返回字符串s的字节数，和字符集有关 CONCAT(s1,s2,...,sn) 连接s1,s2,...,sn为一个字符串 SUBSTR(s,index,len) 返回字符串s从index位置开始的len个字符，位置index从1开始 LOCATE(substr,s) 返回字符串substr在字符串s中首次出现的位置，位置从1开始，未找到返回0 获取日期时间： 函数 用法 CURDATE() / CURRENT_DATE() 返回当前日期，只包含年月日 CURTIME() / CURRENT_TIME() 返回当前时间，只包含时分秒 NOW() / LOCALTIME() / LOCALTIMESTAMP() 返回当前系统日期和时间 YEAR(date) / MONTH(date) / DAY(date) 返回指定日期的年月日 HOUR(time) / MINUTE(time) / SECOND(time) 返回指定时间的时分秒 MONTHNAME(date) 返回指定日期对应的月份 DAYNAME(date) 返回指定日期对应的星期 WEEKOFYEAR(date) 返回指定日期是一年中的第几周 DAYOFYEAR(date) 返回指定日期是一年中的第几天 DAYOFMONTH(date) 返回指定日期是一月中的第几天 DAYOFWEEK(date) 返回指定日期是一周中的第几天，1表示周日，2表示周一，以此类推，7表示周六 处理日期和时间： 函数 用法 DATE_FORMAT(date, fmt) 按照fmt格式将日期date转为字符串 TIME_FORMAT(time, fmt) 按照fmt格式将时间time转为字符串 STR_TO_DATE(str, fmt) 按照fmt格式将字符串str转为日期时间 格式符： 字符 说明 %Y 四位数字表示年份 %m 两位数字表示月份 %d 两位数字表示月中的天数 %H 两位数字表示24小时制的小时数 %i 两位数字表示分钟数 %s 两位数字表示秒数 流程控制： 函数 用法 IF(value,value1,value2) 如果value为TRUE，则返回value1，否则返回value2 IFNULL(value1, value2) 如果value1不为NULL，则返回value1，否则返回value2 NULLIF(value1,value2) 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1 CASE WHEN 条件1 THEN 值1 ... [ELSE 值1] END 依次判断条件并返回对应的值，相当于IF-ELSE判断语句 CASE 表达式 WHEN 条件1 THEN 值1 ... [ELSE 值n] END 依次判断表达式和条件是否相等并返回对应的值，相当于SWITCH-CASE判断语句 加密和解密： 函数 用法 PASSWORD(str) 返回字符串str的加密版本，加密结果不可逆，常用于密码加密 MD5(str) 返回字符串str经过MD5加密后的值，若参数为NULL，则会返回NULL SHA(str) 返回字符串str经过SHA加密后的值，若参数为NULL，则会返回NULL，比MD5更加安全 获取信息： 函数 用法 VERSION() 返回当前的版本号 CONNECTION_ID() 返回当前的连接数 DATABASE() / SCHEMA() 返回当前连接的数据库 USER() / CURRENT_USER() 返回当前连接的用户名 4 聚合函数聚合函数常用于分组后的处理： 函数 用法 AVG(column) 对数值型数据求平均值 SUM(column) 对数值型数据求和 MIN(column) 对任意类型的数据求最小值 MAX(column) 对任意类型的数据求最大值 COUNT(column) 统计任意类型的数据记录总数 比较COUNT(*)&#x2F;COUNT(1)&#x2F;COUNT(column)区别： 对于MyISAM引擎的表没有区别，对于Innodb引擎的表有些区别。 对于Innodb引擎的表，使用COUNT(*)和COUNT(1)的时间复杂度是O(n)，优于使用COUNT(column)的时间复杂度。 使用COUNT(*)和COUNT(1)会统计值为NULL的行，使用COUNT(column)不会统计值为NULL的行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理存储过程","slug":"E00-数据库/E02-MySQL/001-基础/011-管理存储过程","date":"2025-05-22T08:03:27.000Z","updated":"2025-06-21T09:07:51.189Z","comments":true,"path":"posts/20250522/160327/","permalink":"https://momashanhe.com/posts/20250522/160327/","excerpt":"摘要：本文学习了如何使用DDL语句管理存储过程。","text":"摘要：本文学习了如何使用DDL语句管理存储过程。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义存储过程是一组为了完成特定功能的SQL语句集合。 将常用或复杂的工作预先用SQL语句写好，将这些SQL存储起来，这个过程经过编译和优化后存储在数据库服务器中，因此称为存储过程。 1.2 优点性能方面： 减少网络通信：把多条SQL语句封装成存储过程，客户端调用时只需发送一个调用命令，避免逐条发送SQL语句产生的大量网络通信，减少网络延迟和带宽占用。 预编译和缓存：存储过程首次调用时被预编译并缓存，后续调用直接使用缓存的编译结果，无需重复编译，提高执行效率。 安全方面： 权限控制：可对存储过程设置权限，用户获得执行特定存储过程的权限后，无需拥有对底层表的直接访问权限，限制用户对数据库的访问范围，降低数据被错误修改或泄露风险。 封装敏感操作：将复杂、敏感的数据操作逻辑（如涉及多个表更新的事务、核心商业机密计算等）封装在存储过程内部，其代码在服务器端执行，不易被篡改或被恶意用户获取敏感信息。 维护方面： 代码重用：存储过程可被多个应用程序或用户调用，避免在每个应用程序中重复编写相同的SQL代码，提高代码可维护性。 集中管理：数据库逻辑集中在服务器端，修改业务逻辑时，只需在服务器端修改存储过程，所有依赖该存储过程的应用程序都能自动使用新的逻辑，减少维护成本。 2 操作2.1 创建2.1.1 基础语法： sql12create procedure 存储过程名称([参数])存储过程主体 如果开启了二进制日志会导致执行失败，有两种解决办法： 使用命令：sql1set global log_bin_trust_function_creators = 1; 修改配置文件：my.ini1log_bin_trust_function_creators = 1 说明： 存储过程名称：存储过程的名称，默认在当前数据库中创建，可以通过数据库名.存储过程名指定数据库创建存储过程。 参数：存储过程的参数列表。 存储过程主体：存储过程的主体部分，包含在过程调用的时候必须执行的SQL语句。可以是单条SQL语句，也可以是被begin和end包裹的复合语句块。 示例： sql123456delimiter $$create procedure showScore()begin select * from score;end $$delimiter ; 2.1.2 参数参数的格式如下： sql1[in|out|inout] 参数名 参数类型 支持三种类型的参数： 输入参数：用in关键字标识，可以传递存储过程。 输出参数：用out关键字标识，用于存储过程需要返回操作结果的情形。 输入&#x2F;输出参数：用inout关键字标识，既可以充当输入参数也可以充当输出参数。 需要注意的是，参数的取名不要与数据表的列名相同，多个参数时需要用逗号分隔，没有参数时需要保留括号。 2.1.3 关键字存储过程主体中常用的关键字： delimiter：修改语句结束字符。不建议使用;符号，因为这是默认结束字符，该符号后面的存储过程不会执行。也不建议使用\\符号，该符号是转义字符。 begin：存储过程开始符号。 end：存储过程结束符号。 set：变量赋值。 declare：声明变量和条件。 2.2 使用语法： sql1call 存储过程名称([参数]); 示例： sql1234567891011121314151617181920212223mysql&gt; call showScore();+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 2 | 张三 | 英语 | 53 || 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 || 6 | 赵六 | 计算机 | 70 || 7 | 赵六 | 英语 | 92 || 8 | 赵六 | 中文 | 73 || 9 | 孙七 | 英语 | 94 || 10 | 周八 | 计算机 | 90 || 11 | 周八 | 英语 | 85 || 12 | 吴九 | 计算机 | 90 || 13 | 吴九 | 中文 | 55 |+----+---------+--------+-------+13 rows in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.3 查看查看所有存储过程： sql1show procedure status; 查看存储过程的创建： sql1show create procedure 存储过程名称; 2.4 修改可以通过先删除存储过程，然后重新创建存储过程的方法实现修改的操作。 2.5 删除语法： sql1drop procedure 存储过程名称; 示例： sql1234mysql&gt; drop procedure showScore;Query OK, 0 rows affected (0.00 sec)mysql&gt; 3 变量3.1 系统变量系统定义的变量，根据生效范围可以分为全局变量和会话变量： 全局变量：在所有会话有效，修改会影响所有会话，服务重启后失效。 会话变量：只在当前会话有效，修改只会影响当前会话，断开连接后失效。 3.1.1 全局变量查看变量列表： sql1show global variables [like 搜索条件]; 查看变量的值： sql1select @@global.变量名; 可以通过命令修改变量的值，修改后立即生效，服务重启后恢复默认值： sql12set @@global.变量名 = 变量值;set global 变量名 = 变量值; 也可以通过配置文件修改变量的值，服务重启后生效。 3.1.2 会话变量查看变量列表： sql12show variables [like 搜索条件];show session variables [like 搜索条件]; 查看变量的值： sql12select @@变量名;select @@session.变量名; 只能通过命令修改变量的值，修改后立即生效，断开连接后恢复默认值： sql1234set @@变量名 = 变量值;set @@session.变量名 = 变量值;set 变量名 = 变量值;set session 变量名 = 变量值; 3.2 用户变量用户定义的变量，根据生效范围可以分为会话变量和局部变量： 会话变量：只在当前会话有效，修改只会影响当前会话，断开连接后失效。 局部变量：只在存储过程和函数中的语句块中有效。 3.2.1 会话变量会话变量的变量名前面需要使用@符号进行标识。 定义： 直接定义：sql12set @变量名 = 变量值;set @变量名 := 变量值; 查询定义：sql12select @变量名 := 表达式 [from 查询语句];select 表达式 into @变量名 [from 查询语句]; 使用： sql1select @变量名; 3.2.2 局部变量局部变量的变量名前面不需要使用任何标识。 声明： sql1declare 变量名 类型 [default 值]; 说明： 只能在存储过程或函数的begin和end语句块中声明，并且需要在首行声明。 如果在声明时没有定义默认值，则使用NULL作为初始值。 赋值： 直接赋值：sql12set 变量名 = 变量值;set 变量名 := 变量值; 查询赋值：sql12select 变量名 := 表达式 [from 查询语句];select 表达式 into 变量名 [from 查询语句]; 使用： sql1select 变量名; 4 错误处理4.1 默认错误处理在执行存储过程和函数时，如果遇到错误，服务器会退出当前逻辑停止执行，并抛出错误。 如果需要在出现错误时，根据不同的错误类型进行不同的错误处理，保证程序逻辑的完整执行，就需要对错误进行处理。 4.2 错误条件语法： sql1declare 错误名称 condition for 错误类型; 错误类型： 错误码：错误对应的数值代码。 SQLSTATE &#x3D; 错误字符串码：错误对应的字符串代码。 错误条件是可选的，其目的是为处理逻辑提供更加明确的错误名称。 4.3 处理逻辑语法： sql1declare 处理方式 handler for 错误类型 处理语句; 处理方式： CONTINUE：表示遇到错误不处理，继续执行。 EXIT：表示遇到错误马上退出。 UNDO：表示遇到错误后撤回之前的操作。MySQL中暂时不支持。 错误类型： 错误码：错误对应的数值代码。 SQLSTATE 错误字符串码：错误对应的字符串代码。 错误名称：错误条件中定义的错误名称。 SQLWARNING：匹配所有以01开头的SQLSTATE错误。 NOT FOUND：匹配所有以02开头的SQLSTATE错误。 SQLEXCEPTION：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误。 处理语句： 可以通过设置变量进行处理。 也可以通过复合语句进行处理。 处理逻辑是必选的，匹配指定的错误条件并执行相应的处理逻辑。 5 流程控制5.1 判断语句5.1.1 if语句语法： sql1234if 条件 then 命令[elseif 条件 then 命令][else 命令]end if; 示例： sql123456789101112delimiter $$create procedure fixSex(in id int, in sex int)begin if sex = 0 then update student s set s.sex = &#x27;女&#x27; where s.id = id; elseif sex = 1 then update student s set s.sex = &#x27;男&#x27; where s.id = id; else update student s set s.sex = &#x27;未知&#x27; where s.id = id; end if;end $$delimiter ; 5.1.2 case语句语法： sql12345case 变量when 条件 then 命令[...]else 命令end case; 示例： sql12345678910111213delimiter $$create procedure fixSex(in id int, in sex int)begin case sex when 0 then update student s set s.sex = &#x27;女&#x27; where s.id = id; when 1 then update student s set s.sex = &#x27;男&#x27; where s.id = id; else update student s set s.sex = &#x27;未知&#x27; where s.id = id; end case;end $$delimiter ; 5.2 循环语句5.2.1 while语句当条件成立时执行循环。 语法： sql123while 条件 do 命令end while; 示例： sql12345678910delimiter $$create procedure addStudent(in start int, in num int)begin declare i int default 0; while i &lt; num do insert into student(id) values (start + i); set i = i + 1; end while;end $$delimiter ; 5.2.2 repeat语句当条件成立时结束循环。 语法： sql1234repeat 命令 until 条件end repeat; 示例： sql1234567891011delimiter $$create procedure addStudent(in start int, in num int)begin declare i int default 0; repeat insert into student(id) values (start + i); set i = i + 1; until i &gt;= num end repeat;end $$delimiter ; 5.2.3 loop语句可以在循环里判断，可以使用leave跳出循环，也可以使用iterate结束循环。 语法： sql1234567循环名称: loop 命令 if 条件 then leave 循环名称; iterate 循环名称; end if;end loop 循环名称; 示例： sql12345678910111213141516delimiter $$create procedure addStudent(in start int, in num int)begin declare i int default 0; ADD_STUDENT: loop insert into student(id) values (start + i); set i = i + 1; if i == 0 then iterate ADD_STUDENT; end if; if i &gt;= num then leave ADD_STUDENT; end if; end loop ADD_STUDENT;end $$delimiter ;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理视图","slug":"E00-数据库/E02-MySQL/001-基础/010-管理视图","date":"2025-05-22T03:32:08.000Z","updated":"2025-06-21T09:07:51.472Z","comments":true,"path":"posts/20250522/113208/","permalink":"https://momashanhe.com/posts/20250522/113208/","excerpt":"摘要：本文学习了如何使用DDL语句管理视图。","text":"摘要：本文学习了如何使用DDL语句管理视图。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义视图是从表或者视图中导出的虚拟表，包含一系列带有名称的数据列和若干条数据行。 1.2 特点视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。 视图是查看数据表的一种方法，可以查询数据表中某些列构成的数据，只是一些SQL语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。 视图的建立和删除只影响视图本身，不影响对应的基本表。 1.3 注意视图不包含数据，所以每次使用视图时，都必须执行查询操作。 如果用多个连接和过滤条件创建了复杂的视图，可能会发现系统运行性能下降得十分严重。在部署大量视图应用时，应该进行系统测试。 修改视图数据的语句实际上是通过修改表的数据实现的，对于可修改的视图，视图中的行和基本表的行之间必须具有一对一的关系。 2 操作2.1 创建语法： sql1create view 视图名 (列1, 列2, ..., 列n) as 查询语句; 列名可以任意取名，但数量必须和查询的列名相等，如果不指明视图的列名，默认使用查询语句的列名。 创建一个简单的视图： sql1234mysql&gt; create view score_view as select * from score;Query OK, 0 rows affected (0.01 sec)mysql&gt; 创建视图并指定列： sql1234mysql&gt; create view score_view (编号, 学生, 科目, 成绩) as select id, student, course, grade from score;Query OK, 0 rows affected (0.00 sec)mysql&gt; 2.2 查看语法： sql1desc 视图名; 示例： sql123456789101112mysql&gt; desc score_view;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| 编号 | int(10) | NO | | 0 | || 学生 | varchar(20) | NO | | NULL | || 科目 | varchar(20) | NO | | NULL | || 成绩 | int(10) | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)mysql&gt; 说明： Field：列名。 Type：类型。 Null：表示该列是否可以存储NULL值。 Key：表示该列是否已编制索引。PRI表示该列是主键的一部分，UNI表示该列是UNIQUE索引的一部分，MUL表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如：AUTO_INCREMENT等。 2.3 修改语法： sql1alter view 视图名 (列1, 列2, ..., 列n) as 查询语句; 示例： sql1234mysql&gt; alter view score_view (学生, 课程, 成绩) as select student, course, grade from score;Query OK, 0 rows affected (0.01 sec)mysql&gt; 2.4 删除语法： sql1drop view 视图名; 示例： sql1234mysql&gt; drop view score_view;Query OK, 0 rows affected (0.00 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"查询数据","slug":"E00-数据库/E02-MySQL/001-基础/009-查询数据","date":"2025-05-21T07:13:47.000Z","updated":"2025-06-21T09:07:51.948Z","comments":true,"path":"posts/20250521/151347/","permalink":"https://momashanhe.com/posts/20250521/151347/","excerpt":"摘要：本文学习了如何使用DQL语句查询数据。","text":"摘要：本文学习了如何使用DQL语句查询数据。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 查询查询数据： sql1234567select [distinct] 列1 [as &#x27;别名1&#x27;], ..., 列n [as &#x27;别名n&#x27;]from 表名[where 表达式][group by 表达式][having 表达式][order by 表达式][limit 起始编号, 查询条数]; 说明： select：指定查询的字段，多个字段用,分隔，全部字段使用*号代替，使用distinct关键字对结果去重，使用as关键字设置结果显示的别名，可以省略as关键字。 from：指定查询的表，可以是单个或多个，多个表名用,分隔。 where：可选，指定查询的条件。 group by：可选，指定对结果按哪些字段分组。 having：可选，指定分组后查询的条件，用于使用聚合函数的查询条件。 order by：可选，指定排序的方式，使用asc按升序排列，使用desc按降序排列，默认按升序排列。 limit：可选，指定查询的起始编号和查询条数，起始编号可以省略，默认从0开始查询。 查询虚拟表，虚拟表可以省略： sql123456789mysql&gt; select 1 + 1 as sum from dual;+-----+| sum |+-----+| 2 |+-----+1 row in set (0.00 sec)mysql&gt; 查询所有字段： sql123456789101112131415161718192021mysql&gt; select * from score;+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 2 | 张三 | 英语 | 53 || 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 || 6 | 赵六 | 计算机 | 70 || 7 | 赵六 | 英语 | 92 || 8 | 赵六 | 中文 | 73 || 9 | 孙七 | 英语 | 94 || 10 | 周八 | 计算机 | 90 || 11 | 周八 | 英语 | 85 || 12 | 吴九 | 计算机 | 90 || 13 | 吴九 | 中文 | 55 |+----+---------+--------+-------+13 rows in set (0.05 sec)mysql&gt; 查询指定字段： sql123456789101112131415161718192021mysql&gt; select student, course, grade from score;+---------+--------+-------+| student | course | grade |+---------+--------+-------+| 张三 | 计算机 | 98 || 张三 | 英语 | 53 || 李四 | 计算机 | 48 || 李四 | 中文 | 38 || 王五 | 中文 | 95 || 赵六 | 计算机 | 70 || 赵六 | 英语 | 92 || 赵六 | 中文 | 73 || 孙七 | 英语 | 94 || 周八 | 计算机 | 90 || 周八 | 英语 | 85 || 吴九 | 计算机 | 90 || 吴九 | 中文 | 55 |+---------+--------+-------+13 rows in set (0.05 sec)mysql&gt; 查询课程并去重： sql1234567891011mysql&gt; select distinct course from score;+--------+| course |+--------+| 计算机 || 英语 || 中文 |+--------+3 rows in set (0.05 sec)mysql&gt; 查询指定字段并设置显示别名： sql123456789101112131415161718192021mysql&gt; select student &#x27;姓名&#x27;, course &#x27;课程&#x27;, grade &#x27;成绩&#x27; from score;+------+--------+------+| 姓名 | 课程 | 成绩 |+------+--------+------+| 张三 | 计算机 | 98 || 张三 | 英语 | 53 || 李四 | 计算机 | 48 || 李四 | 中文 | 38 || 王五 | 中文 | 95 || 赵六 | 计算机 | 70 || 赵六 | 英语 | 92 || 赵六 | 中文 | 73 || 孙七 | 英语 | 94 || 周八 | 计算机 | 90 || 周八 | 英语 | 85 || 吴九 | 计算机 | 90 || 吴九 | 中文 | 55 |+------+--------+------+13 rows in set (0.05 sec)mysql&gt; 查询指定条数的数据： sql12345678910111213mysql&gt; select * from score limit 5;+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 2 | 张三 | 英语 | 53 || 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 |+----+---------+--------+-------+5 rows in set (0.05 sec)mysql&gt; 查询课程的成绩并从高到低排序： sql123456789101112mysql&gt; select * from score where course = &#x27;中文&#x27; order by grade desc;+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 5 | 王五 | 中文 | 95 || 8 | 赵六 | 中文 | 73 || 13 | 吴九 | 中文 | 55 || 4 | 李四 | 中文 | 38 |+----+---------+--------+-------+4 rows in set (0.05 sec)mysql&gt; 查询成绩并按课程分组，最后计算每个课程的平均分： sql1234567891011mysql&gt; select course, avg(grade) from score group by course;+--------+------------+| course | avg(grade) |+--------+------------+| 中文 | 65.2500 || 英语 | 81.0000 || 计算机 | 79.2000 |+--------+------------+3 rows in set (0.05 sec)mysql&gt; 查询成绩并按课程分组，最后计算每个课程的平均分，只显示平均分大于70的结果： sql12345678910mysql&gt; select course, avg(grade) from score group by course having avg(grade) &gt; 70;+--------+------------+| course | avg(grade) |+--------+------------+| 英语 | 81.0000 || 计算机 | 79.2000 |+--------+------------+2 rows in set (0.05 sec)mysql&gt; 查询计算机课程的成绩： sql12345678910111213mysql&gt; select * from score where course = &#x27;计算机&#x27;;+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 3 | 李四 | 计算机 | 48 || 6 | 赵六 | 计算机 | 70 || 10 | 周八 | 计算机 | 90 || 12 | 吴九 | 计算机 | 90 |+----+---------+--------+-------+5 rows in set (0.05 sec)mysql&gt; 2 连接查询2.1 内连接查询内连接查询返回的是同时满足两个结果集的记录。 使用inner join内连接两个表，可以省略inner关键字。 查询学生信息以及计算机课程的成绩： sql1234567891011121314mysql&gt; select stu.*, sco.course, sco.grade -&gt; from student stu -&gt; join score sco on stu.name = sco.student and sco.course = &#x27;计算机&#x27;;+-----+------+-----+-------+------------+--------------+--------+-------+| id | name | sex | birth | department | address | course | grade |+-----+------+-----+-------+------------+--------------+--------+-------+| 101 | 张三 | 女 | 1990 | 中文系 | 湖南省永州市 | 计算机 | 98 || 102 | 李四 | 男 | 1990 | 英语系 | 辽宁省阜新市 | 计算机 | 48 || 106 | 周八 | 男 | 1986 | 中文系 | 北京市昌平区 | 计算机 | 90 || 107 | 吴九 | 女 | 1996 | 中文系 | 湖北省武汉市 | 计算机 | 90 |+-----+------+-----+-------+------------+--------------+--------+-------+4 rows in set (0.05 sec)mysql&gt; 结果仅显示有计算机课程成绩的记录，没有成绩的不显示。 2.2 外连接查询外连接分为左外连接和右外连接，分别以左表和右表作为主表匹配，保留主表中存在的数据。 使用left join建立左外连接，使用right join建立右外连接。 查询学生信息以及计算机课程的成绩： sql1234567891011121314151617mysql&gt; select stu.*, sco.course, sco.grade -&gt; from student stu -&gt; left join score sco on stu.name = sco.student and sco.course = &#x27;计算机&#x27;;+-----+------+-----+-------+------------+--------------+--------+-------+| id | name | sex | birth | department | address | course | grade |+-----+------+-----+-------+------------+--------------+--------+-------+| 101 | 张三 | 女 | 1990 | 中文系 | 湖南省永州市 | 计算机 | 98 || 102 | 李四 | 男 | 1990 | 英语系 | 辽宁省阜新市 | 计算机 | 48 || 106 | 周八 | 男 | 1986 | 中文系 | 北京市昌平区 | 计算机 | 90 || 107 | 吴九 | 女 | 1996 | 中文系 | 湖北省武汉市 | 计算机 | 90 || 103 | 王五 | 女 | 1991 | 英语系 | 福建省厦门市 | NULL | NULL || 104 | 王六 | 男 | 1988 | 计算机系 | 湖南省衡阳市 | NULL | NULL || 105 | 孙七 | 男 | 1985 | 计算机系 | 北京市海淀区 | NULL | NULL |+-----+------+-----+-------+------------+--------------+--------+-------+7 rows in set (0.05 sec)mysql&gt; 结果仅显示有计算机课程成绩的记录，没有成绩的数据使用Null表示。 3 子查询子查询指一个查询语句嵌套在另一个查询语句内部的查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。 3.1 in子查询in子查询主要用于判断指定字段的值是否存在于子查询的结果集中。 如果子查询的记录较少，主查询的记录较多时使用in，因为这时用到了主表上的索引。 查询所有英语系的学生成绩： sql1234567891011mysql&gt; select * from score where student in (select name from student where department = &#x27;英语系&#x27;);+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 |+----+---------+--------+-------+3 rows in set (0.05 sec)mysql&gt; 3.2 exists子查询exists子查询主要用于判断子查询的结果集是否为空。 如果子查询的记录较多，主查询的记录较少时使用exists，因为这时用到了子表上的索引。 查询是否存在数学系的学生成绩： sql1234mysql&gt; select * from score where exists (select id from student where department = &#x27;数学系&#x27;);Empty set (0.05 sec)mysql&gt; 查询是否存在英语系的学生成绩： sql123456789101112131415161718192021mysql&gt; select * from score sco where exists (select stu.id from student stu where stu.department = &#x27;英语系&#x27;);+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 2 | 张三 | 英语 | 53 || 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 || 6 | 赵六 | 计算机 | 70 || 7 | 赵六 | 英语 | 92 || 8 | 赵六 | 中文 | 73 || 9 | 孙七 | 英语 | 94 || 10 | 周八 | 计算机 | 90 || 11 | 周八 | 英语 | 85 || 12 | 吴九 | 计算机 | 90 || 13 | 吴九 | 中文 | 55 |+----+---------+--------+-------+13 rows in set (0.05 sec)mysql&gt; 查询所有英语系的学生成绩： sql1234567891011mysql&gt; select * from score sco where exists (select stu.id from student stu where sco.student = stu.name and stu.department = &#x27;英语系&#x27;);+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 3 | 李四 | 计算机 | 48 || 4 | 李四 | 中文 | 38 || 5 | 王五 | 中文 | 95 |+----+---------+--------+-------+3 rows in set (0.05 sec)mysql&gt; 3.3 比较运算符子查询使用比较运算符判断子查询是否满足： sql12345678910mysql&gt; select * from score sco where sco.student = (select stu.name from student stu where stu.id = 101);+----+---------+--------+-------+| id | student | course | grade |+----+---------+--------+-------+| 1 | 张三 | 计算机 | 98 || 2 | 张三 | 英语 | 53 |+----+---------+--------+-------+2 rows in set (0.05 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理数据","slug":"E00-数据库/E02-MySQL/001-基础/008-管理数据","date":"2025-05-20T05:04:26.000Z","updated":"2025-06-21T09:07:51.097Z","comments":true,"path":"posts/20250520/130426/","permalink":"https://momashanhe.com/posts/20250520/130426/","excerpt":"摘要：本文学习了如何使用DML语句管理数据。","text":"摘要：本文学习了如何使用DML语句管理数据。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 插入通过传入数据插入： sql12insert into 表名 [(列名1, ..., 列名n)]values (值1, ..., 值n); 通过查询数据插入： sql12insert into 表名 [(列1, ..., 列n)]select 列1, ..., 列n from 目标表; 示例： sql1234mysql&gt; insert into score values (null, &#x27;张三&#x27;, &#x27;计算机&#x27;, 98);Query OK, 1 row affected (0.01 sec)mysql&gt; 2 更新更新数据： sql123update 表名set 字段1 = 值1, ..., 字段n = 值n[where 表达式]; 示例： sql12345mysql&gt; update score set grade = 99 where id = 1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; 3 删除删除数据： sql12delete from 表名[where 表达式]; 示例： sql1234mysql&gt; delete from score where id = 1;Query OK, 1 row affected (0.01 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"使用索引","slug":"E00-数据库/E02-MySQL/001-基础/007-使用索引","date":"2025-05-19T12:35:01.000Z","updated":"2025-06-21T09:07:50.912Z","comments":true,"path":"posts/20250519/203501/","permalink":"https://momashanhe.com/posts/20250519/203501/","excerpt":"摘要：本文学习了如何使用DDL语句使用索引。","text":"摘要：本文学习了如何使用DDL语句使用索引。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义索引是一个排序的列表，存储着索引的值和包含这个值的数据所在行的物理地址。 在数据十分庞大的时候，使用索引可以大大加快查询速度。这是因为使用索引后不需要扫描全表定位数据，而是通过索引表找到数据对应的物理地址然后访问数据。 1.2 作用索引的主要功能是排序和筛选。 1.3 优缺点优点： 可以快速检索，减少IO次数，加快检索速度。 在分组和排序的时候如果使用索引，可以加快分组和排序。 缺点： 索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍。 索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大。 构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。 2 操作2.1 主键索引2.1.1 定义根据主键约束自动生成的索引，不允许重复值，不允许空值。 2.1.2 使用创建主键索引： sql1alter table 表名 add primary key(字段名); 删除主键索引： sql1alter table 表名 drop primary key; 2.2 唯一索引2.2.1 定义根据唯一约束自动生成的索引，不允许重复值。 2.2.2 使用创建唯一索引： sql1alter table 表名 add unique 索引名(字段名); 删除唯一索引： sql1alter table 表名 drop index 索引名; 2.3 普通索引2.3.1 定义使用表中普通的列构建索引。 2.3.2 使用创建普通索引： sql1alter table 表名 add index 索引名(字段名); 删除普通索引： sql1alter table 表名 drop index 索引名; 2.4 组合索引2.4.1 定义用多个列组合构建的索引，这多个列中的值不允许有空值。 2.4.2 使用创建组合索引： sql1alter table 表名 add index 索引名(字段名1, 字段名2, ... 字段名n); 删除组合索引： sql1alter table 表名 drop index 索引名; 2.5 全文索引2.5.1 定义用大文本对象的列构建的索引。 2.5.2 使用创建全文索引： sql1alter table 表名 add fulltext index 索引名(字段名); 删除全文索引： sql1alter table 表名 drop fulltext index 索引名;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"使用约束","slug":"E00-数据库/E02-MySQL/001-基础/006-使用约束","date":"2025-05-19T07:28:24.000Z","updated":"2025-06-21T09:07:51.004Z","comments":true,"path":"posts/20250519/152824/","permalink":"https://momashanhe.com/posts/20250519/152824/","excerpt":"摘要：本文学习了如何使用DDL语句使用约束。","text":"摘要：本文学习了如何使用DDL语句使用约束。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义约束是在创建表时，为某些列添加特定的规则，保证数据满足用户的要求。 1.2 作用约束添加后，在向表中添加和更新数据时，必须要满足约束，否则不能执行操作。 2 操作2.1 主键约束2.1.1 定义主键约束是一个列或者多个列，其值能唯一地标识表中的每一行，这样的一列或多列称为表的主键。 主键约束相当于唯一约束和非空约束的组合，主键约束列不允许重复，也不允许出现空值。 当创建主键约束时，系统默认会建立对应的唯一索引。 2.1.2 自增数据库提供了一个自增的数字，专门用来自动生成主键值，不需要用户维护，自增数从1开始，以1递增。 2.1.3 使用使用primary key添加主键约束，使用auto_increment设置主键自增。 在创建表时添加单列主键约束，主键自增： sql1234567mysql&gt; create table test ( -&gt; id int(11) primary key auto_increment comment &#x27;编号&#x27;, -&gt; name varchar(50) comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在创建表时添加联合主键约束： sql12345678mysql&gt; create table test ( -&gt; id int(11) comment &#x27;编号&#x27;, -&gt; name varchar(50) comment &#x27;姓名&#x27;, -&gt; primary key(id, name) -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在修改表时添加主键约束： sql12345mysql&gt; alter table test add primary key(id);Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 在修改表时删除主键约束： sql12345mysql&gt; alter table test drop primary key;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.2 外键约束2.2.1 定义外键约束用来在两个表的数据之间建立链接，它可以是一列或者多列，一个表可以有一个或多个外键。 外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。 主表和子表： 主表：对于两个具有关联关系的表而言，存储主要信息的表就是主表。 子表：对于两个具有关联关系的表而言，存储详细信息的表就是子表。 比如一个订单主表对应多个订单子表，以及一个信息主表对应一个信息详情表。 2.2.2 使用使用foreign key添加外键约束。 创建主表并定义主键约束： sql1234567mysql&gt; create table man ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; name varchar(50) comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;主表&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在创建子表时添加外键约束： sql123456789mysql&gt; create table child ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; m_id int(11) comment &#x27;主表编号&#x27;, -&gt; name varchar(50) comment &#x27;姓名&#x27;, -&gt; constraint fk_m_id foreign key(m_id) references man(id) -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;子表&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在修改子表时添加外键约束： sql12345mysql&gt; alter table child add constraint fk_m_id foreign key(m_id) references man(id);Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 在修改子表时删除外键约束： sql12345mysql&gt; alter table child drop foreign key fk_m_id;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.3 唯一约束2.3.1 定义唯一约束要求该列唯一，允许为空，但只能出现一个空值。 唯一约束可以确保一列或者几列不出现重复值。 2.3.2 使用使用unique添加唯一约束。 在创建表时添加单列唯一约束： sql1234567mysql&gt; create table test ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; name varchar(50) unique comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在创建表时添加联合唯一约束： sql12345678mysql&gt; create table test ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; name varchar(50) comment &#x27;姓名&#x27;, -&gt; constraint uk_id_name unique(id, name) -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在修改表时添加唯一约束： sql12345mysql&gt; alter table test add unique uk_name(name);Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 在修改表时删除唯一约束： sql12345mysql&gt; alter table test drop index uk_name;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.4 非空约束2.4.1 定义非空约束可以用来约束该列的取值不能为空，对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。 2.4.2 使用使用not null添加非空约束。 在创建表时添加非空约束： sql1234567mysql&gt; create table test ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; name varchar(50) not null comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在修改表时添加非空约束： sql12345mysql&gt; alter table test change column name name varchar(50) not null;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 在修改表时删除非空约束： sql12345mysql&gt; alter table test change column name name varchar(50) default null;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.5 默认值约束2.5.1 定义默认值约束用来指定某列的默认值。 2.5.2 使用使用default添加默认值约束。 在创建表时添加默认值约束： sql1234567mysql&gt; create table test ( -&gt; id int(11) primary key comment &#x27;编号&#x27;, -&gt; name varchar(50) default &#x27;none&#x27; comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 在修改表时添加默认值约束： sql12345mysql&gt; alter table test change column name name varchar(50) default &#x27;none&#x27;;Query OK, 1 row affected (0.01 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; 在修改表时删除默认值约束： sql12345mysql&gt; alter table test change column name name varchar(50) default null;Query OK, 1 row affected (0.01 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理表","slug":"E00-数据库/E02-MySQL/001-基础/005-管理表","date":"2025-05-18T03:28:38.000Z","updated":"2025-06-21T09:07:52.147Z","comments":true,"path":"posts/20250518/112838/","permalink":"https://momashanhe.com/posts/20250518/112838/","excerpt":"摘要：本文学习了如何使用DDL语句管理表。","text":"摘要：本文学习了如何使用DDL语句管理表。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义表是数据库中存储数据的具体结构，它由行和列组成。 表中的每一行代表一条记录，包含了按列组织的数据。 表中的每一列代表一种数据，定义了该列可以存储的数据种类。 1.2 作用表是数据库中实际存储数据的载体，能够将数据以一种结构化的方式组织起来，便于数据的管理。 表与表之间可以通过特定的字段建立关联，从而实现复杂的数据关系。 2 操作2.1 创建语法： sql1create table 表名 [表定义选项] [表选项]; 说明： 表定义选项：用来创建定义表的结构，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。 示例： sql1234567mysql&gt; create table test ( -&gt; id int(11) primary key auto_increment comment &#x27;编号&#x27;, -&gt; name varchar(50) default null comment &#x27;姓名&#x27; -&gt; ) engine=innodb default charset=utf8mb4 comment=&#x27;测试&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; 2.2 查看查看所有表： sql1show tables; 查看表的创建： sql1show create table 表名; 查看表的状态： sql1show table status [like &#x27;模糊查询表名&#x27;] from 数据库 \\G 说明： 使用\\G符号可以垂直显示内容，并且使用\\G后不需要使用;结束。 使用describe命令查看表的结构，可以使用desc简写： sql12describe 表名;desc 表名; 使用desc命令示例： sql12345678910mysql&gt; desc test;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(50) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)mysql&gt; 说明： Field：列名。 Type：类型。 Null：表示该列是否可以存储NULL值。 Key：表示该列是否已编制索引。PRI表示该列是主键的一部分，UNI表示该列是UNIQUE索引的一部分，MUL表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，比如AUTO_INCREMENT等。 使用show命令查看表的字段： sql1show columns from 表名; 使用show命令查看表的索引： sql1show index from 表名; 2.3 复制语法： sql1create table 新表名 as select * from 旧表名; 示例： sql12345mysql&gt; create table test_bak as select * from test;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.4 修改添加列： sql1alter table 表名 add column 新列名 [数据类型] [约束条件] [first | after 已存在的列名]; 示例： sql12345mysql&gt; alter table test add column age int(3) null comment &#x27;年龄&#x27; after name;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 修改列： sql1alter table 表名 change column 旧列名 新列名 [新数据类型]; 示例： sql12345mysql&gt; alter table test change column name name varchar(30) not null default &#x27;none&#x27; comment &#x27;姓名&#x27;;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 删除列： sql1alter table 表名 drop 列名; 示例： sql12345mysql&gt; alter table test drop age;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; 2.5 删除删除表会删除表结构，再次使用需要重新创建。 语法： sql1drop table [if exists] 表名; 示例： sql1234mysql&gt; drop table test;Query OK, 0 rows affected (0.01 sec)mysql&gt; 2.6 清空清空表不会删除表结构，但是会释放表空间，重置自增序列从1开始记录。 语法： sql1truncate table 表名; 示例： sql1234mysql&gt; truncate table test;Query OK, 0 rows affected (0.01 sec)mysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"管理数据库","slug":"E00-数据库/E02-MySQL/001-基础/004-管理数据库","date":"2025-05-17T05:09:15.000Z","updated":"2025-06-21T09:07:51.282Z","comments":true,"path":"posts/20250517/130915/","permalink":"https://momashanhe.com/posts/20250517/130915/","excerpt":"摘要：本文学习了如何使用DDL语句管理数据库。","text":"摘要：本文学习了如何使用DDL语句管理数据库。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 简介1.1 定义数据库是最高层次的存储结构，它可以包含多个表、视图、存储过程、触发器等数据库对象。 一个数据库对应一个独立的命名空间，不同的数据库中可以存在同名的表。 1.2 作用数据库用于逻辑上组织和管理相关的数据表和其他对象。 2 操作2.1 创建数据库语法： sql123create database [if not exists] 数据库名[default] character set 字符集名[default] collate 校对规则名; 示例： sql123456mysql&gt; create database if not exists demo -&gt; default character set utf8mb4 -&gt; default collate utf8mb4_general_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; 2.2 查看数据库创建语法： sql1show create database demo; 示例： sql123456789mysql&gt; show create database demo;+----------+-----------------------------------------------------------------+| Database | Create Database |+----------+-----------------------------------------------------------------+| demo | CREATE DATABASE `demo` /*!40100 DEFAULT CHARACTER SET gb2312 */ |+----------+-----------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; 2.3 查询所有数据库语法： sql1show databases; 示例： sql123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || demo || mysql || performance_schema |+--------------------+4 rows in set (0.00 sec)mysql&gt; 2.4 修改数据库语法： sql123alter database 数据库名[default] character set 字符集名[default] collate 校对规则名; 示例： sql123456mysql&gt; alter database demo -&gt; character set gb2312 -&gt; collate gb2312_chinese_ci;Query OK, 1 row affected (0.00 sec)mysql&gt; 2.5 删除数据库语法： sql1drop database [if exists] 数据库名; 示例： sql1234mysql&gt; drop database demo;Query OK, 0 rows affected, 2 warnings (0.00 sec)mysql&gt; 2.6 选择数据库语法： sql1use demo; 示例： sql123mysql&gt; use demo;Database changedmysql&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"通用语法","slug":"E00-数据库/E02-MySQL/001-基础/003-通用语法","date":"2025-05-13T01:46:14.000Z","updated":"2025-06-21T09:07:52.042Z","comments":true,"path":"posts/20250513/094614/","permalink":"https://momashanhe.com/posts/20250513/094614/","excerpt":"摘要：本文学习了SQL语言中的通用语法。","text":"摘要：本文学习了SQL语言中的通用语法。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 基本规范 支持单行和多行书写，以分号结尾。 可以使用空格和缩进来增强语句的可读性。 不区分大小写，建议关键字使用大写。 2 注释支持单行注释和多行注释： 单行注释：使用--符号或者#符号会注释之后到行末尾之间的单行内容。 多行注释：使用/*符号和*/符号注释之间的多行内容。 3 着重号如果在定义表或者字段等其他实体时命名与保留字和关键字有冲突，在不想更改命名的情况下可以使用``着重号将名称包裹起来，这样就不会被识别为关键字和保留字。 4 语句分类根据SQL语句的功能，主要分为四类： DDL（Data Definition Language）：数据定义语言，用来定义数据库对象，比如数据库，以及表和字段。 DML（Data Manipulation Language）：数据操作语言，用来对数据库表中的数据进行增删改。 DQL（Data Query Language）：数据查询语言，用来查询数据库中表的记录。 DCL（Data Control Language）：数据控制语言，用来创建数据库用户以及控制用户对数据库的访问权限。 5 数据类型5.1 整数类型整数类型的属性字段可以添加auto_increment自增约束条件。 整数类型： 类型名称 存储需求 tinyint 1字节 smallint 2字节 mediumint 3字节 int 4字节 bigint 8字节 定义整型的写法是int(N)，这种写法只需要记住两点： 无论N等于多少，int永远占4个字节。 N表示的是显示宽度，不足的用0补足，超过的无视长度而直接显示整个数字，但这要整型设置了unsigned zerofill才有效。 5.2 浮点类型浮点类型有两种，分别是单精度浮点数（float）和双精度浮点数（double）。 浮点类型： 类型名称 存储需求 float 4字节 double 8字节 定义浮点类型可以用(M,D)来表示，其中M称为精度，表示总共的位数，D称为标度，表示小数的位数。 5.3 定点类型浮点型的float和double存在精度丢失问题，即写入数据库的数据未必是插入数据库的数据。 由此引入了decimal类型，无论写入数据中的数据是多少，都不会存在精度丢失问题。 定点类型： 类型名称 存储需求 decimal 总位数M+2字节 常见于银行系统和互联网金融系统等对小数点后的数字比较敏感的系统中。 定义定点类型可以用(M,D)来表示，和定义浮点类型相同，但区别在浮点类型没有指定参数时默认按照实际精度来处理，而定点类型在没有指定参数时默认使用(10,0)作为参数。 5.4 日期和时间类型支持五种形式的日期类型： 类型名称 日期格式 日期范围 存储需求 year YYYY 1901 ~ 2155 1字节 time HH:MM:SS -838:59:59 ~ 838:59:59 3字节 date YYYY-MM-DD 1000-01-01 ~ 9999-12-03 3字节 datetime YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8字节 timestamp YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4字节 其中datetime与timestamp两种类型的区别： datetime占8个字节，timestamp占4个字节。 由于大小的区别，datetime与timestamp能存储的时间范围也不同。 datetime默认值为空，当插入的值为null时，该列的值就是null。timestamp默认值不为空，当插入的值为null时，该列的值取当前时间。 datetime存储的时间与时区无关，timestamp存储的时间及显示的时间都依赖于当前时区。 在实际工作中，一张表往往会有两个默认字段，一个记录创建时间而另一个记录最新一次的更新时间，这种时候可以使用timestamp类型来实现。 5.5 字符串类型字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据，支持使用正则表达式进行匹配查找。 字符串类型众多，括号中的M表示可以为其指定长度： 类型名称 存储需求 char(M) M字节，1","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"安装","slug":"E00-数据库/E02-MySQL/001-基础/002-安装","date":"2025-05-12T13:59:37.000Z","updated":"2025-06-21T09:09:00.714Z","comments":true,"path":"posts/20250512/215937/","permalink":"https://momashanhe.com/posts/20250512/215937/","excerpt":"摘要：本文学习了如何在Windows中安装MySQL。","text":"摘要：本文学习了如何在Windows中安装MySQL。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 检查在cmd窗口中输入services.msc命令打开服务，如果能找到MySQL服务，说明已经安装了MySQL数据库。 2 下载官方下载地址： 最新版本 历史版本 根据系统运行环境和操作系统位数选择下载相应的软件。 3 安装将下载得到的压缩包放在软件安装目录，直接解压即可安装完成。 4 配置4.1 配置环境变量4.1.1 MYSQL_HOME将解压后的目录作为安装目录，添加到环境变量。 打开环境变量窗口，新建环境变量，变量名为MYSQL_HOME，变量值为安装目录地址。 4.1.2 Path需要把安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件，设置后可以在任何目录下执行命令。 打开环境变量窗口，在下方的系统环境变量里找到Path环境变量并编辑，新建变量%MYSQL_HOME%\\bin并保存。 4.2 配置系统文件从5.7.18版本开始，不在压缩包中提供my-default.ini文件，在安装目录下创建my.ini文件： my.ini123456789101112131415161718192021222324252627282930313233[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\Work\\MySQL\\mysql-5.7.40# 设置mysql数据库的数据的存放目录datadir=D:\\Work\\MySQL\\mysql-5.7.40\\data# 允许最大连接数max_connections=1024# 允许连接失败的次数max_connect_errors=10# 服务端默认字符集character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 设置导入导出文件夹secure-file-priv=D:\\Work\\MySQL\\file# 设置存储进程ID文件的位置pid-file=mysql.pid# default_authentication_plugindefault_authentication_plugin=mysql_native_password# sql_modesql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# explicit_defaults_for_timestampexplicit_defaults_for_timestamp=true[mysql]# 客户端默认字符集default-character-set=utf8mb4[client]# 客户端连接服务端时默认使用的端口port=3306# 客户端连接服务端时默认字符集default-character-set=utf8mb4 4.3 配置服务使用超级管理员的权限打开cmd窗口。 初始化数据库，设置root密码为空： cmd1mysqld --initialize-insecure 说明： –initialize：设置root密码为随机数。 –initialize-insecure：设置root密码为空。 安装服务，默认自动启动： cmd1mysqld --install MySQL 说明： –install：安装服务，默认自动启动。 –install-manual：安装服务，设置手动启动。 –remove：删除服务。 启动服务： cmd1net start MySQL 说明： start：启动服务。 stop：停止服务。 5 登录测试5.1 登录打开cmd窗口，输入mysql -u root -p使用root用户登录，回车后提示输入密码，因为之前配置的时候设置了root用户的密码为空，所以直接回车即可登录成功了： cmd1234567891011121314Enter password:Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.40 MySQL Community Server (GPL)Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\\h&#x27; for help. Type &#x27;\\c&#x27; to clear the current input statement.mysql&gt; 5.2 修改密码将root用户的密码改为123456： cmd1set password for root@localhost = password(&#x27;123456&#x27;); 使用exit命令退出登录，以后登录就需要输入刚刚设置的密码了。 6 使用工具建议使用Navicat工具连接数据库。 打开Navicat并新建连接： 点击测试连接提示连接成功，点击确定保存连接。 双击新建的连接，并点击新建查询，即可编写语句并执行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"入门","slug":"E00-数据库/E02-MySQL/001-基础/001-入门","date":"2025-05-12T07:55:58.000Z","updated":"2025-06-21T09:07:52.236Z","comments":true,"path":"posts/20250512/155558/","permalink":"https://momashanhe.com/posts/20250512/155558/","excerpt":"摘要：本文了解了MySQL关系型数据库和SQL语言的基本知识。","text":"摘要：本文了解了MySQL关系型数据库和SQL语言的基本知识。 环境 Windows 10 企业版 LTSC 21H2MySQL 5.7.40 1 MySQL数据库MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。 MySQL使用的SQL语言是用于访问数据库的最常用的标准化语言。 特性： 使用C和C++编写，并使用多种编译器进行测试，保证源代码的可移植性。 支持AIX、Linux、MacOS、Solaris、Windows等多种操作系统。 为多种编程语言提供了API，包括C、C++、Python、Java、Perl、PHP和Ruby等。 提供TCP&#x2F;IP、ODBC和JDBC等多种数据库连接途径。 支持多线程，充分利用CPU资源。 优化的SQL查询算法，有效地提高查询速度。 既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入其他的软件中。 提供多语言支持，常见的编码如中文的GB2312、BIG5，日文的Shift_JIS等都可以用作数据表名和数据列名。 提供用于管理、检查、优化数据库操作的管理工具。 支持大型的数据库，可以处理拥有上千万条记录的大型数据库。 支持多种存储引擎。 概念： 数据库（Database）：是按照一定结构组织存储在一起的相关数据的集合，这些数据可以被多个用户和应用程序共享。 表（Table）：是数据库中存储数据的基本单位，由行和列组成，对应记录和字段。例如，一个学生表可以包含学号和姓名等字段，每一行代表一条学生记录。 字段（Field）：是表中的一列，具有特定的数据类型。例如，姓名字段的数据类型可能是字符串。 记录（Record）：是表中的一行，包含字段的具体值。一个学生记录包含该学生的学号和姓名等实际信息。 2 SQL语言SQL（Structured Query Language，结构化查询语言）是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 与其他程序设计语言（如C、Java等）不同的是，SQL由很少的关键字组成，每个SQL语句通过一个或多个关键字构成。 优点： 一体化：SQL集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。 使用方式灵活：SQL具有两种使用方式，可以直接以命令方式交互使用，也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java等语言中使用。 非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机做什么，而不需要告诉它怎么做。 语言简洁、语法简单、好学好用：在ANSI标准中，只包含94个英文单词，核心功能只用6个动词，语法接近英语口语。 注意： SQL语句不区分大小写，许多SQL开发人员习惯对关键字进行大写，而对表或者列的名称使用小写，这样可以提高代码的可阅读性和可维护性。 大多数数据库都支持通用的SQL语句，同时不同的数据库具有各自特有的SQL语言特性。 某些数据库系统要求在每条SQL命令的末端使用分号。分号是在数据库系统中分隔每条SQL语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"}]},{"title":"流式处理","slug":"D00-后端/D01-Java/002-高级/005-流式处理","date":"2025-05-08T02:34:13.000Z","updated":"2025-07-22T01:26:42.626Z","comments":true,"path":"posts/20250508/103413/","permalink":"https://momashanhe.com/posts/20250508/103413/","excerpt":"摘要：本文学习了流式处理，使用新增方法操作集合，以及通过Optional类判断空值。","text":"摘要：本文学习了流式处理，使用新增方法操作集合，以及通过Optional类判断空值。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介1.1 定义从JDK1.8开始，新增了一系列Stream相关的API用于流式处理，这些API都在java.util.stream包下，通过Stream可以编写函数式编程风格的代码，使代码更加高效简洁。 1.2 操作方式流式处理可以分为三个部分： 转换成流：将原始数据转换成流对象，以便进行后续操作。 中间操作：将原始的Stream经过逻辑处理，生成新的Stream用于继续处理。 终止操作：产生结果或者执行其他操作。 2 使用2.1 转换成流创建空的Stream对象： java1Stream stream = Stream.empty(); 通过集合类中的stream()方法或者parallelStream()方法创建Stream对象： java123List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);Stream stream = list.stream();// 获取串行的Stream对象Stream parallelStream = list.parallelStream();// 获取并行的Stream对象 通过数组工具类Arrays类的stream()方法创建Stream对象： java12String[] arr = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;;Stream&lt;String&gt; stream = Arrays.stream(arr); 通过Stream类中的of()方法创建Stream对象： java12Stream stream = Stream.of(&quot;test&quot;);Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 通过Stream类中的iterate()方法创建有序的Stream对象： java1public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f); 通过Stream类中的generate()方法创建无序的Stream对象： java1public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s); 2.2 中间操作多个中间操作可以连接起来形成流水线，在终止操作时进行处理并返回结果，称为惰性求值，是函数式编程中的一种策略。 2.2.1 过滤对Stream对象按指定的Predicate进行筛选，将符合条件的元素组成新的Stream对象返回。 语法： java1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).filter(i -&gt; i &gt; 5);// 为了看到效果，使用终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log1288 2.2.2 截取获取指定的前几个元素组成新的Stream对象返回。 语法： java1Stream&lt;T&gt; limit(long maxSize); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).limit(2);// 为了看到效果，使用终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log1218 2.2.3 跳过跳过指定的前几个元素，将剩下的元素组成新的Stream对象返回。 语法： java1Stream&lt;T&gt; skip(long n); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).skip(2);// 为了看到效果，使用终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log1258 2.2.4 去重调用元素的equals()方法进行比较，将去重后的元素组成新的Stream对象返回。 语法： java1Stream&lt;T&gt; distinct(); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).distinct();// 为了看到效果，使用终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log123185 2.2.5 排序调用传入比较器进行比较，将排序后的元素组成新的Stream对象返回。 语法： java1Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).sorted((m, n) -&gt; m - n);// 为了看到效果，使用终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log12341588 2.2.6 映射将Stream中的元素转换成其他元素或者提取信息，调用传入的函数处理每个元素，将处理后的元素组成新的Stream对象返回。 语法： java1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 示例： java123Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8).map(i -&gt; i + 1);// 为了看到效果，使用了终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log12342969 2.2.7 扁平映射将Stream中的元素转换成Stream对象，调用传入的函数处理每个Steam对象，将处理后的Stream对象组成新的Stream对象返回。 语法： java1&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 示例： java123Stream&lt;String&gt; stream = Stream.of(&quot;1 8&quot;, &quot;5 8&quot;).flatMap(s -&gt; Stream.of(s.split(&quot; &quot;)));// 为了看到效果，使用了终止操作forEach()方法进行打印stream.forEach(e -&gt; System.out.println(e)); 结果： log12341858 2.3 终止操作终端操作会使用流水线生成结果，一旦执行终端操作，流就被使用使用了，无法再被使用。 2.3.1 遍历元素语法： java1void forEach(Consumer&lt;? super T&gt; action); 示例： java12Stream&lt;Integer&gt; stream = Stream.of(1, 8, 5, 8);stream.forEach(e -&gt; System.out.println(e)); 结果： log12341858 2.3.2 检查是否所有元素匹配如果所有元素都满足条件，那么返回true，否则返回false。 语法： java1boolean allMatch(Predicate&lt;? super T&gt; predicate); 示例： java12boolean match = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).allMatch(e -&gt; e.contains(&quot;11&quot;));System.out.println(match);// true 2.3.3 检查是否任意元素匹配如果任意元素满足条件，就返回true，否则返回false。 语法： java1boolean anyMatch(Predicate&lt;? super T&gt; predicate); 示例： java12boolean match = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).anyMatch(e -&gt; e.contains(&quot;aa&quot;));System.out.println(match);// true 2.3.4 检查是否没有元素匹配如果没有元素满足条件，返回true，否则返回false。 语法： java1boolean noneMatch(Predicate&lt;? super T&gt; predicate); 示例： java12boolean match = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).noneMatch(e -&gt; e.contains(&quot;cc&quot;));System.out.println(match);// true 2.3.5 返回首个元素返回首个元素，使用Optional对象封装。 语法： java1Optional&lt;T&gt; findFirst(); 示例： java12Optional&lt;String&gt; find = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).findFirst();System.out.println(find);// Optional[aa11] 2.3.6 返回任意元素返回任意元素，通常是处理最快的那个元素，使用Optional对象封装。 语法： java1Optional&lt;T&gt; findAny(); 示例： java12Optional&lt;String&gt; find = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).findAny();System.out.println(find);// Optional[aa11] 2.3.7 返回元素个数语法： java1long count(); 示例： java12long count = Stream.of(&quot;aa11&quot;, &quot;bb11&quot;).count();System.out.println(count);// 2 2.3.8 返回元素最大值语法： java1Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); 示例： java12Optional&lt;Integer&gt; max = Stream.of(1, 8, 5, 8).max((m, n) -&gt; m - n);System.out.println(max);// Optional[8] 2.3.9 返回元素最小值语法： java1Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); 示例： java12Optional&lt;Integer&gt; min = Stream.of(1, 8, 5, 8).min((m, n) -&gt; m - n);System.out.println(min);// Optional[1] 2.3.10 收集元素将流中的元素进行汇总，使用集合收集元素。 可以使用Collectors类提供的静态方法，将流中的元素通过集合收集。 语法： java1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 示例： java123List&lt;Integer&gt; list = Arrays.asList(1, 8, 5, 8);Set&lt;Integer&gt; set = list.stream().collect(Collectors.toSet());System.out.println(set);// [1, 5, 8] 2.3.11 规约元素将流中的元素反复结合，最终生成单一的结果。 语法： java12T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 示例： java1234567List&lt;Integer&gt; list = Arrays.asList(1, 8, 5, 8);Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);System.out.println(sum);// Optional[22]Integer sumWith0 = list.stream().reduce(0, (x, y) -&gt; x + y);System.out.println(sumWith0);// 22Integer sumWith5 = list.stream().reduce(5, (x, y) -&gt; x + y);System.out.println(sumWith5);// 27 3 Optional类为了避免产生NullPointException异常，通常的做法是进行if条件判断，但如果代码里面充满了大量的null判断会让程序变的不再优雅。 从JDK1.8开始，可以使用Optional类处理可能为null的变量，在减少NullPointException的同时，也提升了代码的美观度。 3.1 获取创建空的Optional对象： java1Optional&lt;String&gt; name = Optional.empty(); 包装不为null的对象，如果对象为null，则抛出NullPointException异常： java1Optional&lt;String&gt; name = Optional.of(str); 包装可以为null的对象，如果对象为null，则创建空的Optional对象： java1Optional&lt;String&gt; name = Optional.ofNullable(str); 3.2 常用方法3.2.1 判断是否为空使用isPresent()方法判断Optional对象是否为空，如果为空则返回true，如果不为空则返回false。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(null);System.out.println(name.isPresent());// true 3.2.2 安全执行方法使用ifPresent()方法安全的执行传入的方法，如果不为空则执行方法，如果为空则什么也不做。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(&quot;name&quot;);name.ifPresent(System.out::println);// name 3.2.3 获取值使用get()方法获取Optional对象的值，如果不为空则返回值，如果为空则抛出NoSuchElementException异常。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(&quot;name&quot;);System.out.println(name.get());// name 3.2.4 获取值或默认值使用orElse()方法获取Optional对象的值，如果不为空则返回值，如果为空则返回指定的值。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(null);System.out.println(name.orElse(&quot;null&quot;));// null 3.2.5 获取值或执行方法使用orElseGet()方法获取Optional对象的值，如果不为空则返回值，如果为空则返回执行方法得到的值。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(null);System.out.println(name.orElseGet(() -&gt; &quot;null&quot;));// null 3.2.6 获取值或抛出异常使用orElseThrow()方法获取Optional对象的值，如果不为空则返回值，如果为空则抛出指定的异常，默认抛出NoSuchElementException异常。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(null);System.out.println(name.orElseThrow(() -&gt; new NullPointerException()));// java.lang.NullPointerException 3.2.7 过滤使用filter()方法过滤Optional对象的值，判断是否满足传入的条件，如果满足则返回原来的Optional对象，如果不满足则创建空的Optional对象返回。 示例： java12Optional&lt;String&gt; name = Optional.ofNullable(&quot;name&quot;).filter(e -&gt; e != null);System.out.println(name);// Optional[name] 3.2.8 映射使用map()方法处理Optional对象的值，如果不为空则使用传入的方法处理并将返回值封装为Optional对象返回，如果为空则创建空的Optional对象返回。 示例： java12Optional&lt;Integer&gt; length = Optional.ofNullable(&quot;name&quot;).map(e -&gt; e.length());System.out.println(length);// Optional[4] 3.2.9 扁平映射使用flatMap()方法处理Optional对象的值，如果不为空则使用传入的方法处理并将Optional对象返回，如果为空则创建空的Optional对象返回。 示例： java12Optional&lt;Integer&gt; length = Optional.ofNullable(&quot;name&quot;).flatMap(e -&gt; Optional.ofNullable(e.length()));System.out.println(length);// Optional[4] 3.3 注意事项比较orElse()方法和orElseGet()方法： 当Optional对象不为空时，返回的都是原对象。当Optional对象为空时，orElse()方法返回指定的值，orElseGet()方法返回的是接口调用的返回值。 并且当Optional对象不为空时，orElse()方法也会执行，orElseGet()方法不会执行。如果两个方法都返回新对象，orElse()方法会执行初始化，orElseGet()方法不会执行初始化。 比较map()方法和flatMap()方法： 如果Optional对象为空，都会创建空对象返回。 如果Optional对象不为空，map()方法会将执行方法得到的返回值包装为Optional对象，flatMap()方法会直接返回执行方法得到的Optional对象。 4 集合增强4.1 工具类4.1.1 Collector可以将Collector接口看做是用来处理流的工具，在Collectors类里面封装了很多Collector工具。 4.1.2 CollectorsCollectors类是一个提供了多种Collector接口的工具类。 4.1.2.1 集合示例： java12345678910111213141516171819List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用toCollection()方法收集到Collection返回LinkedList&lt;String&gt; newCollection = list.stream().collect(Collectors.toCollection(LinkedList::new));System.out.println(newCollection);// [123, 521, 100, 228, 838, 250, 345]// 使用toList()方法收集到List返回，默认为ArrayListList&lt;String&gt; newList = list.stream().collect(Collectors.toList());System.out.println(newList);// [123, 521, 100, 228, 838, 250, 345]// 使用toSet()方法收集到Set返回，默认为HashSetSet&lt;String&gt; newSet = list.stream().collect(Collectors.toSet());System.out.println(newSet);// [100, 123, 521, 345, 228, 838, 250]// 使用toMap()方法收集到Map返回，主键冲突时默认抛出异常，默认为HashMapMap&lt;String, String&gt; newMap = null;// 传入主键冲突时的处理方法，保留先插入的值，默认对主键由小到大排序newMap = list.stream().collect(Collectors.toMap(e -&gt; e.substring(0, 1), e -&gt; e, (m, n) -&gt; m));System.out.println(newMap);// &#123;1=123, 2=228, 3=345, 5=521, 8=838&#125;// 传入主键冲突时的处理方法，保留后插入的值，设置对主键按照插入顺序排序newMap = list.stream().collect(Collectors.toMap(e -&gt; e.substring(0, 1), e -&gt; e, (m, n) -&gt; n, LinkedHashMap::new));System.out.println(newMap);// &#123;1=100, 5=521, 2=250, 8=838, 3=345&#125; 4.1.2.2 拼接示例： java12345678910List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用joining()方法将流中的元素拼接为字符串，可以指定连接符，也可以指定前后缀String str = null;str = list.stream().collect(Collectors.joining());System.out.println(str);// 123521100228838250345str = list.stream().collect(Collectors.joining(&quot;-&quot;));System.out.println(str);// 123-521-100-228-838-250-345str = list.stream().collect(Collectors.joining(&quot;-&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;));System.out.println(str);// &lt;123-521-100-228-838-250-345&gt; 4.1.2.3 数学示例： java1234567891011List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用counting()方法统计流中元素的个数Long count = list.stream().collect(Collectors.counting());System.out.println(count);// 7// 使用maxBy()方法获取流中元素的最大值Optional&lt;String&gt; max = list.stream().collect(Collectors.maxBy((m, n) -&gt; Integer.valueOf(m) - Integer.valueOf(n)));System.out.println(max);// Optional[838]// 使用minBy()方法获取流中元素的最小值Optional&lt;String&gt; min = list.stream().collect(Collectors.minBy((m, n) -&gt; Integer.valueOf(m) - Integer.valueOf(n)));System.out.println(min);// Optional[100] 4.1.2.4 映射示例： java1234567List&lt;Score&gt; scoreList = new ArrayList&lt;Score&gt;();scoreList.add(new Score(&quot;201010&quot;, &quot;张三&quot;));scoreList.add(new Score(&quot;201011&quot;, &quot;李四&quot;));scoreList.add(new Score(&quot;201012&quot;, &quot;王五&quot;));// 使用mapping()方法将流中的元素进行处理，按照指定格式返回结果List&lt;String&gt; names = scoreList.stream().collect(Collectors.mapping(Score::getName, Collectors.toList()));System.out.println(names);// [张三, 李四, 王五] 4.1.2.5 收集处理示例： java12345List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用collectingAndThen()方法对收集后的结构进行进一步处理Integer size = list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));System.out.println(size);// 7 4.1.2.6 统计归纳示例： java123456789List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用reducing()方法对流中的元素做统计归纳，有三个重载方法，和Stream里的三个方法对应，二者作用完全一致Optional&lt;Integer&gt; sum = list.stream().map(String::length).collect(Collectors.reducing(Integer::sum));System.out.println(sum);// Optional[21]Integer sumWith0 = list.stream().map(String::length).collect(Collectors.reducing(0, Integer::sum));System.out.println(sumWith0);// 21Integer sumWith5 = list.stream().collect(Collectors.reducing(0, String::length, Integer::sum));System.out.println(sumWith5);// 26 4.2.1.7 分组示例： java123456789List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用groupingBy()方法按照规则将流中的数据分为多个组，有三个重载方法Map&lt;String, List&lt;String&gt;&gt; groupByFirst = list.stream().collect(Collectors.groupingBy(e -&gt; e.substring(0, 1)));System.out.println(groupByFirst);// &#123;1=[123, 100], 2=[228, 250], 3=[345], 5=[521], 8=[838]&#125;Map&lt;String, Set&lt;String&gt;&gt; groupByLast = list.stream().collect(Collectors.groupingBy(e -&gt; e.substring(e.length() - 1), Collectors.toSet()));System.out.println(groupByLast);// &#123;0=[100, 250], 1=[521], 3=[123], 5=[345], 8=[228, 838]&#125;HashMap&lt;Integer, Set&lt;String&gt;&gt; groupByLength = list.stream().collect(Collectors.groupingBy(String::length, HashMap::new, Collectors.toSet()));System.out.println(groupByLength);// &#123;3=[100, 123, 521, 345, 228, 838, 250]&#125; 4.1.2.8 分区示例： java1234567List&lt;String&gt; list = Arrays.asList(&quot;123&quot;, &quot;521&quot;, &quot;100&quot;, &quot;228&quot;, &quot;838&quot;, &quot;250&quot;, &quot;345&quot;);System.out.println(list);// [123, 521, 100, 228, 838, 250, 345]// 使用partitioningBy()方法按照规则将流中的数据分为两个区，有两个重载方法Map&lt;Boolean, List&lt;String&gt;&gt; moreThan = list.stream().collect(Collectors.partitioningBy(e -&gt; Integer.parseInt(e) &gt; 300));System.out.println(moreThan);// &#123;false=[123, 100, 228, 250], true=[521, 838, 345]&#125;Map&lt;Boolean, Set&lt;String&gt;&gt; lessThan = list.stream().collect(Collectors.partitioningBy(e -&gt; Integer.parseInt(e) &lt; 300, Collectors.toSet()));System.out.println(lessThan);// &#123;false=[521, 345, 838], true=[100, 123, 228, 250]&#125; 4.1 遍历集合4.1.1 遍历List示例： java123456List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;张三&quot;);list.add(&quot;李四&quot;);list.add(&quot;王五&quot;);list.add(&quot;赵六&quot;);list.forEach(e -&gt; System.out.println(e)); 4.1.2 遍历Set示例： java123456Set&lt;String&gt; set = new HashSet&lt;String&gt;();set.add(&quot;张三&quot;);set.add(&quot;李四&quot;);set.add(&quot;王五&quot;);set.add(&quot;赵六&quot;);set.forEach(e -&gt; System.out.println(e)); 4.1.3 遍历Map示例： java123456Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();map.put(101, &quot;张三&quot;);map.put(102, &quot;李四&quot;);map.put(103, &quot;王五&quot;);map.put(104, &quot;赵六&quot;);map.forEach((key, value) -&gt; System.out.println(key+&quot;-&gt;&quot;+value));","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"网络编程","slug":"D00-后端/D01-Java/002-高级/004-网络编程","date":"2025-05-07T01:13:26.000Z","updated":"2025-07-22T01:26:33.828Z","comments":true,"path":"posts/20250507/091326/","permalink":"https://momashanhe.com/posts/20250507/091326/","excerpt":"摘要：本文学习了网络编程的相关知识，包括TCP网络编程和UDP网络编程，以及如何使用RMI远程调用。","text":"摘要：本文学习了网络编程的相关知识，包括TCP网络编程和UDP网络编程，以及如何使用RMI远程调用。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 基础1.1 定义网络编程就是在两个或两个以上的设备之间传输数据。程序员所作的事情就是把数据发送到指定的位置，或者接收到指定的数据，这个就是狭义的网络编程范畴。 网络编程的基本模型就是客户机到服务器模型，简单的说就是两个进程之间相互通讯，然后其中一个提供固定位置，而另一个则需要知道这个固定位置，就能建立两者之间的联系，然后完成数据的通讯就可以了。提供固定位置的通常称为服务器，建立联系的通常称为客户端。 Java从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序，联网的底层细节被隐藏在安装系统里，由JVM进行控制。 1.2 网络通信网络通信中的两个要素 IP地址和端口号：用于在网络上找到主机地址和主机上的特定应用。 网络协议，用于可靠高效地进行数据传输，有两套参考模型： OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广。 TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准，还可以细分为四层和五层。 1.3.1 IP地址为了解决如何在网络上找到主机地址的问题，引入了IP地址和域名（Domain Name）的概念。 使用IP地址能够在网络上唯一标识网络设备，但由于IP地址不容易记忆，又创造用于映射IP地址的域名，一个IP地址可以对应多个域名，一个域名只能对应一个IP地址。 在实际传输数据前需要将域名转换为IP地址，实现这种功能的服务器称为DNS服务器，也就是域名解析。 1.3.2 端口号为了解决如何在主机上找到特定应用的问题，引入了端口（Port）的概念。 使用端口能够在主机中唯一标识应用，在主机上可以通过端口区分发送给每个应用的数据，实现了多个网络程序在共同的主机上运行，并且不会互相干扰。 1.3.3 网络协议有了IP地址和端口号以后，在进行网络通讯交换时，就可以通过IP地址查找到主机，然后通过端口标识程序，这样就可以进行网络数据的交换了。 为了解决如何保证数据交换的安全可靠，引入了网络协议（Protocol）的概念。 网络协议用于在实际进行数据交换时规定数据的格式，避免格式不同导致的数据识别错误等问题。 常见的网络模型对比如下： OSI七层网络模型 TCP/IP四层网络模型 TCP/IP五层网络模型 网络协议 工作设备 应用层 应用层 应用层 HTTP HTTPS FTP SMTP POP3 计算机及应用 表示层 会话层 传输层 传输层 传输层 TCP UDP 四层交换机 四层路由器 网络层 网络层 网络层 IP ICMP ARP RARP 三层交换机 路由器 网关 数据链路层 网络接口层 数据链路层 Ethernet PPP 交换机 网桥 物理层 物理层 USB 中继器 集线器 TCP和UDP比较： 特性 TCP UDP 是否连接 面向连接。 无连接。 是否可靠 可靠传输，使用流量控制和拥塞控制。 不可靠传输，不使用流量控制和拥塞控制。 连接对象个数 只能是一对一通信。 支持一对一，一对多，多对一和多对多交互通信。 传输方式 面向字节流。 面向报文。 首部开销 首部最小20字节，最大60字节。 首部开销小，仅8字节。 适用场景 适用于要求可靠传输的应用，例如文件传输。 适用于实时应用，例如IP电话、视频会议。 1.3 统一资源定位符统一资源定位符（URL，Uniform Resource Locator），表示网络上某一资源的地址，通过URL可以访问网络上的各种资源。 URL主要由协议和资组成，语法： java1传输协议://主机名:端口号/文件名#内部引用?参数列表。 1.3.1 URL构造方法： java1234// 根据String表示形式创建URL对象public URL(String spec);// 根据指定protocol、host、port和file创建URL对象public URL(String protocol, String host, int port, String file); 常用方法： java12345678910111213141516// 获取此URL的协议名称public String getProtocol();// 获取此URL的主机名（如果适用）public String getHost();// 获取此URL的端口号public int getPort();// 获取此URL的文件名public String getFile();// 获取此URL的内部引用public String getRef();// 获取此URL的路径部分public String getPath();// 读取网络资源public final InputStream openStream();// 创建URLConnection实例对象public URLConnection openConnection(); 示例： java12345678910111213public static void main(String[] args) &#123; try &#123; URL url = new URL(&quot;http://www.gamelan.com:80/Gamelan/network.html#BOTTOM&quot;); System.out.println(url.getProtocol()); System.out.println(url.getHost()); System.out.println(url.getPort()); System.out.println(url.getFile()); System.out.println(url.getRef()); System.out.println(url.getPath()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125;&#125; 结果： log123456httpwww.gamelan.com80/Gamelan/network.htmlBOTTOM/Gamelan/network.html 1.3.2 URLConnectionURLConnection表示到URL所引用的远程对象的连接。当与URL建立连接时，首先要生成对应的URLConnection对象。如果连接过程失败，将产生IOException。 获取方法： java12// 通过URL类的方法获取URLConnection实例public URLConnection openConnection(); 常用方法： java1234// 获取输入流public InputStream getInputStream();// 获取输出流public OutputStream getOutputStream(); 2 TCP网络编程2.1 常用类2.1.1 InetAddress此类表示互联网协议（IP）地址。 常用方法： java12345678// 根据IP地址或者域名获取InetAddress实例public static InetAddress getByName(String host);// 获取IP地址为本地的InetAddress实例public static InetAddress getLocalHost();// 获取InetAddress实例的主机名public String getHostName();// 获取InetAddress实例的IP地址public String getHostAddress(); 示例： java12345678910public static void main(String[] args) &#123; try &#123; InetAddress baidu = InetAddress.getByName(&quot;www.baidu.com&quot;); InetAddress local = InetAddress.getLocalHost(); System.out.println(baidu.getHostName()); System.out.println(local.getHostAddress()); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125;&#125; 结果： log12www.baidu.com192.168.1.109 2.1.2 InetSocketAddress此类实现IP套接字地址（IP地址和端口号）。 构造方法： java123456// 根据端口创建本地套接字地址public InetSocketAddress(int port);// 根据IP地址和端口号创建套接字地址public InetSocketAddress(InetAddress addr, int port);// 根据主机名和端口号创建套接字地址public InetSocketAddress(String hostname, int port); 常用方法： java12345678// 获取InetAddress实例public final InetAddress getAddress();// 获取主机名public final String getHostName();// 获取端口号public final int getPort();// 构造此InetSocketAddress的字符串表示形式（主机名/IP:端口号）public String toString(); 示例： java123456789101112public static void main(String[] args) &#123; try &#123; InetSocketAddress local = new InetSocketAddress(InetAddress.getLocalHost(), 80); InetSocketAddress baidu = new InetSocketAddress(&quot;www.baidu.com&quot;, 80); System.out.println(baidu); System.out.println(baidu.getHostName()); System.out.println(local.getAddress().getHostAddress()); System.out.println(local.getPort()); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125;&#125; 结果： log1234www.baidu.com/182.61.200.7:80www.baidu.com192.168.1.10980 2.1.3 Socket此类实现客户端套接字，一般使用套接字表示客户端套接字。客户端套接字是两台机器间通信的端点。 构造方法： java1234// 创建一个流套接字并将其连接到指定IP地址的指定端口号public Socket(InetAddress address, int port);// 创建一个流套接字并将其连接到指定主机上的指定端口号public Socket(String host, int port); 常用方法： java123456// 返回此套接字的输出流public OutputStream getOutputStream();// 返回此套接字的输入流public InputStream getInputStream();// 关闭此套接字public void close(); 2.1.4 ServerSocket此类实现服务器套接字。服务器套接字等待请求通过网络传入。 构造方法： java12// 创建绑定到特定端口的服务器套接字public ServerSocket(int port); 常用方法： java1234// 侦听并接受到此套接字的连接public Socket accept();// 关闭此套接字public void close(); 2.2 客户端2.2.1 建立连接在客户端网络编程中，首先需要建立连接。 示例： java1Socket s = new Socket(&quot;192.168.1.103&quot;, 8800); 使用服务端8800号端口建立连接，如果建立连接时本机网络不通，或服务器端程序未开启，会抛出异常。 2.2.2 数据交换建立连接后，需要获得输入流和输出流与服务器端进行通信。使用输出流发送数据到服务器，使用输入流接收服务器发送的数据。 示例： java12OutputStream os = s.getOutputStream();// 获得输出流InputStream is = s.getInputStream();// 获得输入流 2.2.3 关闭连接当数据交换完成以后，关闭网络连接，释放网络连接占用的系统端口和内存等资源。 示例： java1s.close(); 2.3 服务端2.3.1 监听端口在服务器端网络编程中，由于服务器端实现的是被动等待连接，所以首先要监听是否有客户端连接请求。 示例： java1ServerSocket ss = new ServerSocket(8800); 如果服务端8800号端口已经被别的程序占用，那么将抛出异常。 2.3.2 获得连接当有客户端发起连接请求时建立连接。 示例： java1Socket s = ss.accept(); 2.3.3 数据交换获得连接后，需要获得输入流和输出流与客户端端进行通信。使用输入流读取客户端发送的数据，使用输出流发送数据到客户端，服务端交换数据的顺序和客户端刚好相反。 示例： java12OutputStream os = s.getOutputStream();// 获得输出流InputStream is = s.getInputStream();// 获得输入流 2.3.4 关闭连接当数据交换完成以后，关闭网络连接，同时关闭监听。 示例： java12s.close();ss.close(); 2.4 发送消息客户端示例： java12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Socket s = null; OutputStream os = null; try &#123; System.out.println(&quot;客户端已启动&quot;); s = new Socket(InetAddress.getLocalHost(), 8800); os = s.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); System.out.println(&quot;客户端成功发送数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务端示例： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; System.out.println(&quot;服务端已启动&quot;); ss = new ServerSocket(8800); s = ss.accept(); is = s.getInputStream(); byte[] temp = new byte[1024]; int len; baos = new ByteArrayOutputStream(); while ((len = is.read(temp)) != -1) &#123; baos.write(temp, 0, len); &#125; System.out.println(&quot;服务端成功接收数据：&quot; + baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 客户端结果： log12客户端已启动客户端成功发送数据 服务端结果： log12服务端已启动服务端成功接收数据：你好，我是客户端 2.5 响应消息客户端示例： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String[] args) &#123; Socket s = null; OutputStream os = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; System.out.println(&quot;客户端已启动&quot;); s = new Socket(InetAddress.getLocalHost(), 8800); os = s.getOutputStream(); os.write(&quot;你好，我是客户端&quot;.getBytes()); System.out.println(&quot;客户端成功发送数据&quot;); s.shutdownOutput(); is = s.getInputStream(); byte[] temp = new byte[1024]; int len; baos = new ByteArrayOutputStream(); while ((len = is.read(temp)) != -1) &#123; baos.write(temp, 0, len); &#125; System.out.println(&quot;客户端成功接收服务端回传数据：&quot; + baos.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务端示例： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void main(String[] args) &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; ByteArrayOutputStream baos = null; OutputStream os = null; try &#123; System.out.println(&quot;服务端已启动&quot;); ss = new ServerSocket(8800); s = ss.accept(); is = s.getInputStream(); byte[] temp = new byte[1024]; int len; baos = new ByteArrayOutputStream(); while ((len = is.read(temp)) != -1) &#123; baos.write(temp, 0, len); &#125; System.out.println(&quot;服务端成功接收数据：&quot; + baos.toString()); os = s.getOutputStream(); os.write(&quot;你好，我是服务端&quot;.getBytes()); System.out.println(&quot;服务端成功发送回传数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (baos != null) &#123; try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 客户端结果： log123客户端已启动客户端成功发送数据客户端成功接收服务端回传数据：你好，我是服务端 服务端结果： log123服务端已启动服务端成功接收数据：你好，我是客户端服务端成功发送回传数据 3 UDP网络编程3.1 常用类3.1.1 DatagramSocket此类表示用来发送和接收数据报包的套接字。 构造方法： java123456// 创建数据报套接字，将其绑定到本地地址上的随机端口public DatagramSocket();// 创建数据报套接字，将其绑定到本地地址上的指定端口public DatagramSocket(int port);// 创建数据报套接字，将其绑定到指定地址上的指定端口public DatagramSocket(int port, InetAddress laddr); 常用方法： java123456// 从此套接字发送数据报包public void send(DatagramPacket p);// 从此套接字接收数据报包public synchronized void receive(DatagramPacket p);// 关闭此数据报套接字public void close(); 3.1.2 DatagramPacket此类表示数据报包。 构造方法： java12345678// 用来接收数据包public DatagramPacket(byte buf[], int length);// 用来接收数据包public DatagramPacket(byte buf[], int offset, int length);// 用来将数据包发送到指定主机上的指定端口public DatagramPacket(byte buf[], int length, InetAddress address, int port);// 用来将数据包发送到指定主机上的指定端口public DatagramPacket(byte buf[], int offset, int length, InetAddress address, int port); 常用方法： java1234// 从数据报包获得IP地址public synchronized InetAddress getAddress();// 从数据报包获得端口号public synchronized int getPort(); 3.2 客户端3.2.1 建立连接与TCP建立连接不同，使用UDP建立连接不需要指定服务器的IP和端口号。 示例： java1DatagramSocket ds = new DatagramSocket(); 可以指定客户端连接使用的端口号。 示例： java1DatagramSocket ds = new DatagramSocket(8811); 使用客户端8811号端口建立连接，一般在建立客户端连接时没有必要指定端口号。 3.2.2 发送数据在UDP网络编程中，不需要使用IO流，将数据内容以及服务器的IP地址和端口号封装发送即可。 示例： java123byte[] buffer = &quot;&quot;.getBytes();DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length, InetAddress.getLocalHost(), 8800);ds.send(dp); 按照UDP协议的约定，不保证数据一定被正确传输，如果数据在传输过程中丢失，那就丢失了。 3.2.3 接收数据在UDP网络编程中，不需要使用IO流，将数据内容封装接收即可。 示例： java123byte[] buffer = new byte[1024];DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length);ds.receive(dp); 3.2.4 关闭连接当数据交换完成以后，关闭网络连接。 示例： java1ds.close(); 需要说明的是，和TCP建立连接的方式不同，在UDP建立连接时没有固定的IP地址和端口号，可以将数据包发送到不同的IP地址和端口号，这点是TCP无法做到的。 3.3 服务端3.3.1 建立连接与UDP建立连接类似，但是需要指定服务端连接使用的端口号。 示例： java1DatagramSocket ds = new DatagramSocket(8800); 使用服务端8800号端口建立连接，由于服务器端的端口需要固定，所以一般在建立服务器端连接时都指定端口号。 3.3.2 接收数据将数据内容封装接收即可。 示例： java123byte[] buffer = new byte[1024];DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length);ds.receive(dp); 3.3.3 发送数据将数据内容以及客户端的IP地址和端口号封装发送即可。 示例： java123byte[] buffer = &quot;&quot;.getBytes();DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length, InetAddress.getLocalHost(), 8811);ds.send(dp); 建议通过前面接收数据的数据报包获取客户端的IP地址和端口号发送数据。 示例： java12InetAddress address = dp.getAddress();int port = dp.getPort(); 3.3.4 关闭连接当数据交换完成以后，关闭网络连接。 示例： java1ds.close(); 3.4 发送消息客户端示例： java12345678910111213public static void main(String[] args) &#123; try &#123; System.out.println(&quot;客户端已启动&quot;); DatagramSocket ds = new DatagramSocket(); byte[] buffer = &quot;我是客户端&quot;.getBytes(); DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length, InetAddress.getLocalHost(), 8800); ds.send(dp); System.out.println(&quot;客户端成功发送数据&quot;); ds.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 服务端示例： java12345678910111213public static void main(String[] args) &#123; try &#123; System.out.println(&quot;服务端已启动&quot;); DatagramSocket ds = new DatagramSocket(8800); byte[] buffer = new byte[1024]; DatagramPacket dp = new DatagramPacket(buffer, 0, buffer.length); ds.receive(dp); System.out.println(&quot;服务端成功接收数据：&quot; + new String(dp.getData(), 0, dp.getLength())); ds.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 客户端结果： log12客户端已启动客户端成功发送数据 服务端结果： log12服务端已启动服务端成功接收数据：我是客户端 3.5 响应消息客户端示例： java12345678910111213141516171819202122232425public static void main(String[] args) &#123; try &#123; System.out.println(&quot;顾客已上线&quot;); Scanner scan = new Scanner(System.in); DatagramSocket ds = new DatagramSocket(8811); while (true) &#123; String message = scan.next(); byte[] bufMes = message.getBytes(); DatagramPacket dpMes = new DatagramPacket(bufMes, 0, bufMes.length, InetAddress.getLocalHost(), 8800); ds.send(dpMes); byte[] bufRec = new byte[1024]; DatagramPacket dpRec = new DatagramPacket(bufRec, 0, bufRec.length); ds.receive(dpRec); String receive = new String(dpRec.getData(), 0, dpRec.getLength()); System.out.println(&quot;客服说：&quot; + receive); if (message.equals(&quot;bye&quot;)) &#123; break; &#125; &#125; scan.close(); ds.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 服务端示例： java12345678910111213141516171819202122232425public static void main(String[] args) &#123; try &#123; System.out.println(&quot;客服已上线&quot;); Scanner scan = new Scanner(System.in); DatagramSocket ds = new DatagramSocket(8800); while (true) &#123; byte[] bufRec = new byte[1024]; DatagramPacket dpRec = new DatagramPacket(bufRec, 0, bufRec.length); ds.receive(dpRec); String receive = new String(dpRec.getData(), 0, dpRec.getLength()); System.out.println(&quot;顾客说：&quot; + receive); String message = scan.next(); byte[] bufMes = message.getBytes(); DatagramPacket dpMes = new DatagramPacket(bufMes, 0, bufMes.length, InetAddress.getLocalHost(), 8811); ds.send(dpMes); if (message.equals(&quot;bye&quot;)) &#123; break; &#125; &#125; scan.close(); ds.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 客户端结果： log1234567891011顾客已上线客服您好！客服说：您好，请问有什么事情吗？我要退货客服说：好的，请填写退货单号退货单号已经填好了客服说：退货成功！请问还有其他事情吗？没有了，再见！客服说：好的，再见！bye客服说：bye 服务端结果： log1234567891011客服已上线顾客说：客服您好！您好，请问有什么事情吗？顾客说：我要退货好的，请填写退货单号顾客说：退货单号已经填好了退货成功！请问还有其他事情吗？顾客说：没有了，再见！好的，再见！顾客说：byebye 4 RMI远程调用1.1 通信方式常见的通信方式分为两种： 基于RPC远程调用的同步方式。 基于中间件代理的异步方式。 1.1.1 RPC远程调用基于RPC远程调用的同步方式： RPC（Remote Procedure Call，远程过程调用）是一种服务通信的调用方式，并不是具体的协议。 在RPC远程调用方式下，不同系统之间直接调用通信，每个请求直接从调用方发送到被调用方，然后要求被调用方返回响应结果给调用方，以确定本次调用结果是否成功。 此处的同步并不代表调用方式，RPC远程调用也可以有异步非阻塞的调用方式，但本质上仍然是需要在指定时间内得到被调用方的直接响应。 RPC的实现有很多，比如最早的CORBA和RMI，以及最近的WebService和Dubbo，甚至也可以将RESTful API看做是RPC的实现。 1.1.2 中间件代理基于中间件代理的异步方式： 在中间件代理方式下，各子系统之间无需强耦合直接连接，调用方只需要将请求转化成异步事件（通常为异步消息）发送给中间代理，发送成功即可认为该异步链路调用完成，剩下的工作会由中间代理负责将事件可靠通知到下游的调用系统，确保任务执行完成。 中间件代理一般使用消息中间件，比如老牌的ActiveMQ和RabbitMQ，炙手可热的Kafka，以及阿里巴巴自主研发的RocketMQ。 1.2 定义RMI（Remote Method Invocation，远程方法调用）是Java中的一种远程通信协议，允许程序利用序列化机制远程调用方法，可以看做是RPC的一种实现。 RMI与Socket的区别： Socket独立于开发语言，客户端和服务端可以使用不同的开发语言。RMI和Java语言绑定，客户端和服务端都必须使用Java语言开发。 Socket属于传输层协议，使用TCP协议和UDP协议进行通信。RMI属于应用层协议，传输层使用Java远程消息交换协议（JRMP，Java Remote Messaging Protocol）进行通信。 Socket更灵活，可以控制序列化机制。RMI更方便，在Socket的基础上增加了对象序列化机制。 Socket占用的带宽更少，适合需要传输大量数据的场景。RMI占用的宽带较多，适合处理需要逻辑计算的场景。 1.3 使用1.3.1 公共接口编写公共接口，暴露服务： java123456789package base;import java.rmi.Remote;import java.rmi.RemoteException;// 必须继承Remote接口，因为网络通信是不可靠的，所以要抛出RemoteException异常public interface BaseService extends Remote &#123; String hello() throws RemoteException;&#125; 1.3.2 客户端编写客户端启动类： java123456789101112131415161718package client;import base.BaseService;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class MainApp &#123; public static void main(String[] args) throws Exception &#123; // 连接注册中心 Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 8888); // 查找BaseService服务 BaseService baseService = (BaseService) registry.lookup(&quot;BaseService&quot;); // 调用方法 String hello = baseService.hello(); // 打印结果 System.out.println(hello); &#125;&#125; 1.3.3 服务端编写服务端实现类： java1234567891011121314151617package server;import base.BaseService;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;// 必须实现公共接口，必须继承UnicastRemoteObject类用于暴露远程服务public class ServerServiceImpl extends UnicastRemoteObject implements BaseService &#123; protected ServerServiceImpl() throws RemoteException &#123; super(); &#125; @Override public String hello() throws RemoteException &#123; System.out.println(&quot;call hello()&quot;); return &quot;hello&quot;; &#125;&#125; 编写服务端启动类： java12345678910111213141516package server;import base.BaseService;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class MainApp &#123; public static void main(String[] args) throws Exception &#123; // 创建注册中心 Registry registry = LocateRegistry.createRegistry(8888); // 创建BaseService服务 BaseService baseService = new ServerServiceImpl(); // 注册服务 registry.rebind(&quot;BaseService&quot;, baseService); &#125;&#125; 1.3.4 运行先启动服务端启动类，然后启动客户端启动类。 1.4 原理流程如下： 概念说明： Stub：客户端的代理，对开发人员屏蔽了远程方法调用的细节。 Skeleton：服务端的代理，对开发人员屏蔽了远程方法调用的细节。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"文件操作","slug":"D00-后端/D01-Java/002-高级/003-文件操作","date":"2025-05-06T12:38:41.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250506/203841/","permalink":"https://momashanhe.com/posts/20250506/203841/","excerpt":"摘要：本文学习了如何使用输入输出流对文件进行操作。","text":"摘要：本文学习了如何使用输入输出流对文件进行操作。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 文件1.1 概念File类是数据源的一种，可以表示一个文件，也可以表示一个文件目录。 File类只能对文件和目录进行创建和删除等操作，可以查看文件和目录的属性，不能读取或修改内容。如果需要读取或修改文件的内容，需要使用输入输出流。 常常将File类的对象作为参数传递到输入输出流的类的构造器中。 绝对路径和相对路径： 相对路径：相对路径名必须使用取自其他路径名的信息进行解释。 绝对路径：绝对路径名是完整的路径名，不需要任何其他信息就可以定位它所表示的文件或目录。 相对路径创建的实例不等于绝对路径创建的实例。 1.2 常用方法查看文件和目录： java123456// 获得文件名或目录名String getName();// 获得相对路径String getPath();// 获得绝对路径String getAbsolutePath(); 创建和删除文件和目录： java12345678// 创建一个空文件boolean createNewFile();// 创建一个空目录boolean mkdir();// 创建指定的目录及父目录boolean mkdirs();// 删除文件或空目录boolean delete(); 常用的判断方法： java123456// 判断是否存在boolean exists();// 判断是否目录boolean isDirectory();// 判断是否文件boolean isFile(); 1.3 常量1.3.1 名称分隔符使用File.separator获取与系统有关的名称分隔符字符串，此字符串只包含separatorChar字符，用于分隔路径中的文件和目录。 separatorChar被初始化为包含系统属性file.separator值的第一个字符。在UNIX系统上对应/符号，在Windows系统上对应\\符号。 1.3.2 路径分隔符使用File.sepapathSeparatorrator获取与系统有关的路径分隔符字符串，此字符串只包含pathSeparatorChar字符，用于分隔以路径列表中的路径。 pathSeparatorChar被初始为包含系统属性path.separator值的第一个字符。在UNIX系统上对应:符号，在Windows系统上对应;符号。 2 输入输出流2.1 概念流是数据在数据源（文件）和程序（内存）之间经历的路径。 输入输出流可以称为IO流，I即输入流，O即输出流。流的方向以内存为参照，如果数据流向内存流动则是输入流，反之则是输出流。 文件和目录在程序中是以流的形式来操作的，凡是与输入输出相关的都定义在java.io包下。 打开的资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭。关闭流时只需要考虑关闭最外层的流即可，如果要强制关闭所有流，必须先关闭外层的流。 在JDK1.7之后，可以在try-catch代码块中打开流，最后程序会自动关闭流对象。 2.2 分类按数据流的流向：输入流，输出流。 按操作数据单位：字节流（InputStream、OutputStream），字符流（Reader、Writer）。 按流的角色：节点流，处理流。 3 文件流文件流主要有：FileInputStream、FileOutputStream、FileReader、FileWriter。 这四个类用于操作文件流，用法高度相似，前面两个操作字节流，后面两个操作字符流。 文件流直接与操作系统底层交互，因此也被称为节点流，节点流需要关流。 3.1 FileInputStream构造方法： java12FileInputStream(File file);FileInputStream(String name); 常用方法： java12345678// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(byte[] b);// 从输入流中将len个数据读入到数组int read(byte[] b, int off, int len);// 关闭输入流并释放系统资源void close(); 读入文件到输入流： java1234567891011121314151617181920212223public void test() &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream(new File(&quot;D:&quot; + File.separator + &quot;hello.txt&quot;)); byte[] buffer = new byte[1024]; int len = 0; String txt = &quot;&quot;; while ((len = fis.read(buffer)) != -1) &#123; txt += new String(buffer, 0, len); &#125; System.out.println(txt); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.2 FileOutputStream构造方法： java1234FileOutputStream(File file);FileOutputStream(File file, boolean append);FileOutputStream(String name);FileOutputStream(String name, boolean append); 常用方法： java12345678910// 从指定字节中写出到输出流void write(int b);// 从数组中写出到输出流void write(byte[] b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 读出文件到输出流： java1234567891011121314151617public void test() &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(new File(&quot;D:&quot; + File.separator + &quot;hello.txt&quot;)); fos.write(&quot;hello&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.3 FileReader构造方法： java12FileReader(File file);FileReader(String fileName); 常用方法： java12345678910// 返回此流使用的字符编码的名称String getEncoding();// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(char[] cbuf);// 从输入流中将len个数据读入到数组int read(char[] cbuf, int off, int len);// 关闭输入流并释放系统资源void close(); 读入文本到输入流： java1234567891011121314151617181920212223public void test() &#123; FileReader fr = null; try &#123; fr = new FileReader(new File(&quot;D:&quot; + File.separator + &quot;hello.txt&quot;)); char[] buffer = new char[1024]; int len = 0; String txt = &quot;&quot;; while ((len = fr.read(buffer)) != -1) &#123; txt = new String(buffer, 0, len); &#125; System.out.print(txt); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fr != null) &#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.4 FileWriter构造方法： java1234FileWriter(File file);FileWriter(File file, boolean append);FileWriter(String fileName);FileWriter(String fileName, boolean append); 常用方法： java12345678910111213141516// 返回此流使用的字符编码的名称String getEncoding();// 从指定字节中写出到输出流void write(int b);// 从数组中写出到输出流void write(byte[] b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 从字符串中写出到输出流void write(String str);// 从字符串中将len个数据写出到输出流void write(String str, int off, int len);// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 读出文本到输出流： java1234567891011121314151617public void test() &#123; FileWriter fw = null; try &#123; fw = new FileWriter(new File(&quot;D:&quot; + File.separator + &quot;hello.txt&quot;)); fw.write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fw != null) &#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.5 复制文件使用字节流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;D:&quot; + File.separator + &quot;old.jpeg&quot;); fos = new FileOutputStream(&quot;D:&quot; + File.separator + &quot;new.jpeg&quot;); byte[] buffer = new byte[1024]; int len = 0; while ((len = fis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用字符流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader(&quot;D:&quot; + File.separator + &quot;old.txt&quot;); fw = new FileWriter(&quot;D:&quot; + File.separator + &quot;new.txt&quot;); char[] buffer = new char[1024]; int len = 0; while ((len = fr.read(buffer)) != -1) &#123; fw.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fr != null) &#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fw != null) &#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4 缓冲流缓冲流主要有：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。 这四个类可以封装现有的节点流，实现对数据传输的效率的提升。 缓冲流比文件流多了一个缓冲区，读取时先从缓冲区读取，当缓冲区数据读完时再把数据写入到缓冲区。因此，当每次读取的数据量很小时，文件流从硬盘读入，缓冲流从缓冲区读入。读取内存速度比读取硬盘速度快得多，因此缓冲流效率高。 缓冲流的默认缓冲区大小是8192字节，当每次读取数据量接近或远超这个值时，两者效率就没有明显差别了。 缓冲流属于处理流，处理流需要关流。 4.1 BufferedInputStream构造方法： java12BufferedInputStream(InputStream in);BufferedInputStream(InputStream in, int size); 常用方法： java12345678// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(byte[] b);// 从输入流中将len个数据读入到数组int read(byte[] b, int off, int len);// 关闭输入流并释放系统资源void close(); 4.2 BufferedOutputStream构造方法： java12BufferedOutputStream(OutputStream out);BufferedOutputStream(OutputStream out, int size); 常用方法： java12345678910// 从指定字节中写出到输出流void write(int b);// 从数组中写出到输出流void write(byte[] b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 4.3 BufferedReader构造方法： java12BufferedReader(Reader in);BufferedReader(Reader in, int size); 常用方法： java12345678// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(char[] cbuf);// 从输入流中将len个数据读入到数组int read(char[] cbuf, int off, int len);// 关闭输入流并释放系统资源void close(); 4.4 BufferedWriter构造方法： java12BufferedWriter(Writer out);BufferedWriter(Writer out, int size); 常用方法： java1234567891011121314// 从指定字节中写出到输出流void write(int c);// 从数组中写出到输出流void write(char[] cbuf);// 从数组中将len个数据写出到输出流void write(char[] cbuf, int off, int len);// 从字符串中写出到输出流void write(String str);// 从字符串中将len个数据写出到输出流void write(String str, int off, int len);// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 4.5 复制文件使用字节流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; bis = new BufferedInputStream(new FileInputStream(&quot;D:&quot; + File.separator + &quot;old.mp3&quot;)); bos = new BufferedOutputStream(new FileOutputStream(&quot;D:&quot; + File.separator + &quot;new.mp3&quot;)); byte[] buffer = new byte[1024]; int len = 0; while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (bis != null) &#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bos != null) &#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用字符流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader(&quot;D:&quot; + File.separator + &quot;old.txt&quot;)); bw = new BufferedWriter(new FileWriter(&quot;D:&quot; + File.separator + &quot;new.txt&quot;)); char[] buffer = new char[1024]; int len = 0; while ((len = br.read(buffer)) != -1) &#123; bw.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bw != null) &#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5 转换流转换流主要有：InputStreamReader、OutputStreamWriter。 这两个流可以将文本在字节流和字符流之间进行转换，但只能处理文本文件。 转换流需要关流。 5.1 InputStreamReader构造方法： java12InputStreamReader(InputStream in);InputStreamReader(InputStream in, String charsetName); 常用方法： java12345678910// 返回此流使用的字符编码的名称String getEncoding();// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(char[] cbuf);// 从输入流中将len个数据读入到数组int read(char[] cbuf, int off, int len);// 关闭输入流并释放系统资源void close(); 5.2 OutputStreamWriter构造方法： java12OutputStreamWriter(OutputStream out);OutputStreamWriter(OutputStream out, String charsetName); 常用方法： java12345678910111213141516// 返回此流使用的字符编码的名称String getEncoding();// 从指定字节中写出到输出流void write(int c);// 从数组中写出到输出流void write(char[] cbuf);// 从数组中将len个数据写出到输出流void write(char[] cbuf, int off, int len);// 从字符串中写出到输出流void write(String str);// 从字符串中将len个数据写出到输出流void write(String str, int off, int len);// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 5.3 复制文件使用转换流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; InputStreamReader isr = null; OutputStreamWriter osw = null; try &#123; isr = new InputStreamReader(new FileInputStream(&quot;D:&quot; + File.separator + &quot;old.txt&quot;), &quot;UTF-8&quot;);// 确定解码集 osw = new OutputStreamWriter(new FileOutputStream(&quot;D:&quot; + File.separator + &quot;new.txt&quot;), &quot;UTF-8&quot;);// 确定编码集 char[] buffer = new char[20]; int len = 0; while ((len = isr.read(buffer)) != -1) &#123; osw.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (isr != null) &#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (osw != null) &#123; try &#123; osw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 6 内存读写流内存读写流主要有：ByteArrayOutputStream、ByteArrayInputStream。 内存读写流将数组当作流输入输出对象的类。 不同于指向硬盘的流，它内部是使用字节数组读内存的，这个字节数组是它的成员变量，当这个数组不再使用变成垃圾时会被回收，所以内存读写流不需要关流。 6.1 ByteArrayInputStream构造方法： java12ByteArrayInputStream(byte[] b);ByteArrayInputStream(byte[] b, int off, int len); 常用方法： java1234// 从输入流中读入一个字节int read();// 从输入流中将len个数据读入到数组int read(byte[] b, int off, int len); 6.2 ByteArrayIOutputStream构造方法： java12ByteArrayIOutputStream();ByteArrayIOutputStream(int size); 常用方法： java123456789101112// 从指定字节中写出到输出流void write(int b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 将缓冲区内容转换字节数组byte toByteArray();// 将缓冲区内容转换为字符串String toString();// 将缓冲区内容转换为指定编码格式的字符串String toString(String charsetName);// 将缓冲区内容输出到指定的输出流void writeTo(OutputStream out); 6.3 解决乱码当用字节数组读取字符串时，受数组长度的影响，导致产生乱码。 如果用String类型接收，则不能完全解析出正常的文字，需要使用字节数组输出流将字节数组的内容输出到缓冲区，待读取完成后再转换为String类型的字符串。 示例： java12345678910111213141516171819public void test() &#123; ByteArrayInputStream bais = null; ByteArrayOutputStream baos = null; try &#123; bais = new ByteArrayInputStream(&quot;测试写入内容&quot;.getBytes()); baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1]; int len = -1; String txt = &quot;&quot;; while ((len = bais.read(buffer)) != -1) &#123; baos.write(buffer, 0, len); txt += new String(buffer, 0, len); &#125; System.out.println(&quot;正常：&quot; + baos.toString()); System.out.println(&quot;乱码：&quot; + txt); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 7 标准流7.1 System.in可以获取键盘输入的值，属于字节流。 获取方式： java1static InputStream in; 7.2 System.out可以将文本从控制台输出，属于字节流。 PrintStream是FileOutputStream下的子类，而FileOutputStream是OutputStream下的子类。 获取方式： java1static PrintStream out; 7.3 读取输入内容从控制台中读取输入内容： java123456789101112131415161718public void test() &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;请输入字符串：&quot;); System.out.println(&quot;输入的字符串为：&quot; + br.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7.4 读取文件内容从文件中读取输入内容： java1234567891011121314public void test() &#123; try &#123; System.setIn(new FileInputStream(&quot;D:&quot; + File.separator + &quot;output.txt&quot;)); byte[] buffer = new byte[1024]; int len = 0; String str = &quot;&quot;; while ((len = System.in.read(buffer)) != -1) &#123; str += new String(buffer, 0, len); &#125; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 7.5 输出内容将内容输出到控制台和文件： java123456789public void test() &#123; try &#123; System.out.println(&quot;这是输出到控制台的文字。&quot;); System.setOut(new PrintStream(&quot;D:&quot; + File.separator + &quot;input.txt&quot;)); System.out.println(&quot;这是输出到文件里的文字。&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 8 对象流对象流主要有：ObjectInputStream、ObjectOutputStream。 这两个类型都是字节流，可以处理所有文件，可以将内存中的对象保存到本地，也可以将本地的对象还原到内存中。 8.1 序列化8.1.1 概念对象序列化机制允许把内存中的对象转换成平台无关的二进制流，当其它程序获取了这种二进制流，就可以恢复成原来的对象。 如果想将一个对象进行网络传输，要求是该对象必须是可序列化的，该类必须实现Serializable接口或者Externalizable接口。 不能序列化static和transient修饰的属性。 8.1.2 好处序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原。 序列化是远程方法调用（Remote Method Invoke）过程的参数和返回值都必须实现的机制，而RMI是系统调用的基础，因此序列化机制是系统调用的基础。 8.1.3 实现序列化是用ObjectOutputStream类保存基本类型数据或对象的机制，因为是输出到文件里，所以是输出流。 反序列化是用ObjectInputStream类读取基本类型数据或对象的机制，因为将数据输入到内存里，所以是输入流。 8.1.4 自定义在进行序列化和反序列化时，虚拟机会首先试图调用对象里的writeObject和readObject方法，进行用户自定义的序列化和反序列化。 如果没有这样的方法，那么默认调用的是ObjectOutputStream的defaultWriteObject以及ObjectInputStream的defaultReadObject方法。 8.1.5 验证版本序列化机制是通过判断类的serialVersionUID来验证版本一致性的。 在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现InvalidCastException序列化版本不一致的异常。 serialVersionUID有两种生成方式：生成默认的1L，或者生成一个64位的Hash字段。 8.2 ObjectInputStream构造方法： java1ObjectInputStream(InputStream in); 常用方法： java1234567891011121314// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(byte[] buf);// 从输入流中将len个数据读入到数组int read(byte[] buf, int off, int len);// 使用UTF-8编码读取字符串String readUTF();// 读取要保存的变量Object readObject();// 默认的读取变量的方法void defaultReadObject();// 关闭输入流并释放系统资源void close(); 示例： java1234567891011public void deserialize() &#123; try &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:&quot; + File.separator + &quot;object.obj&quot;)); System.out.println(ois.readInt()); System.out.println(ois.readObject()); System.out.println((Box) ois.readObject()); ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 8.3 ObjectOutputStream构造方法： java1DataOutputStream(OutputStream out); 常用方法： java12345678910111213141516// 从指定字节中写出到输出流void write(int b);// 从数组中写出到输出流void write(byte[] b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 使用UTF-8编码写入字符串void writeUTF(String str);// 写入要保存的变量void writeObject(Object obj);// 默认的写入变量的方法void defaultWriteObject();// 刷新该流的缓冲void flush();// 关闭输出流并释放系统资源void close(); 示例： java1234567891011public void serialize() &#123; try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:&quot; + File.separator + &quot;object.obj&quot;)); oos.writeInt(100); oos.writeObject(&quot;String&quot;); oos.writeObject(new Box(&quot;box&quot;, 6, 8)); oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 9 随机存取文件流随机存取文件流可以处理所有文件，既可以充当输入流，又可以充当输出流。 如果将要输出文件不存在则尝试自动创建，并将内容输出到此文件中。如果将要输出的文件存在，则将对文件内容进行覆盖。 9.1 RandomAccessFile构造方法： java12RandomAccessFile(File file, String mode);RandomAccessFile(String name, String mode); 使用mode指定文件的访问模式： r：以只读方式打开。 rw：打开以便读取和写入。 rws：还要求对文件的内容或元数据的更新都同步到底层存储设备。 rwd：还要求对文件内容的更新都同步到底层存储设备。 常用方法： java123456789101112131415161718// 从指定字节中写出到输出流void write(byte[] b);// 从数组中写出到输出流void write(int b);// 从数组中将len个数据写出到输出流void write(byte[] b, int off, int len);// 从输入流中读入一个字节int read();// 从输入流中读入到数组int read(byte[] b);// 从输入流中将len个数据读入到数组int read(byte[] b, int off, int len);// 获取文件记录指针的当前位置long getFilePointer();// 将文件记录指针定位到pos位置void seek(long pos);// 关闭流并释放系统资源void close(); 9.2 复制文件使用随机存取文件流复制文件： java123456789101112131415161718192021222324252627282930public void test() &#123; RandomAccessFile r = null; RandomAccessFile w = null; try &#123; r = new RandomAccessFile(new File(&quot;D:&quot; + File.separator + &quot;read.txt&quot;), &quot;r&quot;); w = new RandomAccessFile(new File(&quot;D:&quot; + File.separator + &quot;write.txt&quot;), &quot;rw&quot;); byte[] buffer = new byte[1024]; int len = 0; while ((len = r.read(buffer)) != -1) &#123; w.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (r != null) &#123; try &#123; r.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (w != null) &#123; try &#123; w.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 9.3 插入内容使用随机存取文件流插入内容： java123456789101112131415161718192021222324public void test() &#123; RandomAccessFile raf = null; try &#123; raf = new RandomAccessFile(&quot;D:&quot; + File.separator + &quot;read.txt&quot;, &quot;rw&quot;); raf.seek(3); byte[] buffer = new byte[1024]; int len = 0; String str = &quot;&quot;; while ((len = raf.read(buffer)) != -1) &#123; str += new String(buffer, 0, len); &#125; raf.seek(3); raf.write(&quot;read&quot;.getBytes()); raf.write(str.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"反射","slug":"D00-后端/D01-Java/002-高级/002-反射","date":"2025-05-06T05:15:26.000Z","updated":"2025-08-03T11:32:46.649Z","comments":true,"path":"posts/20250506/131526/","permalink":"https://momashanhe.com/posts/20250506/131526/","excerpt":"摘要：本文学习了什么是反射，以及如何使用反射。","text":"摘要：本文学习了什么是反射，以及如何使用反射。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介反射被视为动态语言的关键，反射机制允许程序在执行期借助于API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。 这个Class类型的对象就像一面镜子，可以透过这个镜子看到类的结构，所以形象的称之为反射。 2 原理2.1 Class2.1.1 定义Class是用来描述类的类，封装了当前对象所对应的类的信息，通过Class可以得到一个类中所有被加载的结构。 将书看做一个对象，一本书有名称，作者，字数等，使用Book类描述所有书的信息。根据万物皆对象，可以将类看做一个对象，一个类中有属性，方法，构造器等，使用Class类描述所有类的信息。 Class类是一特殊的类，对于每个类而言，虚拟机都为其保留一个不变的Class类的对象。Class类的对象只能由虚拟机创建，一个类只能有一个Class类的对象。 支持Class实例的类型：类，接口，枚举，注解，数组，基本数据类型（包含Void类但不存在Null类）。 2.1.2 方法类的信息： java1234567891011121314// 获取指定类名的Class对象static Class&lt;?&gt; forName(String className);// 获取该Class对象对应的类的实例T newInstance();// 获取全类名String getName();// 获取包名Package getPackage();// 获取修饰符标志数int getModifiers();// 获取类加载器ClassLoader getClassLoader();// 获取读取的文件流InputStream getResourceAsStream(String name); 属性和方法： java123456789101112131415161718192021222324// 获取公共的指定名称的属性，包括父类的Field getField(String name);// 获取指定名称的属性，不包括父类的Field getDeclaredField(String name);// 获取公共的所有的属性，包括父类的Field[] getFields();// 获取所有的属性，不包括父类的Field[] getDeclaredFields();// 获取公共的指定名称和参数的方法，包括父类的Method getMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取指定名称和参数的方法，不包括父类的Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);// 获取公共的所有的方法，包括父类的Method[] getMethods();// 获取所有的方法，不包括父类的Method[] getDeclaredMethods();// 获取公共的指定参数的构造方法Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);// 获取指定参数的方法Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes);// 获取公共的所有的构造方法Constructor&lt;?&gt;[] getConstructors();// 获取所有的构造方法Constructor&lt;?&gt;[] getDeclaredConstructors(); 继承和实现： java12345678910111213141516// 获取公共的所有的注解Annotation[] getAnnotations();// 获取所有的注解Annotation[] getDeclaredAnnotations();// 获取公共的指定类型的注解&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass);// 获取指定类型的注解&lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass);// 获取实现的所有接口Class&lt;?&gt;[] getInterfaces();// 获取实现的所有接口，包含泛型Type[] getGenericInterfaces();// 获取继承的父类Class&lt;? super T&gt; getSuperclass();// 获取继承的父类，包含泛型Type getGenericSuperclass(); 2.1.3 获取Class没有公共构造方法，Class对象是在加载类时由虚拟机创建的。 获取Class类的实例有四种方式： 直接调用运行时类的.class属性：java1Class clazz = String.class; 通过调用运行时类的对象的getClass()方法：java1Class clazz = &quot;www.demo.com&quot;.getClass(); 调用Class的forName()方法：java1Class clazz = Class.forName(&quot;refl.Person&quot;); 使用ClassLoader的loadClass()方法：java12ClassLoader cl = this.getClass().getClassLoader();Class clazz = cl.loadClass(&quot;refl.Person&quot;); 使用Class的forName()方法和使用ClassLoader的loadClass()方法都能获取指定类的Class实例，也都会进行类的加载，都能将class字节码文件加载到虚拟机中。 其区别是： 在调用Class的forName()方法时，会进行类的加载以外，也会进行类的初始化，初始化静态成员变量和执行静态代码块，但不会执行构造方法创建对象。只有在调用了newInstance()方法后，才会调用空参的构造方法创建对象。 在调用ClassLoader的loadClass()方法时，只会进行类的加载，不会进行类的初始化，也不会执行构造方法创建对象。 2.2 ClassLoader2.2.1 类的加载过程当程序主动使用了某个类时，该类还未被加载到内存中，那么系统会通过下面三个步骤对该类进行初始化： 类的加载：将类的class文件读入内存，并为之创建一个Class对象。由类加载器完成。 类的连接：将类的二进制数据合并到JRE中。 类的初始化：JVM负责对类进行初始化。 2.2.2 类的初始化类的主动引用一定会发生类的初始化，类的被动引用不会发生类的初始化。 类的主动引用场景： 当虚拟机启动，先初始化main方法所在的类。 使用new关键字创建了一个类的对象。 调用类的静态成员（除了final常量）和静态方法。 使用java.lang.reflect包的方法对类进行反射调用。 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。 类的被动引用场景： 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 当通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化。 引用常量不会触发此类的初始化，常量在连接阶段就存入调用类的常量池中了。 2.2.3 类加载器的作用将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的Class对象，作为方法区中类数据的访问入口。 2.2.4 类加载器的分类类加载器分为三种： 引导类加载器：用C++编写的，是JVM自带的类装载器，负责Java平台核心库，用来装载核心类库。无法直接获取。 扩展类加载器：负责jre/lib/ext目录下的Jar包或–D java.ext.dirs指定目录下的Jar包装入工作库。 系统类加载器：负责java –classpath或–D java.class.path所指的目录下的类与Jar包装入工作，最常用的加载器。 2.2.5 常用方法常用方法： java12345678910// 将Class文件加载到内存时，并不会执行类的初始化Class&lt;?&gt; loadClass(String name);// 获取系统类加载器static ClassLoader getSystemClassLoader();// 获取当前类加载器的上级类加载器ClassLoader getParent();// 和getResourceAsStream用法类似static InputStream getSystemResourceAsStream(String name);// 从类路径下获取资源InputStream getResourceAsStream(String name); 2.2.6 获取类加载器获取系统类加载器（可以获取）： java1ClassLoader.getSystemClassLoader(); 获取扩展类加载器（可以获取）： java1ClassLoader.getSystemClassLoader().getParent(); 获取引导类加载器（不可以获取）： java1ClassLoader.getSystemClassLoader().getParent().getParent(); 2.2.7 测试类加载器示例： java123456789101112131415public static void main(String[] args) &#123; // 获取系统类加载器 ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(appClassLoader); // 获取扩展类加载器 ClassLoader extClassLoader = appClassLoader.getParent(); System.out.println(extClassLoader); // 获取引导类加载器 ClassLoader bootClassLoader = extClassLoader.getParent(); System.out.println(bootClassLoader); // 自定义类使用的是系统类加载器 System.out.println(ClassLoaderTest.class.getClassLoader()); // JDK提供的类使用的是引导类加载器 System.out.println(String.class.getClassLoader());&#125; 结果： log12345sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@6d9c638nullsun.misc.Launcher$AppClassLoader@18b4aac2null 2.2.8 测试加载资源示例： java1234// InputStream is1 = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;test.txt&quot;);// null// InputStream is2 = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;/com/test/test.txt&quot;);// nullInputStream is3 = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;com/test/test.txt&quot;);InputStream is4 = ClassLoader.getSystemResourceAsStream(&quot;com/test/test.txt&quot;); 3 使用3.1 定义类和接口定义接口： java1234public interface Home&lt;H&gt; &#123; public String address = &quot;&quot;; public String location();&#125; 定义父类： java1234567891011121314151617181920212223242526272829public abstract class People&lt;P&gt; &#123; public People() &#123; System.out.println(&quot;do &gt;&gt;&gt; People()&quot;); &#125; private Integer age; public String name; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String talk(String topic) &#123; System.out.println(&quot;do &gt;&gt;&gt; talk() &quot; + topic); return name; &#125; @Override public String toString() &#123; String ageStr = &quot;age=&quot; + age; String nameStr = &quot;name=&quot; + name; return &quot;People&#123;&quot; + ageStr + &quot;, &quot; + nameStr + &quot;&#125;&quot;; &#125;&#125; 定义子类： java1234567891011121314151617181920212223242526272829303132333435363738public class Student extends People&lt;Integer&gt; implements Serializable, Home&lt;String&gt; &#123; public String teacher; private Integer grade; public Student() &#123; System.out.println(&quot;do &gt;&gt;&gt; Student()&quot;); &#125; private Student(Integer grade) &#123; System.out.println(&quot;do &gt;&gt;&gt; Student(grade)&quot;); this.grade = grade; &#125; public String getTeacher() &#123; return teacher; &#125; public void setTeacher(String teacher) &#123; this.teacher = teacher; &#125; public Integer getGrade() &#123; return grade; &#125; public void setGrade(Integer grade) &#123; this.grade = grade; &#125; @Deprecated private Integer exam(String name) throws ArithmeticException &#123; System.out.println(&quot;do &gt;&gt;&gt; exam() &quot; + name); return 98; &#125; @Override public String location() &#123; return address; &#125; @Override public String toString() &#123; String teacherStr = &quot;teacher=&quot; + teacher; String gradeStr = &quot;grade=&quot; + grade; return &quot;Student&#123;&quot; + teacherStr + &quot;, &quot; + gradeStr + &quot;&#125;&quot;; &#125;&#125; 3.2 测试类的信息示例： java12345678910111213141516171819public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 根据类名获取类的Class实例 Class&lt;?&gt; cla = Class.forName(&quot;test.Student&quot;); // 使用反射创建类的实例 Student student = (Student) cla.newInstance(); System.out.println(&quot;student.toString() &gt;&gt;&gt; &quot; + student); // 获取全类名 System.out.println(&quot;cla.getName() &gt;&gt;&gt; &quot; + cla.getName()); // 获取包名 System.out.println(&quot;cla.getPackage() &gt;&gt;&gt; &quot; + cla.getPackage()); // 获取修饰符标志数 System.out.println(&quot;cla.getModifiers() &gt;&gt;&gt; &quot; + cla.getModifiers()); // 获取翻译后的修饰符 System.out.println(&quot;cla.getModifiers() &gt;&gt;&gt; &quot; + Modifier.toString(cla.getModifiers())); // 获取加载器 System.out.println(&quot;cla.getClassLoader() &gt;&gt;&gt; &quot; + cla.getClassLoader()); &#125;&#125; 结果： log12345678do &gt;&gt;&gt; People()do &gt;&gt;&gt; Student()student.toString() &gt;&gt;&gt; Student&#123;teacher=null, grade=null&#125;cla.getName() &gt;&gt;&gt; test.Studentcla.getPackage() &gt;&gt;&gt; package testcla.getModifiers() &gt;&gt;&gt; 1cla.getModifiers() &gt;&gt;&gt; publiccla.getClassLoader() &gt;&gt;&gt; sun.misc.Launcher$AppClassLoader@18b4aac2 3.3 测试类的继承和实现示例： java12345678910111213141516171819202122232425public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 获取父类 System.out.println(&quot;cla.getSuperclass() &gt;&gt;&gt; &quot; + cla.getSuperclass().getName()); // 获取父类，包含泛型 Type genericSuperclass = cla.getGenericSuperclass(); System.out.println(&quot;cla.getGenericSuperclass() &gt;&gt;&gt; &quot; + genericSuperclass.getTypeName()); // 获取父类，查看泛型 ParameterizedType paramType = (ParameterizedType) genericSuperclass; Type[] actualTypeArguments = paramType.getActualTypeArguments(); for (Type type : actualTypeArguments) &#123; System.out.println(&quot;cla.getGenericSuperclass().getActualTypeArguments() &gt;&gt;&gt; &quot; + type.getTypeName()); &#125; // 获取接口 Class&lt;?&gt;[] interfaces = cla.getInterfaces(); for (Class&lt;?&gt; interfaceClass : interfaces) &#123; System.out.println(&quot;cla.getInterfaces() &gt;&gt;&gt; &quot; + interfaceClass.getName()); &#125; // 获取接口，包含泛型 Type[] genericInterfaces = cla.getGenericInterfaces(); for (Type genericInterface : genericInterfaces) &#123; System.out.println(&quot;cla.getGenericInterfaces() &gt;&gt;&gt; &quot; + genericInterface.getTypeName()); &#125; &#125;&#125; 结果： log1234567cla.getSuperclass() &gt;&gt;&gt; test.Peoplecla.getGenericSuperclass() &gt;&gt;&gt; test.People&lt;java.lang.Integer&gt;cla.getGenericSuperclass().getActualTypeArguments() &gt;&gt;&gt; java.lang.Integercla.getInterfaces() &gt;&gt;&gt; java.io.Serializablecla.getInterfaces() &gt;&gt;&gt; test.Homecla.getGenericInterfaces() &gt;&gt;&gt; java.io.Serializablecla.getGenericInterfaces() &gt;&gt;&gt; test.Home&lt;java.lang.String&gt; 3.4 测试类的属性示例： java1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 获取公共的所有的属性，包括父类的 Field[] fields = cla.getFields(); for (Field field : fields) &#123; System.out.println(&quot;cla.getFields() &gt;&gt;&gt; &quot; + field); &#125; // 获取所有的属性，不包括父类的 Field[] declaredFields = cla.getDeclaredFields(); for (Field field : declaredFields) &#123; System.out.println(&quot;cla.getDeclaredFields() &gt;&gt;&gt; &quot; + field); &#125; // 获取公共的指定名称的属性，包括父类的 System.out.println(&quot;cla.getField(name) &gt;&gt;&gt; &quot; + cla.getField(&quot;name&quot;)); // 获取指定名称的属性，不包括父类的 Field grade = cla.getDeclaredField(&quot;grade&quot;); System.out.println(&quot;cla.getDeclaredField(grade) &gt;&gt;&gt; &quot; + grade); // 获取属性访问修饰符 System.out.println(&quot;grade.getModifiers() &gt;&gt;&gt; &quot; + Modifier.toString(grade.getModifiers())); // 获取属性类型 System.out.println(&quot;grade.getType() &gt;&gt;&gt; &quot; + grade.getType().getTypeName()); // 获取属性名称 System.out.println(&quot;grade.getName() &gt;&gt;&gt; &quot; + grade.getName()); // 获取和修改属性值，非公共属性需要执行setAccessible()方法 grade.setAccessible(true); grade.set(student, 100); System.out.println(&quot;grade.get(student) &gt;&gt;&gt; &quot; + grade.get(student)); &#125;&#125; 结果： log12345678cla.getFields() &gt;&gt;&gt; public ...cla.getDeclaredFields() &gt;&gt;&gt; ...cla.getField(name) &gt;&gt;&gt; public java.lang.String test.People.namecla.getDeclaredField(grade) &gt;&gt;&gt; private java.lang.Integer test.Student.gradegrade.getModifiers() &gt;&gt;&gt; privategrade.getType() &gt;&gt;&gt; java.lang.Integergrade.getName() &gt;&gt;&gt; gradegrade.get(student) &gt;&gt;&gt; 100 3.5 测试类的方法示例： java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 获取公共的所有的方法，包括父类的 Method[] methods = cla.getMethods(); for (Method method : methods) &#123; System.out.println(&quot;cla.getMethods() &gt;&gt;&gt; &quot; + method); &#125; // 获取所有的方法，不包括父类的 Method[] declaredMethods = cla.getDeclaredMethods(); for (Method method : declaredMethods) &#123; System.out.println(&quot;cla.getDeclaredMethods() &gt;&gt;&gt; &quot; + method); &#125; // 获取公共的指定名称和参数的方法，包括父类的 System.out.println(&quot;cla.getMethod(talk, String.class) &gt;&gt;&gt; &quot; + cla.getMethod(&quot;talk&quot;, String.class)); // 获取指定名称和参数的方法，不包括父类的 Method exam = cla.getDeclaredMethod(&quot;exam&quot;, String.class); System.out.println(&quot;cla.getDeclaredMethod(exam, String.class) &gt;&gt;&gt; &quot; + exam); // 获取方法注解 Annotation[] annotations = exam.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(&quot;exam.getAnnotations() &gt;&gt;&gt; &quot; + annotation); &#125; // 获取方法访问修饰符 System.out.println(&quot;exam.getModifiers() &gt;&gt;&gt; &quot; + Modifier.toString(exam.getModifiers())); // 获取方法返回值类型 System.out.println(&quot;exam.getReturnType() &gt;&gt;&gt; &quot; + exam.getReturnType().getTypeName()); // 获取方法名称 System.out.println(&quot;exam.getName() &gt;&gt;&gt; &quot; + exam.getName()); // 获取方法参数 Parameter[] parameters = exam.getParameters(); for (Parameter parameter : parameters) &#123; System.out.println(&quot;exam.getParameters() &gt;&gt;&gt; &quot; + parameter); &#125; // 获取方法异常 Class[] exceptionTypes = exam.getExceptionTypes(); for (Class exceptionType : exceptionTypes) &#123; System.out.println(&quot;exam.getExceptionTypes() &gt;&gt;&gt; &quot; + exceptionType.getTypeName()); &#125; // 调用方法，非公共方法需要执行setAccessible()方法 exam.setAccessible(true); Object result = exam.invoke(student, &quot;Tom&quot;); System.out.println(&quot;exam.invoke(student, Tom) &gt;&gt;&gt; &quot; + result); &#125;&#125; 结果： log123456789101112cla.getMethods() &gt;&gt;&gt; public ...cla.getDeclaredMethods() &gt;&gt;&gt; ...cla.getMethod(talk, String.class) &gt;&gt;&gt; public java.lang.String test.People.talk(java.lang.String)cla.getDeclaredMethod(exam, String.class) &gt;&gt;&gt; private java.lang.Integer test.Student.exam(java.lang.String) throws java.lang.ArithmeticExceptionexam.getAnnotations() &gt;&gt;&gt; @java.lang.Deprecated()exam.getModifiers() &gt;&gt;&gt; privateexam.getReturnType() &gt;&gt;&gt; java.lang.Integerexam.getName() &gt;&gt;&gt; examexam.getParameters() &gt;&gt;&gt; java.lang.String nameexam.getExceptionTypes() &gt;&gt;&gt; java.lang.ArithmeticExceptiondo &gt;&gt;&gt; exam() Tomexam.invoke(student, Tom) &gt;&gt;&gt; 98 3.6 测试类的构造方法示例： java1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] args) throws Exception &#123; // 获取公共的所有的构造方法 Constructor&lt;?&gt;[] constructors = cla.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) &#123; System.out.println(&quot;cla.getConstructors() &gt;&gt;&gt; &quot; + constructor); &#125; // 获取所有的构造方法 Constructor&lt;?&gt;[] declaredConstructors = cla.getDeclaredConstructors(); for (Constructor&lt;?&gt; constructor : declaredConstructors) &#123; System.out.println(&quot;cla.getDeclaredConstructors() &gt;&gt;&gt; &quot; + constructor); &#125; // 获取公共的指定参数的构造方法 System.out.println(&quot;cla.getConstructor() &gt;&gt;&gt; &quot; + cla.getConstructor()); // 获取指定参数的方法 Constructor&lt;?&gt; constructor = cla.getDeclaredConstructor(Integer.class); System.out.println(&quot;cla.getDeclaredConstructor() &gt;&gt;&gt; &quot; + constructor); // 调用构造方法，非公共构造方法需要执行setAccessible()方法 constructor.setAccessible(true); student = (Student) constructor.newInstance(10); System.out.println(&quot;student &gt;&gt;&gt; &quot; + student); &#125;&#125; 结果： log12345678cla.getConstructors() &gt;&gt;&gt; public test.Student()cla.getDeclaredConstructors() &gt;&gt;&gt; public test.Student()cla.getDeclaredConstructors() &gt;&gt;&gt; private test.Student(java.lang.Integer)cla.getConstructor() &gt;&gt;&gt; public test.Student()cla.getDeclaredConstructor() &gt;&gt;&gt; private test.Student(java.lang.Integer)do &gt;&gt;&gt; People()do &gt;&gt;&gt; Student(grade)student &gt;&gt;&gt; Student&#123;teacher=null, grade=10&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"泛型","slug":"D00-后端/D01-Java/002-高级/001-泛型","date":"2025-04-30T02:56:31.000Z","updated":"2025-07-22T01:26:16.696Z","comments":true,"path":"posts/20250430/105631/","permalink":"https://momashanhe.com/posts/20250430/105631/","excerpt":"摘要：本文学习了什么是泛型，以及如何使用泛型。","text":"摘要：本文学习了什么是泛型，以及如何使用泛型。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介1.1 定义在提到参数时，最熟悉的就是定义方法时使用形参指定参数类型，然后调用此方法时传递该类型的实参。 泛型，即参数化类型，就是将参数类型由原来的具体的类型参数化，定义成参数形式（可以称之为类型形参），在使用时传入具体的类型（称之为类型实参）。 在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 1.2 体验示例： java1234567List list = new ArrayList();list.add(&quot;abc&quot;);list.add(100);for (int i = 0; i &lt; list.size(); i++) &#123; String item = (String) list.get(i); System.out.println(item);&#125; 运行时会报异常： java12abcException in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 在实例化List的时候没有指定集合里的元素类型，使用默认的Object类型，能放下String类型和Integer类型的数据。在使用List的时候，如果不知道存放的元素类型，会将所有的数据都转换成String类型的数据，就会抛出类型转换失败的异常。 解决办法是在实例化时指定元素的类型，比如指定类型为String，那么如果存入了Integer类型的数据，在编译期间进行检查发现不是String类型的数据，就会进行错误提示。 示例： java1234567List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;abc&quot;);// abclist.add(100);// 编译报错for (int i = 0; i &lt; list.size(); i++) &#123; String item = (String) list.get(i); System.out.println(item);&#125; 1.3 特性打印不同泛型的List的类型： java1234List&lt;String&gt; strList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();System.out.println(strList.getClass());// class java.util.ArrayListSystem.out.println(intList.getClass());// class java.util.ArrayList 说明泛型只在编译阶段有效，虽然指定了不同泛型，但他们的类型都是ArrayList。 2 使用泛型的使用有三种形式：泛型类，泛型接口，泛型方法。 2.1 泛型类泛型类是在实例化类的时候指明泛型的具体类型。 在使用和定义泛型类时，需要使用泛型标识来代替普通类中的类型。 语法： java123public class 类名&lt;泛型标识&gt; &#123; private 泛型标识 成员变量名;&#125; 其中类名和成员变量名都可以任意取值，泛型标识可以使用诸如T、R、E、K、V等字母作为参数。 定义泛型类： java123456789101112public class Generic&lt;T&gt; &#123; private T generic; public T getGeneric() &#123; return generic; &#125; public void setGeneric(T generic) &#123; this.generic = generic; &#125;&#125; 使用泛型类： java12345public static void main(String[] args) &#123; Generic&lt;String&gt; generic = new Generic&lt;String&gt;(); generic.setGeneric(&quot;test&quot;); System.out.println(generic.getGeneric());// test&#125; 2.2 泛型接口泛型接口与泛型类的定义及使用基本相同，泛型接口常被用在各种类的生产器中。 定义泛型接口： java123public interface Generator&lt;T&gt; &#123; public T showGeneric();&#125; 实现泛型接口： 如果实现类没有指定泛型类型： 实现类需要按照泛型类的方式定义，实现普通方法和泛型方法。 普通方法不需要处理，泛型方法不需要处理。 示例：java123456public class Generic&lt;T&gt; implements Generator&lt;T&gt; &#123; @Override public T showGeneric() &#123; return null; &#125;&#125; 如果实现类指定了泛型类型： 实现类需要按照普通类的方式定义，实现普通方法和泛型方法。 普通方法的泛型改为指定的泛型类型，泛型方法不需要处理。 示例：java123456public class Generic implements Generator&lt;String&gt; &#123; @Override public String showGeneric() &#123; return null; &#125;&#125; 2.3 泛型方法泛型方法是在调用方法的时候指明泛型的具体类型。 泛型方法和普通方法的不同之处，就在于泛型方法在访问修饰符和返回类型中间有一个用于声明泛型的泛型标识，然后在参数列表中就可以使用这个泛型类型的参数了。 语法： java12public &lt;泛型标识&gt; void show(泛型标识 generic) &#123;&#125; 与泛型类的定义一样，此处泛型标识可以使用诸如T、E、K、V等字母作为参数，如果有多个的话使用逗号分隔。 定义泛型方法： java1234public &lt;T, R&gt; void show(T t, R r) &#123; System.out.println(t.getClass()); System.out.println(r.getClass());&#125; 使用泛型方法： java1234public static void main(String[] args) &#123; Generic generic = new Generic(); generic.show(123, &quot;abc&quot;);&#125; 结果： log12class java.lang.Integerclass java.lang.String 2.3.1 泛型类与泛型方法泛型类中的方法不一定是泛型方法，是不是泛型方法要根据方法的访问修饰符与返回类型中间有没有泛型标识来判断。 2.3.1.1 定义普通方法定义泛型类中的普通方法： java12345public class Generic&lt;T&gt; &#123; public void show(T t) &#123; System.out.println(t.getClass()); &#125;&#125; 因为在实例化泛型时就明确了泛型的类型是Integer类型，所以在调用方法的时候就只能传入Integer类型的数据，否则会报错。 使用泛型类中的普通方法： java12345public static void main(String[] args) &#123; Generic&lt;Integer&gt; generic = new Generic&lt;Integer&gt;(); generic.show(123);// class java.lang.Integer generic.show(&quot;abc&quot;);// 编译报错&#125; 2.3.1.2 定义泛型方法如果要在泛型类中定义泛型方法，需要在方法的访问修饰符和返回类型中间加入对泛型类型的声明。 定义泛型类中的泛型方法： java12345public class Generic&lt;T&gt; &#123; public &lt;R&gt; void show(R t) &#123; System.out.println(t.getClass()); &#125;&#125; 使用泛型类中的泛型方法： java12345public static void main(String[] args) &#123; Generic&lt;Integer&gt; generic = new Generic&lt;Integer&gt;(); generic.show(123);// class java.lang.Integer generic.show(&quot;abc&quot;);// class java.lang.String&#125; 2.3.2 可变参数泛型方法定义可变参数的泛型方法： java12345678public class Generic&lt;T&gt; &#123; public &lt;R&gt; void show(R... rs) &#123; System.out.println(rs.getClass()); for (R r : rs) &#123; System.out.println(r.getClass()); &#125; &#125;&#125; 使用可变参数的泛型方法： java1234public static void main(String[] args) &#123; Generic&lt;Integer&gt; generic = new Generic&lt;Integer&gt;(); generic.show(123, &quot;abc&quot;, &#x27;a&#x27;);&#125; 结果： log1234class [Ljava.io.Serializable;class java.lang.Integerclass java.lang.Stringclass java.lang.Character 2.3.3 静态泛型方法泛型类中静态方法的参数不能使用泛型，如果要使用的话，需要将静态方法定义为泛型方法。 在静态方法中使用泛型会在编译期间报错： java12345public class Generic&lt;T&gt; &#123; public static void show(T t) &#123; System.out.println(t.getClass()); &#125;&#125; 可以将静态方法声明为泛型方法： java12345public class Generic&lt;T&gt; &#123; public static &lt;R&gt; void show(R r) &#123; System.out.println(r.getClass()); &#125;&#125; 3 通配符3.1 定义泛型类的类型和泛型类型无关，对于Generic类型的对象和Generic类型的对象来说，他们都是Generic类型。 定义泛型类和方法，并指定方法的入参为Number类型的泛型类对象： java12345678910public class Generic&lt;T&gt; &#123; public static void main(String[] args) &#123; show(new Generic&lt;Number&gt;()); show(new Generic&lt;String&gt;());// 编译报错 &#125; public static void show(Generic&lt;Number&gt; generic) &#123; System.out.println(&quot;show ...&quot;); &#125;&#125; 如果要想在调用方法的时候，传入任何泛型类型的参数都能使用，就需要使用通配符，使用?代替具体的参数类型。 将方法的泛型类型换成通配符： java12345678910public class Generic&lt;T&gt; &#123; public static void main(String[] args) &#123; show(new Generic&lt;Number&gt;()); show(new Generic&lt;String&gt;()); &#125; public static void show(Generic&lt;?&gt; generic) &#123; System.out.println(&quot;show ...&quot;); &#125;&#125; 3.2 使用3.2.2 上界如果要限制只能是Number类及其子类，就需要设置通配符上界，将?替换为? extends Number。 示例： java123456789101112public class Generic&lt;T&gt; &#123; public static void main(String[] args) &#123; show(new Generic&lt;Number&gt;()); show(new Generic&lt;String&gt;());// 编译报错 show(new Generic&lt;Integer&gt;()); show(new Generic&lt;Object&gt;());// 编译报错 &#125; public static void show(Generic&lt;? extends Number&gt; generic) &#123; System.out.println(&quot;show ...&quot;); &#125;&#125; 3.2.3 下界如果要限制只能是Number类及其父类，就需要设置通配符下限，将?替换为? super Number。 示例： java123456789101112public class Generic&lt;T&gt; &#123; public static void main(String[] args) &#123; show(new Generic&lt;Number&gt;()); show(new Generic&lt;String&gt;());// 编译报错 show(new Generic&lt;Integer&gt;());// 编译报错 show(new Generic&lt;Object&gt;()); &#125; public static void show(Generic&lt;? super Number&gt; generic) &#123; System.out.println(&quot;show ...&quot;); &#125;&#125; 4 泛型数组不能使用泛型类型创建数组： java12List&lt;String&gt;[] listArr = new List[10];List&lt;String&gt;[] listArr = new List&lt;String&gt;[10];// 编译报错 需要使用通配符的方式创建： java1List&lt;?&gt;[] listArr = new List&lt;?&gt;[10];","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"线程","slug":"D00-后端/D01-Java/001-基础/014-线程","date":"2025-04-29T03:34:13.000Z","updated":"2025-07-22T01:25:58.611Z","comments":true,"path":"posts/20250429/113413/","permalink":"https://momashanhe.com/posts/20250429/113413/","excerpt":"摘要：本文学习了线程的相关知识，包括线程产生的安全问题和解决办法，以及如何进行线程通信。","text":"摘要：本文学习了线程的相关知识，包括线程产生的安全问题和解决办法，以及如何进行线程通信。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 概述1.1 进程1.1.1 单指令到批处理说起进程的由来，需要从操作系统的发展历史谈起。 在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就在等待，所以很多时候计算机处于等待用户输入的状态。 为了提高效率，将需要执行的多个指令写在磁带上，然后交由计算机去读取并逐个地执行这些指令，并将输出结果写到另一个磁带上。这样就减少了计算机的等待时间，批处理操作系统也由此诞生。 1.1.2 多个程序同时运行虽然批处理操作系统的诞生极大地提高了任务处理的便捷性，但是仍然存在一个很大的问题： 假如有两个任务A和B，任务A在执行到一半时，需要读取大量的数据输入（IO操作），此时CPU只能等待任务A读取完数据才能继续执行，这样就浪费了CPU资源。 此时就需要计算机在任务A读取数据时，让任务B使用CPU执行任务，当任务A读取完数据之后，让任务B暂停，让任务A使用CPU继续执行。 但是这么做需要解决两个问题： 单个程序运行，计算机的内存里存储的是单个程序的数据，多个程序同时运行，内存需要存储多个程序的数据，并能够加以区分。 多个程序轮流使用CPU资源，计算机需要记录每个程序的使用情况，保证程序在暂停后能从原位置继续执行。 1.1.3 进程出现于是便有了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态，比如进程标识、进程的使用的资源等，在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。 这就是并发，能够让操作系统从宏观上看起来同一个时间段有多个任务在执行。 换句话说，进程让操作系统的并发成为了可能。 注意，对于单核CPU来说，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源，因为只有一个CPU。 1.2 线程1.2.1 程序内的多任务虽然进程的出现解决了操作系统的并发问题，但一个进程在一段时间内只能执行一个操作，对于有多个子任务的进程来说，操作系统只能逐个执行这些子任务： 比如有一个音乐播放器程序，如果某一时刻程序正在播放音乐，用户此时又点击了查看歌词，那么程序就需要等待音乐播放完毕才会显示歌词，这显然无法满足用户。 此时就需要操作系统支持在程序内部同时执行多个子任务，在播放音乐的同时显示对应的歌词。 但是这么做需要解决两个问题： 多个子任务属于同一个程序，并且子任务之间需要共享数据，比如需要根据正在播放的音乐显示歌词。 每个子任务在进行暂停和执行时，需要记录各自的运行信息。 1.2.2 线程出现于是便有了线程，用线程来对应一个程序里的一个子任务，一个进程内的多个线程共享进程的存储空间。同时每个线程又有各自的线程标识，存储各自的线程运行信息。 操作系统给每个线程分配的时间段都很短，再加上快速的线程切换，从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。 换句话说，进程让操作系统的并发成为了可能，而线程让进程内部的并发成为了可能。 但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。所以说，进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。 1.2.3 多线程是否一定优于单线程不一定，要看具体的任务以及计算机的配置。 对于单核CPU。如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。如果是交互类型的任务，肯定是需要使用多线程的。 对于多核CPU，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。 虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。 1.3 进程和线程的区别1.3.1 从承担角色的角度进程是拥有资源的基本单位，线程可以共享其隶属进程的系统资源。 线程是操作系统进行调度的基本单位。 1.3.2 从系统开销的角度进程由程序、数据、进程控制块三部分组成。程序就是程序代码，数据存储了运算结果和变量的值，进程控制块存储了进程信息，是进程存在的唯一标志。每次创建进程系统都要分配资源，如内存、IO等，系统开销大。 线程由线程ID、当前指令寄存器、程序计数器、累加寄存器等组成。指令寄存器存储了线程在切换时执行到了哪条指令，程序计数器存储了下一条指令在主存储器中的地址，累加寄存存储了运算结果和变量的值。线程切换只需要存储和设置少量寄存器变量，系统开销小。 2 创建机制2.1 创建创建线程有两种方法： 通过继承Thread类创建：java123456789101112131415161718192021public class Demo &#123; public static void main(String[] args) &#123; Thread t1 = new DemoThread(&quot;线程一&quot;); Thread t2 = new DemoThread(&quot;线程二&quot;); t1.start(); t2.start(); &#125;&#125;class DemoThread extends Thread &#123; public DemoThread(String name) &#123; this.setName(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; &#125;&#125; 通过实现Runnable接口创建：java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; DemoRunnable runnable = new DemoRunnable(); Thread t1 = new Thread(runnable, &quot;线程一&quot;); Thread t2 = new Thread(runnable, &quot;线程二&quot;); t1.start(); t2.start(); &#125;&#125;class DemoRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + i); &#125; &#125;&#125; 这两种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承Thread类可能比实现Runnable接口看起来更加简洁，但是如果自定义类需要继承其他类，则只能选择实现Runnable接口。 事实上，查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。 不论哪种方式创建线程，都必须重写run()方法，在run()方法中定义需要执行的任务。 创建线程对象后通过start()方法去启动线程，在线程中执行run()方法。如果调用run()方法，即相当于在主线程中执行run()方法，跟普通的方法调用没有任何区别，此时并不会在线程中执行run()方法。 2.2 使用属性： java1234// 线程的优先级。最低为1，最高为10，默认为5。优先级高的线程获取CPU时间片的概率高private int priority;// 线程的状态。常见的状态有NEW、RUNNABLE、BLOCKED、WAITINGprivate volatile int threadStatus = 0; 构造方法： java1234// 使用这种方式创建的线程，需要重写Thread类里的run()方法Thread();// 使用这种方式创建的线程，需要实现Runnable接口里的run()方法Thread(Runnable target); 静态方法： java12// 获取当前运行的线程Thread.currentThread(); 常用方法： java12345678910111213141516// 线程执行任务的主要代码。如果没有实现Runnable接口里的run()方法，则需要重写Thread类里的run()方法void run();// 启动线程的方法，虚拟机会调用线程的run()方法。只用调用了start()方法，才会启动一个新的线程执行定义的任务void start();// 本地方法，让当前线程休眠指定时间，不会释放占用的锁void sleep(long millis);// 传入0代表一直等待到结束void join();// 执行指定的线程一段时间，直到执行时间达到传入的时间长度或者线程执行完毕void join(long millis);// 设置线程的中断状态为true，不会停止线程void interrupt();// 返回当前线程的中断状态，然后将中断状态设置为falseboolean interrupted();// 让当前正在运行的线程让出它的时间片，给其他线程抢占的机会，可用于优化忙等待void yield(); 2.3 优先级线程的优先级是为了在多线程环境中便于系统对线程的调度，优先级越高先执行机会越大，并不是一定先执行。 线程的优先级可以理解为线程抢占CPU时间片的概率，并不能保证优先级高的线程一定会先执行。 不同的系统有不同的线程优先级的取值范围，同一个优先级在不同的系统里的值可能是不同的。 一个线程的优先级设置遵从以下原则： 线程创建时，子继承父的优先级。 线程创建后，可通过调用setPriority()方法改变优先级。 线程的优先级是1-10之间的正整数，线程优先级最高为10，最低为1，默认为5。 优先级： 1- MIN_PRIORITY 10-MAX_PRIORITY 5-NORM_PRIORITY 线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线程的运行： 线程体中调用了yield()方法，让出了对CPU的占用权。 线程体中调用了sleep()方法，使线程进入睡眠状态。 线程由于IO操作而受阻塞。 另一个更高优先级的线程出现。 在支持时间片的系统中，该线程的时间片用完。 2.4 生命周期线程的生命周期：一个线程从创建到消亡的过程。 如下图，表示线程生命周期中的各个状态： 2.4.1 新建状态（New）当线程对象创建后，即进入了新建状态。 2.4.2 就绪状态（Ready）当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了start()方法后此线程立即就会执行。 当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性。 2.4.3 运行状态（Running）当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。 就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中。 2.4.4 阻塞状态（Blocked）处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。 根据阻塞产生的原因不同，阻塞状态又可以分为三种： 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态。 同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。 其他阻塞：通过调用线程的sleep()方法或join()方法或发出了IO请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、IO处理完毕时，线程重新转入就绪状态。 2.4.5 死亡状态（Dead）线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 2.5 状态线程在运行的生命周期中可能处于六种不同的状态，在某一时刻线程只能处于其中的一个状态。 各个状态改变如图： 2.5.1 初始状态（New）初始状态表示线程已经创建，但是还没有调用start()方法。 示例： java1234public static void main(String[] args) &#123; Thread thread = new Thread(); System.out.println(thread.getState());&#125; 2.5.2 运行状态（RUNNABLE）运行状态表示线程已经获取了CPU时间片，将操作系统中就绪和运行两种状态笼统地称为运行状态。 示例： java12345public static void main(String[] args) &#123; Thread thread = new Thread(); thread.start(); System.out.println(thread.getState());&#125; 2.5.3 阻塞状态（BLOCKED）阻塞状态表示线程阻塞于锁，假如有两个都是同步安全的线程，当一个线程处于RUNNABLE状态时，则另一个线程处于BLOCKED状态。 示例： java1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; public void run() &#123; synchronized (Object.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; synchronized (Object.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t1.start(); t2.start(); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(t2.getState());&#125; 2.5.4 等待状态（WAITTING）等待状态表示程序处于等待。 调用wait()、join()、await()、lock()等方法时不传入参数，会使线程处于等待。 示例： java1234567891011121314151617181920public static void main(String[] args) &#123; Thread t = new Thread() &#123; public void run() &#123; synchronized (Object.class) &#123; try &#123; join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t.start(); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(t.getState());&#125; 2.5.5 等待超时状态（TIME_WAITTING）等待超时状态表示程序处于限时等待，不同于等待状态，可以在指定的时间后自行返回。 调用wait()、join()、await()、lock()、sleep()等方法时传入参数，会使线程处于等待超时状态。 示例： java1234567891011121314151617181920public static void main(String[] args) &#123; Thread t = new Thread() &#123; public void run() &#123; synchronized (Object.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; t.start(); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(t.getState());&#125; 2.5.6 终止状态（TERMINATED）终止状态表示当前线程已经执行完毕。 2.6 中断机制2.6.1 说明一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，所以使用中断机制用于停止线程。 每个线程对象中都有一个标识，用于标识线程是否被中断。该标识位为true表示中断，该标识为false表示未中断，通过调用线程对象的interrupt()方法将线程的标识位设为true。 如果线程处于正常活动状态，那么会将线程的中断标志设置位true，被设置中断标志的线程将继续正常运行，不受影响。 如果线程处于被阻塞状态（例如处于sleep、wait、join等状态），在别的线程中调用当前线程对象的interrupt()方法，那么当前线程立即被阻塞状态，并抛出InterruptedException异常。 2.6.2 使用在需要中断的线程中不断监听中断状态，一旦发生中断就执行中断处理业务逻辑。 三种识别中断的方式： 通过volatile变量实现：java12345678910111213141516public static volatile boolean isStop = false;public static void main(String[] args) &#123; new Thread(()-&gt;&#123; while (true) &#123; if (isStop) &#123; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); break; &#125; System.out.println(Thread.currentThread().getName() + &quot;运行&quot;); &#125; &#125;, &quot;t1&quot;).start(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; isStop = true; &#125;, &quot;t2&quot;).start();&#125; 通过AtomicBoolean实现：java12345678910111213141516public static AtomicBoolean atomicBoolean = new AtomicBoolean(false);public static void main(String[] args) &#123; new Thread(()-&gt;&#123; while (true) &#123; if (atomicBoolean.get()) &#123; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); break; &#125; System.out.println(Thread.currentThread().getName() + &quot;运行&quot;); &#125; &#125;, &quot;t1&quot;).start(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; atomicBoolean.set(true); &#125;, &quot;t2&quot;).start();&#125; 通过Thread类自带方法实现：java12345678910111213141516public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; while (true) &#123; if (Thread.currentThread().isInterrupted()) &#123; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); break; &#125; System.out.println(Thread.currentThread().getName() + &quot;运行&quot;); &#125; &#125;, &quot;t1&quot;); t1.start(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(()-&gt;&#123; t1.interrupt(); &#125;, &quot;t2&quot;).start();&#125; 3 安全问题3.1 原因多个线程操作共享的数据。 一个线程在操作共享数据时，其他线程也操作了共享数据。 3.2 复现3.2.1 同时售票引发的安全问题有2个售票窗口同时售卖3张车票，在这个情境中，用2个线程模拟2个售票窗口，3张车票是共享资源，可售卖的编号是1到3，从3号车票开始售卖。 如果在售票时没有考虑线程的并发问题，2个窗口都能同时修改车票资源，则很容易引发多线程的安全问题。 示例： java1234567891011121314151617181920212223242526272829303132public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 3; public void sale() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125;&#125; 结果： log1234窗口1 sale 2窗口2 sale 3窗口1 sale 1窗口2 sale 0 结果显示窗口1在最后一次售卖中，卖出了编号为0的车票，实际上是不存在的。 出现这种问题的原因是当车票还剩1张的时候，2个窗口同时判断车票数量是否大于1，这时2个窗口就同时进入了售票扣减的代码，导致本来只能卖出1张的车票被2个窗口各自卖出了1张，从而产生了不存在的车票。 在程序里产生这种问题一般都是因为时间片的切换导致的，当一个线程进入操作共享资源的代码块时，时间片用完，另一个线程也通过判断进入了同一个代码块，导致第二个线程在操作共享资源时，没有重新进行判断。也就是说线程对共享资源的操作时不完整的，中间有可能被其他线程对资源进行修改。 3.2.2 单例模式引发的安全问题3.2.2.1 懒汉式懒汉式存在线程安全问题。 懒汉式支持延迟加载，但只能在单线程环境下使用。在多线程环境下，一个线程进入了判断语句块，还没来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式。 示例： java123456789101112public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 为了解决线程安全问题，可以使用synchronized关键字来修饰获取线程的公有方法，但是这么做会导致每次都要进入到同步方法里判断一下，效率太低。 示例： java123456789101112public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 为了不需要每次都进行同步，可以使用双重锁定检查（DCL，Double Check Lock），只需要在创建的时候进入同步方法，以后只要判断已经存在实例就直接返回实例，不需要再次进入同步方法。 示例： java12345678910111213141516public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 除了使用同步机制保证线程安全之外，还可以使用静态内部类来保证线程安全。 示例： java1234567891011public class Singleton &#123; private Singleton() &#123;&#125; private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 类的静态属性只会在第一次加载类的时候初始化，JVM保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 这种方式跟饿汉式方式采用的机制类似，两者都是采用了类装载的机制来保证初始化实例时只有一个线程，但又有不同： 饿汉式只要Singleton类被装载就会实例化，没有延迟加载的作用。 静态内部类在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance()方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 3.2.2.2 饿汉式饿汉式不存在线程安全问题。 饿汉式的写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题。但这样会导致在类加载时就进行了实例化，没有做到延迟加载，如果这个实例没有被用到，会造成内存浪费。 示例： java123456789public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 3.3 解决3.3.1 使用synchronized关键字synchronized是解决并发问题的一种最常用的方法，也是最简单的一种方法。 作用有三个： 确保线程互斥的访问同步代码。 保证共享变量的修改能够及时可见。 有效解决重排序问题。 从语法上讲，有三种用法： 修饰代码块。 修饰普通方法。 修饰静态方法。 3.3.1.1 修饰代码块使用synchronized关键字修饰的代码块将对共享资源的操作封装起来，当有一个线程运行代码块时，其他线程只能等待，从而避免共享资源被其他线程修改。 要求多个线程同步使用的锁都必须是同一个才能保证同步，常用的是使用一个Object对象，或者使用this，或者使用类的class对象。 示例： java123456789101112131415161718192021222324252627282930313233343536public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 3; public void sale() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (Ticket.class) &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125; &#125; &#125;&#125; 结果： log123窗口2 sale 3窗口1 sale 2窗口2 sale 1 线程在进入卖票的代码块之前，先看一下当前是否由其他线程在执行代码块，如果有其他线程在执行代码块则会等待，直到其他线程执行完之后才能进入代码块，从而保证了线程并发的安全问题。 3.3.1.2 修饰普通方法将操作共享资源的代码封装为方法，添加synchronized关键字修饰，这个方法就是同步方法，使用的锁是this对象。 示例： java1234567891011121314151617181920212223242526272829303132333435363738public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 3; public void sale() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; doSale(); &#125; &#125; public synchronized void doSale() &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125;&#125; 结果： log123窗口1 sale 3窗口1 sale 2窗口2 sale 1 在每次调用sale()方法售票的时候，程序会将实例对象this作为锁，保证一个时间只能有一个线程在操作共享资源。 3.3.1.3 修饰静态方法如果该方法是静态方法，因为静态方法优先于类的实例化，所以静态方法是不能持有this的，静态同步方法的琐是类的class对象。 示例： java1234567891011121314151617181920212223242526272829303132333435363738public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口2&quot;).start(); &#125;&#125;class Ticket &#123; private static int num = 3; public void sale() &#123; while (num &gt; 0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; doSale(); &#125; &#125; public synchronized static void doSale() &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; sale &quot; + num--); &#125; &#125;&#125; 结果： log123窗口1 sale 3窗口2 sale 2窗口1 sale 1 使用静态同步方法除了需要注意共享资源也要用static修饰外，其他的和普通同步方法是一样的。 3.3.2 比较synchronized关键字和volatile关键字3.3.2.1 含义volatile主要用在多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值。它强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，从而保证了数据的可见性。 synchronized主要通过对象锁控制线程对共享数据的访问，持有相同对象锁的线程只能等其他持有同一个对象锁的线程执行完毕之后，才能持有这个对象锁访问和处理共享数据。 3.3.2.2 比较量级比较： volatile轻量级，只能修饰变量。 synchronized重量级，还可修饰方法。 原子性： volatile不能保证原子性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。 synchronized可以保证原子性，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 3.3.2.3 总结要使用synchronized，必须要有两个以上的线程。单线程使用没有意义，还会使效率降低。 要使用synchronized，线程之间需要发生同步，不需要同步的没必要使用synchronized，例如只读数据。 使用synchronized的缺点是效率非常低，因为加锁、释放锁和释放锁后争抢CPU执行权的操作都很耗费资源。 4 死锁问题4.1 产生原因多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，而该资源又被其他线程锁定，从而导致每一个线程都得等其它线程释放其锁定的资源，造成了所有线程都无法正常结束。 死锁产生的四个必要条件： 互斥使用，即当资源被一个线程占有时，别的线程不能使用。 不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 循环等待，即存在一个等待队列，P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。在死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 4.2 复现死锁线程A拿到了资源A需要获取资源B，线程B拿到了资源B需要获取资源A，当两个线程都在等待资源时，就出现了死锁： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo &#123; public static void main(String[] args) &#123; Resource res = new Resource(); new Thread(new Runnable() &#123; @Override public void run() &#123; res.useA(); &#125; &#125;, &quot;线程1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; res.useB(); &#125; &#125;, &quot;线程2&quot;).start(); &#125;&#125;class Resource &#123; public static Object A = new Object(); public static Object B = new Object(); public void useA() &#123; synchronized (Resource.A) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; has a need b&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; useB(); &#125; &#125; public void useB() &#123; synchronized (Resource.B) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; has b need a&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; useA(); &#125; &#125;&#125; 当出现死锁时，控制台打印结果： log12线程1 &gt;&gt;&gt; has a need b线程2 &gt;&gt;&gt; has b need a 4.2 避免死锁通过以下几种方式避免死锁： 避免嵌套占用资源：这是产生死锁最主要的原因，如果已经占有一个资源，就要避免同时占有另一个资源。 只对需要的资源加锁：只对程序用到的资源进行加锁，避免对不需要使用的资源加锁。 避免无限期的等待：在等待另一个线程结束时，那最好设置一个等待的最长时间。 5 线程通信5.1 背景原因在多线程并发的情况下，如果都对共享资源进行操作，会导致线程安全问题，可以使用线程的同步机制来保证多线程环境下程序的安全性。但使用同步机制只能保证线程安全，并不能在两个线程或者多个线程之间自由切换，线程的切换完全受CPU的影响。 使用同步机制让两个线程交替打印10到1的数字： java12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;线程1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;线程2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 10; public void sale() &#123; while (num &gt; 0) &#123; synchronized (Ticket.class) &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); &#125; &#125; &#125; &#125;&#125; 结果： log12345678910线程1 &gt;&gt;&gt; 10线程1 &gt;&gt;&gt; 9线程1 &gt;&gt;&gt; 8线程1 &gt;&gt;&gt; 7线程1 &gt;&gt;&gt; 6线程1 &gt;&gt;&gt; 5线程1 &gt;&gt;&gt; 4线程2 &gt;&gt;&gt; 3线程2 &gt;&gt;&gt; 2线程2 &gt;&gt;&gt; 1 因为两个线程的调度完全受CPU时间片的影响，只有当一个线程运行时间结束后，另一个线程才能运行，并不能实现在线程运行的过程中进行切换。 如果想让两个线程交替打印数字，那么很显然同步机制是做不到的，这时候就需要让两个线程之间进行通信。 5.2 通信机制要达到上面所说的两个线程交替打印，需要两个线程进行通信，当第一个线程打印了之后，把自己锁起来，唤醒第二个线程打印，当第二个线程打印之后，也把自己锁起来，唤醒第一个线程，这样就可以实现两个线程的交替打印了。 线程的协作是通过Object类里的wait()方法，配合notify()方法或者notifyAll()方法实现的： wait()：该方法会导致当前线程等待，直到其他线程调用了此线程的notify()或者notifyAll()方法。注意到wait()方法会抛出异常，所以在面在代码中要对异常进行捕获处理。 wait(long timeout)：该方法与wait()方法类似，唯一的区别就是在指定时间内，如果没有notify或notifAll方法的唤醒，也会自动唤醒。wait(0)等效于wait()。 nofity()：唤醒任意一个线程。 notifyAll()：唤醒所有线程。 比较wait()和sleep()方法的区别： 两个方法声明的位置不同：Thread类中声明sleep() ，Object类中声明wait()。 使用方法不同：wait()可以指定时间，也可以不指定时间，sleep()必须指定时间。 调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中。 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 这些方法都在Object类中定义的原因：这些方法都是同步锁的方法，锁可以是任意对象，任意的对象都可以调用的方法需要定义在Object类中。 这些方法都需要在synchronized代码块中使用的原因： 这些方法用于操作线程状态，所以必须要明确操作的锁是哪个。 如果是在非同步的方法里调用这些方法，程序会编译通过，但是在运行时候程序会报出IllegalMonitorStateException异常，这个异常的含义是调用方法的线程在调用这些方法前必须拥有这个对象的锁，或者当前调用方法的对象锁不是之前同步时的那个锁。 5.3 交替执行示例： java123456789101112131415161718192021222324252627282930313233343536373839public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;线程1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; ticket.sale(); &#125; &#125;, &quot;线程2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 10; public void sale() &#123; while (num &gt; 0) &#123; synchronized (Ticket.class) &#123; Ticket.class.notify(); if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; &gt;&gt;&gt; &quot; + num--); &#125; if (num &gt; 0) &#123; try &#123; Ticket.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 结果： log12345678910线程2 &gt;&gt;&gt; 10线程1 &gt;&gt;&gt; 9线程2 &gt;&gt;&gt; 8线程1 &gt;&gt;&gt; 7线程2 &gt;&gt;&gt; 6线程1 &gt;&gt;&gt; 5线程2 &gt;&gt;&gt; 4线程1 &gt;&gt;&gt; 3线程2 &gt;&gt;&gt; 2线程1 &gt;&gt;&gt; 1 6 虚假唤醒6.1 复现在使用wait()方法时，当被唤醒时有可能会被虚假唤醒，建议使用while而不是if来进行判断，即在循环中使用wait()方法。 没有在循环中使用wait()方法： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Demo &#123; public static void main(String[] args) &#123; Ticket demoThread = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; demoThread.increase(); &#125; &#125; &#125;, &quot;线程1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; demoThread.decrease(); &#125; &#125; &#125;, &quot;线程2&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; demoThread.increase(); &#125; &#125; &#125;, &quot;线程3&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; demoThread.decrease(); &#125; &#125; &#125;, &quot;线程4&quot;).start(); &#125;&#125;class Ticket &#123; private static Integer num = 1; public synchronized void increase() &#123; if (num &gt; 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num++; System.out.print(num + &quot; &quot;); this.notifyAll(); &#125; public synchronized void decrease() &#123; if (num == 0) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; num--; System.out.print(num + &quot; &quot;); this.notifyAll(); &#125;&#125; 结果： log10 1 0 1 0 1 0 1 2 3 2 1 0 1 0 1 可以看到即便使用了synchronized关键字，仍然出现了线程安全问题，原因如下： 在某一刻，一个负责增加的线程获得了资源，此时num为1，所以执行this.wait()并等待。 下一刻，另一个负责增加的线程获得了资源，此时num仍然为1，所以再次执行this.wait()并等待。 此后负责减少的线程将num减少到0并唤醒所有等待进程，两个负责增加的线程被唤醒，执行两次增加运算，导致num为2的情况产生。 6.2 解决解决办法就是将if (num &gt; 0) &#123;和if (num == 0) &#123;中的if换成while。 模拟生产者和消费者： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Demo &#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); new Thread(new Runnable() &#123; @Override public void run() &#123; t.product(); &#125; &#125;, &quot;生产者1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; t.product(); &#125; &#125;, &quot;生产者2&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; t.consume(); &#125; &#125;, &quot;消费者1&quot;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; t.consume(); &#125; &#125;, &quot;消费者2&quot;).start(); &#125;&#125;class Ticket &#123; private int num = 0;// 产品数量 public void product() &#123;// 生产产品 while (true) &#123; synchronized (this) &#123; if (num &lt; 2000) &#123; System.out.println(Thread.currentThread().getName() + &quot;：生产了第&quot; + ++num + &quot;个产品&quot;); notifyAll(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public void consume() &#123;// 消费产品 while (true) &#123; synchronized (this) &#123; if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;：消费了第&quot; + num-- + &quot;个产品&quot;); notifyAll(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 7 案例分析7.1 八个案例通过分析代码，推测打印结果，并运行代码进行验证。 7.1.1 案例一一个对象，两个线程调用一个对象的两个同步方法。 示例： java1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String[] args) &#123; Number number = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public synchronized void getOne() &#123; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log12onetwo 被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行。 7.1.2 案例二一个对象，两个线程调用一个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待。 示例： java12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public static void main(String[] args) &#123; Number number = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123// 等待一秒onetwo 被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行。 7.1.3 案例三一个对象，两个线程调用一个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待。 对象新增一个普通方法，新增一个线程调用同一对象的普通方法。 示例： java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Demo &#123; public static void main(String[] args) &#123; Number number = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getTwo(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getThree(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125; public void getThree() &#123; System.out.println(&quot;three&quot;); &#125;&#125; 结果： log1234three// 等待一秒onetwo 新增的方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。其他线程共用了一把锁，所以还需要等待。 7.1.4 案例四两个对象，两个线程调用两个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待。 示例： java1234567891011121314151617181920212223242526272829303132333435public class Demo &#123; public static void main(String[] args) &#123; Number numberOne = new Number(); Number numberTwo = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberOne.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberTwo.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123two// 等待一秒one 被synchronized修饰的方法，锁的对象是方法的调用者。因为用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。 7.1.5 案例五一个对象，两个线程调用一个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待，并将其设为静态方法。 示例： java12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public static void main(String[] args) &#123; Number number = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public static synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123two// 等待一秒one 被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法锁的对象不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。 7.1.6 案例六一个对象，两个线程调用一个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待。 将两个同步方法设为静态方法。 示例： java12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public static void main(String[] args) &#123; Number number = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; number.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public static synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public static synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123// 等待一秒onetwo 被synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法。 7.1.7 案例七两个对象，两个线程调用两个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待，并将其设为静态方法。 示例： java1234567891011121314151617181920212223242526272829303132333435public class Demo &#123; public static void main(String[] args) &#123; Number numberOne = new Number(); Number numberTwo = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberOne.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberTwo.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public static synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123two// 等待一秒one 被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。 7.1.8 案例八两个对象，两个线程调用两个对象的两个同步方法。 给其中的某个方法增加Thread.sleep()等待。 将两个同步方法设为静态方法。 示例： java1234567891011121314151617181920212223242526272829303132333435public class Demo &#123; public static void main(String[] args) &#123; Number numberOne = new Number(); Number numberTwo = new Number(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberOne.getOne(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; numberTwo.getTwo(); &#125; &#125;).start(); &#125;&#125;class Number &#123; public static synchronized void getOne() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;one&quot;); &#125; public static synchronized void getTwo() &#123; System.out.println(&quot;two&quot;); &#125;&#125; 结果： log123// 等待一秒onetwo 被synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，即便用了两个不同的对象调用方法，两个方法用的还是同一个锁，后调用的方法需要等待先调用的方法。 7.2 案例总结非静态同步方法使用的锁是调用方法的实例对象本身，静态同步方法使用的锁是类对象本身。 因为锁的对象不同，非静态同步方法在执行时不需要等待静态同步方法的执行，静态同步方法在执行时也不需要等待非静态同步方法的执行。 非同步方法不需要锁，非同步方法的执行不受同步方法的影响。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"集合","slug":"D00-后端/D01-Java/001-基础/013-集合","date":"2025-04-28T06:53:09.000Z","updated":"2025-07-22T01:25:59.946Z","comments":true,"path":"posts/20250428/145309/","permalink":"https://momashanhe.com/posts/20250428/145309/","excerpt":"摘要：本文学习了常见的集合类及相关工具类，以及如何遍历集合。","text":"摘要：本文学习了常见的集合类及相关工具类，以及如何遍历集合。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 概述类图： 所有集合类都位于java.util包下，集合类主要由Collection和Map这两个根接口派生而出： 接口用蓝色表示，表示不同集合类型，是集合框架的基础。例如Collection，Map，List，Set，Iterator等。 抽象类用绿色表示，对接口的部分实现。例如AbstractMap，AbstractCollection，AbstractList，AbstractSet等。 实现类用黄色表示，对接口的具体实现。例如ArrayList，LinkedList，HashSet，HashMap等。 1.1 集合类集合容器框架中主要有四大类别：List、Set、Queue、Map。 List、Set、Queue继承了Collection接口，Map是和Collection同级别的顶层接口。 1.1.1 ListList接口代表数组，允许插入重复的数据，是有序的集合，可以通过索引访问元素。 常用实现类有ArrayList和LinkedList，还有不常用的Vector。 另外，LinkedList还实现了Queue接口，因此也可以作为队列使用。 1.1.2 SetSet接口代表集合，不允许插入重复的数据，是无序的集合。 常用实现类有HashSet、LinkedHashSet和TreeSet，HashSet是通过Map中的HashMap实现的，LinkedHashSet是HashSet的子类，TreeSet是通过Map中的TreeMap实现的。 另外，TreeSet还实现了SortedSet接口，是有序的集合。 1.1.3 QueueQueue接口代表队列，遵循先入先出的原则，只允许在表的前端进行删除操作，而在表的后端进行插入操作。 常用实现类有LinkedList。 1.1.4 MapMap接口代表键值对集合，是保存了key-value键值对的集合，属于双列集合，根据每个键值对的键访问值。 常用实现类有HashMap、LinkedHashMap和TreeMap，还有不常用的Hashtable。 1.2 工具类在集合框架中，除了有集合类之外，还有两个工具类，分别是处理集合的Collections类和处理数组的Arrays类。 2 集合类2.1 ArrayList2.1.1 简介最常用的集合，允许任何符合规则的元素插入，包括null和重复元素。 底层是数组结构，提供了索引机制，查找效率高，增删效率低。 线程不安全。 2.1.2 扩容数组结构会有容量的概念，ArrayList的初始容量默认为10，负载因子是1，表示当插入元素后个数超出原有长度时会进行扩增，扩容增量是0.5，所以扩增后容量为1.5倍，可使用方法手动扩容和缩减。 最好指定初始容量值，避免过多的进行扩容操作而浪费时间和效率。 2.1.3 方法构造方法： java123456// 空参构造器，返回默认容量为10的集合public ArrayList();// 指定长度的构造器，如果长度为0，则返回容量为0的集合public ArrayList(int initialCapacity);// 传入了一个集合的构造器，如果集合长度为0，返回容量为0的集合public ArrayList(Collection&lt;? extends E&gt; c); 常用方法： java12345678910111213141516171819202122// 获取个数public int size();// 判断是否为空public boolean isEmpty();// 判断是否包含指定数据public boolean contains(Object o);// 计算指定数据首次出现的下标public int indexOf(Object o);// 计算指定数据最后出现的下标public int lastIndexOf(Object o);// 获取指定下标的元素public E get(int index);// 设置指定下标的指定元素，并返回旧元素public E set(int index, E element);// 添加指定元素，并返回是否成功public boolean add(E e);// 在指定位置添加指定元素public void add(int index, E element);// 删除指定位置的元素，并返回删除的元素public E remove(int index);// 删除指定元素，并返回是否成功public boolean remove(Object o); 2.1.4 源码2.1.4.1 属性属性源码： java12345678910// 默认的初始容量为10private static final int DEFAULT_CAPACITY = 10;// 空数组private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 默认容量的空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 数组transient Object[] elementData;// 元素个数private int size; 2.1.4.2 构造方法构造方法源码： java12345678910111213141516171819202122232425// 空参构造器，返回默认容量为10的集合public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;// 指定长度的构造器，如果长度为0，则返回容量为0的集合public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); &#125;&#125;// 传入了一个集合的构造器，如果集合长度为0，返回容量为0的集合public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // Object[]数组里的类型不一定都是Object类型的，有可能是Object的子类，所以要判断一下 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 2.1.4.3 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// 获取个数public int size() &#123; return size;&#125;// 判断是否为空public boolean isEmpty() &#123; return size == 0;&#125;// 判断是否包含指定数据public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;// 计算指定数据首次出现的下标public int indexOf(Object o) &#123; // 如果指定数据为null if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; // 如果指定数据不为null &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;// 计算指定数据最后出现的下标public int lastIndexOf(Object o) &#123; // 如果指定数据为null if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; // 如果指定数据不为null &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;// 获取指定下标的元素public E get(int index) &#123; // 检查指定下标是否越界 rangeCheck(index); // 返回指定下标的元素 return elementData(index);&#125;// 设置指定下标的指定元素，并返回旧元素public E set(int index, E element) &#123; // 检查指定下标是否越界 rangeCheck(index); // 设置指定元素并返回旧元素 E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;// 添加指定元素，并返回是否成功public boolean add(E e) &#123; // 扩容并增加操作数 ensureCapacityInternal(size + 1); // 元素个数增加并设置指定元素 elementData[size++] = e; // 返回成功 return true;&#125;// 在指定位置添加指定元素public void add(int index, E element) &#123; // 检查指定下标是否越界 rangeCheckForAdd(index); // 扩容并增加操作数 ensureCapacityInternal(size + 1); // 拷贝数组并设置元素，增加元素个数 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;// 删除指定位置的元素，并返回删除的元素public E remove(int index) &#123; // 检查指定下标是否越界 rangeCheck(index); // 操作数自增 modCount++; // 获取指定下标的元素 E oldValue = elementData(index); // 需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设置为null并减少容量大小 elementData[--size] = null; // 返回指定下标的元素 return oldValue;&#125;// 删除指定元素，并返回是否成功public boolean remove(Object o) &#123; // 删除null对象 if (o == null) &#123; for (int index = 0; index &lt; size; index++) // 找到并删除null对象 if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; // 删除非null对象 &#125; else &#123; for (int index = 0; index &lt; size; index++) // 找到并删除非null对象 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;// 快速删除指定位置元素，不检查下标，不返回数据private void fastRemove(int index) &#123; // 操作数自增 modCount++; // 需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设置为null并减少容量大小 elementData[--size] = null;&#125; 2.1.4.4 扩容方法扩容方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 对集合进行扩容public void ensureCapacity(int minCapacity) &#123; // 如果集合不为空，则设置扩充值为0，如果为空，则设置扩充值为10 int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY; // 如果指定容量大于扩充值，则进行扩容 if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;// 对集合进行扩容private void ensureCapacityInternal(int minCapacity) &#123; // 如果集合为空，则在默认大小和最小值之间取最大的 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; // 进行扩容 ensureExplicitCapacity(minCapacity);&#125;// 对集合进行扩容，实际操作private void ensureExplicitCapacity(int minCapacity) &#123; // 操作数自增 modCount++; // 如果最小值大于数组长度，则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;// 数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// 扩容计算private void grow(int minCapacity) &#123; // 获取原容量大小 int oldCapacity = elementData.length; // 右移一位，变为原来的0.5倍，然后加上原容量，扩容后变为1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩容后小于最小值，则设置容量为最小值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果扩容后大于最大值，则进一步设置容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 复制数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;// 扩容后容量过大的处理方法private static int hugeCapacity(int minCapacity) &#123; // 如果最小值小于零，则表示溢出，抛出内存溢出异常 if (minCapacity &lt; 0) throw new OutOfMemoryError(); // 如果扩容后的值大于最大值，则使用Integer的最大值，否则就使用最大值 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 2.1.4.5 序列化方法序列化方法源码： java123456789101112131415161718192021222324252627// 序列化private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; int expectedModCount = modCount; s.defaultWriteObject(); s.writeInt(size); for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 反序列化private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; s.defaultReadObject(); s.readInt(); // ignored if (size &gt; 0) &#123; ensureCapacityInternal(size); Object[] a = elementData; for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 2.1.4.6 遍历方法ArrayList提供了两种迭代器，实现了Iterator接口的Itr类，以及实现了ListIterator接口并继承了Itr类的ListItr类。 ListItr类对Itr类的方法进行了扩展，提供了添加和修改的方法，这里只学习Itr类。 遍历方法源码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 获取Iterator迭代器public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;// Iterator内部类，实现了Iterator接口private class Itr implements Iterator&lt;E&gt; &#123; // 下一个元素的位置 int cursor; // 最后一个元素的位置 int lastRet = -1; // 预期的操作数 int expectedModCount = modCount; // 是否存在下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; // 获取下一个元素 public E next() &#123; // 校验预期操作数和实际操作数 checkForComodification(); // 将下一个元素的位置赋值给i int i = cursor; // 如果i大于或等于集合大小，说明没有元素了，抛出异常 if (i &gt;= size) throw new NoSuchElementException(); // 获取集合数组 Object[] elementData = ArrayList.this.elementData; // 如果i大于或等于数组长度，说明有其他线程改过了，抛出异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // 下一个元素位置加一 cursor = i + 1; // 获取元素并返回，设置最后一个元素位置 return (E) elementData[lastRet = i]; &#125; // 删除当前元素 public void remove() &#123; // 如果当前位置小于零，抛出异常 if (lastRet &lt; 0) throw new IllegalStateException(); // 校验预期操作数和实际操作数 checkForComodification(); try &#123; // 移除当前位置上的元素 ArrayList.this.remove(lastRet); // 将当前位置赋值给下一个元素位置 cursor = lastRet; // 将当前位置设置为-1，表示没有此位置 lastRet = -1; // 同步预期操作数和操作数 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 循环遍历一次，JDK1.8新增方法 @Override public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; // 判断非空 Objects.requireNonNull(consumer); // 集合容量大小 final int size = ArrayList.this.size; // 将下一个元素的位置赋值给i int i = cursor; // 如果i大于或等于集合个数，则返回 if (i &gt;= size) &#123; return; &#125; // 获取集合数组 final Object[] elementData = ArrayList.this.elementData; // 如果i大于或等于数组长度，说明有其他线程改过了，抛出异常 if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; // 循环遍历，当下一个元素不为集合的大小，并且预期操作数和实际操作数相等 while (i != size &amp;&amp; modCount == expectedModCount) &#123; // 执行方法，并且每次循环i加一 consumer.accept((E) elementData[i++]); &#125; // 将循环后的i赋值，导致下个元素的位置和集合长度相等，该迭代器不能再次遍历集合了 cursor = i; // 设置最后一个元素位置 lastRet = i - 1; // 校验预期操作数和实际操作数 checkForComodification(); &#125; // 校验预期操作数和实际操作数 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 2.1.5 补充2.1.5.1 数组没有private查看ArrayList的源码，发现内部定义的elementData数组并没有像size属性一样被private修饰，表示访问权限是默认的包权限，这么做的原因被写在了声明后面的注释里，即非私有的访问权限是为了简化嵌套类的访问。 如果想知道如何简化嵌套类的访问，就需要写一个例子并反编译进一步查看。 示例： java1234567891011121314public class DemoTest &#123; private int i = 1; public Inner inner = new Inner(); class Inner &#123; public void in() &#123; i = 5; &#125; &#125; public static void main(String[] args) &#123; DemoTest demoTest = new DemoTest(); demoTest.inner.in(); System.out.println(demoTest.i); &#125;&#125; 反编译private修饰的代码： java123456789101112131415161718192021222324252627282930// 在外部类的汇编代码中，多了静态方法static int access$002(com.demo.mp.test.DemoTest, int); Code: 0: aload_0 1: iload_1 2: dup_x1 3: putfield #1 // Field i:I 6: ireturn LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 x0 Lcom/demo/mp/test/DemoTest; 0 7 1 x1 I// 内部类的汇编代码中，在方法中引用外部类变量的时候，是通过静态方法设置的public void in(); Code: 0: aload_0 1: getfield #1 // Field this$0:Lcom/demo/mp/test/DemoTest; 4: iconst_5 // 通过静态方法设置 5: invokestatic #3 // Method com/demo/mp/test/DemoTest.access$002:(Lcom/demo/mp/test/DemoTest;I)I 8: pop 9: return LineNumberTable: line 8: 0 line 9: 9 LocalVariableTable: Start Length Slot Name Signature 0 10 0 this Lcom/demo/mp/test/DemoTest$Inner; 反编译没有private修饰的代码： java123456789101112131415// 内部类的汇编代码中，在方法中引用外部类变量的时候，是通过属性直接设置的public void in(); Code: 0: aload_0 1: getfield #1 // Field this$0:Lcom/demo/mp/test/DemoTest; 4: iconst_5 // 通过属性直接设置 5: putfield #3 // Field com/demo/mp/test/DemoTest.i:I 8: return LineNumberTable: line 8: 0 line 9: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lcom/demo/mp/test/DemoTest$Inner; 因此，去掉private修饰简化嵌套类的访问。 2.1.5.2 数组使用transient查看ArrayList的源码，发现内部定义的elementData数组使用了transient修饰，transient表示该数组不参与序列化。 那ArrayList是如何实现序列化的呢？ 这就涉及到了序列化的基础原理了，之前在学习输入输出流的时候，有一种对象流，主要的类是ObjectOutputStream和ObjectInputStream。 ObjectOutputStream类是用于序列化的输出流，ObjectInputStream类是用于反序列化的输入流。 在序列化和反序列化的时候，JVM会调用对象里的writeObject()方法和readObject()方法，进行用户自定义的序列化和反序列化。如果没有提供，那就调用ObjectOutputStream类的defaultWriteObject()方法和ObjectInputStream类的defaultReadObject()方法，进行默认的序列化和反序列化，这时就会忽略transient修饰的成员。 因此，在ArrayList内部自定义了writeObject()方法和readObject()方法，自定义序列化和反序列化，这么做是为了处理实际存储的元素，避免处理整个数组。 2.2 Vector2.2.1 简介不常用的集合，和ArrayList类似，允许任何符合规则的元素插入，包括null和重复元素。 底层是数组结构，提供了索引机制，查找效率高，增删效率低。 线程安全，使用了synchronized关键字。 2.2.2 扩容扩容机制和ArrayList类似，初始容量默认为10，负载因子是1，表示当插入元素后个数超出原有长度时会进行扩增，扩容增量是默认为原容量，所以扩增后容量为2倍，可使用方法手动扩容和缩减。 最好指定初始容量值和增量，避免过多的进行扩容操作而浪费时间和效率。 2.2.3 方法构造方法： java12345678// 空参构造器，返回默认容量为10的集合public Vector();// 指定长度的构造器，默认增量为0public Vector(int initialCapacity);// 指定长度和增量的构造器，默认增量为0public Vector(int initialCapacity, int capacityIncrement);// 传入了一个集合的构造器，如果集合长度为0，返回容量为0的集合public Vector(Collection&lt;? extends E&gt; c); 常用方法： java123456789101112// 获取指定下标的元素public synchronized E get(int index);// 设置指定下标的指定元素，并返回旧元素public synchronized E set(int index, E element);// 添加元素，并返回是否成功public synchronized boolean add(E e);// 在指定位置添加指定元素public void add(int index, E element);// 删除指定位置的元素，并返回删除的元素public synchronized E remove(int index);// 删除元素，并返回是否成功public boolean remove(Object o); 2.2.4 源码2.2.4.1 属性属性源码： java123456// 数组protected Object[] elementData;// 元素个数protected int elementCount;// 扩容增量protected int capacityIncrement; 2.2.4.2 构造方法构造方法源码： java123456789101112131415161718192021222324// 空参构造器，返回默认容量为10的集合public Vector() &#123; this(10);&#125;// 指定长度的构造器，默认增量为0public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;// 指定长度和增量的构造器，默认增量为0public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;// 传入了一个集合的构造器，如果集合长度为0，返回容量为0的集合public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // Object[]数组里的类型不一定都是Object类型的，有可能是Object的子类，所以要判断一下 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125; 2.2.4.3 常用方法常用方法源码： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 获取指定下标的元素public synchronized E get(int index) &#123; // 检查指定下标是否越界 if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 返回指定下标的元素 return elementData(index);&#125;// 设置指定下标的指定元素，并返回旧元素public synchronized E set(int index, E element) &#123; // 检查指定下标是否越界 if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 设置指定元素并返回旧元素 E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;// 添加元素，并返回是否成功public synchronized boolean add(E e) &#123; // 操作数自增 modCount++; // 扩容 ensureCapacityHelper(elementCount + 1); // 元素个数增加并设置指定元素 elementData[elementCount++] = e; // 返回成功 return true;&#125;// 在指定位置添加指定元素public void add(int index, E element) &#123; insertElementAt(element, index);&#125;// 删除指定位置的元素，并返回删除的元素public synchronized E remove(int index) &#123; // 操作数自增 modCount++; // 检查指定下标是否越界 if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); // 获取指定下标的元素 E oldValue = elementData(index); // 需要移动的元素个数 int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设置为null并减少容量大小 elementData[--elementCount] = null; // 返回指定下标的元素 return oldValue;&#125;// 删除元素，并返回是否成功public boolean remove(Object o) &#123; return removeElement(o);&#125; 2.2.4.4 扩容方法扩容方法源码： java12345678910111213141516171819202122232425262728293031323334353637383940// 对集合进行扩容public synchronized void ensureCapacity(int minCapacity) &#123; // 如果指定容量大于扩充值，则进行扩容 if (minCapacity &gt; 0) &#123; // 操作数自增 modCount++; ensureCapacityHelper(minCapacity); &#125;&#125;// 对集合进行扩容private void ensureCapacityHelper(int minCapacity) &#123; // 如果最小值大于数组长度，则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;// 数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// 扩容计算private void grow(int minCapacity) &#123; // 获取原容量大小 int oldCapacity = elementData.length; // 如果增量大于0，则使用增量，否则使用原容量作为增量，最后加上原容量作为新容量 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 如果扩容后小于最小值，则设置容量为最小值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果扩容后大于最大值，则进一步设置容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 复制数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;// 扩容后容量过大的处理方法private static int hugeCapacity(int minCapacity) &#123; // 如果最小值小于零，则表示溢出，抛出内存溢出异常 if (minCapacity &lt; 0) throw new OutOfMemoryError(); // 如果扩容后的值大于最大值，则使用Integer的最大值，否则就使用最大值 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 2.3 Stack2.3.1 简介不常用的集合，继承自Vector，允许任何符合规则的元素插入，包括null和重复元素。 同Vector类似，底层是数组结构，但通过对Vector的扩展，将数组结构倒置形成堆栈结构，使用典型的后进先出操作方式。 线程安全，使用了synchronized关键字。 2.3.2 扩容扩容同Vector。 2.3.3 方法构造方法： java1public Stack(); 常用方法： java12345678910// 判断是否为空public boolean empty();// 入栈，添加到栈顶public E push(E item);// 出栈，查看并删除栈顶元素public synchronized E pop();// 查看栈顶元素public synchronized E peek();// 查找元素，返回栈中首次出现下标public synchronized int search(Object o); 2.3.4 源码2.3.4.1 构造方法构造方法源码： java12public Stack() &#123;&#125; 2.3.4.2 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839// 判断是否为空public boolean empty() &#123; // 通过Vector的size()方法判断 return size() == 0;&#125;// 入栈，添加到栈顶public E push(E item) &#123; // 实际添加到数组尾部 addElement(item); return item;&#125;// 出栈，查看并删除栈顶元素public synchronized E pop() &#123; E obj; int len = size(); // 实际查看数组尾部元素 obj = peek(); // 实际删除数组尾部元素 removeElementAt(len - 1); return obj;&#125;// 查看栈顶元素public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); // 实际查看数组尾部元素 return elementAt(len - 1);&#125;// 查找元素，返回栈中首次出现下标public synchronized int search(Object o) &#123; // 实际查看元素在数组最后出现位置 int i = lastIndexOf(o); if (i &gt;= 0) &#123; // 转换为栈中位置 return size() - i; &#125; return -1;&#125; 2.4 LinkedList2.4.1 简介允许任何符合规则的元素插入，包括null和重复元素。 底层是双向链表结构，使用双向链表代替索引，查找效率低，增删效率高。 线程不安全。 2.4.2 方法构造方法： java1234// 空参构造器public LinkedList();// 传入了一个集合的构造器public LinkedList(Collection&lt;? extends E&gt; c); 常用方法： java1234567891011121314151617181920// 获取个数public int size();// 判断是否包含指定数据public boolean contains(Object o);// 计算指定数据首次出现的下标public int indexOf(Object o);// 计算指定数据最后出现的下标public int lastIndexOf(Object o);// 获取指定下标的元素public E get(int index);// 获取首节点元素，节点不存在会抛异常public E getFirst();// 获取尾节点元素，节点不存在会抛异常public E getLast();// 设置指定下标的指定元素，并返回旧元素public E set(int index, E element);// 在指定位置添加指定元素public void add(int index, E element);// 删除指定位置的元素，并返回删除的元素public E remove(int index); 队列方法： java1234567891011121314151617181920212223242526272829303132// 获取首节点元素，节点不存在会抛异常public E element();// 添加指定元素作为尾节点，并返回是否成功public boolean add(E e);// 添加指定元素作为首节点public void addFirst(E e);// 添加指定元素作为尾节点public void addLast(E e);// 删除同指定元素相同的第一个元素，并返回是否成功public boolean remove(Object o);// 删除首节点元素，并返回删除的元素，节点不存在会抛异常public E removeFirst();// 删除尾节点元素，并返回删除的元素，节点不存在会抛异常public E removeLast();// 获取首节点元素，节点不存在会返回nullpublic E peek();// 获取首节点元素，节点不存在会返回nullpublic E peekFirst();// 获取尾节点元素，节点不存在会返回nullpublic E peekLast();// 添加指定元素作为尾节点public boolean offer(E e);// 添加指定元素作为首节点public boolean offerFirst(E e);// 添加指定元素作为尾节点public boolean offerLast(E e);// 删除首节点元素，并返回删除的元素，节点不存在会返回nullpublic E poll();// 删除首节点元素，并返回删除的元素，节点不存在会返回nullpublic E pollFirst();// 删除尾节点元素，并返回删除的元素，节点不存在会返回nullpublic E pollLast(); 栈方法： java1234// 添加指定元素作为首节点public void push(E e);// 删除首节点元素，并返回删除的元素，节点不存在会抛异常public E pop(); 2.4.3 源码2.4.3.1 属性属性源码： java123456// 元素个数transient int size = 0;// 头节点transient Node&lt;E&gt; first;// 尾节点transient Node&lt;E&gt; last; 2.4.3.2 构造方法构造方法源码： java12345678// 空参构造器public LinkedList() &#123;&#125;// 传入了一个集合的构造器public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 2.4.3.3 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 获取个数public int size() &#123; return size;&#125;// 判断是否包含指定数据public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;// 计算指定数据首次出现的下标public int indexOf(Object o) &#123; int index = 0; // 如果指定数据为null if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; // 如果指定数据不为null &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;// 计算指定数据最后出现的下标public int lastIndexOf(Object o) &#123; int index = size; // 如果指定数据为null if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; // 如果指定数据不为null &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125;// 获取指定下标的元素public E get(int index) &#123; // 检查指定下标是否越界 checkElementIndex(index); // 遍历链表并获取指定下标对应的元素 return node(index).item;&#125;// 获取首节点元素，节点不存在会抛异常public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;// 获取尾节点元素，节点不存在会抛异常public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125;// 设置指定下标的指定元素，并返回旧元素public E set(int index, E element) &#123; // 检查指定下标是否越界 checkElementIndex(index); // 遍历链表并获取指定下标对应的元素 Node&lt;E&gt; x = node(index); // 获取旧元素 E oldVal = x.item; // 替换元素 x.item = element; // 返回旧元素 return oldVal;&#125;// 在指定位置添加指定元素public void add(int index, E element) &#123; // 检查指定下标是否越界 checkPositionIndex(index); // 如果指定位置为末尾，则直接末尾插入 if (index == size) linkLast(element); // 如果指定位置不为末尾，则插入到该位置所在的元素前面 else linkBefore(element, node(index));&#125;// 删除指定位置的元素，并返回删除的元素public E remove(int index) &#123; // 检查指定下标是否越界 checkElementIndex(index); // 找到指定位置的元素并删除 return unlink(node(index));&#125; 2.4.3.4 队列方法队列方法源码： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 获取首节点元素，节点不存在会抛异常public E element() &#123; return getFirst();&#125;// 添加指定元素作为尾节点，并返回是否成功public boolean add(E e) &#123; linkLast(e); return true;&#125;// 添加指定元素作为首节点public void addFirst(E e) &#123; linkFirst(e);&#125;// 添加指定元素作为尾节点public void addLast(E e) &#123; linkLast(e);&#125;// 删除同指定元素相同的第一个元素，并返回是否成功public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;// 删除首节点元素，并返回删除的元素，节点不存在会抛异常public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;// 删除尾节点元素，并返回删除的元素，节点不存在会抛异常public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;// 获取首节点元素，节点不存在会返回nullpublic E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;// 获取首节点元素，节点不存在会返回nullpublic E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;// 获取尾节点元素，节点不存在会返回nullpublic E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125;// 添加指定元素作为尾节点public boolean offer(E e) &#123; return add(e);&#125;// 添加指定元素作为首节点public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;// 添加指定元素作为尾节点public boolean offerLast(E e) &#123; addLast(e); return true;&#125;// 删除首节点元素，并返回删除的元素，节点不存在会返回nullpublic E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;// 删除首节点元素，并返回删除的元素，节点不存在会返回nullpublic E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;// 删除尾节点元素，并返回删除的元素，节点不存在会返回nullpublic E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 2.4.3.5 栈方法栈方法源码： java12345678// 入栈，添加指定元素作为首节点public void push(E e) &#123; addFirst(e);&#125;// 出栈，删除首节点元素，并返回删除的元素，节点不存在会抛异常public E pop() &#123; return removeFirst();&#125; 2.5 HashSet2.5.1 简介不允许重复的元素插入，可以插入null。 底层是HashMap，不能保证插入和输出的顺序一致。 线程不安全。 2.5.2 扩容扩容同HashMap。 2.5.3 方法构造方法： java12345678910// 空参构造器，调用HashMap的构造器public HashSet();// 指定长度的构造器，调用HashMap的构造器public HashSet(int initialCapacity);// 指定长度和负载因子的构造器，调用HashMap的构造器public HashSet(int initialCapacity, float loadFactor);// 传入了一个集合的构造器，调用HashMap的构造器，添加指定集合public HashSet(Collection&lt;? extends E&gt; c);// 指定长度和负载因子的构造器，调用LinkedHashMap的构造器HashSet(int initialCapacity, float loadFactor, boolean dummy); 常用方法： java123456789101112// 获取个数public int size();// 判断是否为空public boolean isEmpty();// 判断是否包含指定数据public boolean contains(Object o);// 添加元素，并返回是否成功public boolean add(E e);// 删除元素，并返回是否成功public boolean remove(Object o);// 清除所有元素public void clear(); 2.5.4 源码2.5.4.1 属性属性源码： java1234// 使用HashMap存储数据private transient HashMap&lt;E,Object&gt; map;// 定义Object对象作为HashMap的valueprivate static final Object PRESENT = new Object(); 2.5.4.2 构造方法构造方法源码： java123456789101112131415161718192021// 空参构造器，调用HashMap的构造器public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;// 指定长度的构造器，调用HashMap的构造器public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;// 指定长度和负载因子的构造器，调用HashMap的构造器public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;// 传入了一个集合的构造器，调用HashMap的构造器，添加指定集合public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;// 指定长度和负载因子的构造器，调用LinkedHashMap的构造器HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 2.5.4.3 常用方法常用方法源码： java123456789101112131415161718192021222324// 获取个数public int size() &#123; return map.size();&#125;// 判断是否为空public boolean isEmpty() &#123; return map.isEmpty();&#125;// 判断是否包含指定数据public boolean contains(Object o) &#123; return map.containsKey(o);&#125;// 添加元素，并返回是否成功public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;// 删除元素，并返回是否成功public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;// 清除所有元素public void clear() &#123; map.clear();&#125; 2.6 LinkedHashSet2.6.1 简介不允许重复的元素插入，可以插入null。 继承自HashSet，底层是LinkedHashMap，维护了数据的插入顺序。 线程不安全。 2.6.2 扩容扩容同LinkedHashMap。 2.6.3 方法构造方法： java12345678// 指定长度和负载因子的构造器，调用HashSet的构造器public LinkedHashSet(int initialCapacity, float loadFactor);// 指定长度的构造器，调用HashSet的构造器public LinkedHashSet(int initialCapacity);// 空参构造器，调用HashSet的构造器public LinkedHashSet();// 传入了一个集合的构造器，调用HashSet的构造器，添加指定集合public LinkedHashSet(Collection&lt;? extends E&gt; c); 常用方法同HashSet。 2.6.4 源码2.6.4.1 属性属性同HashSet。 2.6.4.2 构造方法构造方法源码： java1234567891011121314151617// 指定长度和负载因子的构造器，调用HashSet的构造器public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;// 指定长度的构造器，调用HashSet的构造器public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125;// 空参构造器，调用HashSet的构造器public LinkedHashSet() &#123; super(16, .75f, true);&#125;// 传入了一个集合的构造器，调用HashSet的构造器，添加指定集合public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125; 2.6.4.3 常用方法常用方法同HashSet。 2.7 TreeSet2.7.1 简介不允许重复的元素插入，不可以插入null。 底层TreeMap，使用二叉树结构存储数据，支持自然排序和定制排序。 线程不安全。 2.7.2 扩容扩容同TreeMap。 2.7.3 方法构造方法： java12345678910// 指定NavigableMap的构造器TreeSet(NavigableMap&lt;E,Object&gt; m);// 空参构造器，调用TreeMap的构造器public TreeSet();// 指定比较器的构造器，调用TreeMap的构造器public TreeSet(Comparator&lt;? super E&gt; comparator);// 传入了一个集合的构造器，调用空参的构造器，添加指定集合public TreeSet(Collection&lt;? extends E&gt; c);// 传入了一个有序集合的构造器，调用指定比较器的构造器，添加指定集合public TreeSet(SortedSet&lt;E&gt; s); 常用方法： java123456789101112// 获取个数public int size();// 判断是否为空public boolean isEmpty();// 判断是否包含指定数据public boolean contains(Object o);// 添加元素，并返回是否成功public boolean add(E e);// 删除元素，并返回是否成功public boolean remove(Object o);// 清除所有元素public void clear(); 2.7.4 源码2.7.4.1 属性属性源码： java1234// 使用NavigableMap存储数据private transient NavigableMap&lt;E,Object&gt; m;// 定义Object对象作为NavigableMap的valueprivate static final Object PRESENT = new Object(); 2.7.4.2 构造方法构造方法源码： java12345678910111213141516171819202122// 指定NavigableMap的构造器TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m;&#125;// 空参构造器，调用TreeMap的构造器public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125;// 指定比较器的构造器，调用TreeMap的构造器public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator));&#125;// 传入了一个集合的构造器，调用空参的构造器，添加指定集合public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;// 传入了一个有序集合的构造器，调用指定比较器的构造器，添加指定集合public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s);&#125; 2.7.4.3 常用方法常用方法源码： java123456789101112131415161718192021222324// 获取个数public int size() &#123; return m.size();&#125;// 判断是否为空public boolean isEmpty() &#123; return m.isEmpty();&#125;// 判断是否包含指定数据public boolean contains(Object o) &#123; return m.containsKey(o);&#125;// 添加元素，并返回是否成功public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125;// 删除元素，并返回是否成功public boolean remove(Object o) &#123; return m.remove(o)==PRESENT;&#125;// 清除所有元素public void clear() &#123; m.clear();&#125; 2.8 HashMap2.8.1 简介不允许插入key值相同的元素，允许插入null的key值。 底层由数组、链表、红黑树组成，数组中存储链表或红黑树，将一个key到value的映射作为一个元素，不能保证插入顺序和输出顺序一致。 线程不安全。 2.8.2 扩容数组结构会有容量的概念，HashMap的默认容量为16，默认负载因子是0.75，表示当插入元素后个数超出长度的0.75倍时会进行扩增，默认扩容增量是1，所以扩增后容量为2倍。 最好指定初始容量值，避免过多的进行扩容操作而浪费时间和效率。 2.8.3 方法构造方法： java12345678// 指定长度和负载因子的构造器public HashMap(int initialCapacity, float loadFactor);// 指定长度的构造器，使用默认负载因子public HashMap(int initialCapacity);// 空参构造器，使用默认负载因子public HashMap();// 传入了一个集合的构造器，使用默认负载因子，添加指定集合public HashMap(Map&lt;? extends K, ? extends V&gt; m); 常用方法： java123456789101112// 获取个数public int size();// 判断是否为空public boolean isEmpty();// 根据key获取value，不存在会返回nullpublic V get(Object key);// 设置key和value键值对，返回原value，不存在会返回nullpublic V put(K key, V value);// 根据key删除键值对，返回原value，不存在会返回nullpublic V remove(Object key);// 清除所有元素public void clear(); 2.8.4 源码2.8.4.1 属性静态属性源码： java123456789101112// 默认容量为16，是2的整数次幂static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// 最大容量是2的30次方，传入容量过大将被这个值替换static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认负载因子为0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;// 树化阈值为8，链表中元素的个数超过8时会转换为红黑树static final int TREEIFY_THRESHOLD = 8;// 反树化阈值为6，红黑树中元素的个数小于6时会转换为链表static final int UNTREEIFY_THRESHOLD = 6;// 树化时哈希表最小的容量为64，为了避免冲突，该值至少为树化阈值和4的乘积static final int MIN_TREEIFY_CAPACITY = 64; 普通属性源码： java123456789101112// 数组，用于存储链表和红黑树transient Node&lt;K,V&gt;[] table;// 存储key和value键值对的集合transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 键值对的个数transient int size;// 修改次数，用于快速失败机制transient int modCount;// 扩容阈值int threshold;// 负载因子final float loadFactor; 2.8.4.2 工具方法工具方法源码： java123456789101112131415// 根据key的hashCode重新计算hash值static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// 根据长度计算阈值static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 2.8.4.3 构造方法构造方法源码： java12345678910111213141516171819202122232425// 指定长度和负载因子的构造器public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; // 根据长度设置阈值 this.threshold = tableSizeFor(initialCapacity);&#125;// 指定长度的构造器，使用默认负载因子public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 空参构造器，使用默认负载因子public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;// 传入了一个集合的构造器，使用默认负载因子，添加指定集合public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 2.8.4.4 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172// 获取个数public int size() &#123; return size;&#125;// 判断是否为空public boolean isEmpty() &#123; return size == 0;&#125;// 根据key获取value，不存在会返回nullpublic V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;// 根据key获取节点final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; // 节点数组tab，数组首节点first，目标节点e，数组长度n，目标节点key值k Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 赋值并判断，如果数组已初始化，并且数组首节点不为空，才获取元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断数组首节点的key和value是否满足，满足则返回数组首节点 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 数组首节点不满足，赋值并遍历链表和红黑树 if ((e = first.next) != null) &#123; // 如果是红黑树节点，则通过红黑树节点方式查询 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 如果是链表节点，则遍历链表节点查询 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;// 设置key和value键值对，返回原value，不存在会返回nullpublic V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;// 设置key和value键值对，返回原value，不存在会返回nullfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; // 节点数组tab，指针节点p，数组长度n，数组位置i Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 赋值并判断，如果数组未初始化，则初始化数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length // 如果数组已初始化，并且指针节点不存在，则创建新节点存储key和value if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 如果数组已初始化，并且指针节点存在，则查找key值相同节点并替换value else &#123; // 目标节点e，目标节点key值k Node&lt;K,V&gt; e; K k; // 判断指针节点的key和value是否满足，满足则将指针节点作为目标节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 指针节点不满足，并且是红黑树节点，遍历红黑树并返回目标节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 指针节点不满足，并且是链表节点，遍历链表并返回目标节点 else &#123; // 记录链表节点个数并遍历链表 for (int binCount = 0; ; ++binCount) &#123; // 将下一节点作为目标节点，不存在则表示遍历完成且不存在目标节点 if ((e = p.next) == null) &#123; // 创建新节点存储key和value p.next = newNode(hash, key, value, null); // 如果新增后链表节点个数超过树化阈值，则尝试进行树化操作 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 此时目标节点不存在，跳出循环 break; &#125; // 遍历过程中，找到满足的目标节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 此时目标节点存在，跳出循环 break; // 将目标节点作为新的指针节点进入循环 p = e; &#125; &#125; // 如果目标节点存在，不需要个数自增和扩容，替换value并返回原值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; // 执行到这里，说明增加了新节点，操作数自增 ++modCount; // 个数自增，如果自增后的个数超过了阈值则进行扩容 if (++size &gt; threshold) resize(); // 添加新节点之后的后置处理 afterNodeInsertion(evict); // 返回null return null;&#125;// 根据key删除键值对，返回原value，不存在会返回nullpublic V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;// 根据key删除键值对，并返回原节点final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; // 节点数组tab，指针节点p，数组长度n，数组位置index Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 赋值并判断，如果数组已初始化，并且数组首节点不为空，才删除元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; // 原节点node，目标节点e，目标节点key值k，目标节点value值v Node&lt;K,V&gt; node = null, e; K k; V v; // 判断指针节点的key和value是否满足，满足则将指针节点作为原节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 将指针节点下一节点作为目标节点，如果目标节点存在则继续遍历节点 else if ((e = p.next) != null) &#123; // 如果指针节点是红黑树节点，则通过红黑树节点方式查询原节点 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 如果指针节点是链表节点，则通过链表节点方式查询原节点 else &#123; do &#123; // 遍历过程中，找到满足的目标节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; // 将目标节点作为原节点 node = e; // 此时原节点存在，跳出循环 break; &#125; // 用指针节点保存目标节点，跳出循环时，指针节点保存的是目标节点的上一节点 p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 原节点存在，并且满足value值的判断规则，那就继续执行 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 如果原节点是红黑树节点，则通过红黑树节点方式删除原节点 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果原节点是链表节点，并且原节点和指针节点相同，则将原节点的下一节点作为数组首节点 else if (node == p) tab[index] = node.next; // 如果原节点是链表节点，并且原节点和指针节点不同，则将原节点的下一节点作为指针节点的下一节点 else p.next = node.next; // 执行到这里，说明删除了原节点，操作数自增 ++modCount; // 个数自减 --size; afterNodeRemoval(node); // 返回原节点 return node; &#125; &#125; return null;&#125;// 清除所有元素public void clear() &#123; // 定义节点数组tab Node&lt;K,V&gt;[] tab; // 操作数自增 modCount++; // 如果数组已初始化，则设置个数为0，并且将每个节点置空 if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125;&#125; 2.8.4.5 扩容方法扩容方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107final Node&lt;K,V&gt;[] resize() &#123; // 记录原节点数组 Node&lt;K,V&gt;[] oldTab = table; // 记录原数组容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 记录原阈值 int oldThr = threshold; // 定义新数组容量，定义新数组阈值 int newCap, newThr = 0; // 如果原容量大于0，则进行扩容 if (oldCap &gt; 0) &#123; // 如果原容量大于等于容量最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 将原阈值设为整数最大值，并返回原数组 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 原容量扩容一倍并赋值给新容量，如果新容量小于容量最大值，并且原容量大于等于默认容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 将原阈值扩容一倍并赋值给新阈值 newThr = oldThr &lt;&lt; 1; &#125; // 原容量为0，判断原阈值是否大于0 else if (oldThr &gt; 0) // 首次初始化，将原阈值赋值给新容量 newCap = oldThr; // 原容量为0，并且原阈值也是0 else &#123; // 设置默认容量 newCap = DEFAULT_INITIAL_CAPACITY; // 设置默认阈值 newThr = (int)(DEFAULT_LOAD_FACTOR *DEFAULT_INITIAL_CAPACITY); &#125; // 判断新阈值是否为0 if (newThr == 0) &#123; // 计算新阈值 float ft = (float)newCap* loadFactor; // 新容量小于容量最大值并且阈值小于容量最大值，则使用新阈值，否则使用最大值 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 确定新阀值 threshold = newThr; // 开始构造新的节点数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果原节点数组已初始化，则将原节点放置到新节点数组 if (oldTab != null) &#123; // 遍历原节点数组 for (int j = 0; j &lt; oldCap; ++j) &#123; // 定义原节点 Node&lt;K,V&gt; e; // 如果原节点不为空，记录原节点并移动 if ((e = oldTab[j]) != null) &#123; // 将原节点置空 oldTab[j] = null; // 如果原节点没有子节点，表示数组中只有一个节点，直接放置到新节点数组 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果原节点是红黑树节点，则在红黑树中将原节点存储到新节点数组 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 如果原节点是链表节点，则进行链表节点的移动 else &#123; // 定义低位链表的头节点和尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; // 定义高位链表的头节点和尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; // 定义下一节点 Node&lt;K,V&gt; next; // 循环遍历节点链表 do &#123; // 给下一节点赋值 next = e.next; // 确定原节点在新节点数组中的位置，为0则放在低位链表 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 为1则放在高位链表 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 如果低位链表不为空，则将整个低位链表放到原位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 如果高位链表不为空，则将整个高位链表放到新增的空间中 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 返回新的节点数组 return newTab;&#125; 2.8.5 补充2.8.5.1 为什么数组长度是2的倍数长度减一后的二进制位全为1，可以用来计算节点在数组中的位置，不会造成浪费。 如果指定长度不是2的倍数，在构造方法中的最后一步会根据指定长度计算容量，会通过移位运算得到大于等于指定长度的，并且为2的倍数的最小正整数。 2.8.5.2 为什么不直接使用equals方法比较在Object类中有一个hashCode()方法，用来获取对象的哈希值，也被称作为散列值。 使用native修饰hashCode()方法，意味着这个方法和平台有关。大多数情况下hashCode()方法返回的是与对象信息（存储地址和字段等）有关的数值。 当向集合中插入对象时，如果调用equals()逐个进行比较，虽然可行但是这样做的效率很低。因此，先调用hashCode()进行判断，如果相同再调用equals()判断，就会提高效率。 2.8.5.3 为什么要使用hash方法处理hashCode在计算节点在数组中的下标时，一般是通过与节点有关的数值除以数组长度取余得到的。当数组长度为2的倍数时，取余操作相当于数值同数组长度减一进行与运算。 根据数组长度减一得到的结果，将二进制位分为高位和低位，将左边全为0的部分作为高位，将右边全为1的部分作为低位。在与运算时，任何数字与0相与只能得到0，所以高位无效，只用到了低位。 如果使用hashCode进行与运算，两个hashCode不同但是低位相同的节点会被分到一个数组中，哈希碰撞发生的可能性较大。因此，需要对hashCode进行处理，使两个高位不同低位相同的节点得到的结果也不同。 可以将hash()方法称为扰动函数，是用来对hashCode进行处理的方法。在hash()方法处理后，hashCode高位的变化也会影响低位，这时再使用低位计算下标就能使元素的分布更加合理，哈希碰撞的可能性也会降低。 在JDK1.8版本中，只使用了hashCode进行了一次与运算： java1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 2.8.5.4 什么时候进行扩容扩容有两个触发时机： 插入第一个节点时，初始化数组时进行扩容。 插入节点后，长度超过阈值时进行扩容。 2.8.5.5 如何对链表扩容使用高低位链表，将节点的hash值同原数组长度进行与运算，根据结果0和1放到低位链表和高位链表。 将低位链表放置到新数组的低位，将高位链表放置到新数组的高位，低位的位置加上原数组长度就是高位的位置。 2.8.5.6 为什么要同时重写equals方法和hashCode方法一般在重写equals()方法的时候，也会尽量重写hashCode()方法，就是为了在equals()方法判断相等的时候保证让hashCode()方法判断相等。 2.9 Hashtable2.9.1 简介不允许插入key值相同的元素，不允许插入null的key值，不允许插入null的value值。 底层由数组、链表组成，数组中存储链表，通过单链表解决哈希冲突。 线程安全，使用了synchronized关键字。 2.9.2 扩容默认容量为11，默认负载因子是0.75，扩增后容量为2倍加1。 2.9.3 方法构造方法： java12345678// 指定长度和负载因子的构造器public Hashtable(int initialCapacity, float loadFactor);// 指定长度的构造器，使用默认负载因子public Hashtable(int initialCapacity);// 空参构造器，使用默认长度和默认负载因子public Hashtable();// 传入了一个集合的构造器，使用默认负载因子，添加指定集合public Hashtable(Map&lt;? extends K, ? extends V&gt; t); 常用方法： java12345678910// 获取个数public synchronized int size();// 判断是否为空public synchronized boolean isEmpty();// 根据key获取value，不存在会返回nullpublic synchronized V get(Object key);// 设置key和value键值对，返回原value，不存在会返回nullpublic synchronized V put(K key, V value);// 根据key删除键值对，返回原value，不存在会返回nullpublic synchronized V remove(Object key); 2.9.4 源码2.9.4.1 属性属性源码： java12345678910// 数组private transient Entry&lt;?,?&gt;[] table;// 键值对的个数private transient int count;// 扩容阈值private int threshold;// 负载因子private float loadFactor;// 修改次数，用于快速失败机制private transient int modCount = 0; 2.9.4.2 构造方法构造方法源码： java12345678910111213141516171819202122232425// 指定长度和负载因子的构造器public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry&lt;?,?&gt;[initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);&#125;// 指定长度的构造器，使用默认负载因子public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f);&#125;// 空参构造器，使用默认长度和默认负载因子public Hashtable() &#123; this(11, 0.75f);&#125;// 传入了一个集合的构造器，使用默认负载因子，添加指定集合public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); putAll(t);&#125; 2.9.4.3 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 获取个数public synchronized int size() &#123; return count;&#125;// 判断是否为空public synchronized boolean isEmpty() &#123; return count == 0;&#125;// 根据key获取value，不存在会返回nullpublic synchronized V get(Object key) &#123; // 定义数组 Entry&lt;?,?&gt; tab[] = table; // 计算key的hashCode int hash = key.hashCode(); // 通过key值计算元素在数组中的位置 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 如果数组中对应位置上存在元素，表示发生了哈希碰撞 for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; // 如果链表中存在key值对应的元素，返回value值 if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return (V)e.value; &#125; &#125; return null;&#125;// 设置key和value键值对，返回原value，不存在会返回nullpublic synchronized V put(K key, V value) &#123; // 不支持value为null的键值对，否则会抛出异常 if (value == null) &#123; throw new NullPointerException(); &#125; // 保存原数组 Entry&lt;?,?&gt; tab[] = table; // 计算key的hashCode int hash = key.hashCode(); // 通过key值计算元素在数组中的位置 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 获取数组中对应位置上的元素 Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; // 如果位置元素存在，表示发生了哈希碰撞 for(; entry != null ; entry = entry.next) &#123; // 如果链表中存在key值对应的元素，替换value值，返回原value值 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; // 如果没有发生了哈希碰撞，将键值对添加到数组 addEntry(hash, key, value, index); return null;&#125;// 添加key和value键值对private void addEntry(int hash, K key, V value, int index) &#123; // 增加操作数 modCount++; // 保存原数组 Entry&lt;?,?&gt; tab[] = table; // 如果插入前的元素个数大于等于阈值 if (count &gt;= threshold) &#123; // 进行扩容操作 rehash(); // 重新保存扩容后的原数组 tab = table; // 计算key的hashCode hash = key.hashCode(); // 通过key值计算元素在扩容后数组中的位置 index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // 初始化数组位置 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; // 将键值对设置到数组位置 tab[index] = new Entry&lt;&gt;(hash, key, value, e); // 元素个数自增 count++;&#125;// 根据key删除键值对，返回原value，不存在会返回nullpublic synchronized V remove(Object key) &#123; // 保存原数组 Entry&lt;?,?&gt; tab[] = table; // 计算key的hashCode int hash = key.hashCode(); // 通过key值计算元素在数组中的位置 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 获取数组中对应位置上的元素 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; // 如果位置元素存在，尝试删除元素 for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) &#123; // 如果链表中存在key值对应的元素，则删除元素 if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; // 操作数自增 modCount++; // 上一节点存在，表示要删除的元素不是头节点 if (prev != null) &#123; prev.next = e.next; // 上一节点不存在，表示要删除的元素是头节点 &#125; else &#123; tab[index] = e.next; &#125; // 元素个数自减 count--; // 保存原value值 V oldValue = e.value; // 置空原value值 e.value = null; // 返回原value值 return oldValue; &#125; &#125; return null;&#125; 2.9.4.4 扩容方法扩容方法源码： java12345678910111213141516171819202122232425262728293031323334353637383940// 数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// 扩容操作protected void rehash() &#123; // 保存原数组长度 int oldCapacity = table.length; // 保存原数组 Entry&lt;?,?&gt;[] oldMap = table; // 将旧容量的2倍加1作为新容量 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; // 如果新容量大于最大容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; // 如果旧容量等于最大容量，则仍使用旧容量 if (oldCapacity == MAX_ARRAY_SIZE) return; // 否则使用最大值作为新容量 newCapacity = MAX_ARRAY_SIZE; &#125; // 创建新数组 Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; // 操作数自增 modCount++; // 计算阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); // 使用新数组 table = newMap; // 遍历原数组 for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; // 遍历原数组中的链表，计算每个元素在新数组中的位置并插入到新数组 for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123; // 遍历原链表 Entry&lt;K,V&gt; e = old; old = old.next; // 计算元素在新数组的位置，使用头插法插入到新数组 int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; &#125; &#125;&#125; 2.10 LinkedHashMap2.10.1 简介不允许插入key值相同的元素，允许插入null的key值。 继承自HashMap，底层由数组、链表、红黑树组成。在此基础上，新增了双向链表，连接了集合中的所有节点，维护了节点的插入顺序。 线程不安全。 2.10.2 扩容扩容同HashMap。 2.10.3 方法构造方法： java12345678910// 指定长度和负载因子的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity, float loadFactor);// 指定长度的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity);// 空参构造器，调用HashMap的构造器public LinkedHashMap();// 传入了一个集合的构造器，调用HashMap的构造器，添加指定集合public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m);// 指定长度和负载因子以及遍历顺序标志位的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder); 常用方法同HashMap。 2.10.4 源码2.10.4.1 扩展节点在LinkedHashMap中，对HashMap的节点进行了扩展，在节点中维护了插入顺序： java123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 可以看到，仍使用next节点维护节点间的访问顺序，但新增了before节点和after节点维护节点间的插入顺序。 2.10.4.2 扩展属性扩展属性源码： java123456// 双向链表的头节点transient LinkedHashMap.Entry&lt;K,V&gt; head;// 双向链表的尾节点transient LinkedHashMap.Entry&lt;K,V&gt; tail;// 双向链表访问顺序标志位，默认为false，true表示双向链表按访问顺序排列，false表示双向链表按插入顺序排列final boolean accessOrder; accessOrder用于支持LRU算法，即最近最少使用算法，是一种数据删除方法，表示删除最近一段时间内最少使用的数据。 双向链表是按时间顺序排列的，插入的数据永远在尾部，访问的数据是否要移动到尾部是通过accessOrder判断的： 当accessOrder为true时，访问的数据会被放置到双向链表尾部，表示双向链表是按照访问顺序排列的。 当accessOrder为false时，访问的数据不会被处理，表示双向链表是按照插入顺序排列的。 2.10.4.3 扩展方法扩展方法源码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 重写newNode()方法，添加双向链表的处理Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; // 创建节点 LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); // 将节点放在双向链表尾部 linkNodeLast(p); // 返回节点 return p;&#125;// 将节点放在双向链表尾部private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125;// 重写get()方法，添加双向链表的处理public V get(Object key) &#123; Node&lt;K,V&gt; e; // 根据key获取节点 if ((e = getNode(hash(key), key)) == null) return null; // 如果按照访问顺序排列 if (accessOrder) // 处理访问节点 afterNodeAccess(e); return e.value;&#125;// 处理访问节点，将访问节点移动到双向链表尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125;// 处理插入节点，尝试删除双向链表的首节点void afterNodeInsertion(boolean evict) &#123; LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;// 处理删除节点，在双向链表中删除节点void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 2.10.4.4 构造方法构造方法源码： java1234567891011121314151617181920212223242526// 指定长度和负载因子的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;// 指定长度的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;// 空参构造器，调用HashMap的构造器public LinkedHashMap() &#123; super(); accessOrder = false;&#125;// 传入了一个集合的构造器，调用HashMap的构造器，添加指定集合public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;// 指定长度和负载因子以及遍历顺序标志位的构造器，调用HashMap的构造器public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 2.10.4.5 常用方法常用方法同HashMap。 2.11 TreeMap2.11.1 简介不允许插入key值相同的元素，定制排序允许插入null的key值，自然排序不允许插入null的key值。 底层是红黑树，支持自然排序和定制排序。自然排序要求key值实现Comparable接口，定制排序要求创建TreeMap时传入Comparator对象。 线程不安全。 2.11.2 方法构造方法： java12345678// 空参构造器public TreeMap();// 指定比较器的构造器public TreeMap(Comparator&lt;? super K&gt; comparator);// 传入了一个集合的构造器，集合没有比较器，添加指定集合public TreeMap(Map&lt;? extends K, ? extends V&gt; m);// 传入了一个集合的构造器，集合提供比较器，添加指定集合public TreeMap(SortedMap&lt;K, ? extends V&gt; m); 常用方法： java123456// 根据key获取value，不存在会返回nullpublic V get(Object key);// 设置key和value键值对，返回原value，不存在会返回nullpublic V put(K key, V value);// 根据key删除键值对，返回原value，不存在会返回nullpublic V remove(Object key); 2.11.3 源码2.11.3.1 属性属性源码： java12345678// 自定义的比较器，用于排序private final Comparator&lt;? super K&gt; comparator;// 红黑树的根节点private transient Entry&lt;K,V&gt; root;// 节点个数private transient int size = 0;// 修改次数，用于快速失败机制private transient int modCount = 0; 2.11.3.2 构造方法构造方法源码： java12345678910111213141516171819202122// 空参构造器public TreeMap() &#123; comparator = null;&#125;// 指定比较器的构造器public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125;// 传入了一个集合的构造器，集合没有比较器，添加指定集合public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;// 传入了一个集合的构造器，集合提供比较器，添加指定集合public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; 2.11.3.3 常用方法常用方法源码： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 根据key获取value，不存在会返回nullpublic V get(Object key) &#123; // 根据key查询节点 Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125;// 根据key查询节点final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 比较器存在，则使用比较器获取节点 if (comparator != null) return getEntryUsingComparator(key); // 比较器不存在，并且key值为null，则抛异常 if (key == null) throw new NullPointerException(); // 比较器不存在，则使用key值比较 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 保存红黑树的根节点 Entry&lt;K,V&gt; p = root; // 根节点不为空，则查询红黑树并比较 while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;// 使用比较器查询key值对应的节点final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; // 保存key值 K k = (K) key; // 保存比较器 Comparator&lt;? super K&gt; cpr = comparator; // 比较器存在，使用比较器查询 if (cpr != null) &#123; // 保存红黑树的根节点 Entry&lt;K,V&gt; p = root; // 根节点不为空，则查询红黑树并比较 while (p != null) &#123; // 使用比较器的比较方法 int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; &#125; return null;&#125;// 设置key和value键值对，返回原value，不存在会返回nullpublic V put(K key, V value) &#123; // 保存红黑树的根节点 Entry&lt;K,V&gt; t = root; // 根节点为空，则设置根节点 if (t == null) &#123; // 类型检查 compare(key, key); // 创建根节点 root = new Entry&lt;&gt;(key, value, null); // 节点大小设置为1 size = 1; // 操作数自增 modCount++; // 返回null return null; &#125; // 定义比较的结果 int cmp; // 定义父节点 Entry&lt;K,V&gt; parent; // 保存比较器 Comparator&lt;? super K&gt; cpr = comparator; // 比较器存在，使用比较器查询并设置键值对 if (cpr != null) &#123; // 使用比较器逐个比较节点 do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 比较器不存在，使用key值比较查询并设置键值对 else &#123; // 如果key值为null，则抛异常 if (key == null) throw new NullPointerException(); // 使用key值比较 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 使用key值逐个比较节点 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 创建节点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 比较的结果小于0，新节点作为父节点的左节点 if (cmp &lt; 0) parent.left = e; // 比较的结果大于0，新节点作为父节点的右节点 else parent.right = e; // 节点插入后，调整红黑树的高度和颜色 fixAfterInsertion(e); // 个数自增 size++; // 操作数自增 modCount++; // 返回null return null;&#125;// 根据key删除键值对，返回原value，不存在会返回nullpublic V remove(Object key) &#123; // 根据key查询节点 Entry&lt;K,V&gt; p = getEntry(key); // 节点为null，返回null if (p == null) return null; // 节点不为null，删除节点 V oldValue = p.value; deleteEntry(p); return oldValue;&#125; 3 工具类3.1 Arrays3.1.1 简介Arrays工具类主要用来操作数组。 3.1.2 方法3.1.2.1 打印打印数组。 示例： java12345678910public static void main(String[] args) &#123; Integer[] ints = new Integer[5]; ints[0] = 1; ints[1] = 6; ints[2] = 4; ints[3] = 9; ints[4] = 3; System.out.println(ints);// [Ljava.lang.Integer;@12edcd21 System.out.println(Arrays.toString(ints));// [1, 6, 4, 9, 3]&#125; 3.1.2.2 排序将数组里的元素进行排序。 示例： java1234567891011public static void main(String[] args) &#123; Integer[] ints = new Integer[5]; ints[0] = 1; ints[1] = 6; ints[2] = 4; ints[3] = 9; ints[4] = 3; System.out.println(Arrays.toString(ints));// [1, 6, 4, 9, 3] Arrays.sort(ints); System.out.println(Arrays.toString(ints));// [1, 3, 4, 6, 9]&#125; 3.1.2.3 比较判断两个数组是否相等。 示例： java123456789public static void main(String[] args) &#123; Integer[] ints1 = new Integer[2]; ints1[0] = 1; ints1[1] = 6; Integer[] ints2 = new Integer[2]; ints2[0] = 4; ints2[1] = 3; System.out.println(Arrays.equals(ints1, ints2));// false&#125; 3.1.2.4 复制复制数组。 示例： java12345678910public static void main(String[] args) &#123; Integer[] ints1 = new Integer[5]; ints1[0] = 1; ints1[1] = 6; ints1[2] = 4; ints1[3] = 9; ints1[4] = 3; Integer[] ints2 = Arrays.copyOf(ints1, 3); System.out.println(Arrays.toString(ints2));// [1, 6, 4]&#125; 3.1.2.5 数组转集合将数组转为集合。 示例： java12345678910public static void main(String[] args) &#123; Integer[] ints = new Integer[5]; ints[0] = 1; ints[1] = 6; ints[2] = 4; ints[3] = 9; ints[4] = 3; List&lt;Integer&gt; list = Arrays.asList(ints); System.out.println(list);// [1, 6, 4, 9, 3]&#125; 3.2 Collections3.2.1 简介Collections工具类主要用来操作集合类，比如List和Set。 3.2.2 方法3.2.2.1 排序使用Collections工具类里的sort()方法进行排序，必须满足下列任意一个条件： 第一种是List中的存储的元素实现Comparable接口，重写compareTo()方法。 第二种是在使用sort方法时，传入一个Comparator的实现类，重写compareTo()方法。 示例： java12345678List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(3);list.add(5);list.add(1);System.out.println(list);// Collections.sort(list);System.out.println(list);// [1, 3, 5] 3.2.2.2 反转将集合里元素的顺序进行反转。 示例： java1234567List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(3);list.add(5);list.add(1);System.out.println(list);// [3, 5, 1]Collections.reverse(list);System.out.println(list);// [1, 5, 3] 3.2.2.3 混排对集合里的元素进行随机排序。 示例： java1234567List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(3);list.add(5);list.add(1);System.out.println(list);// [3, 5, 1]Collections.shuffle(list);System.out.println(list);// [3, 1, 5] 3.2.2.4 最大查找集合中最大的一个元素。 示例： java123456List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(3);list.add(5);list.add(1);Integer max = Collections.max(list);System.out.println(max);// 5 3.2.2.5 最小查找集合中最小的一个元素。 示例： java123456List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(3);list.add(5);list.add(1);Integer min = Collections.min(list);System.out.println(min);// 1 3.2.3 获取线程安全的容器创建线程安全的List： java1List&lt;Integer&gt; list = Collections.synchronizedList(new ArrayList&lt;Integer&gt;()); 创建线程安全的Set： java1Set&lt;Integer&gt; set = Collections.synchronizedSet(new HashSet&lt;Integer&gt;()); 创建线程安全的Map： java1Map&lt;String, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;()); 4 遍历4.1 遍历Collection对List和Set的遍历，有四种方式，下面以ArrayList为例进行说明。 4.1.1 普通for循环使用普通for循环的遍历方式效率最高，尽量将循环无关的代码放置在集合外执行。 示例： java123for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(i);&#125; 如果要在普通for循环里对集合元素进行删除操作，可能会出现问题： java1234567891011121314public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(2); list.add(4); list.add(5); for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) == 2) &#123; list.remove(i); &#125; &#125; System.out.println(list);// [1, 2, 4, 5]&#125; 集合中有两个值为2的元素，但是在代码执行之后，值为2的元素并没有完全移除。 在第一次删除后，集合发生了改变，删除位置之后的所有元素都向前挪动了一个位置，删除位置上的元素由下一位置上的元素替代。 在下次遍历时，从删除位置后开始判断，跳过了删除位置上的元素，从而导致最后打印的结果和预期的不一致。 改进的办法是在删除之后设置索引减1，重新判断删除位置上的元素。 4.1.2 增强for循环进一步精简了遍历的代码，底层使用迭代器。 示例： java123for (Integer i : list) &#123; System.out.println(i);&#125; 如果在增强for循环里删除或者添加集合元素，那么一定会报异常： java1234567891011121314public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(2); list.add(4); list.add(5); for (Integer i : list) &#123; if (i == 2) &#123; list.remove(i); &#125; &#125; System.out.println(list);&#125; 运行后会抛出java.util.ConcurrentModificationException异常。 抛出异常是由快速失败（fail-fast）机制引起的，该机制是为了避免在遍历集合时，对集合的结构进行修改。 快速失败机制使用modCount记录集合的修改次数，在删除时除了删除对应元素外，还会更新modCount。 增强for循环使用迭代器进行遍历，迭代器在初始化时会使用expectedModCount记录当时的modCount，遍历时会检查expectedModCount是否和modCount相同，如果不同就会抛出异常。 4.1.3 使用迭代器示例： java1234Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 如果在迭代器中使用集合提供的删除或添加方法，同样会报错： java123456789101112131415public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(2); list.add(4); list.add(5); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; if (iterator.next() == 2) &#123; list.add(6); &#125; &#125; System.out.println(list);&#125; 运行后会抛出java.util.ConcurrentModificationException异常。 这里抛出异常的原因和增强for循环一样，同样是因为快速失败机制。 解决办法是在迭代器中删除或添加元素时，使用迭代器提供的删除或添加方法，不要使用集合提供的删除或添加方法。 需要注意的是，普通迭代器中只提供了删除方法，在集合迭代器中还提供了添加和修改方法。 4.1.4 使用集合迭代器示例： java1234ListIterator&lt;Integer&gt; iterator = list.listIterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 在迭代器中使用迭代器提供的删除或添加方法： java123456789101112131415public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(2); list.add(4); list.add(5); ListIterator&lt;Integer&gt; iterator = list.listIterator(); while (iterator.hasNext()) &#123; if (iterator.next() == 2) &#123; iterator.remove(); &#125; &#125; System.out.println(list);// [1, 4, 5]&#125; 迭代器提供的方法同时维护了modCount和expectedModCount，所以不会产生快速失败。 4.1.5 使用forEach方法forEach方法是JDK1.8新增的方法，需要配合Lambda表达式使用。 示例： java1list.forEach(i -&gt; System.out.println(i)); 使用forEach方法遍历： java1234567891011121314public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(2); list.add(4); list.add(5); list.forEach(i -&gt; &#123; if (i == 2) &#123; list.remove(i); &#125; &#125;); System.out.println(list);&#125; 运行后会抛出java.util.ConcurrentModificationException异常。 这里抛出异常的原因也是因为快速失败机制。 4.2 遍历Map对Map的遍历，有四种方式，下面以HashMap为例进行说明。 4.2.1 通过keySet()方法遍历key和value通过keySet()方法获取到map的所有key值，遍历key值的集合，获取对应的value值。 示例： java123for (Integer i : map.keySet()) &#123; System.out.println(i + &quot; &gt;&gt;&gt; &quot; + map.get(i));&#125; 结果： log123450 &gt;&gt;&gt; 0001 &gt;&gt;&gt; 1112 &gt;&gt;&gt; 2223 &gt;&gt;&gt; 3334 &gt;&gt;&gt; 444 在遍历的时候是可以修改的，但是不能添加和删除，否则会抛出ConcurrentModificationException异常。 示例： java123456for (Integer i : map.keySet()) &#123; System.out.println(i + &quot; &gt;&gt;&gt; &quot; + map.get(i)); if (map.get(i) == &quot;222&quot;) &#123; map.put(i, &quot;999&quot;); &#125;&#125; 结果： log123450 &gt;&gt;&gt; 0001 &gt;&gt;&gt; 1112 &gt;&gt;&gt; 9993 &gt;&gt;&gt; 3334 &gt;&gt;&gt; 444 4.2.2 通过entrySet()方法遍历key和value这种方式同样支持修改，但不支持添加和删除，这种方式的效率最高。 示例： java123for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + &quot; &gt;&gt;&gt; &quot; + entry.getValue());&#125; 4.2.3 通过entrySet()方法获取迭代器遍历key和value这种方式同样支持修改，但不支持添加和删除。 示例： java12345Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot; &gt;&gt;&gt; &quot; + entry.getValue());&#125; 4.2.4 通过values()方法遍历所有的value这种方式只能遍历value，不能遍历key。 示例： java123for (String value : map.values()) &#123; System.out.println(value);&#125; 5 失败机制5.1 快速失败机制快速失败机制，即fail-fast机制，直接在容器上进行遍历，在遍历过程中一旦发现集合的结构发生改变，就会抛出ConcurrentModificationException异常导致遍历失败。 在java.util包下的集合类都是快速失败机制的，常见的的使用fail-fast方式遍历的容器有ArrayList和HashMap等。 fail-fast机制不能保证在不同步的修改下一定会抛出异常，它只是尽最大努力抛出，因此这种机制一般用于检测BUG。 5.1.1 复现触发fail-fast机制的案例： java1234567891011public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;00&quot;); list.add(&quot;11&quot;); list.add(&quot;22&quot;); for (String s : list) &#123; if (&quot;00&quot;.equals(s)) &#123; list.add(&quot;99&quot;); &#125; &#125;&#125; 此处只是列举了一个普通案例，实际上在List、Set、Map中都会发生，并且在单线程和多线程环境下都会发生。 5.1.2 原因fail-fast机制在单线程和多线程环境中均可发生，倘若在迭代遍历过程中检测到集合结构有变化，就有可能触发并抛出异常。 想要理解fail-fast机制，就需要查看底层源码的逻辑，因为引发fail-fast机制的原理是一样的，本文以ArrayList为例进行分析。 查看ArrayList的迭代器方法： java123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 继续查看ArrayList维护的内部类Itr，需要重点关注三个属性： java12345678910111213141516171819202122232425262728private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 遍历集合时即将遍历的索引 int lastRet = -1; // 记录刚刚遍历的索引，-1不是不存在上一个元素 int expectedModCount = modCount;// 初始值为modCount，用于记录集合的修改次数 public boolean hasNext() &#123; return cursor != size;// 判断遍历是否结束 &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification();// 检查是否触发fail-fast机制 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; ... final void checkForComodification() &#123; if (modCount != expectedModCount) // expectedModCount在初始化后并未发生改变，那么如果modCount发生改变，就会抛出异常 throw new ConcurrentModificationException(); &#125;&#125; 通过分析迭代器源码可以发现，迭代器的checkForComodification方法是判断是否要触发fail-fast机制的关键。 在checkForComodification方法中可以看到，是否要抛出异常在于modCount是否发生改变。 查看ArrayList源码，发现modCount的改变发生在对集合修改中，比如add操作。 所以当在使用迭代器遍历集合时，如果同时对集合进行了修改，导致modCount发生改变，就会触发fail-fast机制，抛出异常。 5.1.3 解决有两种解决方式： 使用迭代器提供的方法：为了避免触发fail-fast机制，在迭代集合时，需要使用迭代器提供的修改方法修改集合。 使用线程安全的集合类：也可以使用线程安全的集合类，使用CopyOnWriteArrayList代替ArrayList，使用ConcerrentHashMap代替HashMap。 5.2 安全失败机制安全失败机制，即fail-safe机制，在集合的克隆对象上进行遍历，对集合的修改不会影响遍历操作。 在java.util.concurrent包下的集合类都是安全失败的，可以在多线程下并发使用并发修改，常见的的使用fail-safe方式遍历的容器有CopyOnWriteArrayList和ConcerrentHashMap等。 基于克隆对象的遍历避免了在修改集合时抛出ConcurrentModificationException异常，但同样导致遍历时不能访问修改后的内容。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"异常","slug":"D00-后端/D01-Java/001-基础/012-异常","date":"2025-04-28T03:34:13.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250428/113413/","permalink":"https://momashanhe.com/posts/20250428/113413/","excerpt":"摘要：本文学习了如何处理代码中的异常。","text":"摘要：本文学习了如何处理代码中的异常。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 定义异常是指在运行时期发生的不正常情况。 如果不对异常进行正确的处理，则可能导致程序的中断执行，造成不必要的损失，所以在程序的设计中必须要考虑各种异常的发生，并正确的做好相应的处理，这样才能保证程序正常的执行。 2 分类异常使用Exception类表示，其父类Throwable有两个子类： Exception是人为造成的错误，是可以避免和处理的错误。又分为ChickException受检异常和RuntimeException非受检异常。 Error是指严重的错误，比如内存不足，是无法避免和解决的致命错误。 2.1 受检异常（CheckedException）也称为编译异常，是指编译时被编译器检出的异常，在编译时就必须处理的异常。 常见情况： ClassNotFoundException：类未找到异常，未正确加载类导致的异常，一般发生在加载类的代码中。 SQLException：数据库异常，一般会发生在和数据库建立连接，或者对返回结果进行处理的时候。 IOException：文件异常，一般在读写数据的时候会出现这种问题。 FileNotFoundException：文件不存在异常，属于IOException的子类，一般在读取文件的时候会产生异常，需要进行异常处理。 2.2 非受检异常（RuntimeException）也称为运行时异常，是指在程序运行时出现的异常，编译时不会提示异常，所以在编译时不用处理，系统会默认打印到日志里。 常见情况： NullPointerException：空指针异常，最为常见的一种异常，获取值为null的对象的属性，或者通过null的对象调用了方法。 ArrayIndexOutOfBoundsException：数组下标越界异常，获取数组的值的时候，尝试获取不在下标范围内的下标的值。 ClassCastException：类型转换异常，尝试将两个类进行强制转换时有可能会报这个异常。 ArithmeticException：算术异常，进行数学运算时会发生的异常。 NumberFormatException：数字转换异常，尝试将非数字的数据类型转换为数字类型时，会报这种错误。 3 处理3.1 捕获异常如果需要处理异常，必须先对异常进行捕获，然后再对异常情况进行处理。 可以使用try和catch关键字对异常进行捕获，还可以使用finally保证即便在出现异常后仍能执行操作： try语句块包括的是可能会发生异常的代码段，执行时可能会有一种或者多种异常发生。当有异常发生时，会交给catch处理，如果没有发生异常，则略过catch语句块。 catch语句块里需要的参数是某种异常类型，一个try代码块可能有一个或者多个catch代码块，以便对不同的异常捕获处理。 finally语句块为异常代码提供必要的处理，只要程序在执行，无论发生了什么，最后都会执行finally里的代码。 示例： java1234567891011121314public void readFile(String name) &#123; FileReader fr = null; try &#123; fr = new FileReader(new File(name)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; throw关键字可以在catch到相应类型的异常后，将异常重新抛出，交由上一级调用的代码处理。 示例： java1234567public void readFile(String name) &#123; try &#123; System.out.println(name.length()); &#125; catch (NullPointerException e) &#123; throw e; &#125;&#125; 3.2 抛出异常如果不想捕获和处理出现的异常，可以使用throws关键字把产生的异常抛出，交给调用方法的上一级代码处理。 示例： java1234public void readFile(String name) throws IOException &#123; FileReader fr = new FileReader(new File(name)); fr.close();&#125; 如果在catch捕获之后，使用throw抛出了受检异常，同样需要使用throws关键字进行抛出处理。 示例： java12345678public void readFile(String name) throws IOException &#123; try &#123; FileReader fr = new FileReader(new File(name)); fr.close(); &#125; catch (IOException e) &#123; throw e; &#125;&#125; 4 自定义异常4.1 创建异常命名规则为XxxException，继承自Exception类或者其子类。 定义自定义异常的有参构造方法，调用父类的有参构造方法。 4.2 使用异常使用throw关键字，调用自定义异常的构造方法，传入异常信息，实现抛出自定义异常。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"日期时间","slug":"D00-后端/D01-Java/001-基础/011-日期时间","date":"2025-04-27T05:23:51.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250427/132351/","permalink":"https://momashanhe.com/posts/20250427/132351/","excerpt":"摘要：本文学习了如何使用和格式化日期时间。","text":"摘要：本文学习了如何使用和格式化日期时间。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 说明从JDK1.8开始，可以使用新的日期时间API来进一步加强对日期时间的处理。 在旧版的API中存在诸多问题： 线程不安全，如果两个线程同时操作同一个java.util.Calendar类的对象，可能会导致不可预测的行为。 设计不合理，在java.util和java.sql的包中都有日期类，并且两个包存在类名相同的类，但是却在java.text包中定义用于格式化和解析的类。 时区处理麻烦，在处理不同语言和地区的日期格式时不够灵活。 新API基于ISO标准日历系统，所有类都在java.time包下，是不可变类型而且线程安全。 2 使用2.1 LocalDate2.1.1 获取当前日期新版： java12LocalDate date = LocalDate.now();System.out.println(date);// 2025-05-02 旧版： java12Date date = new Date();System.out.println(date);// Fri May 02 11:24:22 CST 2025 2.1.2 获取特定日期新版： java12LocalDate date = LocalDate.of(2025, 05, 02);System.out.println(date);// 2025-05-02 旧版： java1234Calendar cal = Calendar.getInstance();cal.set(2025, Calendar.MAY, 02);Date date = cal.getTime();System.out.println(date);// Fri May 02 11:25:14 CST 2025 2.1.3 日期加减操作新版： java123LocalDate date = LocalDate.now();date = date.plusYears(1);System.out.println(date);// 2026-05-02 旧版： java1234Calendar cal = Calendar.getInstance();cal.add(Calendar.YEAR, 1);Date date = cal.getTime();System.out.println(date);// Sat May 02 11:26:47 CST 2026 2.2 LocalTime2.2.1 获取当前时间新版： java12LocalTime time = LocalTime.now();System.out.println(time);// 11:27:28.161 旧版： java12345Calendar cal = Calendar.getInstance();int hour = cal.get(Calendar.HOUR_OF_DAY);int minute = cal.get(Calendar.MINUTE);int second = cal.get(Calendar.SECOND);System.out.println(hour + &quot;:&quot; + minute + &quot;:&quot; + second);// 11:28:15 2.2.2 获取特定时间新版： java12LocalTime time = LocalTime.of(11, 28, 59);System.out.println(time);// 11:28:59 旧版： java123456Calendar cal = Calendar.getInstance();cal.set(Calendar.HOUR_OF_DAY, 11);cal.set(Calendar.MINUTE, 28);cal.set(Calendar.SECOND, 59);Date time = cal.getTime();System.out.println(time);// Fri May 02 11:28:59 CST 2025 2.2.3 时间加减操作新版： java123LocalTime time = LocalTime.now();time = time.plusHours(1);System.out.println(time);// 12:30:09.575 旧版： java1234Calendar cal = Calendar.getInstance();cal.add(Calendar.HOUR, 1);Date time = cal.getTime();System.out.println(time);// Fri May 02 12:30:29 CST 2025 2.3 LocalDateTime2.3.1 获取当前日期时间新版： java12LocalDateTime dateTime = LocalDateTime.now();System.out.println(dateTime);// 2025-05-02T11:31:34.928 旧版： java12Date dateTime = new Date();System.out.println(datdateTimee);// Fri May 02 11:32:06 CST 2025 2.3.2 获取特定日期时间新版： java1234LocalDate date = LocalDate.of(2025, 05, 02);LocalTime time = LocalTime.of(11, 32, 59);LocalDateTime dateTime = LocalDateTime.of(date, time);System.out.println(dateTime);// 2025-05-02T11:32:59 旧版： java1234567Calendar cal = Calendar.getInstance();cal.set(2025, Calendar.MAY, 02);cal.set(Calendar.HOUR_OF_DAY, 11);cal.set(Calendar.MINUTE, 32);cal.set(Calendar.SECOND, 59);Date dateTime = cal.getTime();System.out.println(dateTime);// Fri May 02 11:32:59 CST 2025 2.3.3 日期时间加减操作新版： java1234LocalDateTime dateTime = LocalDateTime.now();dateTime = dateTime.plusMonths(1);dateTime = dateTime.plusMinutes(1);System.out.println(dateTime);// 2025-06-02T11:34:17.008 旧版： java12345Calendar cal = Calendar.getInstance();cal.add(Calendar.MONTH, 1);cal.add(Calendar.MINUTE, 1);Date dateTime = cal.getTime();System.out.println(dateTime);// Mon Jun 02 11:34:35 CST 2025 2.4 ZonedDateTime2.4.1 获取指定时区的当前日期时间新版： java123ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);ZonedDateTime zonedDateTime = ZonedDateTime.now(zoneId);System.out.println(zonedDateTime);// 2025-05-02T11:35:03.895+08:00[Asia/Shanghai] 旧版： java123456Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));Date dateTime = cal.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss Z&quot;);TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;);sdf.setTimeZone(timeZone);System.out.println(sdf.format(dateTime));// 2025-05-02 11:35:22 +0800 2.4.2 获取指定时区的特定日期时间新版： java1234LocalDateTime localDateTime = LocalDateTime.of(2025, 05, 02, 11, 35, 59);ZoneId zoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, zoneId);System.out.println(zonedDateTime);// 2025-05-02T11:35:59+08:00[Asia/Shanghai] 旧版： java1234567891011Calendar cal = Calendar.getInstance();cal.set(2025, Calendar.MAY, 02);cal.set(Calendar.HOUR_OF_DAY, 11);cal.set(Calendar.MINUTE, 35);cal.set(Calendar.SECOND, 59);TimeZone timeZone = TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;);cal.setTimeZone(timeZone);Date dateTime = cal.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss Z&quot;);sdf.setTimeZone(timeZone);System.out.println(sdf.format(dateTime));// 2025-05-02 11:35:59 +0800 3 格式化3.1 参数说明格式化参数说明： 字母序列 描述 示例 y 一位数或两位数的年份。 0 - 99 yy 两位数的年份。 00 - 99 yyyy 四位数的年份。 0099 2000 YYYY 四位数的年份，指本周的年份。很少用到。 0099 2000 M 一位数或两位数的月份。 1 - 12 MM 两位数的月份。 01 - 12 MMM 当前语言环境下月份的缩写。 Jan - Dec MMMM 当前语言环境下月份的全称。 January - December d 一个月中一位数或两位数的日期。 1 - 31 dd 一个月中两位数的日期。 01 - 31 DDD 一年中三位数的日期。 001 - 366 EEE 当前语言环境下一周中的日期缩写。 Mon - Sun EEEE 当前语言环境下一周中的日期全称。 Monday - Sunday a 表示AM或PM。 AM PM h 12小时制中一位数或两位数的小时数。 1 - 12 hh 12小时制中两位数的小时数。 01 - 12 H 24小时制中一位数或两位数的小时数。 0 - 23 HH 24小时制中两位数的小时数。 00 - 23 m 一小时中一位数或两位数的分钟数。 0 - 59 mm 一小时中两位数的分钟数。 00 - 59 s 一分钟中一位数或两位数的秒数。 0 - 59 ss 一分钟中两位数的秒数。 00 - 59 S 一位数、两位数或三位数的毫秒数。 0 - 999 SSS 三位数的毫秒数。 000 - 999 z或zzz 三个字母的时区缩写。 EST CST Z 相对于GMT的时区。 -0500 3.2 对象转字符串新版： java123LocalDateTime dateTime = LocalDateTime.now();DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(dateTime.format(formatter));// 2025-05-02 11:36:36 旧版： java123Date date = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(date));// 2025-05-02 11:37:08 3.3 字符串转对象新版： java123DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);LocalDateTime dateTime = LocalDateTime.parse(&quot;2025-05-02 11:37:59&quot;, formatter);System.out.println(dateTime);// 2025-05-02T11:37:59 旧版： java1234567SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);try &#123; Date date = sdf.parse(&quot;2025-05-02 11:37:59&quot;); System.out.println(date);// Fri May 02 11:37:59 CST 2025&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; 4 计算间隔4.1 计算日期间隔示例： java123456LocalDate startDate = LocalDate.of(2024, 04, 01);LocalDate endDate = LocalDate.of(2025, 05, 02);Period period = Period.between(startDate, endDate);int years = period.getYears();// 获取年份间隔int months = period.getMonths();// 获取月份间隔int days = period.getDays();// 获取天数间隔 4.2 计算时间间隔示例： java12345LocalDate date = LocalDate.of(2025, 05, 02);LocalDateTime startTime = LocalDateTime.of(date, LocalTime.of(23, 59, 00));LocalDateTime endTime = LocalDateTime.of(date, LocalTime.of(23, 59, 59));Duration duration = Duration.between(startTime, endTime);long seconds = duration.getSeconds();// 获取秒数间隔","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"大数值","slug":"D00-后端/D01-Java/001-基础/010-大数值","date":"2025-04-27T02:22:08.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250427/102208/","permalink":"https://momashanhe.com/posts/20250427/102208/","excerpt":"摘要：本文学习了如何使用大数值处理大整数和高精度浮点数。","text":"摘要：本文学习了如何使用大数值处理大整数和高精度浮点数。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 BigInteger在整数类型里面，byte为8位，short为16位，int为32位，long为64位，这些数值的二进制位数已经固定，能表示的数值大小就有一定的范围限制，因此提供BigInteger类来处理更大的数字。 构造方法： java12// 创建一个具有参数所指定以字符串表示的数值的对象public BigInteger(String val) 常用方法： java1234567891011121314151617181920// 加法运算public BigInteger add(BigInteger val)// 减法运算public BigInteger subtract(BigInteger val)// 乘法运算public BigInteger multiply(BigInteger val)// 除法运算，可能会产生除零异常public BigInteger divide(BigInteger val)// 获取商值和余数组成的数组，初始元素是商值，最终元素是余数public BigInteger[] divideAndRemainder(BigInteger val)// 将BigInteger对象的数值转换成字符串public String toString()// 将BigInteger对象中的值以双精度数返回public double doubleValue()// 将BigInteger对象中的值以单精度数返回public float floatValue()// 将BigInteger对象中的值以长整数返回public long longValue()// 将BigInteger对象中的值以整数返回public int intValue() 示例： java12345678910public void test() &#123; BigInteger a = new BigInteger(&quot;10&quot;); BigInteger b = new BigInteger(&quot;3&quot;); System.out.println(&quot;add &gt;&gt;&gt; &quot; + a.add(b));// add &gt;&gt;&gt; 13 System.out.println(&quot;subtract &gt;&gt;&gt; &quot; + a.subtract(b));// subtract &gt;&gt;&gt; 7 System.out.println(&quot;multiply &gt;&gt;&gt; &quot; + a.multiply(b));// multiply &gt;&gt;&gt; 30 System.out.println(&quot;divide &gt;&gt;&gt; &quot; + a.divide(b));// divide &gt;&gt;&gt; 3 System.out.println(&quot;divideAndRemainder[0] &gt;&gt;&gt; &quot; + a.divideAndRemainder[b](0));// divideAndRemainder[0] &gt;&gt;&gt; 3 System.out.println(&quot;divideAndRemainder[1] &gt;&gt;&gt; &quot; + a.divideAndRemainder[b](1));// divideAndRemainder[1] &gt;&gt;&gt; 1&#125; 2 BigDecimal在使用float和double的时候，可能会出现精度缺失的问题： java123456public void test() &#123; System.out.println(0.2 + 0.1);// 0.30000000000000004 System.out.println(0.3 - 0.1);// 0.19999999999999998 System.out.println(0.2 * 0.1);// 0.020000000000000004 System.out.println(0.3 / 0.1);// 2.9999999999999996&#125; 虽然基本类型提供了float和double类型，但在执行浮点运算的时候，只是提供了一个较为精确的结果，不能用于要求精确度很高的环境中，因此提供了BigDecimal类来保证结果的精确度。 在进行每一步运算时，都会产生一个新的对象，所以在使用BigDecimal做运算时要保存操作后的值。 使用BigDecimal的坏处是性能比double和float差，在处理庞大复杂的运算时尤为明显，因根据实际需求决定使用哪种类型。 构造方法： java123456// 创建一个具有参数所指定整数值的对象public BigDecimal(int val)// 创建一个具有参数所指定双精度值的对象（不建议使用）public BigDecimal(double val)// 创建一个具有参数所指定以字符串表示的数值的对象public BigDecimal(String val) 因为float和double会导致精度缺失的问题，所以不建议使用将double作为参数的构造方法： java12345678public void test() &#123; BigDecimal a = new BigDecimal(2); BigDecimal b = new BigDecimal(2.3); BigDecimal c = new BigDecimal(&quot;2.3&quot;); System.out.println(a);// 2 System.out.println(b);// 2.29999999999999982236431605997495353221893310546875 System.out.println(c);// 2.3&#125; 常用方法： java12345678910111213141516171819202122// 加法运算public BigDecimal add(BigDecimal augend)// 减法运算public BigDecimal subtract(BigDecimal subtrahend)// 乘法运算public BigDecimal multiply(BigDecimal multiplicand)// 除法运算，可能会产生除零异常和不能整除异常public BigDecimal divide(BigDecimal divisor)// 除法运算，可传入精确小数位数scale，和舍入模式roundingModepublic BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)// 获取商值和余数组成的数组，初始元素是商值，最终元素是余数public BigDecimal[] divideAndRemainder(BigDecimal divisor)// 进行舍入操作public BigDecimal setScale(int newScale, int roundingMode)// 将BigDecimal对象的数值转换成字符串public String toString()// 将BigDecimal对象中的值以双精度数返回public double doubleValue()// 将BigDecimal对象中的值以单精度数返回public float floatValue()// 将BigDecimal对象中的值以整数返回public int intValue() 舍入模式： ROUND_UP：向远离零的方向舍入。舍弃非零部分，并将非零舍弃部分相邻的一位数字加一。 ROUND_DOWN：向接近零的方向舍入。舍弃非零部分，同时不会非零舍弃部分相邻的一位数字加一，采取截取行为。 ROUND_CEILING：向正无穷的方向舍入。如果为正数，舍入结果同ROUND_UP一致；如果为负数，舍入结果同ROUND_DOWN一致。 ROUND_FLOOR：向负无穷的方向舍入。如果为正数，舍入结果同ROUND_DOWN一致；如果为负数，舍入结果同ROUND_UP一致。 ROUND_HALF_UP：向最接近的数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式，即四舍五入。 ROUND_HALF_DOWN：向最接近的数字舍入，如果与两个相邻数字的距离相等，则为向下舍入的舍入模式，即五舍六入。 ROUND_UNNECESSARY：断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。 示例： java1234567891011public void test() &#123; BigDecimal a = new BigDecimal(10); BigDecimal b = new BigDecimal(3); System.out.println(&quot;add &gt;&gt;&gt; &quot; + a.add(b));// add &gt;&gt;&gt; 13 System.out.println(&quot;subtract &gt;&gt;&gt; &quot; + a.subtract(b));// subtract &gt;&gt;&gt; 7 System.out.println(&quot;multiply &gt;&gt;&gt; &quot; + a.multiply(b));// multiply &gt;&gt;&gt; 30 // System.out.println(&quot;divide &gt;&gt;&gt; &quot; + a.divide(b));// Non-terminating decimal expansion; no exact representable decimal result. System.out.println(&quot;divide &gt;&gt;&gt; &quot; + a.divide(b, 2, BigDecimal.ROUND_HALF_UP));// divide &gt;&gt;&gt; 3.33 System.out.println(&quot;divideAndRemainder[0] &gt;&gt;&gt; &quot; + a.divideAndRemainder[b](0));// divideAndRemainder[0] &gt;&gt;&gt; 3 System.out.println(&quot;divideAndRemainder[1] &gt;&gt;&gt; &quot; + a.divideAndRemainder[b](1));// divideAndRemainder[1] &gt;&gt;&gt; 1&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"字符串","slug":"D00-后端/D01-Java/001-基础/009-字符串","date":"2025-04-26T07:33:17.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250426/153317/","permalink":"https://momashanhe.com/posts/20250426/153317/","excerpt":"摘要：本文学习了和字符串有关的类库。","text":"摘要：本文学习了和字符串有关的类库。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 String1.1 不可变String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。 String类其实是通过char数组来保存字符串的。 所有对String类的操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何改变都会生成新的对象。 下面代码中对String的改动并不会影响到原有的String字符串： java1234567891011public static void change(String str) &#123; str = str + &quot;def&quot;;&#125;public static void main(String[] args) &#123; String a = &quot;abc&quot;; String b = new String(&quot;abc&quot;); change(a); change(b); System.out.println(&quot;a &gt;&gt;&gt; &quot; + a);// a &gt;&gt;&gt; abc System.out.println(&quot;b &gt;&gt;&gt; &quot; + b);// b &gt;&gt;&gt; abc&#125; 1.2 常量池JVM为了提高性能和减少内存的开销，每当创建字符串常量时，JVM会首先检查字符串常量池。 如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。 如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，同时返回对该实例的引用。 示例： java12String a = &quot;abc&quot;;String b = new String(&quot;abc&quot;); 说明： a保存的是常量池里abc的地址，这是在编译时就能确定的。 b保存的是堆内存里abc的地址，因为字符串都是保存在常量池里的，所以堆内存里保存的也是常量池里abc的地址。因为在编译时是不确定的，所以b保存的地址值是在运行时确定的。 示例： java123456789public void test() &#123; String a = &quot;abc&quot;; String b = &quot;abc&quot;; String c = new String(&quot;abc&quot;); String d = new String(&quot;abc&quot;); System.out.println(a == b);// true System.out.println(a == c);// false System.out.println(c == d);// false&#125; 说明： a和b保存的是常量池里abc的地址，常量池里只有一个abc的地址，所以a == b判断返回true。 c和d保存的是堆内存里abc的地址，通过new创建的对象会有独立的堆内存的地址，所以a == c和c == d判断返回false。 示例： java123456789101112131415public void test() &#123; String a = &quot;abc&quot;; String b = &quot;def&quot;; String c = a + b; String d = a + b; String e = &quot;abc&quot; + &quot;def&quot;; String f = &quot;abcdef&quot;; String g = &quot;abc&quot; + new String(&quot;def&quot;); System.out.println(c == d);// false System.out.println(c == e);// false System.out.println(c == f);// false System.out.println(c == g);// false System.out.println(e == f);// true System.out.println(f == g);// false&#125; 说明： 因为a + b拼接的是变量，在编译期不能确定结果，需要在运行期确定，所以c和d保存的是堆内存里的地址，并且堆内存里的地址都是独立的，所以c == d判断返回false。 因为&quot;abc&quot; + &quot;def&quot;拼接的是字符串，在编译期能确定结果，所以e保存的是常量池里的地址，并且e == f判断返回true。 因为g拼接的是变量，保存的是堆内存里的地址，所以f == g判断返回false。 示例： java123456789public void test() &#123; final String a = &quot;abc&quot;; String b = &quot;abc&quot;; String c = a + &quot;def&quot;; String d = b + &quot;def&quot;; String e = &quot;abcdef&quot;; System.out.println(c == e);// true System.out.println(d == e);// false&#125; 说明： 因为a是被final修饰的常量，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝，存储到常量池中或嵌入到它的字节码流中。 因为a是常量，所以a + &quot;def&quot;在编译期间可以确定，c保存的是常量池里的地址，执行c == e判断为true。 因为b是变量，所以b + &quot;def&quot;在编译期间不能确定，d保存的是堆内存里的地址，执行d == e判断为false。 1.3 拼接编译器每次碰到+拼接的时候，都会创建StringBuilder对象并调用append()方法进行拼接，再调用toString()方法生成新字符串。如果代码中有很多的+操作就会创建很多StringBuilder对象，这种方式对内存是一种浪费。 示例： java123456789public void test() &#123; String a = &quot;abc&quot;; String b = &quot;def&quot;; String c = &quot;abc&quot; + &quot;def&quot;; String d = a + b; String e = &quot;abcdef&quot;; System.out.println(c == e);// true System.out.println(d == e);// false&#125; 字符串对字面量和变量的拼接操作是有区别的： 字符串对字面量的拼接操作&quot;abc&quot; + &quot;def&quot;是在编译期执行的，会将拼接字符串放到常量池中，返回的是常量池的地址。 字符串对变量的拼接操作a + b是在运行期执行的，会将拼接字符串放到堆内存中，返回的是堆内存的地址。 1.4 关于intern()方法使用intern()方法会从字符串常量池中查询与当前字符串相同的字符串，如果存在则返回常量池的地址，如果不存在则在常量池中创建字符串，并更新当前对象保存常量池的地址。 1.4.1 示例一示例： java123456public void test()&#123; String a = new String(&quot;ab&quot;); a.intern(); String b = &quot;ab&quot;; System.out.println(a == b);// false&#125; 说明： 创建a后，在堆内存和常量池创建&quot;ab&quot;字符串，此时a保存的是堆内存的地址。 执行a.intern()方法后，在常量池找到&quot;ab&quot;字符串，不会更新a的引用，所以此时a保存的是堆内存的地址。 创建b后，在常量池找到&quot;ab&quot;字符串，此时b保存的是常量池的地址。 1.4.2 示例二示例： java123456public void test()&#123; String a = new String(&quot;a&quot;) + new String(&quot;b&quot;); a.intern(); String b = &quot;ab&quot;; System.out.println(a == b);// true&#125; 说明： 创建a后，在堆内存和常量池创建&quot;a&quot;和&quot;b&quot;字符串，并且只在堆内存创建拼接的&quot;ab&quot;字符串，此时a保存的是堆内存的地址。 执行a.intern()方法后，在常量池找不到&quot;ab&quot;字符串，在常量池创建字符串，并且更新a的引用，所以此时a保存的是常量池的地址。 创建b后，在常量池找到&quot;ab&quot;字符串，此时b保存的是常量池的地址。 1.4.3 示例三示例： java123456public void test()&#123; String a = new String(&quot;a&quot;) + new String(&quot;b&quot;); String b = &quot;ab&quot;; a.intern(); System.out.println(a == b);// false&#125; 说明： 创建a后，在堆内存和常量池创建&quot;a&quot;和&quot;b&quot;字符串，并且只在堆内存创建拼接的&quot;ab&quot;字符串，此时a保存的是堆内存的地址。 创建b后，在常量池找不到&quot;ab&quot;字符串，在常量池创建字符串，此时b保存的是常量池的地址。 执行a.intern()方法后，在常量池找到&quot;ab&quot;字符串，不会更新a的引用，所以此时a保存的是堆内存的地址。 1.4.4 示例四示例： java123456public void test()&#123; String a = new String(&quot;a&quot;) + new String(&quot;b&quot;); String b = &quot;ab&quot;; a = a.intern(); System.out.println(a == b);// true&#125; 说明： 创建a后，在堆内存和常量池创建&quot;a&quot;和&quot;b&quot;字符串，并且只在堆内存创建拼接的&quot;ab&quot;字符串，此时a保存的是堆内存的地址。 创建b后，在常量池找不到&quot;ab&quot;字符串，在常量池创建字符串，此时b保存的是常量池的地址。 执行a.intern()方法后，在常量池找到&quot;ab&quot;字符串，并且更新a的引用，所以此时a保存的是常量池的地址。 2 StringBuilder构造方法： java1234// 创建一个长度为默认16的char类型的数组public StringBuilder();// 创建一个指定长度的char类型的数组public StringBuilder(int capacity); 常用方法： java12345678// 追加内容public StringBuilder append(String str);// 删除指定位置的内容public StringBuilder delete(int start, int end);// 把指定位置的字符串替换为传入的字符串public StringBuilder replace(int start, int end, String str);// 在指定位置插入传入的字符串public StringBuilder insert(int offset, String str); 3 StringBuffer构造方法： java1234// 创建一个长度为默认16的char类型的数组public StringBuffer();// 创建一个指定长度的char类型的数组public StringBuffer(int capacity); 常用方法： java12345678// 追加内容public synchronized StringBuffer append(String str);// 删除指定位置的内容public synchronized StringBuffer delete(int start, int end);// 把指定位置的字符串替换为传入的字符串public synchronized StringBuffer replace(int start, int end, String str);// 在指定位置插入传入的字符串public synchronized StringBuffer insert(int offset, String str); 4 比较4.1 可变与不可变String是不可变字符串对象。 StringBuilder和StringBuffer是可变字符串对象，其内部的字符数组长度可变。 4.2 是否多线程安全String中的对象是不可变的，也就可以理解为常量，显然线程安全。 StringBuffer中的方法大都采用了synchronized关键字进行修饰，是线程安全的。 StringBuilder没有synchronized关键字修饰，是非线程安全的。 4.3 执行效率执行效率从高到低排序是StringBuilder &gt; StringBuffer &gt; String顺序。 应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用String这种形式。 当字符串相加操作较多的情况下，如果不需要保证线程安全，建议使用StringBuilder这种形式，执行效率会高一些。 当字符串相加操作较多的情况下，如果需要保证线程安全，建议使用StringBuffer这种形式。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"包装类","slug":"D00-后端/D01-Java/001-基础/008-包装类","date":"2025-04-25T23:46:32.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250426/074632/","permalink":"https://momashanhe.com/posts/20250426/074632/","excerpt":"摘要：本文学习了和数据类型有关的包装类，包括装箱和拆箱，以及与字符串的转换。","text":"摘要：本文学习了和数据类型有关的包装类，包括装箱和拆箱，以及与字符串的转换。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据。 分类： 基本类型 大小 包装类 byte 8bit Byte short 16bit Short int 32bit Integer long 64bit Long float 32bit Float double 64bit Double char 16bit Character boolean / Boolean 2 装箱和拆箱2.1 装箱装箱就是根据数据创建对应的包装对象。 JDK1.5之后提供了自动装箱的机制： java12Integer a = new Integer(10);Integer b = 10;// 自动装箱 2.2 拆箱拆箱就是将包装类转换为基本数据类型。 JDK1.5之后提供了自动拆箱的机制： java12int c = a.intValue();int d = b;// 自动拆箱 3 和字符串的转换3.1 包装类或基本类型转字符串调用包装类的toString()方法。 调用String类的valueOf()方法。 也可以直接拼接空字符串，基本类型会自动转为字符串，包装类会自动调用toString()方法转为字符串。 3.2 字符串转包装类或基本类型调用包装类的valueOf()方法或者parseXxx()方法。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"枚举","slug":"D00-后端/D01-Java/001-基础/007-枚举","date":"2025-04-25T12:09:53.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250425/200953/","permalink":"https://momashanhe.com/posts/20250425/200953/","excerpt":"摘要：本文学习了枚举的概念和使用。","text":"摘要：本文学习了枚举的概念和使用。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介从JDK1.5开始，增加了枚举（Enumeration）类型，允许定义一组固定的常量值。 使用枚举类可以弥补常量的以下几个缺陷： 类型不安全。如果需要传入int类型的性别，可以传入int类型的任意值。但如果需要传入枚举类型的性别，就只能传入枚举类中包含的对象。 没有命名空间。枚举类可以使用Sex作为前缀，这样其他开发者会知道这个枚举代表性别。 2 说明枚举类默认继承Enum类，而不是Object类，因此枚举类不能显示继承其他父类。 使用enum定义的非抽象的枚举类默认使用final修饰，不能被继承。使用enum定义的抽象的枚举类默认使用abstract修饰，可以被继承。 枚举类的构造器默认并且只能使用private访问控制符，如果强制指定其他的访问控制符会报错。 枚举类的所有实例必须在枚举类的第一行显示列出，否则这个枚举类永远都不可能产生实例。列出的这些实例，系统会自动给它们加上public static final修饰。枚举类的实例以逗号分隔，分号结束，这些列出的枚举值代表了该枚举类的所有可能的实例。 3 使用当switch控制表达式使用枚举类型时，后面case表达式中的值可以直接使用枚举值的名字。 创建枚举类： java123public enum SexEnum &#123; FEMALE, MALE;&#125; 使用枚举类： java123456789101112public void test(SexEnum sex) &#123; switch (sex) &#123; case FEMALE: System.out.println(&quot;性别女&quot;); break; case MALE: System.out.println(&quot;性别男&quot;); break; default: break; &#125;&#125; 获取枚举类所有实例： java123456public void test() &#123; SexEnum[] values = SexEnum.values(); for (SexEnum sex : values) &#123; System.out.println(sex); &#125;&#125; 4 成员枚举类是一种特殊的类，它一样可以有自己的成员变量、方法，可以有自己的构造器，也可以实现一个或多个接口，但不能继承其他的类。 枚举类的每个实例的成员变量的值是不能改变的，而且不需要使用修饰符修饰。 所有成员变量都使用final修饰，必须使用下面三种方法为成员变量指定初始值： 在构造器里为这些成员变量指定初始值。 在定义成员变量时指定默认值。 在初始化块中指定初始值。 实际上，后面两种方式并不常用。所以，应该为枚举类显示定义带参数的构造器，列举枚举值时就传入对应的参数。 示例： java12345678910111213public enum SexEnum &#123; FEMALE(0), MALE(1); int sex; private SexEnum(int sex) &#123; this.sex = sex; &#125; public void showSex() &#123; System.out.println(sex); &#125;&#125; 在第一行列出所有枚举值时，实际上就是调用了构造器创建枚举类对象，只是这里不需要使用new关键字，也无需显示调用构造器罢了。 如果在定义SexEnum时，没有传入参数，甚至没有使用括号，那么使用的就是SexEnum里默认的无参构造器。 5 实现接口如果枚举类实现了接口，可以给每个实例提供不同的实现方式。 定义一个接口： java123public interface Feature &#123; public void showFeature();&#125; 5.1 普通枚举类由枚举类来实现接口里的方法，每个枚举类的实例调用的都是同一个方法： java123456789101112131415161718public enum SexEnum implements Feature &#123; FEMALE(0), MALE(1); int sex; private SexEnum(int sex) &#123; this.sex = sex; &#125; public void showSex() &#123; System.out.println(sex); &#125; @Override public void showFeature() &#123; System.out.println(&quot;性别&quot;); &#125;&#125; 当每个枚举实例分别实现方法时，在枚举实例调用方法时就会呈现出不同的行为方式： java123456789101112131415161718192021222324public enum SexEnum implements Feature &#123; FEMALE(0) &#123; @Override public void showFeature() &#123; System.out.println(&quot;性别女&quot;); &#125; &#125;, MALE(1) &#123; @Override public void showFeature() &#123; System.out.println(&quot;性别男&quot;); &#125; &#125;; int sex; private SexEnum(int sex) &#123; this.sex = sex; &#125; public void showSex() &#123; System.out.println(sex); &#125;&#125; 上面这种在枚举值后面紧跟花括号的语法其实是创建匿名内部类的语法，花括号就是类体部分。当创建枚举类的实例时，并不是直接创建，而是相当于创建匿名子类的实例。 5.2 抽象枚举类抽象枚举类就是在枚举类里定义一个抽象方法，让每个枚举类的实例分别去实现： java1234567891011121314151617181920212223242526public enum SexEnum &#123; FEMALE(0) &#123; @Override public void showFeature() &#123; System.out.println(&quot;性别女&quot;); &#125; &#125;, MALE(1) &#123; @Override public void showFeature() &#123; System.out.println(&quot;性别男&quot;); &#125; &#125;; int sex; private SexEnum(int sex) &#123; this.sex = sex; &#125; public void showSex() &#123; System.out.println(sex); &#125; public abstract void showFeature();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"注解","slug":"D00-后端/D01-Java/001-基础/006-注解","date":"2025-04-25T07:28:17.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250425/152817/","permalink":"https://momashanhe.com/posts/20250425/152817/","excerpt":"摘要：本文学习了注解的概念和使用。","text":"摘要：本文学习了注解的概念和使用。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 定义从JDK1.5开始，增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。 2 分类按运行机制分类： 源码注解，这种注解只在源码阶段存在存在。 编译注解，注解不但在源码中存在，而且在class文件中也存在，JDK自带的注解就是属于这种类型的注解。 运行时注解，即便到在运行阶段仍然起作用的注解，第三方提供的注解大部分是属于这种类型的注解。 按来源分类： JDK自带的注解。 第三方的注解。 自定义注解。 按功能分类： 普通注解，对程序和代码进行标注的注解。 元注解，对注解标记的注解。 3 常见注解JDK自带注解： @Override：表示覆盖或重写父类的方法。 @Deprecated：表示该方法已经过时了，不建议使用。 @SuppressWarnings：表示忽略指定警告。 第三方注解： @AutoWired：Spring框架中的注解。 自定义注解： 开发者自己定义的注解。 4 元注解元注解的作用就是负责注解其他注解。 4.1 @Target用于描述注解的使用范围，即被描述的注解可以用在什么地方。 取值： ElementType.PACKAGE：包。 ElementType.TYPE：接口、类、枚举。 ElementType.FIELD：字段、枚举的常量。 ElementType.METHOD：方法。 ElementType.PARAMETER：方法参数。 ElementType.CONSTRUCTOR：构造函数。 ElementType.LOCAL_VARIABLE：局部变量。 ElementType.ANNOTATION_TYPE：注解。 4.2 @Retention用于描述注解的生命周期，即被描述的注解在什么范围内有效。 取值： RetentionPolicy.SOURCE：注解仅存在于源码中，在class字节码文件中不包含。 RetentionPolicy.CLASS：默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得。 RetentionPolicy.RUNTIME：注解会在class字节码文件中存在，在运行时可以通过反射获取到。 4.3 @Inherited用于说明这个注解是可以被继承的。如果父类使用了@Inherited注解，则其子类也会使用这个注解。 4.4 @Documented用于描述注解可以被放到文档里。 5 自定义注解使用@interface自定义注解，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。 自定义注解的每一个方法实际上是声明了一个配置参数，方法的名称就是参数的名称，返回值类型就是参数的类型，并且只能是基本类型&#x2F;Class&#x2F;String&#x2F;Enum。 可以通过default来声明参数的默认值。 语法： java1234public @interface 注解名称 &#123; // 若干参数 修饰符 类型 名称() default 默认值;&#125; 说明： 修饰符：只能用public或默认（default）这两个访问权限修饰符。 类型：只能用byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、Annotations等数据类型，以及这一些类型的数组。 名称：可以自定义，如果只有一个参数成员，最好把参数名称设为value，不要忘了后加小括号。 默认值：注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，通常使用空字符串或0作为默认值。 编写自定义注解： java123456789@Target(&#123;ElementType.METHOD, ElementType.PACKAGE, ElementType.TYPE&#125;)@Retention(RetentionPolicy.SOURCE)@Documented@Inheritedpublic @interface TestAnnotation &#123; public String value() default &quot;&quot;; public String name(); public int age();&#125; 使用自定义注解： java123456@TestAnnotation(age = 0, name = &quot;&quot;)public class Demo &#123; public static void main(String[] args) &#123; System.out.println(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"面向对象","slug":"D00-后端/D01-Java/001-基础/005-面向对象","date":"2025-04-25T01:22:23.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250425/092223/","permalink":"https://momashanhe.com/posts/20250425/092223/","excerpt":"摘要：本文学习了面向对象的一些基础知识，介绍了类和对象的概念，以及如何使用接口和导入包。","text":"摘要：本文学习了面向对象的一些基础知识，介绍了类和对象的概念，以及如何使用接口和导入包。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 简介面向对象编程是一种对现实世界建立计算机模型的一种编程方法。简称OOP（Object Oriented Programming）。 面向对象是一种编程思想，是一种思考问题的思维方式。 在现实世界中，当提到动物这个概念，实际上它是一个抽象的概念，而具体动物是指老虎，狮子，大象等等。 在对应的计算机模型中，把动物这种抽象的概念称之为Class，也就是类。而那些具体的对象称之为实例，并且用不同变量标识不同的实例。 面向过程与面向对象都是编写程序的一种思维方式： 面向过程：遇到一件事时，先做什么，再做什么，然后一步步实现的过程。 面向对象：遇到一件事时，先思考有哪些类和对象，然后思考类和对象里有哪些属性和方法，然后分析类和类之间的关系，最后一群对象合力能把事就好。 2 类2.1 定义类是一组具有相同特征的对象的集合，是一个抽象的概念。类中定义了这一类对象所具有的属性和方法。 定义类： java1234567891011public class 类名 &#123; 属性类型 属性名 = 属性值; ... public void 方法名() &#123; 方法体; &#125; ... public static void main(String[] args) &#123; 主函数方法体; &#125;&#125; 对象是一个类具体的某一个实例，是看得见摸得着的东西。世间存在的一切都可以看做是对象。 定义对象： java1类名 对象名 = new 类名(); 2.2 成员2.2.1 属性属性称为成员变量，一般来讲不用赋值，因为有默认值，显式赋值会导致所有由此类创建对象都是此值。 默认值： Boolean类型成员变量的默认值是false。 Int类型成员变量的默认值是0。 Double类型成员变量的默认值是0.0。 String类型成员变量的默认值是null。 Char类型成员变量的默认值是\\u0000。 2.2.1.1 局部变量定义：方法中，语句块中，方法参数中定义的变量。 作用域：方法内部，语句块内部。其他方法，其他代码块不能访问。 生命周期：方法或者语句块调用开始到方法或者语句块调用结束。 共享性：方法内部，语句块内部共享。对于多个线程来讲，变量初始化到自己的方法区中，主内存不存在该变量，每个线程在访问方法时使用各自的局部变量，所以线程之间不共享，也就不存在线程安全问题。 访问修饰符：不能被修饰，因为局部变量的作用域本身就比最小的访问权限还要小，所以即便修饰了也不具备相应的访问权限。 默认值：没有默认值，被声明后必须经过初始化才可以使用。 值传递：局部变量解决了方法内部，语句块内部行之间的变量传递问题。如果没有局部变量，不知道行之间怎么传递变量。 2.2.1.2 实例变量定义：类中定义的变量。又称为成员属性，是描述对象状态的数据，是类中很重要的组成成分。 作用域：同一个类的实例对象内部，不同的实例对象直接不共享。 生命周期：伴随整个类实例始终，变量在创建类实例时被创建，在实例对象被销毁的时候销毁。 共享性：在同一个类实例内部共享，不同实例对象不共享。对于多线程来讲，变量被初始化到主内存中，每个线程拷贝变量到工作内存中进行操作，如果使用的是同一个实例对象的变量，线程之间共享一个主内存变量，存在线程安全问题。 访问修饰符：可以被修饰。 默认值：有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定。 值传递：成员变量解决了类实例各方法之间的变量传递。如果没有成员变量，方法之间变量传递只能靠参数。 2.2.1.3 全局变量定义：全局变量在Java中也可以叫静态变量，通过static关键字修饰。全局变量也称为类变量、静态变量。 作用域：整个类，在每个实例对象之间共享。 生命周期：伴随整个类始终，变量在第一次使用该类时被创建。 共享性：在整个类共享，并且在不同实例对象之间共享。对于多线程来讲，变量被初始化到主内存中，每个线程拷贝变量到工作内存中进行操作，线程之间共享一个主内存变量，存在线程安全问题。 访问修饰符：可以被修饰。 默认值：有默认值，和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 值传递：全局变量解决了类之间的变量传递。如果没有全局变量，类之间变量只能靠构造实例的时候相互传递。 2.2.2 方法2.2.2.1 定义方法就是用来完成解决某件事情或实现某个功能的办法。 语法： java1234修饰符 返回值类型 方法名(参数类型 参数名, ... , 参数类型 参数名) &#123; 执行语句; return 返回值;&#125; 说明： 修饰符：方法的修饰符比较多，有对访问权限进行限定的，有静态修饰符static，还有最终修饰符final等，这些修饰符在后面的学习过程中会逐步介绍。 返回值类型：用于限定方法返回值的数据类型，返回给调用方，返回类型可以是任意类型。根据是否需要返回值： 如果需要返回值，则需要写一个返回类型，并且return后的返回值需要和返回类型一致。 如果不需要返回值，则写void，方法结束的时候不需要写return和返回值。 方法名：功能块的名字，命名规则和变量命名规则一样。 参数类型：参数类型用于限定调用方法时传入参数的数据类型，可以为任意类型，参数类型和返回类型没有任何关系。 参数名：参数名是一个变量，用于接收调用方法时传入的数据。 参数：参数类型和参数名组成参数，参数可以有多个，中间用逗号隔开。 执行语句：里面可以写任何逻辑语句，表示的是此方法的具体功能。 返回值：返回值是被return语句返回的值，该值会返回给调用者。 2.2.2.2 调用方法的调用可以通过如下方式调用： java1类型 变量名 = 对象实例.方法名(参数); 根据不同情况调用方法： 调用情况 调用语法 是否有参数 有参数：类型 变量名 = 对象实例.方法名(参数, 参数); 无参数：类型 变量名 = 对象实例.方法名(); 是否有返回值 有返回值：类型 变量名 = 对象实例.方法名(参数); 无返回值：对象实例.方法名(参数); 是否在当前类中使用 在当前类中使用：类型 变量名 = 方法名(参数); 在其他类中使用：类型 变量名 = 对象实例.方法名(参数); 被static修饰的方法：类型 变量名 = 类名.方法名(参数); 2.2.2.3 参数传递参数传递是指，调用方法时，将实参的值传递给形参过程。 形参和实参： 定义方法时，参数列表中的变量，称为形式参数。 调用方法时，传入给方法的数值，称为实际参数。 入参类型： 当调用方法时，如果传入的数值为基本数据类型（包含String类型），形式参数的改变对实际参数不影响。 当调用方法时，如果传入的数值为引用数据类型（String类型除外），形式参数的改变对实际参数有影响。 2.2.2.4 重载重载（overload）是在同一个类中，方法名相同，参数列表不同。 所谓的参数列表不同，主要是参数的个数或者类型，只要有一处不同就可以构成方法的重载了。 2.2.2.5 重写重写（override）是在子类中重新定义了父类的方法，必须有相同的方法名、参数列表、返回类型。 重写的方法不能拥有比父类的方法更严格的访问控制权限。 构造方法不能被继承，因此不能被重写，在子类中只能通过super关键字调用父类的构造方法。 2.2.3 构造方法构造方法是类用于创建对象的一个特殊的方法，当类创建对象时，就会调用类的构造方法。 语法： java123修饰符 类名(参数列表) &#123; 方法体;&#125; 调用： java12new 类名();new 类名(参数); 说明： 构造方法没有返回类型，也不能使用void关键字。 构造方法的方法名必须和类名一致。 如果在类中没有定义构造方法，那么编译器会提供默认的构造方法，默认的构造方法没有参数列表，也没有方法体。 如果在类中定义了构造方法，那么编译器就不会提供默认的构造方法。 构造方法必须使用new关键字进行调用。 2.2.4 初始化块初始化块分为静态初始化块和普通初始化块，优先于构造方法执行，经常执行初始化信息。 静态初始化块和普通初始化块都可以有多个，都可以写任何逻辑语句，不能定义方法。 执行顺序： 静态成员变量和静态初始化块的执行顺序由定义位置决定，从上往下执行。 成员变量和初始化块的执行顺序由定义的位置决定，从上往下执行。 最后执行构造方法。 普通初始化块和静态初始化块的区别： 普通初始化块能执行多次，静态初始化块只执行一次。 普通初始化块实在对象创建后执行，静态初始化块是在类加载时执行。 普通初始化块可以访问普通成员和静态成员，静态成员初始化块只能访问静态成员。 在静态成员初始化块中，可以对定义在代码前的静态成员进行赋值和访问，可以对定义在代码后的静态成员进行赋值，但是不能访问。 2.2.5 内部类定义在一个类体内部的类称为内部类，包含内部类的类称为外部类，其他的类称为外部其他类。 内部类可以创建和外部类同名的成员，默认访问内部类成员，通过Outer.this.成员访问外部类成员。 2.2.5.1 普通内部类特点： 可以直接访问外部类的所有成员。 可以使用访问修饰符。 可以使用普通成员，不能使用静态成员。 外部类访问内部类： java1Inner inner = new Inner(); 外部其他类访问内部类： java12Outer outer = new Outer();Outer.Inner inner = outer.new Inner(); 2.2.5.2 静态内部类特点： 只能访问外部类的静态成员，不能访问普通成员，需要通过创建对象的方式访问外部类普通成员。 可以使用访问修饰符。 可以使用普通成员，可以使用静态成员。 外部类访问内部类： java12Inner inner = new Inner();Inner.静态成员; 外部其他类访问内部类： java12Outer.Inner inner = new Outer.Inner();Outer.Inner.静态成员; 2.2.5.3 局部内部类特点： 可以直接访问外部类的所有成员，能访问当前局部块中的final修饰的变量。 不能使用访问修饰符。 可以使用普通成员，不能使用静态成员。 作用范围只是在定义它的方法内，并且只能在定义之后访问，否则报编译错误。 外部方法访问内部类： java1Inner inner = new Inner(); 2.2.5.4 匿名内部类匿名内部类new 类名()&#123;&#125;;相当于创建了类名的子类对象。 特点： 可以直接访问外部类的所有成员，能访问当前局部块中的final修饰的变量。 不能使用访问修饰符。 可以使用普通成员，不能使用静态成员。 外部类和外部其他类都不能访问匿名内部类。 匿名内部类经常用在方法的实参中，比较简洁： java123new 抽象类或接口() &#123; 重写方法&#125;; 2.2.6 内部接口定义在一个类体内部的接口称为内部接口，也称为嵌套接口。 内部接口不能使用访问修饰符，其访问权限受外部类控制，只有外部类及其成员才能访问内部接口。 内部接口中的方法默认使用public abstract修饰，需要创建内部类实现接口中的方法。 2.3 子类和父类子类使用extends关键字继承父类，类是单继承的，一个子类只能继承一个父类。 2.3.1 表示2.3.1.1 this解决了全局变量和局部变量重名的问题。 代表的是当前类的对象，可以访问属性、方法、构造方法。 语法： java123this.属性名;this.方法名();this(参数); 访问构造方法时，必须放在构造方法中，而且必须放在构造方法的第一句。 在一个构造方法中，不能多次调用其他构造方法。 2.3.1.2 super表示子类中拿到的父类的引用，不是父类的对象。 语法： java123super.属性名;// 访问父类属性super.方法名();// 访问父类方法super(参数);// 访问父类构造方法 访问构造方法时，必须放在构造方法中，而且必须放在构造方法的第一句。 不能与this同时使用。 2.3.2 加载机制从父到子，静态先行。 父类的静态初始化块和静态变量赋值代码，子类的静态初始化块和静态变量赋值代码，父类的初始化块和变量赋值代码，父类的构造器，子类的初始化块和变量赋值代码，子类的构造器。 2.3.3 创建顺序先调用子类的构造方法。 子类中调用父类的构造方法。如果没有显式说明调用父类的哪个构造，则默认是调用父类的无参构造。如果显式说明了，则调用指定的父类的构造。 依次向上递推，一直到最上级。 2.4 三大特性2.4.1 封装封装是指一个类隐藏了对象的属性和实现细节，对自己的数据和方法进行访问权限控制，只允许某些类和对象进行访问和使用，其他的类不能进行访问和使用。 封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。 在一个类的内部，某些代码或某些数据是私有的，不能被外界访问。通过这种方式，类对内部数据提供了不同级别的保护，以防止类中的私有数据被外部程序窃取和改动。 好处： 良好的封装能够减少耦合。耦合，指的是模块间的关联程度，封装可以使模块变得更加独立，降低了耦合度。 封装后的类，在类内部可以自由修改代码，不会影响外部的代码。 对类的成员进行精确的访问控制。 访问控制： public：公共访问权限。属性可以被所有类和对象访问，没有进行封装。 private：私有访问权限。只能在这个类中被访问，对属性和方法进行彻底的封装。 protected：继承访问权限。可以被子类访问，封装的不彻底。 一般来说，如果类中的某个属性不是公有的，而外部程序又需要访问，那么可以提供一个公有的方法，外部程序可以通过调用方法实现对该属性的间接访问。 2.4.2 继承继承是子类可以获得父类的属性和方法，并且可以在不影响父类代码的前提下，在子类里面对继承的方法进行改写，扩展添加父类里面没有的方法。 继承是单继承，一个父类只能有一个子类，一个子类也只能有一个父类。 好处： 子类可以直接使用父类的属性和方法，不需要重复编写代码，提高了代码的可重用性。 特点： Object类是所有类的基类，所有的类都直接或间接继承了Object类，所以具备Object类的方法。 子类不可以继承父类的构造方法，并且子类必须调用父类的构造方法。 子类的构造方法中默认调用父类的无参构造，如果父类没有无参构造，报编译错误。 子类用super调用父类的有参构造方法。 2.4.3 多态多态是指一个方法或一个对象具备多种表现形式。 多态主要变现在两个方面： 引用多态，即对象的向上转型，父类的引用指向子类的对象。 方法多态，即子类重写了父类的方法，子类在调用该方法的时候调用的是子类重写的方法，父类在调用该方法的时候调用的是父类的方法。 如果在子类中扩展了一个父类没有的方法，就不能通过父类的引用创建的子类对象来调用该方法。 多态是运行时行为，不是编译时行为。 继承是多态实现的基础。 方法重写体现了多态，而方法重载并没有体现多态，因为重载没有继承。 2.5 类型转换2.5.1 向上类型转换向上类型转换（自动类型转换）： java1Animal animal = new Dog(); 小类型转换成大类型。 子类创建的实例指向父类的引用。 2.5.2 向下类型转换向下类型转换（强制类型转换）： java1Dog dog = (Dog) new Animal(); 大类型转换成小类型，有可能导致溢出。 子类的引用指向父类的引用。 如果将子类的引用指向父类创建的实例，在编译时不会报错，但是在运行时会报错： java1Dog dog = (Dog) new Animal(); 使用instanceof运算符来解决引用对象的类型，避免类型转换的安全性问题。 作用是测试左边的对象是否是右边的类的实例，返回Boolean类型的数据。 在写程序的时候，如果要进行类型转换，最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。 2.6 修饰符2.6.1 访问修饰符通过访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，隐藏实现细节。 四种访问控制级别： public：对所有类可见。 protected：对当前包可见，以及对子类可见，即使子类在其他包也是可见的。 default：对当前包可见。 private：对当前类可见。 2.6.1.1 public可修饰类、接口、属性、方法、构造方法。 被public修饰的目标能够被所有的类访问，如果是其他包中的类，则需要导入所在的包。 父类中声明为public的方法在子类中也必须为public。 如果一个类使用public修饰，那该类的类名必须与他所在的源文件名相同。一个源文件中有且只有一个public类。 2.6.1.2 protected可修饰属性、方法、构造方法，不能修饰类和接口。 被protected修饰的目标能够被同一个包里的类访问，如果是其他包中的类，只能被其他包中的子类访问。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。 2.6.1.3 default可修饰类、接口、属性、方法、构造方法。 被default修饰的目标只能被同一个包里的类访问。 父类中声明为default的方法，不能在子类中声明为private。 如果没有使用任何修饰符，默认就是default访问控制级别。 2.6.1.4 private可修饰内部类、属性、方法、构造方法，不能修饰普通类和接口。 被声明为private的目标只能被当前类访问。 父类中声明为private的方法，不能被子类重写。 2.6.2 静态修饰符静态修饰符static可修饰内部类、属性、方法、初始化块，不能修饰普通类、接口、构造方法。 说明： 修饰类，其成员被称为静态成员，比如静态属性、静态方法、静态初始化块、静态内部类。 修饰成员，可以直接通过类名调用，比较简单。 修饰方法和初始化块，只能访问静态成员，不能访问非静态成员。 静态成员随着类的加载而加载，静态成员优先于普通成员而加载。只加载一次，普通成员随着对象创建而加载，可以加载多次。 所有对象都共享静态成员。 被static修饰的方法和初始化块中不能使用this或super。 2.6.3 最终修饰符最终修饰符final可修饰类、属性、方法。 说明： 修饰类，不能被继承，也称为太监类、最终类，比如String类就是最终类。 修饰方法，不能被重写，但可以被继承。 修饰局部变量和全局变量，都称为常量，一旦赋值不能更改，保存在常量池。修饰的全局变量声明时必须赋值，要么在声明时，要么在所有构造方法，要么在初始化块。 常量不能更改： 如果常量类型为基本类型，那么常量的值不能更改。 如果常量的类型为引用类型，那么引用的对象不能更改，但对象的属性可以更改。 final和static的相同点： 修饰的方法都只能在本类中被重载，不能被子类重写。 final和static的不同点： 含义不同：static表示该成员要随类加载而加载。final表示该成员不可被修改。 修饰范围不同：static可修饰内部类、属性、方法、初始化块，不可修饰普通类、构造方法。final可修饰类、属性、方法，不可修饰初始化块、构造方法。 2.6.4 抽象修饰符抽象修饰符abstract可以修饰类和方法，但不能用来修饰属性，也不能修饰构造方法。不能和private连用，也不能同final和static连接使用。 说明： 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类。如果子类没有实现父类中所有的抽象方法，那么子类也必须被定义为抽象类。 抽象类中可以有构造方法，创建子类的实例时可能会调用这些构造方法。 与其他修饰符： 抽象方法不能被static修饰符修饰。因为static修饰的方法随类的加载而加载，而此时抽象类没有方法体。 抽象类及抽象方法不能被final修饰符修饰。因为final修饰的类不允许拥有子类，而抽象类允许创建其子类实现抽象方法。 2.7 Lambda表达式2.7.1 简介Lambda表达式也可称为闭包，允许把函数作为一个方法的参数传递进方法中。 JDK1.8之后提供了Lambda表达式，可以使代码变的更加简洁紧凑。 2.7.2 规范语法： java1参数列表 -&gt; 方法体 说明： 如果参数列表有多个值，可以使用小括号包含，如果只有一条，则可以省略小括号。 如果方法体有多条语句，可以使用大括号包含，如果只有一条，则可以省略大括号，如果是return语句，则可以省略return关键字。 2.7.3 使用使用Lambda表达式之前： java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; // 使用匿名内部类实现接口 WorkInterface work = new WorkInterface() &#123; @Override public void doSomething() &#123; System.out.println(&quot;使用匿名内部类执行方法&quot;); &#125; &#125;; // 执行方法 work.doSomething(); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(); &#125;&#125; 使用Lambda表达式之后： java12345678910111213public class Demo &#123; public static void main(String[] args) &#123; // 使用Lambda表达式实现接口 WorkInterface work = () -&gt; System.out.println(&quot;使用Lambda表达式执行方法&quot;); // 执行方法 work.doSomething(); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(); &#125;&#125; 2.7.4 作用域Lambda表达式只能引用标记了final的外层局部变量，不能在Lambda内部修改定义在域外的局部变量，否则会编译错误。 示例： java123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; // 局部变量 final int num = 100; // 使用Lambda表达式实现接口 WorkInterface work = i -&gt; System.out.println(i); // 执行方法，编译报错 work.doSomething(num++); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(int i); &#125;&#125; 在Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 示例： java123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; // 局部变量 final int num = 100; // 使用Lambda表达式实现接口，编译报错 WorkInterface work = num -&gt; System.out.println(num); // 执行方法 work.doSomething(num); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(int i); &#125;&#125; 2.7.5 方法引用方法引用是JDK1.8中提出的用来简化Lambda表达式的一种手段，通过类名和方法名定位静态方法或者实例方法。 2.7.5.1 静态方法引用如果是静态方法引用，使用类名::静态方法名的形式，支持传入参数作为方法入参。 示例： java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; // 使用静态方法引用 WorkInterface work = Demo::sum; // 执行方法 work.doSomething(1, 2); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(int a, int b); &#125; // 定义静态方法 public static void sum(int a, int b) &#123; System.out.println(a + b); &#125;&#125; 2.7.5.2 实例方法引用如果是实例方法引用，使用对象实例::方法名语法执行，支持传入参数作为方法入参。 示例： java1234567891011121314151617181920public class Demo &#123; public static void main(String[] args) &#123; // 创建对象 Demo demo = new Demo(); // 使用实例方法引用 WorkInterface work = demo::sum; // 执行方法 work.doSomething(1, 2); &#125; // 定义内部接口 interface WorkInterface &#123; void doSomething(int a, int b); &#125; // 定义实例方法 public void sum(int a, int b) &#123; System.out.println(a + b); &#125;&#125; 2.7.5.3 构造方法引用如果是构造方法引用，使用类名::new语法执行，支持传入参数作为方法入参。 示例： java123456789101112131415161718public class Demo &#123; public static void main(String[] args) &#123; // 使用构造方法引用 WorkInterface work = Demo::new; // 执行方法 work.doSomething().sum(1, 2);; &#125; // 定义内部接口 interface WorkInterface &#123; Demo doSomething(); &#125; // 定义实例方法 public void sum(int a, int b) &#123; System.out.println(a + b); &#125;&#125; 3 接口3.1 说明接口可以理解成一种特殊的抽象类，定义了一组规范，体现了程序设计的多态和高内聚低偶合的设计思想。 定义接口： java123public interface 接口名 &#123; void 方法名();&#125; 接口不能实例化。 3.2 好处允许多继承、多实现，解决了前面单继承缺陷。 灵活，解耦性高。 3.3 成员不能定义普通变量，只能定义常量，并且只能使用public static final修饰符，可以省略修饰符。 不能定义普通方法，可以定义抽象方法，使用public abstract修饰符，可以省略修饰符。 从JDK1.8开始支持定义默认方法和静态方法： 默认方法：使用default修饰符，非抽象方法，可以拥有方法体。 静态方法：使用static修饰符，非抽象方法，可以拥有方法体。 不能定义构造方法，因为接口不支持实例化。 支持内部类和内部接口。 3.4 关系3.4.1 类对接口的实现类对接口的实现使用implement关键字完成，一个类可以实现多个接口。 语法： java1class A implements B, C &#123; ... &#125; 普通类必须实现里面所有的抽象方法，抽象类不用实现里面所有抽象方法。 实现接口的抽象方法只能使用public修饰符。 3.4.2 接口对接口的继承接口对接口的继承使用extends关键字，一个接口可以继承多个接口。 语法： java1interface A extends B, C &#123; ... &#125; 3.5 函数式接口3.5.1 定义从JDK1.8开始新增函数式接口，在接口里面只能有一个抽象方法，也称为SAM（Single Abstract Method）接口。 示例： java123interface DemoInterface &#123; void demo();&#125; 可以使用@FunctionalInterface注解对接口进行编译级错误检查，当接口不符合函数式接口定义的时候，编译器会报错。 示例： java1234@FunctionalInterfaceinterface DemoInterface &#123; void demo();&#125; 3.5.2 使用函数式接口可以包含默认方法： java123456789101112@FunctionalInterfaceinterface DemoInterface &#123; void demo(); default void defaultRead() &#123; System.out.println(&quot;defaultRead() ...&quot;); &#125; default void defaultWrite() &#123; System.out.println(&quot;defaultWrite() ...&quot;); &#125;&#125; 函数式接口可以包含静态方法 java123456789101112@FunctionalInterfaceinterface DemoInterface &#123; void demo(); static void staticRead() &#123; System.out.println(&quot;staticRead() ...&quot;); &#125; static void staticWrite() &#123; System.out.println(&quot;staticWrite() ...&quot;); &#125;&#125; 函数式接口可以包含Object类的public方法： java12345678910@FunctionalInterfaceinterface DemoInterface &#123; void demo(); @Override public String toString(); @Override public boolean equals(Object obj);&#125; 这些方法对于函数式接口来说，不会被当成抽象方法。虽然是抽象方法，但接口的实现类是Object的子类，会自动实现这些方法。 包含Object类的public方法，其他访问修饰符修饰的方法是不允许在函数式接口里定义的。 3.5.3 内置接口内置的函数式接口放在java.util.function包下，默认在JDK安装路径下的src.zip文件中。 3.5.3.1 Supplier接口没有参数，有返回值，作用是为了产生对象。 示例： java1234@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125; 3.5.3.2 Consumer接口有参数，没有返回值，作用是为了进行某种操作，比如打印操作。 示例： java123456789@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 3.5.3.3 Function接口有参数，有返回值，作用是对参数进行处理并返回。 示例： java123456789101112131415161718@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 3.5.3.4 Predicate接口有参数，有返回值，但返回值是Boolean类型的值，作用是对传入的参数进行某种判断。 示例： java123456789101112131415161718192021222324@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t); default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; 4 包包可以对程序员编写的代码文件进行目录层次的管理，解决了同一个项目中类名重复的问题。 在不同的包下的两个名字相同的两个类，会被编译器看做是不同的两个类。 4.1 命名规则小圆点、数字、下划线、美元符，不能数字开头，不能是关键字。 一般由小写字母和小圆点组成，采用域名倒置的写法。 4.2 声明规则必须在代码的第一行对包进行声明。 使用package关键字进行声明，语法是： java1package 包名; 如果没有声明包，则表示无包名。 一个文件中最多只能有一个包的声明。 4.3 导入规则建议在包的声明下面导入包，实际上是导入包中的某个用到的类。 使用import关键字对包进行导入，语法是： java1import 包名.类名; 如果没有导入在当前类用到的类，那么在使用的时候需要写明用到的类所在的包名和类名，导入之后便可以只写类名。 一个文件中可以有多个导入。 4.4 核心包比较重要的核心包： java.lang：包含一些核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.net：包含执行与网络相关的操作的类和接口。 java.io：包含能提供多种输入&#x2F;输出功能的类。 java.util：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。 java.text：包含了一些格式化相关的类。 java.sql：包含了进行JDBC数据库编程相关的类。 java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.applet：包含applet运行所需的一些类。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"编程基础","slug":"D00-后端/D01-Java/001-基础/004-编程基础","date":"2025-04-24T02:55:21.000Z","updated":"2025-06-21T08:59:55.121Z","comments":true,"path":"posts/20250424/105521/","permalink":"https://momashanhe.com/posts/20250424/105521/","excerpt":"摘要：本文学习了Java编程的基础知识。","text":"摘要：本文学习了Java编程的基础知识。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 注释支持多种注释方式： 行注释：可以注释单行内容，使用//注释从当前位置到行结尾。 块注释：可以注释多行内容，使用/*和*/注释两个符号之间的内容。 文档注释：可以生成文档，使用/**标记文档开始，使用*/标记文档结束，每行开头使用*标记文档内容。 2 命名2.1 标识符为各种变量、方法、类和包等起的名字，统统称之为标识符。 命名规则： 应以字母、下划线、美元符开头，不能以数字开头，不能使用空格或非法的字符，如：#，%，&amp;等。 后跟字母、下划线、美元符、数字。 大小写敏感，长度无限制。 不能使用关键字。 命名约定： 类和接口的首字母大写，比如TestClass。 方法的首字母小写，其余首字母大写，尽量少用下划线，比如setTime。这种命名方法叫做驼峰式命名。 基本数据类型常量的全部字母都大写，字与字之间用下划线分隔，比如SIZE_NAME。对象常量可大小混写，比如Person。 变量可大小写混写，首字母小写，字间分隔符的首字母大写。不用下划线，少用美元符号。 2.2 关键字关键字对编译器有特殊意义，它们用来表示一种数据类型，或则表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数名。 常见关键字： 分类 关键字 说明 保留字 const 其他计算机语言中的关键字，用于修改字段或局部变量的声明，指定字段或局部变量的值是常数，不能被修改。 goto 其他计算机语言中的关键字，指定跳转到标签，找到标签后，程序将处理从下一行开始的命令。 包相关 import 引入包的关键字。 package 定义包的关键字。 访问控制 public 公有的，可跨包使用。 protected 受保护的，只能在当前包内使用。 private 私有的，当前类可用。 异常处理 try 执行有可能抛出异常的代码块。 catch 捕获异常。 throw 抛出一个异常对象。 finally 有没有异常都执行的代码块。 throws 声明一个异常，可能被抛出。 实例相关 new 新建，用于创建类的实例。 this 本类，用于引用当前实例。 super 父类，用于引用当前实例所属类的父类。也成为超类 instanceof 实例，用于确定对象所属的类。 特殊值 true boolean类型的值，表示真。 false boolean类型的值，表示假。 null 空值。 数据类型 byte 字节型的数据。 char 字符型的数据。 boolean 布尔型的数据。 short 短整型的数据。 int 整型的数据。 float 浮点型的数据。 long 长整型的数据。 double 双精度的数据。 void 表示null类型或者无返回值。 流程控制 if 如果，指示有条件地执行代码块。条件的计算结果必须是布尔值。 else 否则，与if关键字结合使用。else子句是可选的，如果if条件为false，则执行该子句。 for 循环，用于指定一个在每次迭代结束前检查其条件的循环。 while 循环，用于指定一个只要条件为真就会重复的循环。 do 运行，用于指定一个在每次迭代结束时检查其条件的循环。 switch 观察，基于某个表达式，选择执行多个代码块中的某一个。 case 返回观察里的结果，用来标记switch语句中的每个分支。 default 默认，用来标记switch语句中的默认分支。 break 跳出，中断，关键字用于提前退出循环。 continue 继续，用来跳转到循环的下一个迭代。 return 返回，会导致方法返回到调用它的方法，从而传递与返回类型匹配的值。 类和接口 class 类，用来定义类。 interface 接口，用来定义接口。 extends 继承，声明类和接口继承的父类和父接口。 implements 实现，声明类实现的接口。 修饰 abstract 声明抽象，修饰类和方法。 final 终极，不可改变的，修饰类和方法。 static 静态，意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 synchronized 线程，同步。 native 本地，表示该方法是用Java以外的语言实现的。 strictfp 严格，精准，声明一个类、接口或者方法，所声明的范围内会完全依照浮点规范执行。 transient 短暂，应用于类的成员变量，表示成员变量不应被序列化。 volatile 易失，表示可以被多个线程异步修改的成员变量。 3 变量3.1 定义一块内存中的数据存储空间，因为里面的数据可以更改，所以称为变量。 分类： 局部变量：方法或语句块内部定义的变量，作用域是当前方法或当前语句块，需要在初始化时赋值，存在栈内存中。 成员变量：方法外部或类的内部定义的变量，作用域是整个类，有默认值，存在堆内存中。 3.2 常量常量是特殊的变量，常量存储的数据不可以更改。 4 数据类型4.1 说明Java语言是一种强类型语言。通俗点说，在Java中存储的数据都是有类型的，而且必须在编译时就确定其类型。 4.2 分类分类： 基本类型变量：保存原始值，它代表的值就是数值本身。通过值传递进行赋值。 引用类型变量：保存引用值，指向内存空间的地址，代表了某个对象的引用，对象本身存放在这个引用值所表示的地址的位置。通过引用传递进行赋值。 图示： 基本数据类型： 分类 类型 内容 默认值 大小 范围 布尔型 boolean true false false 1bit true false 字符型 char Unicode字符集 \\u0000 16bits \\u0000 ~ \\uFFFF 整数类型 byte 带符号整数 0 8bits -2^7 ~ 2^7-1 short 带符号整数 0 16bits -2^15 ~ 2^15-1 int 带符号整数 0 32bits -2^31 ~ 2^31-1 long 带符号整数 0L 64bits -2^63 ~ 2^63-1 浮点类型 float IEEE 754标准的浮点数 0.0f 32bits -2^63 ~ 2^63-1 double IEEE 754标准的浮点数 0.0 64bits -2^63 ~ 2^63-1 4.2.1 布尔型boolean类型表示1位的信息，只有true和false两个取值，这种类型只作为一种标志来记录true和false情况。 默认值是false。 4.2.2 字符型char类型是一个单一的16位Unicode字符，单引号括起来的单个字符表达，通常用16进制表示。 最小值是\\u0000（即为0），最大值是\\uffff（即为65535），可以当整数来用，它的每一个字符都对应一个数字。 字符常量指用单引号括起来的单个字符，比如&#39;a&#39;和&#39;A&#39;。请特别注意，字符的定界符是单引号，而非双引号。 除了以上所述形式的字符常量值之外，还有一种特殊形式的字符常量值，这通常用于表示难以用一般字符来表示的字符，这种特殊形式的字符是以一个\\开头的字符序列，称为转义字符。 常用转义字符： 转义字符 意义 ASCII码值（十进制） \\a 响铃（BEL） 007 \\b 退格（BS），将当前位置移到前一列 008 \\f 换页（FF），将当前位置移到下一页 012 \\n 换行（LF），将当前位置移到下一行 010 \\r 回车（CR），将当前位置移到本行开头 013 \\t 水平制表（HT），跳到下一个TAB位置 009 \\v 垂直制表（VT） 011 \\\\ 代表\\反斜线字符 092 \\' 代表'单引号字符 039 \\\" 代表\"双引号字符 034 \\0 空字符（NULL） 000 4.2.3 整数类型4.2.3.1 bytebyte类型是8位的有符号的以二进制补码表示的整数，占1字节。 最小值是-128（-2^7），最大值是127（2^7-1），默认值是0。 4.2.3.2 shortshort类型是16位的有符号的以二进制补码表示的整数，占2字节。 最小值是-32768（-2^15），最大值是32767（2^15-1），默认值是0。 4.2.3.3 intint类型是32位的有符号的以二进制补码表示的整数，占4字节。 最小值是-2^31，最大值是2^31-1，默认值是0。 4.2.3.4 longlong类型是64位的有符号的以二进制补码表示的整数，占8字节。 最小值是-2^63，最大值是2^63-1，默认值是0L。 4.2.4 浮点类型4.2.4.1 floatfloat类型是32位的单精度的符合IEEE 754标准的浮点数，占4字节。 默认值是0.0F。 4.2.4.2 doubledouble类型是64位的双精度的符合IEEE 754标准的浮点数，占8字节。 默认值是0.0D，浮点数的默认类型为double类型。 4.3 类型转换字符型、整型、浮点型的数据在混合运算中相互转换，遵循以下规则： boolean类型不可以转换为其他的数据类型。 容量小的类型自动转换为容量大的类型，顺序为： byte&#x2F;short&#x2F;char int long float double byte&#x2F;short&#x2F;char之间不会相互转换，他们在计算时会首先转为int类型。 容量大的数据类型转为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出。 有多种类型的数据类型混合运算时，首先自动将所有的数据转换成容量最大的数据类型，然后在进行计算。 5 运算符5.1 说明运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算。 支持如下运算符： 算术运算符：++，–，+，-，*，&#x2F;，%。 赋值运算符：&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;。 关系运算符：&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;。 逻辑运算符：&amp;，|，!，^，&amp;&amp;，||。 条件运算符：?:。 位运算符：&amp;，|，~，^，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;。 优先级如下图所示： 优先级 运算符 名称 结合性 1 . 点 从左到右 () 圆括号 从左到右 [] 方括号 从左到右 2 + 取正 从右到左 - 取负 从右到左 ++ 自增 从右到左 -- 自减 从右到左 ~ 按位非 从右到左 ! 逻辑非 从右到左 3 * 相乘 从左到右 / 相除 从左到右 % 取余 从左到右 4 + 相加 从左到右 - 相减 从左到右 5 带符号右移 从左到右 >>> 无符号右移 从左到右 6 = 大于等于 从左到右 instanceof 是否属于类 从左到右 7 == 等于 从左到右 != 不等于 从左到右 8 & 逻辑与（按位与） 从左到右 9 | 逻辑或（按位或） 从左到右 10 ^ 逻辑异或（按位异或） 从左到右 11 && 短路与 从左到右 12 || 短路或 从左到右 13 ?: 条件运算符 从右到左 14 = 将右侧的值赋给左侧的变量 从右到左 += 左侧的变量加右侧的值取和，将和赋给左侧的变量 从右到左 -= 左侧的变量减右侧的值取差，将差赋给左侧的变量 从右到左 *= 左侧的变量乘右侧的值取积，将积赋给左侧的变量 从右到左 /= 左侧的变量除右侧的值取商，将商赋给左侧的变量 从右到左 %= 左侧的变量除右侧的值取余，将余赋给左侧的变量 从右到左 5.2 分类5.2.1 算术运算符算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。 分类： 单目运算符主要有+（取正），-（取负），++（自增），–（自减）。 双目运算符主要有+（相加），-（相减），*（相乘），&#x2F;（相除），%（取余）。 5.2.2 自增和自减只能用来操作变量，不能用来操作数值或者常量。 自增（++）或自减（–）在变量后面，会先赋值，然后再计算： java123456public static void main(String [] args) &#123; int a = 0; int b = a++; System.out.println(&quot;a = &quot; + a);// a = 1 System.out.println(&quot;b = &quot; + b);// b = 0&#125; 自增（++）或自减（–）在变量前面，会先计算，然后再赋值： java123456public static void main(String [] args) &#123; int a = 0; int b = ++a; System.out.println(&quot;a = &quot; + a);// a = 1 System.out.println(&quot;b = &quot; + b);// b = 1&#125; 5.2.3 赋值运算符赋值运算符是指为变量或常量指定数值的符号，如可以使用=将右边的表达式结果赋给左边的操作数。 说明： a += b等价于a = a + b a -= b等价于a = a - b a *= b等价于a = a * b a /= b等价于a = a / b a %= b等价于a = a % b 5.2.4 关系运算符比较运算符用于判断两个数据的大小，如大于、等于、不等于，比较的结果是一个布尔值。 注意不要对浮点数进行相等性运算，比如1.0 - 0.3 == 0.7。 注意： 使用&gt; &lt; &gt;= &lt;=只支持左右两边操作数是数值类型。 使用== !=两边的操作数既可以是数值类型，也可以是引用类型。 比较equals和&#x3D;&#x3D;的区别： 变量类型 存储位置 == equals 值类型 栈 比较值是否相等 无（值类型通常使用==比较） 引用类型 栈中存储地址，对象存储在堆中 比较地址是否相同（栈中内容是否相同） 判断对象的内容是否相同 说明： &#x3D;&#x3D;比较的是地址，equals比较的是内容。当equals为true时，&#x3D;&#x3D;不一定为true。 5.2.5 逻辑运算符逻辑运算符主要用于进行逻辑运算： 逻辑与（&amp;）：只有当两边都为真，结果才为真，如果有一边为假，结果为假。 逻辑或（|）：如果有一边为真，结果为真，只有当两边都为假，结果才为假。 逻辑非（!）：当右边为假，结果为真，当右边为真，结果为假。 逻辑异或（^）：当两边真假不一致，结果才为真，两边同为真或两边同为假，结果均为假。 短路与（&amp;&amp;）：当左边为假，则不再判断右边，直接得出结果为假。 短路或（||）：当左边为真，则不再判断右边，直接得出结果为真。 5.2.6 条件运算符条件运算符（?:）也称为三元运算符。 语法： java1布尔表达式 ? 表达式1 : 表达式2; 运算过程： 如果布尔表达式的值为真，则返回表达式1的值。 如果布尔表达式的值为假，则返回表达式2的值。 5.2.7 位运算符主要有按位与（&amp;），按位或（|），按位非（~），按位异或（^），带符号左移（&lt;&lt;），带符号右移（&gt;&gt;），无符号右移（&gt;&gt;&gt;）。 位运算是以二进制位为单位进行的运算，其操作数和运算结果都是整型值。 位运算与逻辑运算的相应操作的真值表完全相同，其差别只是位运算操作的操作数和运算结果都是二进制整数，而逻辑运算相应操作的操作数和运算结果都是逻辑值布尔型。 移位运算符： 带符号左移（&lt;&lt;）是将一个二进制数按指定移动的位数向左移位，移掉的被丢弃，右边移进的部分正数补0负数补1。将一个数带符号左移会使该值乘以2的幂。 带符号右移（&gt;&gt;）是将一个二进制数按指定移动的位数向右移位，移掉的被丢弃，左边移进的部分正数补0负数补1。将一个数带符号右移会使该值除以2的幂。 无符号右移（&gt;&gt;&gt;）是将一个二进制数按指定移动的位数向右移位，左边移进的部分始终补0，所以永远不会产生负号。将一个数无符号右移会使该值除以2的幂，如果是负数，可能会得到一个很大的正数。 6 进制6.1 介绍二进制的前缀是0B或0b，范围是0-1。 八进制的前缀是0，范围是0-7。 十进制不需要前缀，范围是0-9。 十六进制的前缀是0X或0x，范围是0-9 A-F或者0-9 a-f。 6.2 转换6.2.1 其他进制转换为十进制6.2.1.1 二进制转换为十进制从右往左开始计算，底数为2，指数从0开始依次递增，最后结果累加。 二进制数字0111转为十进制的计算逻辑： java11 * 2 ^ 0 + 1 * 2 ^ 1 + 1 * 2 ^ 2 + 0 * 2 ^ 3 = 7 6.2.1.2 八进制转换为十进制从右往左开始计算，底数为8，指数从0开始依次递增，最后结果累加。 八进制数字017转为十进制的计算逻辑： java17 * 8 ^ 0 + 1 * 8 ^ 1 = 15 6.2.1.3 十六进制转换为十进制从右往左开始计算，底数为16，指数从0开始依次递增，最后结果累加。 十六进制数字0x2c转为十进制的计算逻辑： java112 * 16 ^ 0 + 2 * 16 ^ 1 = 44 6.2.2 十进制转换为其他进制6.2.2.1 十进制转换为二进制一直除以2，求出每次的余数，直到商为0为止，最后余数倒过来就是二进制数。 十进制数字10转二进制数字为1010。 6.2.2.2 十进制转换为八进制一直除以8，求出每次的余数，直到商为0为止，最后余数倒过来就是八进制数。 十进制数字10转八进制数字为012。 6.2.2.3 十进制转换为十六进制一直除以16，求出每次的余数，直到商为0为止，最后余数倒过来就是十六进制数。 十进制数字10转十六进制数字为A。 6.2.3 其他进制转换为二进制6.2.3.1 八进制转换为二进制从最低位开始算，每一位转换一个三位的二进制数，最后拼成一个最终的二进制数。 八进制数字0136转二进制数字为000 001 011 110。 6.2.3.2 十六进制转换为二进制从最低位开始算，每一位转换成一个四位的二进制数，最后拼成一个最终的二进制数。 十六进制数字5E转二进制数字为0101 1110。 6.2.4 二进制转换为其他进制6.2.4.1 二进制转换为八进制从最低位开始算，每三位转换成一个十进制数，最后拼成一个八进制数。 二进制数字000 001 011 110转八进制数字为0136。 6.2.4.2 二进制转换为十六进制从最低位开始算，每四位转换成一个十进制数，最后拼成一个十六进制数。 二进制数字0101 1110转十六进制数字为5E。 6.3 码制相关概念： 原码：人最容易看得懂和理解的一种形式，进制转换都是原码。 反码：计算机为了让符号位参与运算，所以有了反码。 补码：计算机为了解决0的符号问题，所以有了补码。 移码：不管正负数，只要将其补码的符号位取反即可得到移码。 特点： 正数：正数的原码、反码、补码都一样。 负数：负数的反码符号位不变，其他位取反。负数对的补码符号位不变，在反码基础上加1。 7 流程控制流程控制指的是在程序运行的过程中控制程序运行走向的方式。主要分为以下三种： 顺序结构：从上到下依次执行每条语句操作。 分支结构：根据条件判断执行哪些语句操作。 循环结构：根据循环初始条件和终结要求，执行循环体内的操作。 7.1 分支结构分支结构有if分支结构和switch分支结构： if分支结构使用布尔表达式或者布尔值进行判断来进行分支的控制。 switch分支结构使用整数、String类型、枚举类型进行判断来进行分支的控制。 分支的各种情况要满足不重复，不遗漏的原则。相互独立，完全穷尽（MECE，Mutually Exclusive Collectively Exhaustive）。 7.1.1 if分支结构7.1.1.1 if语句语法： java123if (条件) &#123; 语句;&#125; 说明： 如果条件成立，执行大括号中的语句。 如果条件不成立，跳过大括号，执行后面的语句。 判断一个数字是否是正数： java1234int i = 1;if (i &gt; 0) &#123; System.out.println(i + &quot;是正数！&quot;);&#125; 7.1.1.2 if … else语句语法： java12345if (条件) &#123; 语句;&#125; else &#123; 语句;&#125; 说明： 如果条件成立，执行大括号中的语句。 如果条件不成立，执行else后面大括号中的语句。 判断成绩是否及格： java123456int i = 58;if (i &gt;= 60) &#123; System.out.println(&quot;成绩及格了！&quot;);&#125; else &#123; System.out.println(&quot;成绩不及格！&quot;);&#125; 7.1.1.3 if … else … if语句语法： java1234567if (条件) &#123; 语句;&#125; else if (条件) &#123; 语句;&#125; else &#123; 语句;&#125; 说明： 如果第一个条件成立，执行第一个条件后面大括号里的语句。 如果第一个条件不成立，判断下一个条件，依次类推。 如果所有条件都不成立，执行else中的语句。 判断成绩级别： java123456789101112int i = 78;if (i == 100) &#123; System.out.println(&quot;满分！&quot;);&#125; else if (i &gt;= 90) &#123; System.out.println(&quot;优秀！&quot;);&#125; else if (i &gt;= 80) &#123; System.out.println(&quot;良好！&quot;);&#125; else if (i &gt;= 60) &#123; System.out.println(&quot;及格！&quot;);&#125; else &#123; System.out.println(&quot;不及格！&quot;);&#125; 7.1.2 switch分支结构语法： java1234567891011switch (表达式) &#123;case 常量: 语句; break;case 常量: 语句; break;default: 语句; break;&#125; 说明： 拿着变量或表达式得到的值，去和各个case后面常量的值做判断，看是否匹配， 如果有匹配，则执行当前常量后面的语句，遇见break则跳出匹配，否则继续匹配。 如果没有匹配，则执行default后面的语句。 判断性别： java123456789101112int sex = 1;switch (sex) &#123;case 1: System.out.println(&quot;性别男！&quot;); break;case 2: System.out.println(&quot;性别女！&quot;); break;default: System.out.println(&quot;无性别！&quot;); break;&#125; 注意： switch只能做等值判断，支持基本类型的byte、short、int、char，在JDK1.7以后还支持引用类型的String和Enum。 case后的常量值不可以重复。 default可以省略，而且default位置也可以提到前面，只是不建议。 break可以省略。 7.1.3 对比相同点： 都可以实现分支结构。 不同点： 能用switch解决的题目肯定能用if解决，switch结构的效率比if结构的效率高。 能用if解决的题目不一定可以用switch解决，switch只能处理等值的条件判断，且条件是整型变量或字符变量的等值判断。 7.2 循环结构循环语句也称作迭代语句，循环语句可以在满足条件的情况下反复执行某一段代码。 7.2.1 while循环结构语法： java123while (条件) &#123; 语句;&#125; 说明： 先判断条件是否满足，如果不满足则跳出循环，如果满足则执行语句。 然后再次判断条件是否满足，直到条件不满足或跳出循环。 循环打印从0到10的数字： java12345int i = 0;while (i &lt;= 10) &#123; System.out.println(i); i++;&#125; 7.2.2 do … while循环结构语法： java123do &#123; 语句;&#125; while (条件); 说明： 先执行一次语句，然后判断条件是否满足，如果不满足则跳出循环，如果满足则执行循环语句。 继续判断条件是否满足，直到条件不满足或跳出循环。 循环打印从0到10的数字： java12345int i = 0;do &#123; System.out.println(i); i++;&#125; while (i &lt;= 10); 7.2.3 for循环结构语法： java123for (初始化表达式; 条件; 变量更新) &#123; 语句;&#125; 说明： 先执行一次初始化表达式，然后判断条件，如果不满足则跳出循环，如果满足则执行语句，然后执行变量更新。 判断条件是否满足，不满足则跳出，满足则执行语句和变量更新，直到条件不满足或跳出循环。 循环打印从0到10的数字： java123for (int i = 0; i &lt;= 10; i++) &#123; System.out.println(i);&#125; 注意事项： 两个分号必不可少。 三个表达式可以不写，但有可能造成死循环。 表达式1可以有多个变量初始化，要用逗号隔开。 表达式3可以有多个变量更新，要用逗号隔开。 7.2.4 对比相同点： 都具备循环的四要素：循环变量初始化，循环条件，循环操作（循环体），循环变量更新（迭代）。 不同点： 语法不同。 执行顺序不同，while循环和for循环都是先判断后执行，do-while是先执行后判断。 执行效率不同，do-while的执行效率最高。 7.3 跳转结构跳转语句用于实现循环执行过程中程序流程的跳转。 7.3.1 break语句在switch条件语句和循环语句中都可以使用break语句。 当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。 当它出现在循环语句中，作用是跳出循环语句，执行后面的代码。 循环打印从0到10的数字，要求当要打印6时停止循环： java123456for (int i = 0; i &lt;= 10; i++) &#123; if (i == 6) &#123; break; &#125; System.out.println(i);&#125; 当条件判断i为6时，循环终止，不再打印6和之后的数字。 7.3.2 continue语句只能用在循环语句中，它的作用是跳过本次循环，执行下一次循环。 循环打印从0到10的数字，要求当要打印6时跳过，继续打印剩下的： java123456for (int i = 0; i &lt;= 10; i++) &#123; if (i == 6) &#123; continue; &#125; System.out.println(i);&#125; 当条件判断i为6时，循环跳过，不再打印6，继续打印之后的数字。 7.3.3 return语句用于跳出循环结构。 8 数组8.1 定义数组可以理解成保存一组数的容器，而变量可以理解为保存一个数的容器。 数组是一种引用类型，用于保存一组相同类型的数据。 数组定义的类型可以为任意类型，可以定义int类型的数组，也可以定义String类型的数组，或其他任何类型的数组。 数组实际在内存的存储和基本类型不同，实际上是在堆中申请空间保存一组数，栈中只是有一个地址的引用。 8.2 使用8.2.1 声明语法： java12类型[] 数组名;类型 数组名[]; 示例： java12int[] sum;int color[]; 此时只是声明了一个数组变量，并没有在内存中开辟空间。 8.2.2 开辟空间语法： java1数组名 = new 类型[长度]; 示例： java1sum = new int[5]; 数组开辟空间时，必须要设置开辟的空间长度。 这时会根据类型对数组里的数据设置默认值。 8.2.3 赋值语法： java1数组名[下标] = 值; 示例： java1sum[0] = 10; 除了上面通过下标赋值，还可以在声明时开辟空间并赋值，或者在开辟空间时赋值。 语法： java12数组名 = new 类型[]&#123;值, 值&#125;;类型[] 数组名 = &#123;值, 值&#125;; 示例： java12int[] sum = &#123;1, 2&#125;;sum = new int[]&#123;1, 2, 3&#125;; 在对数组进行赋值时，注意下标不要超过数组的长度范围，否则会产生错误。 在开辟空间时赋值，不需要在中括号里面填写数组长度。 8.2.4 访问元素语法： java1数组名[下标] 示例： java1System.out.println(sum[0]); 同样需要注意下标不要超过数组的长度范围。 8.2.5 注意数组不赋值也有默认值。 数组中每个元素的赋值和访问都是通过数组名[下标]实现的，不能直接使用数组名。 通过数组名.length获取数组的长度，经常用在循环中，提高代码的维护性。 数组的下标从0到数组名.length - 1，如果不是这个范围，会导致一个数组下标越界的异常（ArrayIndexOutOfBoundsException）。 数组没有开辟空间直接使用，会导致一个空指针异常（NullPointerException）。 8.3 进阶使用8.3.1 复制8.3.1.1 复制引用地址引用类型的数组复制的是引用地址，二者共同引用一个地址，其中一个对数组做了更改，都会影响另一个。 示例： java123456int[] a1 = &#123;1, 2, 3&#125;;int[] a2;a2 = a1;System.out.println(a2[0]);// 1a1[0] = 100;System.out.println(a2[0]);// 100 8.3.1.2 复制数值内容基本类型的数组复制的是数值内容，实际上是一个备份，其中一个对它更改，不会影响另一个。 示例： java12345678int[] a1=&#123;1, 7, 8&#125;;int[] a2 = new int[a1.length];for (int i = 0; i &lt; a1.length; i++) &#123; a2[i] = a1[i];&#125;System.out.println(a2[0]);// 1a2[1]=100;System.out.println(a2[0]);// 1 8.8.2 排序示例： java12345678910int[] nums = &#123;1, 9, 3, 5, 2, 8, 4&#125;;for(int i = 0; i &lt; nums.length - 1; i++) &#123;// 控制轮数 for(int j = 0; j &lt; nums.length - 1 - i; j++) &#123; if (nums[j] &lt; nums[j + 1]) &#123;// 交换 int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; &#125; &#125;&#125; 8.8.3 倒置示例： java123456int[] nums = &#123;1, 9, 3, 5, 2, 8, 4&#125;;for(int i = 0; i &lt; nums.length / 2; i++) &#123; int temp = nums[i]; nums[i] = nums[nums.length - 1 - i]; nums[nums.length - 1 - i] = temp;&#125; 8.4 工具类排序： java1Arrays.sort(nums) 填充： java1Arrays.fill(nums, 1) 比较： java1Arrays.equals(a1, a2) 转字符串： java1Arrays.toString(nums) 8.5 二维数组二维数组可以看做是一个数组，里面存放的元素是一维数组。 声明： java123int[][] nums;int nums[][];int[] nums[]; 开辟空间： java12nums = new int[3][];// 行固定，列不固定nums = new int[3][2];// 行固定，列固定 数组赋值： 动态初始化，使用时赋值，需要指明行和列：java1nums[0][1] = 1; 静态初始化，声明时赋值，不必也不能指明行和列，否则会提示错误：java12int[][] nums = new int[][]&#123;&#123;1&#125;, &#123;9, 3, 5, 2&#125;, &#123;7, 6&#125;&#125;;int[][] nums = &#123;&#123;1&#125;, &#123;9, 3, 5, 2&#125;, &#123;7, 6&#125;&#125;; 说明： 如果在动态初始化时明确了二维数组的行数和列数，那么一维数组的长度就是固定的列数。 如果在动态初始化时仅仅明确了行数，或者通过静态初始化赋值，那么一维数组可以有不同的长度。 8.6 排序算法8.6.1 冒泡排序思路： 属于交换排序。 从第一个元素开始，比较两个相邻的元素，如果两个元素位置不正确，则进行交换，否则继续比较下面相邻的两个元素。 示例： java12345678910111213141516public void test() &#123; int[] arr = new int[]&#123;1, 7, 3, 8, 5&#125;; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 8.6.2 快速排序思路： 属于交换排序。 任取序列的某个元素作为界点，将序列分为两个子序列，左子序列的元素小于界点，右子序列的元素大于界点，然后递归每个子序列，直到每个子序列只有一个元素。 示例： java1234567891011121314151617181920212223242526272829public void test() &#123; int[] arr = new int[]&#123;8, 3, 11, 4, 9, 5, 1&#125;; sort(0, arr.length - 1, arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125;public void sort(int left, int right, int[] arr)&#123; int l = left; int r = right; int pivot = arr[(left + right)/2];// 找中间值 int temp = 0; while(l &lt; r)&#123; while(arr[l] &lt; pivot) l++; while(arr[r] &gt; pivot) r--; if(l &gt;= r) break; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if(arr[l] == pivot) --r; if(arr[r] == pivot) ++l; &#125; if(l == r)&#123; l++; r--; &#125; if(left &lt; r) sort(left, r, arr); if(right &gt; l) sort(l, right, arr);&#125; 8.6.3 直接选择排序思路： 属于选择排序。 每次都选取最小值放在起始位上，一共通过n-1次。 示例： java1234567891011121314151617public void test() &#123; int[] arr = new int[]&#123;3, 2, 6, 10, 1, 9, 8&#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[index] &gt; arr[j]) &#123; index = j; &#125; &#125; int temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"初体验","slug":"D00-后端/D01-Java/001-基础/003-初体验","date":"2025-04-24T00:43:12.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250424/084312/","permalink":"https://momashanhe.com/posts/20250424/084312/","excerpt":"摘要：本文学习了如何使用Java编写第一个程序。","text":"摘要：本文学习了如何使用Java编写第一个程序。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 编写在VSCode中新建Hello.java文本文档，输入如下代码： Hello.java12345class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 2 编译并运行2.1 编译打开终端，选择cmd终端，进入Hello.java文件所在目录，执行javac Hello.java命令。 说明： javac命令是用来编译的命令，它可以将程序员编写的源文件（.java）编译成字节码文件（.class）。 编译后会在目录中生成Hello.class文件，这是编译后产生的字节码文件。 2.2 执行执行java Hello命令： cmd1Hello World 说明： java命令是用来解释并执行的命令，它可以解释字节码文件（.class）并执行代码。 执行后显示打印内容，表示执行成功。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"安装","slug":"D00-后端/D01-Java/001-基础/002-安装","date":"2025-04-23T12:49:58.000Z","updated":"2025-06-21T08:58:50.981Z","comments":true,"path":"posts/20250423/204958/","permalink":"https://momashanhe.com/posts/20250423/204958/","excerpt":"摘要：本文学习了Java的下载和安装。","text":"摘要：本文学习了Java的下载和安装。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 下载和安装1.1 说明SDK（Software Development Kit）即软件开发工具包，一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。 JDK（Java Development Kit）即软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序，是整个Java开发的核心，它包含了Java的运行环境和Java工具。 下载可以去官网：官方地址 1.2 安装下载到合适的版本之后开始安装，选择合适的安装目录并执行安装。 安装时，还会询问是否安装JRE，因为JDK本身已经包含了JRE，所以可以取消安装。 按指引完成安装即可。 2 配置环境变量2.1 JAVA_HOME指定JDK的安装目录，Eclipse和Tomcat等软件通过JAVA_HOME变量使用JDK。 打开环境变量窗口，新建环境变量，变量名为JAVA_HOME，变量值为安装JDK时设置的安装目录。 2.2 CLASSPATH指定类的搜索路径，要使用已经编写好的类，前提当然是能够找到它们，JVM通过JAVA_HOME变量寻找类。 打开环境变量窗口，新建环境变量，变量名为CLASSPATH，变量值为.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar。 2.3 Path指定命令的搜索路径，在命令行下面执行命令时，会到Path变量指定的路径中查找相应的命令程序。 需要把JDK安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件，设置后可以在任何目录下执行命令。 打开环境变量窗口，在下方的系统环境变量里找到Path环境变量并编辑，新建两个变量%JAVA_HOME%\\bin和%JAVA_HOME%\\jre\\bin并保存。 3 测试打开cmd命令行，执行java -version命令： cmd123java version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 如能正确显示安装的版本，则说明环境变量配置正确。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"初识","slug":"D00-后端/D01-Java/001-基础/001-初识","date":"2025-04-22T05:43:15.000Z","updated":"2025-08-06T01:43:14.496Z","comments":true,"path":"posts/20250422/134315/","permalink":"https://momashanhe.com/posts/20250422/134315/","excerpt":"摘要：本文介绍了Java相关的知识。","text":"摘要：本文介绍了Java相关的知识。 环境 Windows 10 企业版 LTSC 21H2Java 1.8 1 Java简介1.1 说明Java语言历时十多年，已发展成为人类计算机史上影响深远的编程语言，从某种程度上来看，它甚至超出了编程语言的范畴，成为一种开发平台，一种开发规范。 Java语言所崇尚的开源、自由等精神，吸引了全世界无数优秀的程序员。事实是，从人类有史以来，从来没有一门编程语言能吸引这么多的程序员，也没有一门编程语言能衍生出如此之多的开源框架。 Java语言是一门非常纯粹的面向对象编程语言，它吸收了C++语言的各种优点，又摒弃了C++里难以理解的指针等概念。Java语言作为静态面向对象编程语言的代表，很好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程开发。 不仅如此，Java语言相关的JavaEE规范里包含了时下最流行的各种软件工程理念，各种先进的设计思想总能在JavaEE平台以及相关框架里找到相应实现。从某种程度上来看，学精了Java语言的相关方面，相当于系统地学习了软件开发相关知识，而不是仅仅学完了一门编程语言。 时至今日，大部分银行、电信、证券、电子商务、电子政务等系统已经采用JavaEE平台构建，或者正在逐渐过渡到采用JavaEE平台来构建，JavaEE规范是目前最成熟的也是应用最广的企业级应用开发规范。 1.2 诞生Java语言的诞生具有一定的戏剧性，它并不是经过精心策划、制作，最后产生的划时代产品，从某个角度来看，Java语言的诞生完全是一种误会。 1990年年末，Sun公司预料嵌入式系统将在未来家用电器领域大显身手。于是Sun公司成立了一个由James Gosjing领导的Green计划，准备为下一代智能家电（如电视机、微波炉、电话）编写一个通用控制系统。 该团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家Bill Joy，发现C++和可用的API在某些方面存在很大问题。而且工作小组使用的是嵌入式平台，可用的系统资源极其有限。并且很多成员都发现C++太复杂，以致很多开发者经常错误使用。而且C++缺少垃圾回收系统、可移植性、分布式和多线程等功能。 根据可用的资金，Bill Joy决定开发一种新语言，他提议在C++的基础上，开发一种面向对象的环境。于是James Gosling试图通过修改和扩展C++的功能来满足这个要求，但是后来他放弃了，他决定创造一种全新的语言，即Oak。 到了1992年的夏天，Green计划已经完成了新平台的部分功能，包括Green操作系统、Oak的程序设计语言、类库等。同年11月，Green计划被转化成了一个Sun公司的全资子公司。 新公司致力于创建一种高度互动的设备。当时代华纳公司发布了一个关于电视机顶盒的征求提议书时，他们改变了目标，作为对征求提议书的响应，提出了一个机顶盒平台的提议，但在当时市场不成熟的情况下，他们的项目没有获得成功。 此时，可怜的Green项目几乎接近夭折，甚至Green项目组的一半成员也被调到了其他项目组。 正如中国古代的寓言所言：塞翁失马，焉知非福？如果Green项目在机顶盒平台投标成功，也许就不会诞生Java这门伟大的语言了。 1994年夏天，互联网和浏览器的出现不仅给广大互联网的用户带来了福音，也给Oak语言带来了新的生机。Gosling立即意识到，这是一个机会，于是对Oak进行了小规模的改造。 到了1994年秋，小组完成了第一个Java语言的网页浏览器。Sun公司实验室主任和技术总监观看了该浏览器的演示，对该浏览器的效果给予了高度评价。当时Oak这个商标已被别人注册，于是只得将Oak更名为Java。 1.3 发展Sun公司在1995年年初发布了Java语言，Sun公司直接把Java放到互联网上，免费给大家使用。甚至连源代码也不保密，也放在互联网上向所有人公开。 几个月后，让所有人都大吃一惊的事发生了，Java成了互联网上最热门的宝贝，竟然有10万多人次访问了Sun公司的网页，下载了Java语言。然后，互联网上立即就有数不清的Java小程序（也就是Applet），演示着各种小动画、小游戏等。Java语言终于扬眉吐气了，成为了一种广为人知的编程语言。 在Java语言出现之前，互联网的网页实质上就像是一张纸，不会有任何动态的内容。有了Java语言之后，浏览器的功能被扩大了，Java程序可以直接在浏览器里运行，可以直接与远程服务器交互，用Java语言编程，可以在互联网上像传送电子邮件一样方便地传送程序文件。 2 历史版本2.1 JDK1.0Sun公司在1995年年初发布了Java语言，同时放到了互联网上，免费给大家使用，甚至连源代码也不保密，对所有人公开，这就是所谓的开源。之后吸引了大批的程序员使用Java语言开发出了各种小动画、小游戏等。 Sun公司虽然推出了Java，但这只是一种语言，如果想要开发复杂的应用程序，必须要有一个强大的开发类库。 因此，Sun在1996年年初发布了JDK1.0。这个版本包括两部分： 运行环境（JRE，Java Runtime Environment）：包括核心API、集成API、用户界面API、发布技术、虚拟机（JVM）。 开发环境（JDK，Java Development Kit）：包括编译Java程序的编译器（即javac命令）。 在JDK1.0时代，JDK除了AWT（一种用于开发图形用户界面的API）外，其它的库并不完整。 2.2 JDK1.1接着，Sun在1997年2月18日发布了JDK1.1。JDK1.1增加了JIT（Just In Time，即时）编译器。 JIT和传统的编译器不同，传统的编译器是编译一条，运行完后将其扔掉，而JIT会将经常用到的指令保存在内存中，当下次调用时就不需要重新编译了，通过这种方式让JDK在效率上有了较大提升。 但一直以来，Java主要的应用就是网页上的Applet以及一些移动设备。 到了1996年年底，Flash面世了，这是一种更加简单的动画设计软件，使用Flash几乎无须任何编程语言知识，就可以做出丰富多彩的动画。随后Flash增加了ActionScript编程脚本，Flash逐渐蚕食了Java在网页上的应用。 从1995年Java的诞生到1998年年底，Java语言虽然成为了互联网上广泛使用的编程语言，但它并没有找到一个准确的定位，也没有找到它必须存在的理由。Java语言可以编写Applet，而Flash一样可以做到，而且更快，开发成本更低。 2.3 JDK1.2直到1998年12月，Sun发布了JDK1.2，这是Java历史上最重要的JDK版本。 伴随JDK1.2一同发布的还有Jsp&#x2F;Servlet、EJB（Enterprise Java Bean）等规范，并将Java分成了J2EE、J2SE和J2ME三个版本： J2EE 企业版（Java 2 Platform，Enterprise Edition）：Java技术中应用最广泛的部分，J2EE提供了企业应用开发相关的完整解决方案。 J2SE 标准版（Java 2 Platform，Simple Edition）：整个Java技术的核心和基础，它是J2ME和J2EE编程的基础。 J2ME 微缩版（Java 2 Platform，Micro Edition）：主要用于控制移动设备和信息家电等有限存储的设备。 这标志着Java已经吹响了向企业、桌面和移动3个领域进军的号角，标志着Java已经进入JDK1.2时代，这个时期也是Java飞速发展的时期。 在JDK1.2中，Java发生了很多革命性的变化，而这些革命性的变化一直沿用到现在，对Java的发展形成了深远的影响，直到今天还能看到J2EE等名称。 不仅如此，JDK1.2还把它的API分成了三大类： 核心API：由Sun公司制定的基本的API，所有的Java平台都应该提供。这就是Java核心类库。 可选API：这是Sun为JDK提供的扩充API，这些API因平台的不同而不同。 特殊API：用于满足特殊要求的API。如用于JCA相JCE的第三方加密类库。 2.4 JDK1.42002年2月，Sun发布了JDK1.4，这是JDK历史上最为成熟的版本。 此时由于Compaq、Fujitsu、SAS、Symbian、IBM等公司的参与，使JDK1.4成为发展最快的一个JDK版本。到JDK1.4为止，已经可以使用Java实现大多数的应用了。 在此期间，Java语言在企业应用领域大放异彩。涌现出大量基于Java语言的开源框架，比如：Struts、WebWork、Hibemate、Spring等。也涌现出大量企业应用服务器，比如：WebLogic、WebSphere、JBoss等。 这些都标志着Java语言进入了飞速发展时期。 2.5 JDK1.52004年10月，Sun发布了万众期待的JDK1.5，同时，Sun将JDK1.5改名为JavaSE 5。J2EE、J2ME也相应地改名JavaEE和JavaME。 JDK1.5增加了诸如泛型、增强的for语句、可变数量的形参、注释（Annotations）、自动拆箱和装箱等功能。同时也发布了新的企业级平台规范如通过注释等新特性来简化EJB的复杂性，并推出了EJB 3.0规范。还推出了JSF规范用于MVC框架，JSF规范类似于ASP.NET的服务器端控件，通过它可以快速地构建复杂的JSP界面。 2.6 JDK1.62006年12月，Sun公司发布了JDK1.6（也被称为JavaSE 6）。一直以来，Sun公司维持了大约2年发布一次JDK新版本的习惯。 但在2009年4月20日，Oracle宣布将以每股9.5美元的价格收购Sun，该交易的总价值约为74亿美元。而Oracle通过收购Sun公司获得了Java和Solaris这两项软件资产。 于是曾经代表一个时代的Sun公司终于被雨打风吹去，江湖上再也没有了Sun公司的身影。多年以来，在新一辈的程序员心中可能会遗忘曾经的Sun公司，但老一辈的程序员们将永久地怀念Sun公司的传奇。 Sun倒下了，不过Java的大旗依然猎猎作响。2007年11月，Google宣布突出一款基于Linux平台的的开源手机操作系统：Android。 Android的出现顺应了即将出现的移动互联网潮流，而且Android系统的用户体验非常好，因此迅速成为手机操作系统的中坚力量。 Android平台使用了Dalvik虚拟机来运行.dex文件，Dalvik虚拟机的作用类似于虚拟机，只是他并未遵守JVM规范而已。 Android使用Java语言来开发应用程序，这也给了Java语言一个新的机会。在过去的岁月中，Java语言作为服务器端编程语言，已经取得了极大的成功。而Android平台的流行，则让Java语言获得了在客户端程序上大展拳脚的机会。 2.7 JDK1.72011年7月28日，Oracle公司终于如约发布了JavaSE 7，这次版本的升级经过了将近5年时间，也是Oracle发布的第一个Java版本。虽然并未完全满足所有人的期望，不过它也加入了不少新特性。 2.8 JDK1.82014年3月19日，Oracle公司发布了JavaSE 8，这是Java发展史上的又一个里程碑，Lambda表达式和流式API的引入极大地提升了Java语言的表达能力和函数式编程支持。 需要注意的是，从2019年1月份开始，Oracle公司开始对JavaSE 8之后的版本开始进行商用收费，更确切的说，是对8u201和8u202之后的版本商用收费。 3 基本概念3.1 特点完全面向对象，动态。 解释性，简单易移植，跨平台。 安全健壮，高性能。 多线程，分布式。 3.2 执行方式计算机高级语言接程序的执行方式可以分为编译型和解释型两种。 Java语言是一种特殊的高级语言，它既具有解释型语言的特征，也具有编译型语言的特征，因为Java程序要经过先编译和后解释两个步骤。 3.2.1 编译型语言编译型语言是指使用专门的编译器，针对特定平台（操作系统）将某种高级语言源代码一次性翻译成可被该平台硬件执行的机器码（包括机器指令和操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程称为编译（Compile）。 编译生成的可执行性程序可以脱离开发环境，在特定的平台上独立运行。有些程序编译结束后，还可能需要对其他编译好的目标代码进行链接，即组装两个以上的目标代码模块生成最终的可执行性程序，通过这种方式实现低层次的代码复用。 因为编译型语言是一次性地编译成机器码，所以可以脱离开发环境独立运行，而且通常运行效率较高。但因为编译型语言的程序被编译成特定平台上的机器码，因此编译生成的可执行性程序通常无法移植到其他平台上运行。如果需要移植，则必须将源代码复制到特定平台上，针对特定平台进行修改，至少也需要采用特定平台上的编译器重新编译。 现有的C、C++、Fortran、Pascal等高级语言都属于编译型语言。 3.2.2 解释型语言解释型语言是指使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。 解释型语言通常不会进行整体性的编译和链接处理，解释型语言相当于把编译型语言中的编译和解释过程混合到一起同时完成。 可以认为每次执行解释型语言的程序都需要进行一次编译，因此解释型语言的程序运行效率通常较低，而且不能脱离解释器独立运行。但解释型语言有一个优势，那就是跨平台比较容易，只需提供特定平合的解释器即可，每个特定平台上的解释器负责将源程序解释成特定平台的机器指令即可。 解释型语言可以方便地实现源程序级的移植，但这是以牺牲程序执行效率为代价的。 现有的Ruby、Python等语言都属于解释型语言。 3.2.3 伪编译型语言除此之外，还有一种伪编译型语言，如Visual Basic，它属于半编译型语言，并不是真正的编译型语言。它首先被编译成P-代码，并将解释引擎封装在可执行性程序内，当运行程序时P-代码会被解析成真正的二进制代码。 表面上看起来，Visual Basic可以编译生成可执行性的EXE文件，而且这个EXE文件也可以脱离开发环境，在特定平台上运行，非常像编译型语言。实际上，在这个EXE文件中，既有程序的启动代码，也有链接解释程序的代码，而这部分代码负责启动Visual Basic解释程序，再对Visual Basic代码进行解释并执行。 4 运行机制Java语言比较特殊，由Java语言编写的程序需要经过编译步骤，但这个编译步骤并不会生成特定平台的机器码，而是生成一种与平台无关的字节码（也就是.class文件）。当然，这种字节码不是可执行性的，必须使用Java解释器来解释执行。 因此，可以认为Java语言既是编译型语言，也是解释型语言。或者说，Java语言既不是纯粹的编译型语言，也不是纯粹的解释型语言。 Java程序的执行过程必须经过先编译和后解释两个步骤，如图所示： 5 JVM5.1 定义Java语言里负责解释执行字节码文件的是虚拟机，即JVM（Java Virtual Machine），JVM是可运行Java字节码文件的虚拟计算机。 所有平台上的JVM向编译器提供相同的编程接口，而编译器只需要面向虚拟机，生成虚拟机能理解的代码，然后由虚拟机来解释执行。在一些虚拟机的实现中，还会将虚拟机代码转换成特定系统的机器码执行，从而提高执行效率。 当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体平台，只面向JVM。不同平台上的JVM都是不同的，但它们都提供了相同的接口。 JVM是Java程序跨平台的关键部分，只要为不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。 显然，相同的字节码程序需要在不同的平台上运行，几乎是不可能的，只有通过中间的转换器才可以实现，JVM就是这个转换器。 5.2 说明JVM的作用很容易理解，就像一个插座，使用相同的充电器给两个不同接口的手机充电。JVM的作用就类似于充电器： 向上的接口相同，用于适应同一个插座。 向下的接口不同，用于适应两个不同的手机。 在这个类比中，可以近似的理解两个不同的手机就是不同的操作系统，而同一个插座就是Java字节码程序，充电器角色则对应JVM。 类似地，也可以认为JVM分为向上和向下两个部分，所有平台上的JVM： 向上提供给Java字节码程序的接口完全相同。 向下适应不同平台的接口则互不相同。 5.3 规范Sun公司制定的虚拟机规范，在技术上规定了JVM的统一标准，具体定义了JVM的如下细节： 指今集。 寄存器。 类文件的格式。 栈。 存储区。 Sun公司制定这些规范的目的是为了提供统一的标准，最终实现Java程序的平台无关性。","categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"}]},{"title":"会话控制","slug":"C00-前端/C04-Node/001-基础/011-会话控制","date":"2025-04-13T15:02:14.000Z","updated":"2025-06-21T08:57:44.935Z","comments":true,"path":"posts/20250413/230214/","permalink":"https://momashanhe.com/posts/20250413/230214/","excerpt":"摘要：本文了解了什么是会话控制，以及如何使用Cookie和Session管理会话并进行身份验证。","text":"摘要：本文了解了什么是会话控制，以及如何使用Cookie和Session管理会话并进行身份验证。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 简介会话是服务器与客户端之间的一次交互过程，用于在多次请求中保持用户的状态。 会话控制是对会话进行控制，因为HTTP是一个无状态的协议，无法区分多次的请求是否来自同一客户端，所以需要通过会话控制解决该问题。 会话控制是实现用户认证、权限控制等核心功能的关键。 2 Cookie2.1 简介Cookie是服务器发送到客户端浏览器并保存在浏览器本地的数据，占用空间小，通过域名区分数据所属的服务器。 浏览器向服务器发送请求时，会自动将当前域名下可用的Cookie设置在请求头中传递给服务器。 2.2 使用2.2.1 设置语法： js1res.setHeader(&#x27;Set-Cookie&#x27;, &#x27;name=value; Max-Age=value; Path=value; HttpOnly=value; Secure=value; SameSite=value&#x27;); 参数： Max-Age：设置过期时间，单位是秒。 Path：设置作用路径。 HttpOnly：是否禁止JS脚本访问，只允许HTTP请求访问，设置为true可以避免XSS攻击。 Secure：是否只在HTTPS连接下发送。 SameSite：控制发送级别，发送防止CSRF攻击，可选值为Strict&#x2F;Lax&#x2F;None。 示例： js1234567891011// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 设置Cookie请求 if (req.url == &#x27;/info/setCookie&#x27;) &#123; // 设置Cookie res.setHeader(&#x27;Set-Cookie&#x27;, &#x27;service=info; Max-Age=60; Path=/info; HttpOnly; Secure; SameSite=Strict&#x27;); // 返回响应 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;设置成功&lt;/h1&gt;&#x27;); &#125;&#125;); 2.2.2 读取语法： js1req.headers.cookie 示例： js1234567891011121314151617181920212223242526// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 读取Cookie请求 if (req.url == &#x27;/info/getCookie&#x27;) &#123; // 读取Cookie let cookies = req.headers.cookie ? req.headers.cookie.split(&#x27;; &#x27;) : []; let service = &#x27;&#x27;; cookies.forEach((cookie) =&gt; &#123; const [key, value] = cookie.split(&#x27;=&#x27;); if (key == &#x27;service&#x27;) &#123; service = value; &#125; &#125;); // 返回响应 if (service) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(` &lt;h1&gt;读取成功&lt;/h1&gt; &lt;p&gt;服务名：$&#123;service&#125;&lt;/p&gt; `); &#125; else &#123; res.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125; &#125;&#125;); 2.2.3 删除语法： js1res.setHeader(&#x27;Set-Cookie&#x27;, &#x27;name=; Max-Age=0&#x27;); 示例： js1234567891011// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 删除Cookie请求 if (req.url == &#x27;/info/delCookie&#x27;) &#123; // 删除Cookie res.setHeader(&#x27;Set-Cookie&#x27;, &#x27;service=; Max-Age=0&#x27;); // 返回响应 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;删除成功&lt;/h1&gt;&#x27;); &#125;&#125;); 3 Session3.1 简介Session是保存在服务器本地的数据，可以保存当前访问的用户的相关信息，用于实现会话控制和用户免登录功能。 3.2 流程用户在登录网站以后，可以在服务端创建Session会话，并将用户信息保存在Session中，同时生成并保存Session对应的sessionId标识，然后将sessionId标识通过Cookie发送到客户端浏览器。 当用户通过浏览器访问网站时，会将Cookie里的sessionId发送给服务器，服务器通过sessionId可以唯一的确定用户的Session数据。 如果sessionId在浏览器的Cookie里没过期，并且能通过sessionId找到用户对应的Session数据。说明已经登录过了，跳过登录直接访问网站内容。 如果sessionId在浏览器的Cookie里过期了，或者不能通过sessionId找到用户对应的Session数据。说明登录时间超时了，或者没有登录过，这时就需要重新登录，保存用户信息到服务器的Session里，同时保存对应的sessionId标识，然后将sessionId标识通过Cookie发送到浏览器保存。 3.3 使用3.3.1 设置示例： js1234567891011121314151617// 创建对象存储数据const sessions = new Map();// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 设置Session请求 if (req.url == &#x27;/info/setSession&#x27;) &#123; // 设置Session let sessionId = `$&#123;Date.now()&#125;_$&#123;Math.random()&#125;`; let sessionData = &#123; service: &#x27;info&#x27; &#125;; sessions.set(sessionId, sessionData); // 设置Cookie res.setHeader(&#x27;Set-Cookie&#x27;, `sessionId=$&#123;sessionId&#125;; Max-Age=60; Path=/info; HttpOnly; Secure; SameSite=Strict`); // 返回响应 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;设置成功&lt;/h1&gt;&#x27;); &#125;&#125;); 生成sessionId用于在Session中管理数据，并在Cookie中设置sessionId用于识别会话。 3.3.2 读取示例： js1234567891011121314151617181920212223242526272829303132333435// 创建对象存储数据const sessions = new Map();// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 读取Session请求 if (req.url == &#x27;/info/getSession&#x27;) &#123; // 读取Cookie let cookies = req.headers.cookie ? req.headers.cookie.split(&#x27;; &#x27;) : []; // 读取Session let sessionId = &#x27;&#x27;; cookies.forEach(cookie =&gt; &#123; const [key, value] = cookie.split(&#x27;=&#x27;); if (key == &#x27;sessionId&#x27;) &#123; sessionId = value; &#125;; &#125;); // 返回响应 if (sessionId) &#123; let sessionData = sessions.get(sessionId); if (sessionData) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(` &lt;h1&gt;读取成功&lt;/h1&gt; &lt;p&gt;服务名：$&#123;sessionData.service&#125;&lt;/p&gt; `); &#125; else &#123; res.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125; &#125; else &#123; res.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125; &#125;&#125;); 3.3.3 删除示例： js123456789101112131415161718192021222324252627// 创建对象存储数据const sessions = new Map();// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 删除Session请求 if (req.url == &#x27;/info/delSession&#x27;) &#123; // 读取Cookie let cookies = req.headers.cookie ? req.headers.cookie.split(&#x27;; &#x27;) : []; // 读取Session let sessionId = &#x27;&#x27;; cookies.forEach(cookie =&gt; &#123; const [key, value] = cookie.split(&#x27;=&#x27;); if (key == &#x27;sessionId&#x27;) &#123; sessionId = value; &#125;; &#125;); // 返回响应 if (sessionId) &#123; sessions.delete(sessionId); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;删除成功&lt;/h1&gt;&#x27;); &#125; else &#123; res.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125; &#125;&#125;); 3.4 比较使用Cookie和Session的区别： 名称 Cookie Session 存储位置 客户端浏览器 服务器 数据量 通常限制在4KB 可存储更多数据 生命周期 可设置过期时间 通常在会话结束或超时后销毁 安全性 容易被篡改 更安全，数据存储在服务器端 用途 用户偏好设置、会话标识符 用户认证、购物车数据 适用场景 简单的用户状态管理 复杂的用户会话管理 4 Token4.1 简介Token是由服务端创建并保存在客户端的数据，客户端存储Token并在请求时传递给服务器，用于验证用户身份和授权访问，是无状态的认证机制。 4.2 流程用户登录后，服务器使用存储在服务器的秘钥对用户的相关信息进行加密，将加密后的密文作为Token返回给客户端。 客户端保存Token，并在后续请求的请求头中带上Token，服务器通过对Token解密进行验证来确认用户身份。 验证通过则允许访问资源，验证失败则拒绝访问资源。 4.3 类型4.3.1 SessionSession是一种特殊的Token，在用户登录后，服务器生成一个唯一的会话ID，并将其存储在服务器端，同时将该ID发送给客户端。 4.3.2 JWTJWT（JSON Web Token）是一种自包含的令牌，包含用户信息和签名，可以在客户端和服务器之间传递。 4.3.3 OAuthOAuth是一种用于授权的令牌，通常用于第三方应用访问用户资源。 4.4 区别比较Session和Token的区别： 名称 Session Token 状态保持 服务器需要维护每个用户的Session信息，因此是有状态的。 服务器通过验证Token的签名来确认用户身份，无需存储用户状态，因此是无状态的。 存储位置 服务器将用户状态存储在Session中，客户端通过Cookie存储sessionId，通过sessionId在服务器查询用户状态。 服务器不存储用户状态，客户端通过LocalStorage或Cookie存储Token，通过Token在服务器解析用户信息。 传输方式 通常通过Cookie将sessionId传递给服务器。 通常通过请求头将Token传递给服务器。 安全问题 面临的主要安全威胁是CSRF（跨站请求伪造）攻击，因为Cookie会自动附带在每个请求中。可以通过设置HttpOnly和Secure标志来增强安全性。 面临的主要安全威胁是XSS（跨站脚本攻击），因为Token通常存储在LocalStorage中，可能被恶意脚本读取。传输过程中使用HTTPS可以防止中间人攻击。 性能 服务器需要存储和管理Session数据，分布式系统需要将Session存储到分布式数据库中，增加了服务器的内存或存储负担。 服务器无需存储用户状态，减少了服务器负担，适合分布式系统，但每次请求都需要验证Token的签名，增加了计算开销。 适用场景 适合需要服务器维护用户状态的场景，特别是在用户量不大且对安全性要求较高的情况下。 适合分布式系统、单点登录（SSO）和需要高扩展性的场景 5 JWT5.1 简介JWT（JSON Web Token）是目前最流行的跨域认证解决方案，可用于基于Token的身份验证，使Token的生成与校验更规范。 5.2 使用使用JWT通常会借助一些成熟的库来简化操作，比如jsonwebtoken库，使用npm install jsonwebtoken命令安装。 5.2.1 签发对用户信息进行签名，获得JWT。 示例： js12345678910111213// 引入模块const jwt = require(&#x27;jsonwebtoken&#x27;);// 签发Tokenfunction signToken(payload, secret, options) &#123; try &#123; return jwt.sign(payload, secret, options); &#125; catch (error) &#123; console.error(&#x27;签发失败: &#x27; + error.message); return null; &#125;&#125;let token = signToken(&#123; username: &#x27;张三&#x27;, sex: &#x27;男&#x27; &#125;, &#x27;salt&#x27;, &#123; expiresIn: 600 &#125;);console.log(token); 参数： payload：包含用户信息的对象。 secret：用于签名的密钥。 options：可选参数。 expiresIn：令牌过期时间，单位是秒。 5.2.2 验证对JWT进行验证，获得用户信息。 示例： js12345678910111213// 引入模块const jwt = require(&#x27;jsonwebtoken&#x27;);// 验证Tokenfunction verifyToken(token, secret) &#123; try &#123; return jwt.verify(token, secret); &#125; catch (error) &#123; console.error(&#x27;验证失败: &#x27;, error.message); return null; &#125;&#125;let data = verifyToken(&#x27;eJhbGciO.NzQ0ODA4.vlc8FbdY&#x27;, &#x27;salt&#x27;);console.log(data); 参数： token：需要验证的JWT。 secret：用于签名的密钥。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"接口管理","slug":"C00-前端/C04-Node/001-基础/010-接口管理","date":"2025-04-11T06:29:34.000Z","updated":"2025-06-21T08:57:45.135Z","comments":true,"path":"posts/20250411/142934/","permalink":"https://momashanhe.com/posts/20250411/142934/","excerpt":"摘要：本文了解了接口的概念和组成，以及什么是RESTful风格的接口。","text":"摘要：本文了解了接口的概念和组成，以及什么是RESTful风格的接口。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 简介在网络通信的场景中，接口是前后端通信的桥梁。前端将数据封装到请求里，根据请求路径访问后端提供的接口，接口在收到请求后会处理数据并生成结果，最终将结果返回给客户端。 在前后端沟通中常常将接口称为API（Application Program Interface）接口，通常由后端提供给前端和其他后端调用。 2 组成2.1 请求地址接口所在的资源路径，即URL地址。 2.2 请求方法接口接受的请求类型。 常见的有四种： GET请求：这种类型的请求主要用于获取数据，对应查询操作。 POST请求：这种类型的请求主要用于提交数据，对应增加操作。 PUT请求：这种类型的请求主要用于更新数据，对应更新操作。 DELETE请求：这种类型的请求主要用于删除数据，对应删除操作。 2.3 请求参数接口需要的数据。 按参数所在位置不同，可以分为三种： 参数附加在请求地址后面。示例：url1https://api.example.com/getData?id=1 参数附加在请求地址中。示例：url1https://api.example.com/getData/1 参数附加在请求体中，通常使用JSON格式传递。示例：json1&#123; id: 1 &#125; 2.3.1 原生表单原生表单的请求体为application/x-www-form-urlencoded类型，页面中的form元素的默认类型。 提交后会将数据通过键值对的形式传递，如果请求方法是GET请求会拼接到请求地址传输，如果请求方法是POST请求会通过请求体传输。 通过form元素请求接口： html1234567&lt;form action=&quot;/info&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 通过form元素和AJAX请求接口： html123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;form id=&quot;infoForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; $(document).ready(function () &#123; $(&#x27;#infoForm&#x27;).on(&#x27;submit&#x27;, function (e) &#123; // 阻止表单自动提交 e.preventDefault(); // 序列化表单数据 const formData = $(this).serialize(); $.ajax(&#123; url: &#x27;/info&#x27;, type: &#x27;POST&#x27;, data: formData, success: function (response) &#123; console.log(&#x27;Success:&#x27;, response); &#125;, error: function (xhr, status, error) &#123; console.error(&#x27;Error:&#x27;, error); &#125;, &#125;); &#125;); &#125;);&lt;/script&gt; 提交后浏览器会自动将请求头中的Content-Type属性设置为application/x-www-form-urlencoded类型。 2.3.2 复杂表单复杂表单的请求体为multipart/form-data类型，页面中form元素的enctype属性值设为multipart/form-data类型。 提交后会将数据通过分段的形式传递，只在请求方法是POST请求的时候生效，主要用于处理文件上传。 通过form元素请求接口： html1234567891011&lt;form action=&quot;/info&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;portrait&quot;&gt;头像：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;portrait&quot; name=&quot;portrait&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 通过form元素和AJAX请求接口： html123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;form id=&quot;infoForm&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;portrait&quot;&gt;头像：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;portrait&quot; name=&quot;portrait&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; $(document).ready(function () &#123; $(&#x27;#infoForm&#x27;).on(&#x27;submit&#x27;, function (e) &#123; // 阻止表单自动提交 e.preventDefault(); // 获取表单数据，不需要序列化 const formData = new FormData(this); $.ajax(&#123; url: &#x27;/info&#x27;, type: &#x27;POST&#x27;, data: formData, processData: false, // 不需要处理数据 contentType: false, // 不需要设置类型 success: function (response) &#123; console.log(&#x27;Success:&#x27;, response); &#125;, error: function (xhr, status, error) &#123; console.error(&#x27;Error:&#x27;, error); &#125;, &#125;); &#125;); &#125;);&lt;/script&gt; 提交后浏览器会自动将请求头中的Content-Type属性设置为multipart/form-data类型，同时设置分段用到的分隔符。 2.3.3 原生数据原生数据用于发送纯文本数据，需要手动设置数据类型，支持JSON&#x2F;XML&#x2F;HTML&#x2F;TXT等格式，不能通过页面中form元素提交，只能通过JS提交。 提交后会将数据通过JSON字符串的形式传递，只在请求方法是POST请求的时候生效，主要用于处理异步请求。 通过AJAX请求接口： html12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button id=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(document).ready(function () &#123; $(&#x27;#submit&#x27;).on(&#x27;click&#x27;, function (e) &#123; // 准备数据 const data = &#123; username: $(&#x27;#username&#x27;).val() &#125;; // 将数据转为JSON字符串 const jsonData = JSON.stringify(data); $.ajax(&#123; url: &#x27;/info&#x27;, type: &#x27;POST&#x27;, data: jsonData, contentType: &#x27;application/json&#x27;, // 设置类型为JSON类型 success: function (response) &#123; console.log(&#x27;Success:&#x27;, response); &#125;, error: function (xhr, status, error) &#123; console.error(&#x27;Error:&#x27;, error); &#125;, &#125;); &#125;); &#125;);&lt;/script&gt; 2.3.4 文件数据文件数据用于发送二进制文件数据，用于上传文件，只能通过JS提交。 提交后会将数据通过二进制的形式传递，只在请求方法是POST请求的时候生效，主要用于处理文件上传。 通过AJAX请求接口： html123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div&gt; &lt;label for=&quot;portrait&quot;&gt;头像：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;portrait&quot; name=&quot;portrait&quot;&gt; &lt;/div&gt; &lt;button id=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(document).ready(function () &#123; $(&#x27;#submit&#x27;).on(&#x27;click&#x27;, function (e) &#123; // 创建表单数据，添加上传文件 const formData = new FormData(); const fileInput = $(&#x27;#portrait&#x27;)[0]; formData.append(&#x27;portrait&#x27;, fileInput.files[0]); $.ajax(&#123; url: &#x27;/info&#x27;, type: &#x27;POST&#x27;, data: formData, processData: false, // 不需要处理数据 contentType: &#x27;application/octet-stream&#x27;, // 设置类型为二进制类型 success: function (response) &#123; console.log(&#x27;Success:&#x27;, response); &#125;, error: function (xhr, status, error) &#123; console.error(&#x27;Error:&#x27;, error); &#125;, &#125;); &#125;); &#125;);&lt;/script&gt; 2.4 响应结果接口处理数据后返回的结果。 通常包括三部分： 状态码：表示请求是否成功，比如200表示成功等。 响应头：包含额外信息，比如内容类型和编码等。 响应体：返回的具体数据，比如JSON格式的数据。 常见的状态码： 状态码 描述 含义 200 OK 请求成功，返回数据。 301 Moved Permanently 资源永久移动到新地址。 302 Found 资源临时移动到新地址。 304 Not Modified 资源未修改，使用缓存。 400 Bad Request 请求格式错误。 401 Unauthorized 请求未授权。 403 Forbidden 服务器拒绝访问。 404 Not Found 资源不存在。 500 Internal Server Error 服务器内部错误。 502 Bad Gateway 网关或代理收到无效响应。 503 Service Unavailable 服务器暂时不可用。 总结： 2xx：成功类状态码，表示请求已正确处理。 3xx：重定向类状态码，表示资源位置已改变。 4xx：客户端错误类状态码，表示请求存在问题。 5xx：服务器错误类状态码，表示服务器无法处理请求。 3 RESTfulRESTful是一种特殊风格的接口，主要特点有如下几个： 接口的请求地址表示资源，路径中不能有动词，结尾不能使用/符号。 接口的请求方法要与接口的处理逻辑对应。 接口的响应结果要与状态码对应。 建议规范： 获取资源统一为GET /resource-names/&#123;recourceId&#125;地址。 复杂查询统一为GET /resource-names?age=0,10&amp;name=,姓&amp;q=查询关键字&amp;page=1&amp;size=10地址。 创建资源统一为POST /resource-names地址，请求参数通过请求体使用JSON格式传递。 删除资源统一为DELETE /resource-names/&#123;recourceId&#125;地址。 更新资源统一为PUT /resource-names/&#123;recourceId&#125;地址。 其他操作统一为POST /resouce-names/&#123;resourceId&#125;/action-name地址。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"布局方式整理","slug":"C00-前端/C02-CSS/002-技巧/002-布局方式整理","date":"2025-04-06T00:37:55.000Z","updated":"2025-06-21T08:57:45.413Z","comments":true,"path":"posts/20250406/083755/","permalink":"https://momashanhe.com/posts/20250406/083755/","excerpt":"摘要：本文整理了几种常见的布局方式。","text":"摘要：本文整理了几种常见的布局方式。 1 静态布局特点：最为原始的布局方式。 场景：用于简单的页面，或者需要固定尺寸的模块，不需要根据屏幕尺寸变化调整。 原理：最简单的布局方式，不需要使用特别的技巧。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;静态布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; ul, ol &#123; list-style: none; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; &#125; /* 头部样式 */ header &#123; width: 100%; height: 80px; background-color: #333; color: white; display: flex; justify-content: center; align-items: center; border-bottom: 1px solid #222; &#125; /* 容器样式 */ .container &#123; width: 100%; display: flex; max-width: 1200px; margin: 0 auto; &#125; /* 侧边栏样式 */ .sidebar &#123; width: 250px; background-color: #444; color: white; padding: 20px; border-right: 1px solid #333; &#125; /* 主体内容样式 */ .main-content &#123; flex: 1; background-color: white; padding: 20px; &#125; /* 页脚样式 */ footer &#123; width: 100%; height: 60px; background-color: #333; color: white; display: flex; justify-content: center; align-items: center; border-top: 1px solid #222; margin-top: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;网站标题&lt;/h1&gt; &lt;/header&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 侧边栏 --&gt; &lt;div class=&quot;sidebar&quot;&gt; &lt;h3&gt;侧边栏&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;菜单一&lt;/li&gt; &lt;li&gt;菜单二&lt;/li&gt; &lt;li&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 主体内容 --&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;h2&gt;主要内容&lt;/h2&gt; &lt;p&gt;这是一个静态布局的示例页面。页面结构包括头部、侧边栏、主体内容和页脚。所有元素的尺寸都是固定的。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 静态布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 2 浮动布局特点：脱离文档流，方便进行图文混排和多列显示。 场景：用于图文混排的页面，以及需要多列布局场景。 原理：通过设置float属性进行浮动，需要在合适的元素上使用清除浮动，解决浮动塌陷等问题。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;浮动布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; &#125; /* 头部样式 */ header &#123; padding: 20px; background-color: #333; color: white; text-align: center; &#125; /* 容器样式 */ .container &#123; width: 100%; max-width: 1200px; margin: 0 auto; background-color: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); &#125; /* 主体内容样式 */ .main-content &#123; padding: 20px; &#125; /* 三列布局 */ .columns &#123; overflow: hidden; /* 清除浮动塌陷 */ &#125; .column &#123; float: left; width: 33.33%; /* 三列等宽 */ padding: 15px; box-sizing: border-box; &#125; .column:first-child &#123; background-color: #f0f0f0; &#125; .column:nth-child(2) &#123; background-color: #e0e0e0; &#125; .column:last-child &#123; background-color: #d0d0d0; &#125; /* 页脚样式 */ footer &#123; padding: 20px; background-color: #333; color: white; text-align: center; margin-top: 20px; &#125; /* 清除浮动 */ .clearfix::after &#123; content: &#x27;&#x27;; clear: both; display: table; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;浮动布局示例&lt;/h1&gt; &lt;/header&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;h2&gt;三列布局&lt;/h2&gt; &lt;p&gt;这是一个使用浮动布局实现的三列布局示例。&lt;/p&gt; &lt;/div&gt; &lt;!-- 三列布局 --&gt; &lt;div class=&quot;columns clearfix&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;h3&gt;第一列&lt;/h3&gt; &lt;p&gt;这是第一列的内容。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;h3&gt;第二列&lt;/h3&gt; &lt;p&gt;这是第二列的内容。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;h3&gt;第三列&lt;/h3&gt; &lt;p&gt;这是第三列的内容。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 浮动布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 3 定位布局特点：控制元素在页面上的位置，能够实现悬浮等效果。 场景：用于导航栏的固定显示，侧边广告的悬浮，弹框和模态框的显示。 原理：通过设置position属性实现不同的定位方式，进而控制元素的定位。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;定位布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; &#125; /* 头部样式 */ header &#123; padding: 20px; background-color: #333; color: white; text-align: center; &#125; /* 容器样式 */ .container &#123; width: 100%; max-width: 800px; margin: 0 auto; background-color: white; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); position: relative; /* 为绝对定位的子元素提供参考 */ min-height: 500px; &#125; /* 相对定位 */ .relative-box &#123; width: 600px; height: 240px; background-color: #e0e0e0; margin-bottom: 20px; padding: 10px; &#125; .relative-inner &#123; position: relative; top: -82px; left: 48px; width: 460px; background-color: #d0d0d0; padding: 10px; &#125; /* 绝对定位 */ .absolute-box &#123; width: 600px; height: 180px; background-color: #e0e0e0; margin-bottom: 20px; padding: 10px; &#125; .absolute-inner &#123; position: absolute; top: 410px; left: 78px; width: 460px; background-color: #d0d0d0; padding: 10px; &#125; /* 固定定位 */ .fixed-box &#123; position: fixed; top: 120px; right: 20px; background-color: #333; color: white; padding: 10px; z-index: 1000; /* 确保悬浮在其他内容之上 */ &#125; /* 粘性定位 */ .sticky-header &#123; position: sticky; top: 0; background-color: #444; color: white; margin-bottom: 20px; padding: 10px; z-index: 100; &#125; /* 内容区域 */ .content &#123; margin-top: 20px; padding: 20px; background-color: #f9f9f9; min-height: 200px; &#125; /* 按钮样式 */ .button &#123; padding: 10px 20px; background-color: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer; &#125; .button:hover &#123; background-color: #45a049; &#125; /* 页脚样式 */ footer &#123; padding: 20px; background-color: #333; color: white; text-align: center; margin-top: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;定位布局示例&lt;/h1&gt; &lt;/header&gt; &lt;!-- 固定定位 --&gt; &lt;div class=&quot;fixed-box&quot;&gt; &lt;button class=&quot;button&quot;&gt;固定定位&lt;/button&gt; &lt;/div&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 粘性定位 --&gt; &lt;div class=&quot;sticky-header&quot;&gt; &lt;h2&gt;粘性定位&lt;/h2&gt; &lt;p&gt;粘性定位的内容是固定的，不会随滚动条滚动。&lt;/p&gt; &lt;/div&gt; &lt;!-- 相对定位 --&gt; &lt;div class=&quot;relative-box&quot;&gt; &lt;h3&gt;相对定位&lt;/h3&gt; &lt;div&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;relative-inner&quot;&gt; &lt;h4&gt;相对定位&lt;/h4&gt; &lt;p&gt;这是一个相对定位的元素，相对于自身原始位置偏移。&lt;/p&gt; &lt;p&gt;相对定位会覆盖其他元素。&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;相对定位后面的元素不会占用上面相对定位元素的位置。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 绝对定位 --&gt; &lt;div class=&quot;absolute-box&quot;&gt; &lt;h3&gt;绝对定位&lt;/h3&gt; &lt;div&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;p&gt;被覆盖的内容。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;absolute-inner&quot;&gt; &lt;h4&gt;绝对定位&lt;/h4&gt; &lt;p&gt;这是一个绝对定位的元素，相对于最近的已定位父元素偏移。&lt;/p&gt; &lt;p&gt;父元素没有定位，相对于根元素偏移。&lt;/p&gt; &lt;p&gt;绝对定位会覆盖其他元素。&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;绝对定位后面的元素不会占用上面相对定位元素的位置。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 内容区域 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2&gt;内容区域&lt;/h2&gt; &lt;p&gt;这是一个内容区域，用于展示页面的主要内容。&lt;/p&gt; &lt;p&gt;你可以滚动页面查看粘性定位的效果。&lt;/p&gt; &lt;p&gt;尝试滚动页面，观察粘性定位的表头是否会固定在顶部。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 定位布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 4 弹性布局特点：能够灵活的实现页面上的布局，支持按照屏幕分辨率显示页面内容。 场景：适合处理动态内容和复杂对齐需求。 原理：通过设置display属性为flex开启弹性布局，通过相关属性控制页面元素。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;弹性布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; &#125; /* 头部样式 */ header &#123; padding: 20px; background-color: #333; color: white; text-align: center; &#125; /* 容器样式 */ .container &#123; width: 100%; max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); &#125; /* 主体内容样式 */ .main-content &#123; margin-top: 20px; &#125; /* 水平居中 */ .horizontal-center &#123; display: flex; justify-content: center; background-color: #f0f0f0; margin: 20px 0; &#125; .horizontal-center .item &#123; padding: 20px; background-color: #e0e0e0; margin: 0 10px; &#125; /* 垂直居中 */ .vertical-center &#123; display: flex; justify-content: center; align-items: center; height: 200px; background-color: #f0f0f0; margin: 20px 0; &#125; .vertical-center .item &#123; padding: 20px; background-color: #d0d0d0; margin: 0 10px; &#125; /* 等分布局 */ .space-between &#123; display: flex; justify-content: space-between; margin: 20px 0; &#125; .space-between .item &#123; padding: 20px; background-color: #e0e0e0; flex: 1; margin: 0 10px; &#125; /* 弹性布局 */ .flex-box &#123; display: flex; flex-wrap: wrap; margin: 20px 0; &#125; .flex-box .item &#123; padding: 20px; background-color: #e0e0e0; flex: 1 1 200px; /* 基础宽度为 200px，允许伸缩 */ margin: 10px; min-width: 150px; &#125; /* 页脚样式 */ footer &#123; padding: 20px; background-color: #333; color: white; text-align: center; margin-top: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;弹性布局示例&lt;/h1&gt; &lt;/header&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;!-- 水平居中 --&gt; &lt;h3&gt;水平居中&lt;/h3&gt; &lt;div class=&quot;horizontal-center&quot;&gt; &lt;div class=&quot;item&quot;&gt;项目一&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目二&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目三&lt;/div&gt; &lt;/div&gt; &lt;!-- 垂直居中 --&gt; &lt;h3&gt;垂直居中&lt;/h3&gt; &lt;div class=&quot;vertical-center&quot;&gt; &lt;div class=&quot;item&quot;&gt;项目一&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目二&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目三&lt;/div&gt; &lt;/div&gt; &lt;!-- 等分布局 --&gt; &lt;h3&gt;等分布局&lt;/h3&gt; &lt;div class=&quot;space-between&quot;&gt; &lt;div class=&quot;item&quot;&gt;项目一&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目二&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目三&lt;/div&gt; &lt;/div&gt; &lt;!-- 弹性布局 --&gt; &lt;h3&gt;弹性布局&lt;/h3&gt; &lt;div class=&quot;flex-box&quot;&gt; &lt;div class=&quot;item&quot;&gt;项目一&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目二&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目三&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;项目四&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 弹性布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 5 流体布局特点：能够按照屏幕的分辨率调整页面元素的宽度，保证整体布局不变，也称为栅栏系统。 场景：适合需要适配不同屏幕的场景。 原理：使用百分比定义宽度，配合min-width属性和max-width属性控制尺寸流动范围，尽可能的适应各种分辨率。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;流体布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; ul, ol &#123; list-style: none; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; &#125; /* 头部样式 */ header &#123; padding: 20px; background-color: #333; color: white; text-align: center; &#125; /* 容器样式 */ .container &#123; width: 100%; max-width: 1200px; margin: 0 auto; background-color: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); &#125; /* 主体内容样式 */ .main-content &#123; padding: 20px; &#125; /* 流体布局 */ .fluid-layout &#123; display: flex; flex-wrap: wrap; &#125; .sidebar-left &#123; width: 20%; padding: 15px; background-color: #f0f0f0; &#125; .content &#123; width: 60%; padding: 15px; background-color: #fff; &#125; .sidebar-right &#123; width: 20%; padding: 15px; background-color: #e0e0e0; &#125; /* 响应式调整 */ @media (max-width: 768px) &#123; .sidebar, .content, .sidebar-right &#123; width: 100%; &#125; &#125; /* 页脚样式 */ footer &#123; padding: 20px; background-color: #333; color: white; text-align: center; margin-top: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;流体布局示例&lt;/h1&gt; &lt;/header&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;h2&gt;流体布局&lt;/h2&gt; &lt;p&gt;以下展示了流体布局的实现方式，元素的宽度基于百分比，可以自适应不同的屏幕尺寸。&lt;/p&gt; &lt;!-- 流体布局 --&gt; &lt;div class=&quot;fluid-layout&quot;&gt; &lt;div class=&quot;sidebar-left&quot;&gt; &lt;h3&gt;左侧边栏&lt;/h3&gt; &lt;p&gt;这是一个左侧的侧边栏。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;菜单一&lt;/li&gt; &lt;li&gt;菜单二&lt;/li&gt; &lt;li&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;h3&gt;主要内容&lt;/h3&gt; &lt;p&gt;这是一个流体布局的示例。流体布局通过设置元素的宽度为百分比来实现自适应效果。&lt;/p&gt; &lt;p&gt;当浏览器窗口大小改变时，元素的宽度会自动调整，以适应不同的屏幕尺寸。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;sidebar-right&quot;&gt; &lt;h3&gt;右侧边栏&lt;/h3&gt; &lt;p&gt;这是一个右侧的侧边栏。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;菜单一&lt;/li&gt; &lt;li&gt;菜单二&lt;/li&gt; &lt;li&gt;菜单三&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 流体布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 6 响应式布局特点：能够兼容多个终端，解决不同设备上页面的显示问题。 场景：适合在多个终端展示页面的场景。 原理：通过设置@media属性进行媒体查询，以及与网格系统配合进行布局。 示例： html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;响应式布局示例&lt;/title&gt; &lt;style&gt; /* 重置默认样式 */ * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; &#125; /* 头部样式 */ header &#123; padding: 20px; background-color: #333; color: white; text-align: center; &#125; /* 容器样式 */ .container &#123; width: 100%; max-width: 1200px; margin: 0 auto; background-color: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); &#125; /* 主体内容样式 */ .main-content &#123; padding: 20px; &#125; /* 导航栏样式 */ nav &#123; background-color: #444; padding: 10px; &#125; nav ul &#123; list-style-type: none; display: flex; justify-content: center; &#125; nav ul li &#123; margin: 0 15px; &#125; nav ul li a &#123; color: white; text-decoration: none; &#125; /* 卡片布局 */ .card-container &#123; display: flex; flex-wrap: wrap; justify-content: space-between; margin: 20px 0; &#125; .card &#123; width: calc(33.33% - 20px); margin: 10px; padding: 20px; background-color: #f0f0f0; border-radius: 5px; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1); &#125; /* 响应式调整 */ @media (max-width: 768px) &#123; .card &#123; width: calc(50% - 20px); &#125; nav ul &#123; flex-direction: column; align-items: center; &#125; nav ul li &#123; margin: 5px 0; &#125; &#125; @media (max-width: 480px) &#123; .card &#123; width: 100%; &#125; header h1 &#123; font-size: 1.5rem; &#125; &#125; /* 页脚样式 */ footer &#123; padding: 20px; background-color: #333; color: white; text-align: center; margin-top: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;h1&gt;响应式布局示例&lt;/h1&gt; &lt;/header&gt; &lt;!-- 导航栏 --&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;!-- 容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;h2&gt;响应式布局&lt;/h2&gt; &lt;p&gt;以下展示了响应式布局的实现方式，页面会根据屏幕尺寸自动调整布局。&lt;/p&gt; &lt;!-- 卡片布局 --&gt; &lt;div class=&quot;card-container&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;h3&gt;卡片一&lt;/h3&gt; &lt;p&gt;这是一个响应式卡片。在大屏幕上并排显示，在小屏幕上堆叠显示。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;h3&gt;卡片二&lt;/h3&gt; &lt;p&gt;这是一个响应式卡片。在大屏幕上并排显示，在小屏幕上堆叠显示。&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;h3&gt;卡片三&lt;/h3&gt; &lt;p&gt;这是一个响应式卡片。在大屏幕上并排显示，在小屏幕上堆叠显示。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页脚 --&gt; &lt;footer&gt; &lt;p&gt;© 响应式布局示例&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"Bootstrap","slug":"C00-前端/C02-CSS/004-框架/001-Bootstrap","date":"2025-04-04T22:20:36.000Z","updated":"2025-06-21T08:57:45.600Z","comments":true,"path":"posts/20250405/062036/","permalink":"https://momashanhe.com/posts/20250405/062036/","excerpt":"摘要：本文学习了如何使用Bootstrap框架，了解了栅格系统的原理。","text":"摘要：本文学习了如何使用Bootstrap框架，了解了栅格系统的原理。 环境 Windows 10 企业版 LTSC 21H2Bootstrap 3.4.1 1 简介Bootstrap是一个开源的前端UI框架，用于快速开发响应式网站和Web应用。 Bootstrap基于HTML、CSS和JS，提供了丰富的样式、组件和插件，帮助开发者快速构建美观且功能强大的界面。 Bootstrap具有以下特点： 响应式布局：能够自适应不同设备的屏幕尺寸，如手机、平板和桌面电脑等，确保网页在各种设备上都能呈现出良好的视觉效果和用户体验。 丰富的组件：包含了大量的预定义组件，如导航栏、按钮、表单、模态框、轮播图等，开发者可以直接使用这些组件，快速搭建网页界面，提高开发效率。 社区支持强大：拥有庞大且活跃的社区，开发者可以在社区中找到丰富的资源、插件和教程，也可以分享自己的经验和成果，遇到问题时能够得到及时的帮助和解决方案。 跨浏览器兼容：支持主流浏览器，确保网页在不同浏览器上都能正常显示和运行，减少了开发者处理浏览器兼容性问题的工作量。 官方网址： 官网主站 V3文档 V4文档 V5文档 本文使用的是3.4.1版本： 支持IE8+浏览器。 依赖JQuery，需要先引入JQuery。 使用的CSS预编译器是Less。 2 引入2.1 通过CDN链接引入在HTML文件的head元素中引入： html123456&lt;!-- 引入CSS文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css&quot;&gt;&lt;!-- 引入JQuery文件 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入JS文件 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 2.2 通过本地文件引入下载地址：在GitHub上下载3.4.1版本 文件中包含dist的是编译后的文件，不包含源码，体积小，用于部署到生产环境。 解压后目录说明： css文件夹：放置样式文件。 js文件夹：放置脚本文件，其中的npm.js文件只在编译时使用。 fonts文件夹：放置图标字体库。 3 原理3.1 容器3.1.1 流体容器使用class属性为container-fluid的元素，使用默认宽度，占据整行。 样式： css123456.container-fluid &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125; 流体容器类似于width: 100%;样式，占据全部视口，使用场景较少。 3.1.2 固定容器使用class属性为container的元素，使用媒体查询控制宽度，不会占据整行。 样式： css123456789101112131415161718192021@media (min-width: 1200px) &#123; .container &#123; width: 1170px; &#125;&#125;@media (min-width: 992px) &#123; .container &#123; width: 970px; &#125;&#125;@media (min-width: 768px) &#123; .container &#123; width: 750px; &#125;&#125;.container &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125; 一般使用固定容器，支持响应式布局，很少使用流体容器。 3.2 栅格系统3.2.1 简介栅格系统用于通过一系列的行（row）与列（col）的组合来创建页面布局，可以将内容放入这些创建好的布局中。 栅格系统的基本组成部分： Container：用于包裹整个栅格系统的容器，可以分为流体容器和固定容器。 Row：栅格行，用于包含列元素，并确保列在水平排列时正确对齐。 Col：栅格列，负责实际内容的显示，每一行最多可以包含12列，不足会保持空白，超出会自动换行。 3.2.2 断点断点类似固定容器里的阈值： 断点缩写 屏幕类型 宽度范围 xs 超小屏幕 小于768px sm 小屏幕 小于992px md 中屏幕 小于1200px lg 大屏幕 小于1400px xl 超大屏幕 大于等于1400px 3.2.3 响应式列使用class属性为row的元素表示行，使用class属性为col-断点-跨度的元素表示列。 示例： html123456789101112&lt;div class=&quot;container&quot;&gt; &lt;!-- 在小屏幕及以上的屏幕分为8份和4份，其他屏幕分为12份和12份 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-8&quot;&gt;col-sm-8&lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt;col-sm-4&lt;/div&gt; &lt;/div&gt; &lt;!-- 在中屏幕及以上的屏幕分为8份和4份，其他屏幕分为12份和12份 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.2.4 列偏移设置class属性为col-断点-offset-跨度控制将元素从左侧向右补充的跨度。 示例： html123456789101112&lt;div class=&quot;container&quot;&gt; &lt;!-- 不使用偏移 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;!-- 使用偏移 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-4 col-md-offset-2&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.2.5 列排序设置class属性为col-断点-方式-跨度控制元素的顺序： 方式 说明 push 控制将元素从左侧向右推的跨度 pull 控制将元素从左侧向右拉的跨度 示例： html123456789101112&lt;div class=&quot;container&quot;&gt; &lt;!-- 不使用排序 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;!-- 使用排序 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8 col-md-push-4&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4 col-md-pull-8&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.2.6 列嵌套支持在外层的列嵌套内层的列，内层同样分为12列。 示例： html123456789101112131415161718&lt;div class=&quot;container&quot;&gt; &lt;!-- 不使用嵌套 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;!-- 外层嵌套 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;!-- 内层嵌套 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4 样式4.1 表格4.1.1 基础样式在table元素上添加table类名，效果是增加水平分隔线。 示例： html12&lt;table class=&quot;table&quot;&gt;&lt;/table&gt; 4.1.2 条纹样式在table元素上添加table-striped类名，效果是增加条纹样式。 示例： html12&lt;table class=&quot;table table-striped&quot;&gt;&lt;/table&gt; 4.1.3 悬停样式在table元素上添加table-hover类名，效果是增加悬停样式。 示例： html12&lt;table class=&quot;table table-hover&quot;&gt;&lt;/table&gt; 4.2 表单4.2.1 基础表单在div元素上添加form-group类名，用于包含label元素和表单元素。 示例： html1234567&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;账户：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 在表单元素上添加form-control类名，设置默认width: 100%;样式。 示例： html1&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; 4.2.2 内联表单在form元素上添加form-inline类名，将表单元素变为inline-block级别，设置width: auto;样式，并使其内容左对齐。 示例： html1234567&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;账户：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 添加外层div元素，包含多个添加form-group类名的内层div元素。 在外层div元素上添加form-inline类名，将内层div元素变为inline-block级别。 在外层div元素上添加row类名，在内层div元素使用栅格系统控制每行显示的表单数量。 示例： html1234567891011121314151617181920212223&lt;form&gt; &lt;div class=&quot;form-inline row&quot;&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;username&quot;&gt;账户：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;sex&quot;&gt;性别：&lt;/label&gt; &lt;select class=&quot;form-control&quot; id=&quot;sex&quot; name=&quot;sex&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-inline row&quot;&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;address&quot;&gt;住址：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;address&quot; name=&quot;address&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 4.2.3 水平表单在form元素上添加form-horizontal类名，使用div元素包含表单元素，在label元素和div元素上使用栅格系统控制每行显示的表单数量。 示例： html123456789101112131415161718192021222324252627&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;username&quot; class=&quot;col-sm-2&quot;&gt;账户：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;sex&quot; class=&quot;col-sm-2&quot;&gt;性别：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;select class=&quot;form-control&quot; id=&quot;sex&quot; name=&quot;sex&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;label for=&quot;address&quot; class=&quot;col-sm-2&quot;&gt;住址：&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;address&quot; name=&quot;address&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group col-sm-6&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 4.3 按钮给某些元素添加btn类名，可以使用按钮样式： html1234&lt;a class=&quot;btn btn-default&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;链接&lt;/a&gt;&lt;button class=&quot;btn btn-default&quot; type=&quot;submit&quot;&gt;按钮&lt;/button&gt;&lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; value=&quot;表单按钮&quot;&gt;&lt;input class=&quot;btn btn-default&quot; type=&quot;submit&quot; value=&quot;表单提交&quot;&gt; 按钮支持的样式： html1234567&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;默认样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;首选样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;成功样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;提示样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;警告样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;危险样式&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;链接样式&lt;/button&gt; 按钮尺寸： html1234&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot;&gt;大按钮&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-sm&quot;&gt;小按钮&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot;&gt;超小按钮&lt;/button&gt; 4.4 辅助类4.4.1 显示或隐藏内容在块级元素上可以使用show类名和hidden类名设置元素显示和隐藏： html123456&lt;div class=&quot;show&quot;&gt; &lt;p&gt;显示&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;hidden&quot;&gt; &lt;p&gt;隐藏&lt;/p&gt;&lt;/div&gt; 4.4.2 浮动使用pull-left类名和pull-right类名设置元素向左浮动和向右浮动： html123456&lt;div class=&quot;pull-left&quot;&gt; &lt;p&gt;向左浮动&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;pull-right&quot;&gt; &lt;p&gt;向右浮动&lt;/p&gt;&lt;/div&gt; 使用clearfix类名设置父元素用于清除浮动： html12&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; 4.5 响应工具根据断点显示： html123456789101112&lt;div class=&quot;visible-xs&quot;&gt; &lt;p&gt;超小屏幕显示&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;visible-sm&quot;&gt; &lt;p&gt;小屏幕显示&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;visible-md&quot;&gt; &lt;p&gt;中屏幕显示&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;visible-lg&quot;&gt; &lt;p&gt;大屏幕显示&lt;/p&gt;&lt;/div&gt; 根据断点隐藏： html123456789101112&lt;div class=&quot;hidden-xs&quot;&gt; &lt;p&gt;超小屏幕隐藏&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;hidden-sm&quot;&gt; &lt;p&gt;小屏幕隐藏&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;hidden-md&quot;&gt; &lt;p&gt;中屏幕隐藏&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;hidden-lg&quot;&gt; &lt;p&gt;大屏幕隐藏&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Less","slug":"Less","permalink":"https://momashanhe.com/tags/Less/"}]},{"title":"使用MongoDB数据库","slug":"C00-前端/C04-Node/003-数据库/002-使用MongoDB数据库","date":"2025-04-01T05:22:06.000Z","updated":"2025-06-21T08:57:43.267Z","comments":true,"path":"posts/20250401/132206/","permalink":"https://momashanhe.com/posts/20250401/132206/","excerpt":"摘要：本文学习了如何在Node中使用MongoDB数据库。","text":"摘要：本文学习了如何在Node中使用MongoDB数据库。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12MongoDB 6.0.21Mongoose 8.13.1 1 介绍Mongoose是一个对象文档模型库，通过Mongoose可以更方便的在Node中操作MongoDB数据库。 官网地址：http://www.mongoosejs.net/ 2 安装使用npm install mongoose命令安装。 3 连接有两种方式建立连接： 全局连接独立连接语法： js1234// 建立连接mongoose.connect(&#x27;mongodb://username:password@host:port/database?options&#x27;)// 关闭连接mongoose.connection.close() 参数： mongodb：标识标准连接格式。 username：用户名，可选。 password：密码，可选。 host：域名或IP地址。 port：端口，可选，默认为27017端口。 database：要连接的数据库。 options：选项，可选。 示例： js1234567891011121314151617// 引入模块const mongoose = require(&#x27;mongoose&#x27;);// 建立连接mongoose.connect(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 执行操作async function execExample() &#123; try &#123; // 执行CRUD操作 &#125; catch (err) &#123; // 打印错误 console.error(&quot;执行失败: &quot; + err); &#125; finally &#123; // 关闭连接 mongoose.connection.close(); &#125;&#125;execExample(); 使用connect()方法返回的Promise对象处理连接错误： js12345// 引入模块const mongoose = require(&#x27;mongoose&#x27;);// 建立连接mongoose.connect(&#x27;mongodb://127.0.0.1:27017/test&#x27;) .catch(err =&gt; console.log(&quot;连接失败: &quot; + err)); 回调事件： js1234567891011121314// 建立连接失败时执行mongoose.connection.on(&#x27;error&#x27;, err =&gt; console.log(&#x27;error: &#x27; + err));// 建立连接时和重新连接时执行，可能会执行多次mongoose.connection.on(&#x27;connected&#x27;, () =&gt; console.log(&#x27;connected&#x27;));// 建立连接时和重新连接时执行，可能会执行多次mongoose.connection.on(&#x27;open&#x27;, () =&gt; console.log(&#x27;open&#x27;));// 丢失连接时和关闭连接时执行，可能会执行多次mongoose.connection.on(&#x27;disconnected&#x27;, () =&gt; console.log(&#x27;disconnected&#x27;));// 重新连接时执行mongoose.connection.on(&#x27;reconnected&#x27;, () =&gt; console.log(&#x27;reconnected&#x27;));// 关闭连接时执行mongoose.connection.on(&#x27;disconnecting&#x27;, () =&gt; console.log(&#x27;disconnecting&#x27;));// 关闭连接时执行mongoose.connection.on(&#x27;close&#x27;, () =&gt; console.log(&#x27;close&#x27;));语法： js1234// 建立连接const conn = mongoose.createConnection(&#x27;mongodb://username:password@host:port/database?options&#x27;)// 关闭连接conn.close() 参数： mongodb：标识标准连接格式。 username：用户名，可选。 password：密码，可选。 host：域名或IP地址。 port：端口，可选，默认为27017端口。 database：要连接的数据库。 options：选项，可选。 示例： js1234567891011121314151617// 引入模块const mongoose = require(&#x27;mongoose&#x27;);// 建立连接const conn = mongoose.createConnection(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 执行操作async function execExample() &#123; try &#123; // 执行CRUD操作 &#125; catch (err) &#123; // 打印错误 console.error(&quot;执行失败: &quot; + err); &#125; finally &#123; // 关闭连接 conn.close(); &#125;&#125;execExample(); 回调事件： js1234567891011121314// 建立连接失败时执行conn.on(&#x27;error&#x27;, err =&gt; console.log(&#x27;error: &#x27; + err));// 建立连接时和重新连接时执行，可能会执行多次conn.on(&#x27;connected&#x27;, () =&gt; console.log(&#x27;connected&#x27;));// 建立连接时和重新连接时执行，可能会执行多次conn.on(&#x27;open&#x27;, () =&gt; console.log(&#x27;open&#x27;));// 丢失连接时和关闭连接时执行，可能会执行多次conn.on(&#x27;disconnected&#x27;, () =&gt; console.log(&#x27;disconnected&#x27;));// 重新连接时执行conn.on(&#x27;reconnected&#x27;, () =&gt; console.log(&#x27;reconnected&#x27;));// 关闭连接时执行conn.on(&#x27;disconnecting&#x27;, () =&gt; console.log(&#x27;disconnecting&#x27;));// 关闭连接时执行conn.on(&#x27;close&#x27;, () =&gt; console.log(&#x27;close&#x27;)); 如果只有一个数据库，建议使用独立连接。 4 模式（Schema）4.1 概念使用模式映射集合，模式中属性的模式类型对应文档中属性的类型。 4.2 模式类型模式类型用于定义模型中字段的数据类型，可以自定义类型。 语法： js123456new mongoose.Schema(&#123; 属性名: &#123; type: 模式类型, 选项名: 选项值 &#125;&#125;) 如果没有选项，可以简写： js123new mongoose.Schema(&#123; 属性名: 模式类型&#125;) 常见模式类型： String：字符串类型。 Number：数字类型。 Date：日期类型。 Buffer：二进制数据类型。 Boolean：布尔类型。 Mixed：混合类型。 ObjectId：对象ID类型，通常用于唯一标识符。 Array：数组类型。 特殊模式类型： Map：映射类型。 UUID：通用唯一标识符类型。 BigInt：大整数类型。 Double：64位浮点数类型。 Int32：32位整数类型。 Decimal128：128位浮点数类型。 4.3 模式类型选项模式类型选项用于对模式类型进行处理和验证，可以同时设置多个选项，也可以自定义选项。 4.3.1 required适用于所有模式类型。 类型为布尔值或函数，支持返回错误消息。 作用是指定是否必填，默认为false，true表示必填，false表示非必填。 示例： js123const userSchema = new mongoose.Schema(&#123; name: &#123; type: String, required: [true, &#x27;属性不能为空: name&#x27;] &#125;&#125;); 4.3.2 default适用于所有模式类型。 类型为任何值或函数。 作用是指定字段默认值，默认为null。 示例： js123const userSchema = new mongoose.Schema(&#123; age: &#123; type: Number, default: 18 &#125;&#125;); 4.3.3 select适用于所有模式类型。 类型为布尔值。 作用是指定是否在查询时默认返回字段，默认为true，true表示返回，false表示不返回。 示例： js123const userSchema = new mongoose.Schema(&#123; password: &#123; type: String, select: false &#125;&#125;); 4.3.3 validate适用于所有模式类型。 类型为对象。 作用是指定字段的验证对象。 示例： js123456789101112const emailValidator = &#123; validator: function(v) &#123; return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v); &#125;, message: props =&gt; `邮箱地址错误: $&#123;props.value&#125;`&#125;;const userSchema = new mongoose.Schema(&#123; email: &#123; type: String, validate: emailValidator &#125;&#125;); 5 模型（Model）模型是从模式编译而来的奇特构造函数，负责管理文档。 文档是模型的实例，通过模型创建文档。 语法： js1const 模型 = 连接实例.model(模型名, 模式对象实例, 集合名) 说明： 全局连接和独立连接的连接实例不一样。 集合名可以省略，默认使用模型名的小写复数。 根据连接方式的不同，使用模型的方式也不同： 全局连接独立连接在全局连接中使用模型： js123456// 建立连接mongoose.connect(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 创建模式const userSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;);// 创建模型，集合名为usersconst userModel = mongoose.model(&#x27;User&#x27;, userSchema);在独立连接中使用模型： js123456// 建立连接const conn = mongoose.createConnection(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 创建模式const userSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;);// 创建模型，集合名为usersconst userModel = conn.model(&#x27;User&#x27;, userSchema); 6 文档（Document）6.1 插入插入文档： js12345678userModel.insertOne(&#123; name: &quot;张三&quot; &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.2 查询查询文档： js12345678userModel.findOne(&#123; name: &quot;张三&quot; &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.3 删除删除文档： js12345678userModel.deleteOne(&#123; name: &quot;张三&quot; &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.4 更新更新文档： js12345678userModel.updateOne(&#123; name: &quot;张三&quot; &#125;, &#123; name: &quot;李四&quot; &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 在执行操作时，建议通过await在async方法中执行，保证执行顺序，避免异步带来的问题。 6.5 查询优化6.5.1 排序使用sort()方法实现排序： js12345678910userModel.find(&#123; age: &#123; $gt: 10 &#125; &#125;).sort(&#123; age: 1 &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.5.2 分页使用skip()方法和limit()方法实现分页： js1234567891011userModel.find(&#123; age: &#123; $gt: 10 &#125; &#125;).skip(1).limit(2).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.5.3 投影使用select()方法实现投影： js12345678910userModel.find(&#123; age: &#123; $gt: 10 &#125; &#125;).select(&#123; _id: 0, name: 1, age: 1 &#125;).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 6.5.4 聚合使用aggregate()方法实现聚合： js123456789101112131415userModel.aggregate([ &#123; $match: &#123; age: &#123; $gt: 10 &#125; &#125; &#125;, &#123; $project: &#123; _id: 0, name: 1, age: 1 &#125;&#125;, &#123; $sort: &#123; age: 1 &#125; &#125;, &#123; $skip: 1 &#125;, &#123; $limit: 2 &#125;]).then( data =&gt; &#123; console.log(&quot;执行成功: &quot; + JSON.stringify(data)); &#125;, err =&gt; &#123; console.error(&quot;执行失败: &quot; + err); &#125;); 7 事务使用事务需要开启副本集，否则会报错。 根据连接方式的不同，使用事务的方式也不同： 全局连接独立连接在全局连接中使用事务： js123456789101112131415161718192021222324252627282930313233343536// 引入模块const mongoose = require(&#x27;mongoose&#x27;);// 建立连接mongoose.connect(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 创建模式const userSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;);// 创建模型，集合名为usersconst userModel = mongoose.model(&#x27;User&#x27;, userSchema);// 执行操作async function execSelect() &#123; // 创建会话 const session = await mongoose.startSession(); try &#123; // 开始事务 await session.startTransaction(); // 执行操作 await userModel.insertOne(&#123; name: &quot;张三&quot; &#125;, &#123; session: session &#125;); await userModel.insertOne(&#123; name: &quot;李四&quot; &#125;, &#123; session: session &#125;); // 模拟错误 if (user) &#123; throw new Error(&#x27;操作异常&#x27;); &#125; // 提交事务 await session.commitTransaction(); &#125; catch (err) &#123; console.error(&quot;执行失败: &quot; + err); // 回滚事务 await session.abortTransaction(); &#125; finally &#123; // 结束事务 session.endSession(); // 关闭连接 mongoose.connection.close(); &#125;&#125;execSelect();在独立连接中使用事务： js12345678910111213141516171819202122232425262728293031323334353637// 引入模块const mongoose = require(&#x27;mongoose&#x27;);// 建立连接const conn = mongoose.createConnection(&#x27;mongodb://127.0.0.1:27017/test&#x27;);// 创建模式const userSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;);// 创建模型，集合名为usersconst userModel = conn.model(&#x27;User&#x27;, userSchema);// 执行操作async function execSelect() &#123; // 创建会话 const session = await conn.startSession(); try &#123; // 开始事务 await session.startTransaction(); // 执行操作 await userModel.insertOne(&#123; name: &quot;张三&quot; &#125;, &#123; session: session &#125;); await userModel.insertOne(&#123; name: &quot;李四&quot; &#125;, &#123; session: session &#125;); // 模拟错误 if (user) &#123; // ReferenceError: user is not defined throw new Error(&#x27;操作异常&#x27;); &#125; // 提交事务 await session.commitTransaction(); &#125; catch (err) &#123; console.error(&quot;执行失败: &quot; + err); // 回滚事务 await session.abortTransaction(); &#125; finally &#123; // 结束事务 session.endSession(); // 关闭连接 conn.close(); &#125;&#125;execSelect(); 8 钩子钩子是十分重要的函数，它可以用来控制对数据的访问以及修改，包括数据的CURD等操作。 钩子函数主要分为两种类型： 预处理钩子（Pre Hooks）：在执行各种数据库操作之前执行。 后处理钩子（Post Hooks）：在执行各种数据库操作之后执行。 在使用钩子函数时，可以定义多个钩子函数，并以串联的方式依次执行，以达到特定的业务逻辑目的。 需要在创建模型前设置： js123456789101112131415161718192021222324// 创建模式const userSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;);// 预处理钩子函数AuserSchema.pre(&#x27;deleteOne&#x27;, (next) =&gt; &#123; console.log(&#x27;预处理钩子函数A&#x27;); next();&#125;);// 预处理钩子函数BuserSchema.pre(&#x27;deleteOne&#x27;, (next) =&gt; &#123; console.log(&#x27;预处理钩子函数B&#x27;); next();&#125;);// 后处理钩子函数AuserSchema.post(&#x27;deleteOne&#x27;, (docs, next) =&gt; &#123; console.log(&#x27;后处理钩子函数A docs: &#x27; + JSON.stringify(docs)); next();&#125;);// 后处理钩子函数BuserSchema.post(&#x27;deleteOne&#x27;, (docs, next) =&gt; &#123; console.log(&#x27;后处理钩子函数B docs: &#x27; + JSON.stringify(docs)); next();&#125;);// 创建模型，集合名为usersconst userModel = mongoose.model(&#x27;User&#x27;, userSchema);","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"分片","slug":"E00-数据库/E01-MongoDB/002-高级/003-分片","date":"2025-03-30T18:24:12.000Z","updated":"2025-06-21T09:07:49.530Z","comments":true,"path":"posts/20250331/022412/","permalink":"https://momashanhe.com/posts/20250331/022412/","excerpt":"摘要：本文学习了什么是分片，以及如何配置简单的分片集群。","text":"摘要：本文学习了什么是分片，以及如何配置简单的分片集群。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 介绍1.1 背景服务上线后，由于用户数量和业务规模的增长，对数据存储空间的需求也越来越大。有两种方法可解决系统增长问题： 垂直扩展（Vertical Scaling）意味着增加单个服务器的容量，例如使用更强大的CPU，添加更多RAM或增加存储空间量，可用技术所存在的限制可能会导致单个机器对给定工作负载来说不够强大。此外，基于云的提供商存在基于可用硬件配置的硬上限。因此，垂直扩展存在实际的最大值。 水平扩展（Horizontal Scaling）意味着划分系统数据集并加载多个服务器，添加其他服务器以根据需要增加容量。虽然单个机器的总体速度或容量可能不高，但每台机器处理整个工作负载的子集，可能提供比单个高速大容量服务器更高的效率。扩展部署容量只需要根据需要添加额外的服务器，这可能比单个机器的高端硬件的总体成本更低。但代价在于它会增大部署的基础设施与维护的复杂性。 1.2 概念分片（Sharding）是指将数据拆分，将其分散存在不同的机器上的过程，有时也用分区（Partitioning）来表示这个概念。将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载。 MongoDB支持通过分片进行水平扩展。 2 组成MongoDB的分片集群（Sharded Cluster）由以下组件构成： 分片服务器（Shard） 配置服务器（Conﬁg Server） 路由服务器（Router） 2.1 分片服务器（Shard Server）存储分片集群中分片数据的子集，集群的分片服务器共同保存集群的整个数据集，分片服务器必须部署为副本集。 2.2 配置服务器（Conﬁg Server）存储分片集群的元数据和配置设置，配置服务器必须部署为副本集： 元数据反映了分片集群内所有数据和组件的状态和组织，包括每个分片上的数据段列表以及定义数据段的范围。 配置信息保存了访问控制和身份验证设置，需要将admin数据库和config数据库存在配置服务器上。 每个分片集群必须拥有自己的配置服务器，请勿对不同的分片集群使用相同的配置服务器。 配置服务器副本集（Config Server Replica Set，CSRS）有以下限制： 不能有仲裁节点。 不得包含延迟节点。 必须构建索引，即buildIndexes都应为false。 2.3 路由服务器（Router Server）路由服务器通常由mongos实例实现，负责将客户端的请求转发到正确的分片，并汇总各个分片的响应结果返回给客户端。 路由服务器会定时缓存配置服务器的元数据，用于查询请求的分片键，通过分片键转发到对应的分片。 路由服务器的工作流程可以分为以下几个步骤： 接收客户端的请求。 根据缓存的元数据查询分片键，确定请求应该发送到哪个分片。 将请求分发到相应的分片。 汇总各个分片的响应结果，并将最终结果返回给客户端。 3 架构建议生产配置： 部署多个路由服务器。 部署3个或以上配置服务器副本集。 部署3个或以上分片服务器副本集。 建议开发配置： 部署一个路由服务器。 部署1个配置服务器副本集。 部署1个分片服务器副本集。 4 配置配置2个分片服务器副本集，采用1主节点1从节点1仲裁节点的配置。 配置1个配置服务器副本集，不能使用仲裁节点，采用1主节点2从节点配置。 配置1个路由服务器，使用mongos服务，不是mongod服务。 4.1 第1个分片服务器副本集4.1.1 创建节点创建目录，修改mongod.conf配置文件，修改目录位置和端口，增加副本集和分片角色的配置： mongod.conf1234567replication: # 副本集的名称 replSetName: srs01sharding: # 分片角色 shardsvr-分片服务器 configsvr-配置服务器 clusterRole: shardsvr 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd123mongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs01_27001\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs01_27002\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs01_27003\\mongod.conf 4.1.2 配置副本集连接节点： cmd1mongosh.exe mongodb://127.0.0.1:27001 启动副本集： cmd1rs.initiate() 添加从节点： cmd1rs.add(&quot;127.0.0.1:27002&quot;) 明确设置默认写关注： cmd123456db.adminCommand(&#123; &quot;setDefaultRWConcern&quot;: 1, &quot;defaultWriteConcern&quot;: &#123; &quot;w&quot;: &quot;majority&quot; &#125;&#125;) 添加仲裁节点： cmd1rs.addArb(&quot;127.0.0.1:27003&quot;) 4.2 第2个分片服务器副本集4.2.1 创建节点创建目录，修改mongod.conf配置文件，修改目录位置和端口，增加副本集和分片角色的配置： mongod.conf1234567replication: # 副本集的名称 replSetName: srs02sharding: # 分片角色 shardsvr-分片服务器 configsvr-配置服务器 clusterRole: shardsvr 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd123mongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs02_27004\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs02_27005\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\srs02_27006\\mongod.conf 4.2.2 配置副本集连接节点： cmd1mongosh.exe mongodb://127.0.0.1:27004 启动副本集： cmd1rs.initiate() 添加从节点： cmd1rs.add(&quot;127.0.0.1:27005&quot;) 明确设置默认写关注： cmd123456db.adminCommand(&#123; &quot;setDefaultRWConcern&quot;: 1, &quot;defaultWriteConcern&quot;: &#123; &quot;w&quot;: &quot;majority&quot; &#125;&#125;) 添加仲裁节点： cmd1rs.addArb(&quot;127.0.0.1:27006&quot;) 4.3 配置服务器副本集4.3.1 创建节点创建目录，修改mongod.conf配置文件，修改目录位置和端口，增加副本集和分片角色的配置： mongod.conf1234567replication: # 副本集的名称 replSetName: csrssharding: # 分片角色 shardsvr-分片服务器 configsvr-配置服务器 clusterRole: configsvr 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd123mongod.exe -f D:\\Home\\momashanhe\\mongodb\\csrs_27007\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\csrs_27008\\mongod.confmongod.exe -f D:\\Home\\momashanhe\\mongodb\\csrs_27009\\mongod.conf 4.3.2 配置副本集连接节点： cmd1mongosh.exe mongodb://127.0.0.1:27007 启动副本集： cmd1rs.initiate() 添加从节点： cmd12rs.add(&quot;127.0.0.1:27008&quot;)rs.add(&quot;127.0.0.1:27009&quot;) 4.4 路由服务器4.4.1 配置路由创建router_27010目录，在目录下创建log目录和mongos.conf配置文件： mongos.conf12345678910111213141516171819# mongos.confsystemLog: # 日志输出目的地，表示输出到日志文件，如果不指定，则会输出到标准输出中 destination: file # 日志路径，启动后自动创建 path: D:\\Home\\momashanhe\\mongodb\\router_27010\\log\\mongos.log # 重启后如何记录日志，如果为true则将日志添加到尾部，如果为false则备份日志并创建新文件，默认为false logAppend: truenet: # 设置MongoDB的端口 port: 27010 # 设置可以访问的ip地址，多个用逗号分隔 bindIp: 127.0.0.1sharding: # 配置节点的配置服务器副本集 configDB: csrs/127.0.0.1:27007,127.0.0.1:27008,127.0.0.1:27009 进入安装MongoDB的bin目录，通过mongos.exe文件启动： cmd1mongos.exe -f D:\\Home\\momashanhe\\mongodb\\router_27010\\mongos.conf 4.4.2 连接路由连接路由服务器： cmd1mongosh.exe mongodb://127.0.0.1:27010 此时是无法写入数据的，因为还没有关联分片服务器副本集。 建议不要直接在分片服务器副本集操作数据，而是通过路由服务器操作数据。 多台服务器配置了相同的配置服务副本集，因此配置分片只需要在其中一台操作，其他服务器就可以直接查看数据和分片信息，不需要重新配置。 4.5 配置分片4.5.1 添加分片使用命令添加分片： bson1sh.addShard(&lt;url&gt;) 含义： 名称 类型 说明 url 字符串 以副本集/IP地址:端口的形式传入参数。 添加分片： bson12sh.addShard(&quot;srs01/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003&quot;);sh.addShard(&quot;srs02/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006&quot;); 添加分片如果提示： bson1MongoServerError[OperationFailed]: Cannot add xxx as a shard since the implicit default write concern on this shard is set to &#123;w : 1&#125;, because number of arbiters in the shard&#x27;s configuration caused the number of writable voting members not to be strictly more than the voting majority. Change the shard configuration or set the cluster-wide write concern using the setDefaultRWConcern command and try again. 这是因为当前mongos设置的写入安全机制defaultWriteConcern是majority表示多数确认，这意味着当进行写操作时，至少要有超过半数的数据节点确认写操作成功，才会返回成功的响应。目前有3个节点，半数的节点数量为2，超过半数也就是至少要有3个节点写入成功才行，但是传入了仲裁节点，导致3个节点中只有2个可写数据的节点，怎么也不会写成功，所以导致失败。 解决方是将写入安全级别调低，然后再添加分片： bson1234db.adminCommand(&#123; &quot;setDefaultRWConcern&quot;: 1, &quot;defaultWriteConcern&quot;: &#123; &quot;w&quot;: 1 &#125;&#125;); 4.5.2 查看分片状态使用命令查看分片状态： bson1sh.status(); 4.5.3 集合分片使用命令对集合分片： bson1sh.shardCollection(&lt;namespace&gt;, &lt;key&gt;, &lt;unique&gt;) 含义： 名称 类型 说明 namespace 字符串 以数据库.集合的形式指定命名空间。 key 文档 以&#123; 属性名: 1 &#125;或者&#123; 属性名: \"hashed\" &#125;的形式指定一个或多个字段用作分片键的文档。 unique 布尔 是否强制底层索引使用唯一约束，默认为false，true表示强制唯一，false表示不强制唯一。在使用哈希分片键时，不能设置为true 对集合分片： bson1sh.shardCollection(&quot;school.student&quot;, &#123; _id: &quot;hashed&quot; &#125;); 4.5.4 测试分片切换数据库： bson1use school; 循环插入数据： bson123for (var i=1; i&lt;=1000; i++) &#123; db.student.insert(&#123; _id: i + &quot;&quot;, name: &quot;test_&quot; + i &#125;);&#125; 查看分片键分布状态： bson1db.student.getShardDistribution(); 显示数据被均匀分到两个分片上了： bson12345678910111213141516171819202122232425262728293031323334Shard srs02 at srs02/127.0.0.1:27004,127.0.0.1:27005&#123; data: &#x27;18KiB&#x27;, docs: 503, chunks: 2, &#x27;estimated data per chunk&#x27;: &#x27;9KiB&#x27;, &#x27;estimated docs per chunk&#x27;: 251&#125;---Shard srs01 at srs01/127.0.0.1:27001,127.0.0.1:27002&#123; data: &#x27;17KiB&#x27;, docs: 497, chunks: 2, &#x27;estimated data per chunk&#x27;: &#x27;8KiB&#x27;, &#x27;estimated docs per chunk&#x27;: 248&#125;---Totals&#123; data: &#x27;35KiB&#x27;, docs: 1000, chunks: 4, &#x27;Shard srs02&#x27;: [ &#x27;50.34 % data&#x27;, &#x27;50.3 % docs in cluster&#x27;, &#x27;36B avg obj size on shard&#x27; ], &#x27;Shard srs01&#x27;: [ &#x27;49.65 % data&#x27;, &#x27;49.7 % docs in cluster&#x27;, &#x27;36B avg obj size on shard&#x27; ]&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"副本集","slug":"E00-数据库/E01-MongoDB/002-高级/002-副本集","date":"2025-03-30T11:24:43.000Z","updated":"2025-06-21T09:07:49.530Z","comments":true,"path":"posts/20250330/192443/","permalink":"https://momashanhe.com/posts/20250330/192443/","excerpt":"摘要：本文学习了什么是副本集，包括副本集的角色和选举，节点的管理和故障模拟。","text":"摘要：本文学习了什么是副本集，包括副本集的角色和选举，节点的管理和故障模拟。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 介绍副本集（Replica Set）是一组维护相同数据集的mongod进程。副本集可提供冗余和高可用性，是所有生产部署的基础。 也可以说，副本集类似于有自动故障恢复功能的主从集群。多台机器拥有同一数据的多个副本，当主服务器掉线时能够自动切换其他备份服务器，而且还可以实现读写分离，提高负载。 2 角色副本集包含多个数据节点和一个可选的仲裁节点。 仲裁节点没有数据集的副本，不属于数据节点。在数据节点中，只有一个主节点，其他被认为是从节点。 每个副本集节点必须属于且只属于一个副本集，副本集节点不能属于多个副本集。 2.1 主节点主节点是副本集中唯一接受写入操作的成员，一个副本集只能有一个主节点。 主节点接受写入操作并记录oplog操作日志，以便从节点复制。 2.2 从节点从节点维护主节点的数据集副本，一个副本集可以有一个或多个从节点。 从节点会对主节点的操作日志oplog进行复制，并应用于其数据集，同步主节点的数据集状态。 2.3 仲裁节点仲裁节点参与主节点的选举，不参与维护数据集副本。 如果从节点和主节点总数为偶数，在选举时可能无法打破平局，建议加入一个仲裁节点，以便打破平局选出主节点。 如果从节点和主节点总数为奇数，可以不需要仲裁节点。 建议最多添加一个仲裁节点，默认情况下副本集不支持添加多个仲裁节点。 3 高可用性3.1 选举副本集使用选举来确定哪个数据节点会成为主节点。 可触发选举的事件： 启动副本集。 维护副本集。 副本集添加新的数据节点。 主节点失效，与主节点连接超时，默认超时时间为10秒。 触发选举后，发起投票和获得票数的影响因素： 根据优先级决定发起投票的时间，越高的从节点越能较早的发起投票。 根据任期和版本决定获得的票数，越高的从节点越能获得较高的票数。 如果在选举超时之前有从节点获得超过半数的投票，它将成为新的主节点，开始处理写入操作并记录日志。 如果有之前的主节点掉线重连了，并且执行了不成功的写操作，在加入副本集变成从节点后还要进行回滚操作。 3.2 心跳数据节点每两秒向彼此发送一次心跳用于进行网络探测，如果心跳在10秒内未返回，会将接收心跳的数据节点标记为不可访问。 3.3 回滚如果主节点在降级之前接受了从节点尚未成功复制的写操作，那么当主节点作为从节点重新加入副本集时，就需要回滚写操作，以保持与其他节点的一致性。 4 使用4.1 创建节点4.1.1 创建主节点创建mgrs_27018目录，在目录下创建db目录和log目录。 在mgrs_27018目录下创建mongod.conf配置文件，修改目录位置和端口，增加副本集的配置： mongod.conf123replication: # 副本集的名称 replSetName: mgrs 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd1mongod.exe -f D:\\Home\\momashanhe\\mongodb\\mgrs_27018\\mongod.conf 4.1.2 创建从节点创建mgrs_27019目录，在目录下创建db目录和log目录。 在mgrs_27019目录下创建mongod.conf配置文件，修改目录位置和端口，增加副本集的配置： mongod.conf123replication: # 副本集的名称 replSetName: mgrs 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd1mongod.exe -f D:\\Home\\momashanhe\\mongodb\\mgrs_27019\\mongod.conf 4.1.3 创建仲裁节点创建mgrs_27020目录，在目录下创建db目录和log目录。 在mgrs_27020目录下创建mongod.conf配置文件，修改目录位置和端口，增加副本集的配置： mongod.conf123replication: # 副本集的名称 replSetName: mgrs 进入安装MongoDB的bin目录，通过mongod.exe文件启动： cmd1mongod.exe -f D:\\Home\\momashanhe\\mongodb\\mgrs_27020\\mongod.conf 4.2 连接节点需要使用命令行工具连接，官方推荐的工具下载地址：下载地址 进入命令行工具安装目录下的bin目录，使用命令指定主机和端口号连接： cmd1mongosh.exe mongodb://127.0.0.1:27018 4.3 启动副本集连接节点以后，因为还未启动副本集，很多命令无法使用。 使用命令启动副本集： cmd1rs.initiate(&lt;configuration&gt;) 含义： 名称 类型 说明 configuration 文档 可选。指定副本集的配置文档。 启动副本集： cmd1rs.initiate() 执行命令后命令行提示符变为： cmd1mgrs [direct: other] test&gt; 然后按下回车后命令行提示符会变为： cmd1mgrs [direct: secondary] test&gt; 稍等片刻后再次按下回车后命令行提示符变为： cmd1mgrs [direct: primary] test&gt; 表示该节点已经启动，并由从节点变为主节点。 4.4 查看副本集4.4.1 查看副本集配置使用命令查看副本集配置： cmd1rs.conf() 结果： conf1234567891011121314151617&#123; _id: &#x27;mgrs&#x27;, version: 1, term: 1, members: [ &#123; _id: 0, host: &#x27;127.0.0.1:27018&#x27;, arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1, votes: 1 &#125; ], settings: &#123;&#125;&#125; 含义： 名称 类型 说明 _id 字符串 副本集的配置数据存储的主键值，默认就是副本集的名字。 version 整型 递增的版本，用于判断节点新旧程度，任期相同的情下，版本越大节点越新。 term 整型 递增的任期，用于判断节点新旧程度，任期越大节点越新。 members 数组 节点配置文档数组，副本集的每个节点对应一个文档。 members[n]._id 整型 副本集中节点的整数标识符，在所有节点中具有唯一性。 members[n].host 数组 副本集中节点的主机和端口号。 members[n].arbiterOnly 布尔值 可选。是否仲裁节点，默认为false，true表示仲裁节点，false表示数据节点。 members[n].priority 整型 可选。节点的优先级，使用0到1000之间的数字表示成为主节点的可能性，数字越大可能性越高。 仲裁节点的优先级为0，表示无法成为主节点。 members[n].votes 整型 可选。节点在选举中可以投出的票数。 settings 文档 可选。包含整个副本集的配置文档。 副本集配置的查看命令，本质上查询的是system.replset表中的数据。 4.4.2 查看副本集状态使用命令查看副本集状态： cmd1rs.status() 4.5 添加节点4.5.1 添加从节点使用命令添加从节点： cmd1rs.add(&lt;host&gt;, &lt;arbiterOnly&gt;) 含义： 名称 类型 说明 host 字符串或文档 指定主机名和端口。 arbiterOnly 布尔值 可选。是否仲裁节点，默认为false，true表示仲裁节点，false表示数据节点。 添加从节点： cmd1rs.add(&quot;127.0.0.1:27019&quot;) 添加后查看副本集状态，能够看到添加的从节点。 4.5.2 添加仲裁节点添加仲裁节点会改变默认的写关注，需要明确设置写关注： cmd1234db.adminCommand(&#123; &quot;setDefaultRWConcern&quot;: 1, &quot;defaultWriteConcern&quot;: &#123; &quot;w&quot;: 1 &#125;&#125;) 使用命令添加仲裁节点： cmd1rs.addArb(&lt;host&gt;) 含义： 名称 类型 说明 host 字符串 指定主机名和端口。 添加仲裁节点： cmd1rs.addArb(&quot;127.0.0.1:27020&quot;) 添加后查看副本集状态，能够看到添加的仲裁节点。 4.6 读写文档连接主节点，可以写入，可以读取。 连接从节点，无法写入，可以读取。 连接仲裁节点，无法写入，无法读取。 4.7 故障模拟4.7.1 主节点宕机从节点成为主节点，主节点恢复后变为从节点继续同步数据。 4.7.2 从节点宕机主节点不受影响，从节点恢复后能继续同步数据。 4.7.3 仲裁节点宕机主节点不受影响，从节点不受影响，仍然能进行主从同步。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"聚合查询","slug":"E00-数据库/E01-MongoDB/002-高级/001-聚合查询","date":"2025-03-28T06:41:02.000Z","updated":"2025-06-21T09:07:49.455Z","comments":true,"path":"posts/20250328/144102/","permalink":"https://momashanhe.com/posts/20250328/144102/","excerpt":"摘要：本文学习了如何使用聚合查询，包括管道操作符和聚合操作符的使用。","text":"摘要：本文学习了如何使用聚合查询，包括管道操作符和聚合操作符的使用。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 介绍聚合是将复杂的查询分解为多个阶段，每个阶段使用操作符定义操作方式，最后将所有的阶段聚合形成结果并返回。 操作符分为管道操作符和聚合操作符，管道操作符定义阶段，聚合操作符需要在特定的管道操作符中使用，得到相应的聚合结果。 2 规范语法： bson1db.集合名.aggregate(pipeline) 含义： 名称 类型 说明 pipeline 文档或数组 由操作符组成的多个阶段。 3 使用3.1 管道操作符3.1.1 match用于过滤文档，只允许匹配条件的文档通过。 根据查询条件过滤文档： bson1&#123; $match: &lt;query&gt; &#125; 含义： 名称 类型 说明 query 文档 要查询的文档，支持通过查询操作符匹配，不支持聚合操作符匹配。如果需要支持聚合操作符匹配，应该在$expr中使用。 查询age属性等于25的文档： bson1db.student.aggregate(&#123; $match: &#123; age: &#123; $eq: 25 &#125; &#125; &#125;); 等价于： bson1db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;); 3.1.2 project用于定制返回结果，指定返回的属性，支持别名。 根据规则定制返回结果： bson1&#123; $project: &lt;projections&gt; &#125; 含义： 名称 类型 说明 projections 文档 返回属性的规则，支持包含和排除，以及重命名。 查询name属性，并排除_id属性： bson1db.student.aggregate(&#123; $project: &#123; _id: 0, name: 1 &#125; &#125;); 查询name属性和addr属性，并将addr属性重命名为address属性： bson12db.student.aggregate(&#123; $project: &#123; _id: 0, name: 1, address: &quot;$addr&quot; &#125; &#125;); 3.1.3 sort用于对文档进行排序。 根据规则对文档进行排序： bson1&#123; $sort: &lt;rules&gt; &#125; 含义： 名称 类型 说明 rules 文档 排序规则，使用键值对形式。 查询文档，按age属性和sex属性排序并返回： bson1db.student.aggregate(&#123; $sort: &#123; age: 1, sex: 1 &#125; &#125;); 等价于： bson12db.student.find() .sort(&#123; age: 1, sex: 1 &#125;); 3.1.4 skip用于跳过指定数量的文档。 跳过指定数量的文档： bson1&#123; $skip: &lt;skipNum&gt; &#125; 含义： 名称 类型 说明 skipNum 整型 跳过的文档数量。 跳过前2条文档： bson1db.student.aggregate(&#123; $skip: 2 &#125;); 等价于： bson12db.student.find() .skip(2); 3.1.5 limit用于查询指定数量的文档。 查询指定数量的文档： bson1&#123; $limit: &lt;limitNum&gt; &#125; 含义： 名称 类型 说明 limitNum 整型 查询的文档数量。 查询前2条文档： bson1db.student.aggregate(&#123; $limit: 2 &#125;); 等价于： bson12db.student.find() .limit(2); 3.1.6 count用于统计查询的文档数量。 统计查询的文档数量： bson1&#123; $count: &lt;countName&gt; &#125; 含义： 名称 类型 说明 countName 字符串 输出的统计名称。 统计查询的文档数量，并将count作为名称返回： bson1db.student.aggregate(&#123; $count: &quot;count&quot; &#125;); 3.1.7 group用于对文档分组，并执行聚合操作。 统计查询的文档数量： bson123456&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field&gt;: &#123; &lt;operator&gt;: &lt;expression&gt; &#125; &#125;&#125; 含义： 名称 类型 说明 field 属性 可选。返回的属性，可以有多个。 operator 操作符 通过操作符处理返回的属性。 expression 字符串或文档 用于操作符处理的表达式。 使用$属性的方式指定属性。 对文档分组，统计数量： bson123456db.student.aggregate(&#123; $group: &#123; _id: null, count: &#123; $count: &#123;&#125; &#125; &#125;&#125;); 对文档按sex属性分组，统计文档数量： bson123456db.student.aggregate(&#123; $group: &#123; _id: &quot;$sex&quot;, sexCount: &#123; $count: &#123;&#125; &#125; &#125;&#125;); 在$group中使用的$count是聚合操作符，并不是管道操作符。 3.1.8 lookup用于将多个集合中的文档关联查询。 3.1.8.1 单个条件单个条件的关联查询： bson12345678&#123; $lookup: &#123; from: &lt;collectionName&gt;, localField: &lt;localFieldName&gt;, foreignField: &lt;foreignFieldName&gt;, as: &lt;asName&gt; &#125;&#125; 含义： 名称 类型 说明 collectionName 字符串 同一个数据库中的关联集合。 localFieldName 字符串 本地集合中的属性，用于同关联集合中的属性关联。 foreignFieldName 字符串 关联集合中的属性，用于同本地集合中的属性关联。 asName 字符串 返回的属性名。 单个条件的关联查询，将学校信息关联到学生信息表： bson12345678db.student.aggregate(&#123; $lookup: &#123; from: &quot;school&quot;, localField: &quot;school&quot;, foreignField: &quot;_id&quot;, as: &quot;schoolInfo&quot; &#125;&#125;); 将学校信息关联到学生信息表： bson1234567891011121314&#123; &quot;_id&quot;: 1, &quot;name&quot;: &quot;张三&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;addr&quot;: &quot;北京市 东城区&quot;, &quot;age&quot;: 25, &quot;expenditure&quot;: 80, &quot;income&quot;: 100, &quot;school&quot;: 2, &quot;total&quot;: 720, &quot;schoolInfo&quot;: [ &#123; &quot;_id&quot;: 2, &quot;name&quot;: &quot;北京大学&quot;, &quot;score&quot;: 700 &#125; ]&#125; 3.1.8.2 多个条件多个条件的关联查询： bson12345678&#123; $lookup: &#123; from: &lt;collectionName&gt;, let: &#123; &lt;localName&gt;: &lt;localFieldName&gt; &#125;, pipeline: [ &lt;operator&gt;: &lt;expression&gt; ], as: &lt;asName&gt; &#125;&#125; 含义： 名称 类型 说明 collectionName 字符串 同一个数据库中的关联集合。 let 文档 本地集合中的属性，可以有多个。 localName 字符串 本地集合中的属性别名。 localFieldName 字符串 本地集合中的属性别名对应的本地属性。 使用$属性的方式指定本地集合属性。 pipeline 数组 关联集合中的属性，使用管道操作符关联本地集合和关联集合，可以有多个。 operator 操作符 通过操作符处理返回的属性。 expression 字符串或文档 用于操作符处理的表达式。 使用$属性的方式指定关联集合属性，使用$$属性的方式指定本地集合属性别名。 asName 字符串 返回的属性名。 多个条件的关联查询，将学校信息关联到学生信息表，并查询学生总分超过学校分数的文档： bson1234567891011121314151617db.student.aggregate(&#123; $lookup: &#123; from: &quot;school&quot;, let: &#123; stuSchool: &quot;$school&quot;, stuTotal: &quot;$total&quot; &#125;, pipeline: [ &#123; $match: &#123; $expr: &#123; $and: [ &#123; $eq: [ &quot;$_id&quot;, &quot;$$stuSchool&quot; ] &#125;, &#123; $lte: [ &quot;$score&quot;, &quot;$$stuTotal&quot; ] &#125; ] &#125; &#125; &#125; ], as: &quot;schoolInfo&quot; &#125;&#125;); 将学校信息关联到学生信息表，并查询学生总分超过学校分数的文档： bson1234567891011121314&#123; &quot;_id&quot;: 1, &quot;name&quot;: &quot;张三&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;addr&quot;: &quot;北京市 东城区&quot;, &quot;age&quot;: 25, &quot;expenditure&quot;: 80, &quot;income&quot;: 100, &quot;school&quot;: 2, &quot;total&quot;: 720, &quot;schoolInfo&quot;: [ &#123; &quot;_id&quot;: 2, &quot;name&quot;: &quot;北京大学&quot;, &quot;score&quot;: 700 &#125; ]&#125; 3.2 聚合操作符3.2.1 count统计文档的数量。 统计数量不需要使用参数： bson1&#123; $count: &#123;&#125; &#125; 对文档按sex属性分组，统计文档数量： bson123456db.student.aggregate(&#123; $group: &#123; _id: &quot;$sex&quot;, sexCount: &#123; $count: &#123;&#125; &#125; &#125;&#125;); 3.2.2 sum计算并返回数字的总和。 在$project中对数组属性求和，或者在$group中对数字属性求和： bson1&#123; $sum: &lt;expression&gt; &#125; 在$project中对数组属性求和： bson1&#123; $sum: [ &lt;expression&gt;, &lt;expression&gt; ] &#125; 含义： 名称 类型 说明 expression 数字或属性 使用$属性的方式指定属性，忽略非数字的属性值。 对文档按sex属性分组，统计文档数量并计算age属性的总和： bson1234567db.student.aggregate(&#123; $group: &#123; _id: &quot;$sex&quot;, sexCount: &#123; $count: &#123;&#125; &#125;, sexSumAge: &#123; $sum: &quot;$age&quot; &#125; &#125;&#125;); 统计文档scores数组的总和作为totalScore属性返回，只显示name属性和totalScore属性： bson1234567db.student.aggregate(&#123; $project: &#123; _id: 0, name: 1, totalScore: &#123; $sum: &quot;$scores&quot; &#125; &#125;&#125;); 3.2.3 avg计算并返回数字的平均值。 在$project中对数组属性求平均值，或者在$group中对数字属性求平均值： bson1&#123; $avg: &lt;expression&gt; &#125; 在$project中对数组属性求平均值： bson1&#123; $avg: [ &lt;expression&gt;, &lt;expression&gt; ] &#125; 含义： 名称 类型 说明 expression 数字或属性 使用$属性的方式指定属性，忽略非数字的属性值。 对文档按sex属性分组，统计文档数量并计算age属性的平均值： bson1234567db.student.aggregate(&#123; $group: &#123; _id: &quot;$sex&quot;, sexCount: &#123; $count: &#123;&#125; &#125;, sexAvgAge: &#123; $avg: &quot;$age&quot; &#125; &#125;&#125;); 统计文档scores数组的平均值作为meanScore属性返回，只显示name属性和meanScore属性： bson1234567db.student.aggregate(&#123; $project: &#123; _id: 0, name: 1, meanScore: &#123; $avg: &quot;$scores&quot; &#125; &#125;&#125;); 3.2.4 cond条件表达式，根据条件执行表达式。 根据条件执行表达式： bson1234567&#123; $cond: &#123; if: &lt;expression&gt;, then: &lt;trueCase&gt;, else: &lt;falseCase&gt; &#125;&#125; 含义： 名称 类型 说明 expression 文档 计算结果为布尔类型的表达式。 trueCase 文档 计算结果为true时返回此表达式的结果。 falseCase 文档 计算结果为false时返回此表达式的结果。 统计文档scores数组的总和，根据是否超过250作为level属性，返回name属性和level属性： bson12345678910111213db.student.aggregate(&#123; $project: &#123; _id: 0, name: 1, level: &#123; $cond: &#123; if: &#123; $gt: [ &#123; $sum: &quot;$scores&quot; &#125;, 250 ] &#125;, then: &quot;尖子生&quot;, else: &quot;普通生&quot; &#125; &#125; &#125;&#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"使用索引","slug":"E00-数据库/E01-MongoDB/001-基础/006-使用索引","date":"2025-03-24T02:56:33.000Z","updated":"2025-06-21T09:07:49.718Z","comments":true,"path":"posts/20250324/105633/","permalink":"https://momashanhe.com/posts/20250324/105633/","excerpt":"摘要：本文学习了什么是索引，索引的创建和删除，以及如何查看索引和分析索引的使用情况。","text":"摘要：本文学习了什么是索引，索引的创建和删除，以及如何查看索引和分析索引的使用情况。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 介绍索引通常能够极大的提高查询的效率，如果没有使用索引，在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可能要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。 在MongoDB中，常见的索引类型包括： 单属性索引：基于单个属性的索引。 复合索引：基于多个属性组合的索引。 文本索引：用于支持全文搜索。 地理空间索引：用于地理空间数据的查询。 哈希索引：用于对属性值进行哈希处理的索引。 2 创建2.1 基本语法语法： bson12345678db.集合名.createIndex( &lt;keys&gt;, &#123; name: &lt;indexName&gt;, unique: &lt;isUnique&gt;, hidden: &lt;isHidden&gt; &#125;) 含义： 名称 类型 说明 keys 文档 包含属性和值对的文档，其中属性是索引键，值描述该属性的索引类型。 indexName 字符串 可选。索引名称。默认使用索引属性的名称和排序顺序来生成索引名称。 isUnique 布尔 可选。是否唯一索引，默认为false，true表示唯一索引，false表示非唯一索引。 isHidden 布尔 可选。是否隐藏索引，默认为false，true表示隐藏索引，false表示非隐藏索引。隐藏索引不会参与评估查询计划 2.2 索引类型2.2.1 单属性索引单属性索引是在单个属性上创建的索引，适用于查询条件中只涉及该属性的情况。 取值为1时表示升序索引，取值为-1时表示降序索引。 示例： bson1db.student.createIndex(&#123; age: 1 &#125;); 2.2.2 复合索引复合索引由多个单属性索引组成，适用于查询条件中涉及多个属性的情况。 创建复合索引时，属性的顺序很重要，通常应将最常用且选择性高的属性放在索引的前面。 示例： bson1db.student.createIndex(&#123; age: 1, birthDate: 1 &#125;); 2.2.3 多键索引多键索引用于数组属性，当属性的值是一个数组时，会自动为数组中的每个元素创建索引键。 示例： bson1db.student.createIndex(&#123; scores: 1 &#125;); 2.2.4 文本索引文本索引支持对包含字符串内容的属性进行文本搜索查询。当在字符串内容中搜索特定单词或字符串时，文本索引可以提高性能。 文本索引使用text表示，一个集合只能有一个文本索引，但该索引可以包含多个属性。 示例： bson1db.student.createIndex(&#123; intro: &quot;text&quot;, desc: &quot;text&quot; &#125;); 2.2.5 地理空间索引地理空间索引用于存储地理位置信息，支持地理空间查询，如查找某个区域内的位置等。 提供两种类型的地理空间索引： 类型 描述 示例 2d 支持在平面上解释几何图形的查询。 bson1db.student.createIndex(&#123; location: &quot;2d&quot; &#125;); 2dsphere 支持解释球体上的几何形状的查询。 bson1db.student.createIndex(&#123; location: &quot;2dsphere&quot; &#125;); 2.2.6 哈希索引哈希索引适用于基于等值匹配的查询，它将属性值映射到一个哈希值，从而加快等值比较的速度。 哈希索引使用hashed表示。 示例： bson1db.student.createIndex(&#123; id: &quot;hashed&quot; &#125;); 3 删除3.1 删除一个索引语法： bson1db.集合名.dropIndex(&lt;indexName&gt;) 含义： 名称 类型 说明 indexName 字符串 要删除的索引名称。 示例： bson1db.student.dropIndex(&quot;age_1&quot;); 3.2 删除多个索引语法： bson1db.集合名.dropIndexes(&lt;indexNames&gt;) 含义： 名称 类型 说明 indexNames 数组 多个要删除的索引名称，如果为空会删除全部索引。 示例： bson1db.student.dropIndexs([ &quot;age_1&quot;, &quot;birthDate_1&quot; ]); 注意：不能删除_id属性索引，该索引是系统默认创建的，无法删除，只能删除非_id属性的索引。 3.3 设置隐藏索引可以在不实际删除索引的情况下评估删除索引的潜在影响。 语法： bson1db.集合名.hideIndex(&lt;indexName&gt;) 含义： 名称 类型 说明 indexName 字符串 要设置隐藏的索引名称。 示例： bson1db.student.hideIndex(&quot;age_1&quot;); 3.4 解除隐藏索引语法： bson1db.集合名.unhideIndex(&lt;indexName&gt;) 含义： 名称 类型 说明 indexName 字符串 要解除隐藏的索引名称。 示例： bson1db.student.unhideIndex(&quot;age_1&quot;); 4 查看语法： bson1db.集合名.getIndexes() 示例： bson1db.student.getIndexes(); 5 分析5.1 分析计划使用explain()方法可以获取计划信息。 语法： bson12db.集合名.find() .explain(&lt;verbosity&gt;) 含义： 名称 类型 说明 verbosity 字符串 可选。指定分析返回信息的详细模式。详细模式支持三种： queryPlanner：默认值，返回执行的计划信息。 executionStats：返回执行的计划信息以及统计信息。 allPlansExecution：返回所有的计划信息以及统计信息。 为了向后兼容早期版本，设置为true等价于设置为allPlansExecution，设置为false等价于设置为queryPlanner。 在使用索引前分析查询： bson12db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;) .explain(&quot;allPlansExecution&quot;); 分析查询部分结果： bson1234567891011121314151617181920212223242526272829303132&#123; &quot;queryPlanner&quot;: &#123; &quot;namespace&quot;: &quot;school.student&quot;, &quot;winningPlan&quot;: &#123; &quot;stage&quot;: &quot;COLLSCAN&quot;, &quot;filter&quot;: &#123; &quot;age&quot;: &#123; &quot;$eq&quot;: 25 &#125; &#125;, &quot;direction&quot;: &quot;forward&quot; &#125;, &quot;rejectedPlans&quot;: [] &#125;, &quot;executionStats&quot;: &#123; &quot;nReturned&quot;: NumberInt(&quot;1&quot;), &quot;executionTimeMillis&quot;: NumberInt(&quot;0&quot;), &quot;totalKeysExamined&quot;: NumberInt(&quot;0&quot;), &quot;totalDocsExamined&quot;: NumberInt(&quot;4&quot;), &quot;executionStages&quot;: &#123; &quot;stage&quot;: &quot;COLLSCAN&quot;, &quot;filter&quot;: &#123; &quot;age&quot;: &#123; &quot;$eq&quot;: 25 &#125; &#125;, &quot;nReturned&quot;: NumberInt(&quot;1&quot;), &quot;executionTimeMillisEstimate&quot;: NumberInt(&quot;0&quot;) &#125;, &quot;allPlansExecution&quot;: [] &#125;&#125; 在使用索引后分析查询： bson123db.student.createIndex(&#123; age: 1 &#125;);db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;) .explain(&quot;allPlansExecution&quot;); 分析查询部分结果： bson1234567891011121314151617181920212223242526272829303132&#123; &quot;queryPlanner&quot;: &#123; &quot;namespace&quot;: &quot;school.student&quot;, &quot;winningPlan&quot;: &#123; &quot;stage&quot;: &quot;FETCH&quot;, &quot;inputStage&quot;: &#123; &quot;stage&quot;: &quot;IXSCAN&quot;, &quot;keyPattern&quot;: &#123; &quot;age&quot;: 1 &#125;, &quot;indexName&quot;: &quot;age_1&quot;, &quot;direction&quot;: &quot;forward&quot; &#125; &#125;, &quot;rejectedPlans&quot;: [] &#125;, &quot;executionStats&quot;: &#123; &quot;nReturned&quot;: NumberInt(&quot;1&quot;), &quot;executionTimeMillis&quot;: NumberInt(&quot;1&quot;), &quot;totalKeysExamined&quot;: NumberInt(&quot;1&quot;), &quot;totalDocsExamined&quot;: NumberInt(&quot;1&quot;), &quot;executionStages&quot;: &#123; &quot;stage&quot;: &quot;FETCH&quot;, &quot;nReturned&quot;: NumberInt(&quot;1&quot;), &quot;executionTimeMillisEstimate&quot;: NumberInt(&quot;0&quot;), &quot;inputStage&quot;: &#123; &quot;stage&quot;: &quot;IXSCAN&quot; &#125; &#125;, &quot;allPlansExecution&quot;: [] &#125;&#125; 分析查询部分说明： 属性 类型 说明 queryPlanner 文档 查询的计划信息。 queryPlanner.namespace 字符串 使用数据库和集合指定的命名空间。 queryPlanner.winningPlan 文档 最终使用的计划。 queryPlanner.winningPlan.stage 字符串 计划的阶段，阶段是对操作的描述。 queryPlanner.winningPlan.inputStage 文档 计划的子阶段，为其父阶段提供文档或索引键。如果有一个子阶段，则该属性存在。 queryPlanner.winningPlan.inputStages 数组 计划的子阶段数组，为其父阶段提供文档或索引键。如果有多个子阶段，则该属性存在。 queryPlanner.rejectedPlans 数组 拒绝的候选计划数组。如果没有其他候选计划，则数组可能为空。 executionStats 文档 查询的统计信息。只有设置为executionStats和allPlansExecution才会有此内容。 executionStats.nReturned 整型 查询的文档数。 executionStats.executionTimeMillis 整型 查询的执行时间，单位是毫秒。包括选择计划和执行计划的总时间。 executionStats.totalKeysExamined 整型 扫描的索引键数量。 executionStats.totalDocsExamined 整型 扫描的文档数量。 executionStats.executionStages 文档 以阶段树的形式详细说明计划的执行情况。 executionStats.allPlansExecution 数组 候选计划的部分统计信息。只有设置为allPlansExecution才会有此内容。 计划的阶段可选值举例： 值 说明 FETCH 索引文档，表示查询使用了索引，并且需要从索引中检索文档。 IXSCAN 索引扫描，表示查询使用了索引，并且正在扫描索引键。 COLLSCAN 集合扫描，表示查询没有使用索引，直接扫描整个集合。 LIMIT 应用限制，限制返回的文档数量。 SKIP 应用跳过，跳过指定数量的文档。 SORT 应用排序，对结果进行排序。 COUNT 应用计数，对结果进行计数。 PROJECTION 应用投影，返回指定属性。 PROJECTION_COVERED 覆盖查询，所有需要的属性都在索引中，不需要回表查询。 IDHACK 对`_id`属性进行查询。 TEXT 处理文本查询。 IXHASH 处理散列查询。 5.2 指定索引使用hint()方法可以强制使用指定的索引，或者强制不使用索引扫描集合。 使用这种方式可以跳过选择计划的时间，直接通过索引执行计划，节省了查询时间。 语法： bson12db.集合名.find() .hint(&lt;index&gt;) 含义： 名称 类型 说明 index 字符串或文档 执行查询时强制使用指定的索引。通过索引名称或属性来指定索引。 使用索引属性指定索引： bson12db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;) .hint(&#123; &quot;age&quot;: 1 &#125;); 使用索引名称指定索引： bson12db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;) .hint(&quot;age_1&quot;); 强制扫描集合，不使用任何索引： bson12db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;) .hint(&#123; $natural : 1 &#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"查询优化","slug":"E00-数据库/E01-MongoDB/001-基础/005-查询优化","date":"2025-03-24T02:01:36.000Z","updated":"2025-06-21T09:07:49.530Z","comments":true,"path":"posts/20250324/100136/","permalink":"https://momashanhe.com/posts/20250324/100136/","excerpt":"摘要：本文学习了如何对查询结果进行排序和分页，以及使用投影定制查询结果。","text":"摘要：本文学习了如何对查询结果进行排序和分页，以及使用投影定制查询结果。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 排序在查询后可以对结果进行排序显示。 语法： bson12db.集合名.find() .sort(&lt;rules&gt;) 含义： 名称 类型 说明 rules 文档 排序规则，使用键值对形式，键是排序属性，值是排序方式。排序方式为1表示正序，排序方式为-1表示逆序。 支持多个，按照先后顺序进行排序。 示例： bson12db.student.find(&#123; sex: &quot;男&quot; &#125;) .sort(&#123; age: -1, id: 1 &#125;); 2 分页在查询时可以指定查询的文档数量以及要跳过的文档数量，从而实现分页的效果。 语法： bson123db.集合名.find() .skip(&lt;skipNum&gt;) .limit(&lt;limitNum&gt;) 含义： 名称 类型 说明 skipNum 文档 跳过数量。 limitNum 文档 查询数量。 示例： bson123db.student.find(&#123; sex: &quot;男&quot; &#125;) .skip(10) .limit(10); 3 投影使用投影指定返回哪些属性。 语法： bson1db.集合名.find(&lt;query&gt;, &lt;projection&gt;) 含义： 名称 类型 说明 query 文档 可选。要查询的文档，如果为空则查询第一个文档，支持通过查询操作符匹配。 projection 文档 可选。指定与查询过滤匹配的文档中要返回的属性。 查询name为张三的文档，只需要返回_id属性和name属性： bson1234db.student.findOne( &#123; name: &quot;张三&quot; &#125;, &#123; name: 1 &#125;); 查询name为张三的文档，只需要返回name属性： bson1234db.student.findOne( &#123; name: &quot;张三&quot; &#125;, &#123; name: 1, _id: 0 &#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"操作符","slug":"E00-数据库/E01-MongoDB/001-基础/004-操作符","date":"2025-03-21T01:15:53.000Z","updated":"2025-06-21T09:07:50.539Z","comments":true,"path":"posts/20250321/091553/","permalink":"https://momashanhe.com/posts/20250321/091553/","excerpt":"摘要：本文学习了查询操作符和更新操作符。","text":"摘要：本文学习了查询操作符和更新操作符。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 查询操作符1.1 比较查询1.1.1 eq等于，查询属性等于指定值的文档。 查询age属性等于25的文档： bson1db.student.find(&#123; age: &#123; $eq: 25 &#125; &#125;); 1.1.2 ne不等于，查询属性不等于指定值的文档。 查询age属性不等于25的文档： bson1db.student.find(&#123; age: &#123; $ne: 25 &#125; &#125;); 1.1.3 gt大于，查询属性大于指定值的文档。 查询age属性大于25的文档： bson1db.student.find(&#123; age: &#123; $gt: 25 &#125; &#125;); 1.1.4 lt小于，查询属性小于指定值的文档。 查询age属性小于25的文档： bson1db.student.find(&#123; age: &#123; $lt: 25 &#125; &#125;); 1.1.5 gte大于等于，查询属性大于等于指定值的文档。 查询age属性大于等于25的文档： bson1db.student.find(&#123; age: &#123; $gte: 25 &#125; &#125;); 1.1.6 lte小于等于，查询属性小于等于指定值的文档。 查询age属性小于等于25的文档： bson1db.student.find(&#123; age: &#123; $lte: 25 &#125; &#125;); 1.1.7 in包含，查询属性在指定范围的文档。 查询age属性在25和35的文档： bson1db.student.find(&#123; age: &#123; $in: [ 25, 35 ] &#125; &#125;); 1.1.8 nin不包含，查询属性不在指定范围的文档。 查询age属性不在25和35的文档： bson1db.student.find(&#123; age: &#123; $nin: [ 25, 35 ] &#125; &#125;); 1.2 逻辑查询1.2.1 and逻辑与，查询指定条件全都满足的文档。 查询age属性等于25且sex属性为女的文档： bson123456db.student.find(&#123; $and: [ &#123; age: &#123; $eq: 25 &#125; &#125;, &#123; sex: &quot;女&quot; &#125; ]&#125;); 可以省略操作符： bson1234db.student.find(&#123; age: &#123; $eq: 25 &#125;, sex: &quot;女&quot;&#125;); 1.2.2 or逻辑或，查询指定条件部分满足的文档。 查询age属性等于25或sex属性为女的文档： bson123456db.student.find(&#123; $or: [ &#123; age: &#123; $eq: 25 &#125; &#125;, &#123; sex: &quot;女&quot; &#125; ]&#125;); 1.2.3 nor逻辑非或，查询指定条件都不满足的文档。 查询age属性不等于25且sex属性不为女的文档： bson123456db.student.find(&#123; $nor: [ &#123; age: &#123; $eq: 25 &#125; &#125;, &#123; sex: &quot;女&quot; &#125; ]&#125;); 1.2.4 not逻辑非，查询指定条件不满足的文档。 查询age属性不等于25的文档： bson1db.student.find(&#123; age: &#123; $not: &#123; $eq: 25 &#125; &#125; &#125;); 等价于： bson1db.student.find(&#123; age: &#123; $ne: 25 &#125; &#125;); 1.3 元素查询1.3.1 exists查询指定属性是否存在的文档。 查询存在age属性的文档： bson1db.student.find(&#123; age: &#123; $exists: true &#125; &#125;); 1.3.2 type查询指定属性是否符合指定类型的文档。 查询age属性类型为整数的文档： bson1db.student.find(&#123; age: &#123; $type: [ &quot;double&quot;, &quot;int&quot; ] &#125; &#125;); 1.4 评估查询1.4.1 expr允许使用聚合操作符查询文档。 查询income属性大于expenditure属性的文档： bson1db.student.find(&#123; $expr: &#123; $gt: [ &quot;$income&quot;, &quot;$expenditure&quot; ] &#125; &#125;); 1.4.2 regex允许使用正则表达式查询文档。 查询address属性以北京市开头的文档： bson1db.student.find(&#123; address: &#123; $regex: /^北京市/ &#125; &#125;); 1.5 数组查询1.5.1 all查询属性是数组并且包含所有元素的文档。 查询tags数组中同时包含age和sex的文档： bson1db.student.find(&#123; tags: &#123; $all: [ &quot;age&quot;, &quot;sex&quot; ] &#125; &#125;); 1.5.2 elemMatch查询属性是数组并且满足指定条件的文档。 查询scores数组中存在大于80的文档： bson1db.student.find(&#123; scores: &#123; $elemMatch: &#123; $gt: 80 &#125; &#125; &#125;); 1.5.3 size查询属性是数组并且符合指定大小的文档。 查询books数组大小为2的文档： bson1db.student.find(&#123; books: &#123; $size: 2 &#125; &#125;); 2 更新操作符2.1 属性更新2.1.1 rename根据条件修改指定属性名。 查询name属性为张三的文档，将location属性名修改为address： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $rename: &#123; &quot;location&quot;: &quot;address&quot; &#125; &#125;); 2.1.2 set根据条件修改指定属性值。 查询name属性为张三的文档，将age属性值设置为30： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $set: &#123; age: 30 &#125; &#125;); 2.1.3 unset根据条件删除指定属性。 查询name属性为张三的文档，将age属性删除： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $unset: &#123; age: 0 &#125; &#125;); 2.1.4 inc根据条件将属性按指定值相加。 查询name属性为张三的文档，将age属性减1： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $inc: &#123; age: -1 &#125; &#125;); 2.1.5 mul根据条件将属性按指定值相乘。 查询name属性为张三的文档，将age属性乘2： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $mul: &#123; age: 2 &#125; &#125;); 2.1.6 min根据条件设置最大值，当指定值小于属性值，更新为指定值。 查询name属性为张三的文档，将age属性的最大值更新为16： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $min: &#123; age: 16 &#125; &#125;); 2.1.7 max根据条件设置最小值，当指定值大于属性值，更新为指定值。 查询name属性为张三的文档，将age属性的最小值更新为18： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $max: &#123; age: 18 &#125; &#125;); 2.2 数组更新2.2.1 pop将元素从数组的开头或末尾移除，末尾是1，开头是-1。 查询name属性为张三的文档，将元素从scores数组的末尾移除： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $pop: &#123; scores: 1 &#125; &#125;); 2.2.2 push将元素添加到数组的末尾。 查询name属性为张三的文档，将元素添加到scores数组的末尾： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $push: &#123; scores: 100 &#125; &#125;); 2.2.3 pull将元素从数组中移除。 查询name属性为张三的文档，将元素从scores数组移除： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $pull: &#123; scores: 90 &#125; &#125;); 2.2.4 pullAll将多个元素从数组中移除。 查询name属性为张三的文档，将多个元素从scores数组移除： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $pullAll: &#123; scores: [ 70, 80 ] &#125; &#125;); 等价于： bson1234db.student.updateOne( &#123; name: &quot;张三&quot; &#125;, &#123; $pull: &#123; scores: &#123; $in: [ 70, 80 ] &#125; &#125; &#125;);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"基本操作","slug":"E00-数据库/E01-MongoDB/001-基础/003-基本操作","date":"2025-03-19T04:08:28.000Z","updated":"2025-06-21T09:07:49.530Z","comments":true,"path":"posts/20250319/120828/","permalink":"https://momashanhe.com/posts/20250319/120828/","excerpt":"摘要：本文学习了常用的操作，包括对数据库和用户的管理，对集合的管理，以及对文档的增删改查。","text":"摘要：本文学习了常用的操作，包括对数据库和用户的管理，对集合的管理，以及对文档的增删改查。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 通用命令1.1 帮助执行show dbs命令查看数据库。 执行use 数据库命令切换到指定数据库。 执行show collections命令查看当前数据库的集合。 执行show users命令查看当前数据库的用户。 1.2 数据库命令语法： bson12db.runCommand(&lt;command&gt;)db.adminCommand(&lt;command&gt;) 含义： 名称 类型 说明 command 文档 数据库命令。 注意： runCommand针对当前数据库运行命令。 adminCommand针对admin数据库运行管理命令。 大部分方法都封装了对应的数据库命令，以方便开发人员使用数据库。 2 数据库管理2.1 显示数据库使用show dbs命令查看数据库。 2.2 切换数据库使用use 数据库命令切换到指定数据库。 使用db命令查看当前数据库。 允许使用use 数据库进入不存在的数据库，在插入文档后会自动创建数据库和集合。 2.3 删除数据库语法： bson1db.dropDatabase() 示例： bson1db.dropDatabase(); 3 用户管理3.1 显示用户使用show users命令查看当前数据库的用户。 3.2 创建用户语法： bson12345678db.createUser(&#123; user: &lt;username&gt;, pwd: &lt;password&gt;, customData: &lt;userinfo&gt;, roles: [ &#123; role: &lt;rolename&gt;, db: &lt;dbname&gt; &#125; ]&#125;) 含义： 名称 类型 说明 username 字符串 用户的名称。 password 字符串 用户的密码。使用明文字符串表示用户密码，或使用passwordPrompt()方法提示输入用户密码。 userinfo 文档 可选。用户信息。此属性可用于存储管理员希望与此特定用户关联的任何数据。 roles 数组 用户的角色。可以指定一个空数组创建无角色的用户。可以省略数据库，默认为当前数据库。 rolename 字符串 角色名。 dbname 字符串 数据库名。 示例： bson12345678db.createUser(&#123; user: &quot;xz&quot;, pwd: &quot;123456&quot;, customData: &#123; name: &quot;校长&quot; &#125;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;school&quot; &#125; ]&#125;); 用户的角色包括内置角色和自定义角色，内置角色如下： 类型 角色 说明 数据库用户角色 read 允许用户获取指定数据库的读权限。 数据库用户角色 readWrite 允许用户获取指定数据库的读写权限。 数据库管理角色 dbAdmin 允许用户获取指定数据库的管理权限。 数据库管理角色 userAdmin 允许用户获取指定数据库的用户管理权限。 数据库管理角色 dbOwner 允许用户对数据库执行任何管理操作。包含readWrite角色、dbAdmin角色、userAdmin角色。 集群管理角色 只在admin数据库中可用 clusterAdmin 提供最大的集群管理访问权限。包含clusterManager角色、clusterMonitor角色、hostManager角色。还提供dropDatabase操作。 备份和恢复角色 只在admin数据库中可用 backup 提供备份数据所需的最低特权。 备份和恢复角色 只在admin数据库中可用 restore 提供数据恢复所需权限。 全数据库角色 只在admin数据库中可用，适用于除local和config的数据库 readAnyDatabase 提供所有数据库的读权限。 全数据库角色 只在admin数据库中可用，适用于除local和config的数据库 readWriteAnyDatabase 提供所有数据库的读写权限。 全数据库角色 只在admin数据库中可用，适用于除local和config的数据库 dbAdminAnyDatabase 提供所有数据库的管理权限。 全数据库角色 只在admin数据库中可用，适用于除local和config的数据库 userAdminAnyDatabase 提供所有数据库的用户管理权限。 超级用户角色 只在admin数据库中可用，适用于除local和config的数据库 root 提供所有权限。 3.3 删除用户语法： bson1db.dropUser(&lt;username&gt;) 含义： 名称 类型 说明 username 字符串 用户名。 示例： bson1db.dropUser(&quot;xz&quot;); 3.4 更新用户语法： bson12345678910db.updateUser( &lt;username&gt;, &#123; pwd: &lt;password&gt;, customData: &lt;userinfo&gt;, roles: [ &#123; role: &lt;rolename&gt;, db: &lt;dbname&gt; &#125; ] &#125;) 含义： 名称 类型 说明 username 字符串 用户名。 password 字符串 用户的密码。使用明文字符串表示用户密码，或使用passwordPrompt()方法提示输入用户密码。 userinfo 文档 可选。用户信息。此属性可用于存储管理员希望与此特定用户关联的任何数据。 roles 数组 用户的角色。可以指定一个空数组创建无角色的用户。可以省略数据库，默认为当前数据库。 rolename 字符串 角色名。 dbname 字符串 数据库名。 示例： bson12345678910db.updateUser( &quot;xz&quot;, &#123; pwd: &quot;123456&quot;, customData: &#123; name: &quot;校长&quot; &#125;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;school&quot; &#125; ] &#125;); 3.5 查询用户语法： bson1db.getUser(&lt;username&gt;) 含义： 名称 类型 说明 username 字符串 用户名。 示例： bson1db.getUser(&quot;xz&quot;); 3.6 验证用户语法： bson1db.auth(&lt;username&gt;, &lt;password&gt;) 含义： 名称 类型 说明 username 字符串 用户名。 password 字符串 用户密码。 示例： bson1db.auth(&quot;xz&quot;, &quot;123456&quot;); 4 集合管理4.1 显示集合执行show collections命令查看当前数据库的集合。 4.2 创建集合语法： bson1db.createCollection(&lt;name&gt;) 含义： 名称 类型 说明 name 字符串 要创建的集合名。 示例： bson1db.createCollection(&quot;student&quot;); 4.3 删除集合语法： bson1db.集合名.drop() 示例： bson1db.student.drop(); 4.4 重命名集合语法： bson1db.集合名.renameCollection(&lt;name&gt;, &lt;drop&gt;) 含义： 名称 类型 说明 name 字符串 要重命名的新集合名。 drop 布尔 新集合已存在，是否删除现有的新集合，默认为false，true是删除，false是不删除。 示例： bson1db.student.renameCollection(&quot;member&quot;); 5 文档管理5.1 插入文档5.1.1 插入单个文档语法： bson1db.集合名.insertOne(&lt;document&gt;) 含义： 名称 类型 说明 document 文档 要插入的文档。 示例： bson1db.student.insertOne(&#123; name: &quot;张三&quot;, sex: &quot;男&quot;, age: 16 &#125;); 说明： 如果插入的文档不包含_id属性，会默认创建_id属性并分配唯一的ObjectId()值。如果插入的文档包含_id属性，会使用传入的属性，要求该属性必须是唯一值，否则会引发异常。 插入后会将结果通过acknowledged返回，使用true表示插入成功，使用false表示插入失败。同时将_id属性通过insertedId返回。 5.1.2 插入多个文档语法： bson1234db.集合名.insertMany( &lt;documents&gt;, &#123; ordered: &lt;flag&gt; &#125;) 含义： 名称 类型 说明 documents 文档 要插入的文档数组。 flag 布尔 可选。指定执行有序插入还是无序插入，默认为true，true表示有序，false表示无序。 示例： bson123456789db.student.insertMany( [ &#123; _id: 1, name: &quot;张三&quot;, sex: &quot;男&quot;, age: 16 &#125;, &#123; _id: 2, name: &quot;李四&quot;, sex: &quot;女&quot;, age: 28 &#125;, &#123; _id: 3, name: &quot;王五&quot;, sex: &quot;男&quot;, age: 32 &#125;, &#123; _id: 4, name: &quot;赵六&quot;, sex: &quot;女&quot;, age: 54 &#125; ], &#123; ordered: false &#125;); 说明： 如果使用有序插入，当插入某个文档失败时，不会继续插入文档。如果使用无序插入，当插入某个文档失败时，会跳过继续插入其他文档。 每组中的操作次数不得超过数据库的maxWriteBatchSize值，默认值为100000个。该值会显示在hello.maxWriteBatchSize属性中。 5.2 查询文档5.2.1 查询单个文档语法： bson1db.集合名.findOne(&lt;query&gt;) 含义： 名称 类型 说明 query 文档 可选。要查询的文档，如果为空则查询第一个文档，支持通过查询操作符匹配。 示例： bson1db.student.findOne(&#123; name: &quot;张三&quot; &#125;); 5.2.2 查询多个文档语法： bson1db.集合名.find(&lt;query&gt;) 含义： 名称 类型 说明 query 文档 可选。要查询的文档，如果为空则查询全部文档，支持通过查询操作符匹配。 示例： bson1db.student.find(&#123; sex: &quot;男&quot; &#125;); 5.3 删除文档5.3.1 删除单个文档语法： bson1db.集合名.deleteOne(&lt;filter&gt;) 含义： 名称 类型 说明 filter 文档 要删除的文档，如果为&#123;&#125;则删除第一个文档，支持通过查询操作符匹配。 示例： bson1db.student.deleteOne(&#123; name: &quot;张三&quot;, sex: &quot;男&quot; &#125;); 说明： 删除后会将结果通过acknowledged返回，使用true表示插入成功，使用false表示插入失败。同时将删除个数通过deletedCount返回。 如果匹配到多个文档，只会删除第一个文档。 5.3.2 删除多个文档语法： bson1db.集合名.deleteMany(&lt;filter&gt;) 含义： 名称 类型 说明 filter 文档 要删除的文档，如果为&#123;&#125;则删除全部文档，支持通过查询操作符匹配。 示例： bson1db.student.deleteMany(&#123; name: &quot;张三&quot;, sex: &quot;男&quot; &#125;); 5.4 更新文档5.4.1 更新单个文档语法： bson12345db.集合名.updateOne( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;flag&gt; &#125;) 含义： 名称 类型 说明 filter 文档 要更新的文档，如果为&#123;&#125;则更新第一个文档，支持通过查询操作符匹配。 update 文档或管道 要应用更新的修改，只能使用更新操作符或管道。 flag 布尔 可选。指定未匹配时是否插入文档，默认为false，false表示不插入，true表示插入。 示例： bson1234db.student.updateOne( &#123; name: &quot;张三&quot;, sex: &quot;男&quot; &#125;, &#123; $set: &#123; sex: &quot;女&quot; &#125; &#125;); 说明： 更新后会将结果通过acknowledged返回，使用true表示更新成功，使用false表示更新失败。同时将匹配个数通过matchedCount返回，将更新个数通过modifiedCount返回。 如果匹配到多个文档，只会更新第一个文档。 5.4.2 更新多个文档语法： bson12345db.集合名.updateMany( &lt;filter&gt;, &lt;update&gt;, &#123; upsert: &lt;flag&gt; &#125;) 含义： 名称 类型 说明 filter 文档 要更新的文档，如果为&#123;&#125;则更新全部文档，支持通过查询操作符匹配。 update 文档或管道 要应用更新的修改，只能使用更新操作符或管道。 flag 布尔 可选。指定未匹配时是否插入文档，默认为false，false表示不插入，true表示插入。 示例： bson1234db.student.updateMany( &#123; name: &quot;张三&quot;, sex: &quot;男&quot; &#125;, &#123; $set: &#123; name: &quot;赵六&quot; &#125; &#125;); 5.4.3 替换单个文档语法： bson12345db.集合名.replaceOne( &lt;filter&gt;, &lt;replace&gt;, &#123; upsert: &lt;flag&gt; &#125;) 含义： 名称 类型 说明 filter 文档 要替换的文档，如果为&#123;&#125;则替换第一个文档，支持通过查询操作符匹配。 replace 文档 要应用替换的文档，只能使用文档。 flag 布尔 可选。指定未匹配时是否插入文档，默认为false，false表示不插入，true表示插入。 示例： bson1234db.student.replaceOne( &#123; name: &quot;张三&quot;, sex: &quot;男&quot; &#125;, &#123; name: &quot;赵六&quot; &#125;); 说明： 替换后会将结果通过acknowledged返回，使用true表示替换成功，使用false表示替换失败。同时将匹配个数通过matchedCount返回，将替换个数通过modifiedCount返回。 如果匹配到多个文档，只会替换第一个文档。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"安装","slug":"E00-数据库/E01-MongoDB/001-基础/002-安装","date":"2025-03-18T01:45:13.000Z","updated":"2025-06-21T09:09:00.305Z","comments":true,"path":"posts/20250318/094513/","permalink":"https://momashanhe.com/posts/20250318/094513/","excerpt":"摘要：本文学习了在Windows中下载和安装MongoDB数据库，以及在安装后进行配置和开启权限验证。","text":"摘要：本文学习了在Windows中下载和安装MongoDB数据库，以及在安装后进行配置和开启权限验证。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 下载和安装1.1 下载官方下载地址： 最新版本 历史版本 发布的版本号以X.Y.Z的形式记录，X是主版本号，Y是次版本号，Z是补丁版本号。 在4.4以及更早的版本中，使用生产版本和开发版本发布，通过次版本号控制，偶数表示生产版本，奇数表示开发版本。 从5.0开始，使用主要版本和快速版本发布。如果只有主版本号，那就是主要版本。如果有次版本号，那就是快速版本。其他情况就是补丁版本。 1.2 安装建议下载zip版本，在安装目录新建MongoDB目录，将mongodb-windows-x86_64-6.0.21.zip解压到MongoDB目录并重命名为mongodb-6.0.21。 2 配置2.1 目录在mongodb-6.0.21目录下创建db目录和log目录。 使用db目录存储数据文件，使用log目录存储日志。 2.2 配置文件在mongodb-6.0.21目录下创建mongod.conf文件： mongod.conf12345678910111213141516171819# mongod.cfgsystemLog: # 日志输出目的地，表示输出到日志文件，如果不指定，则会输出到标准输出中 destination: file # 日志路径，启动后自动创建 path: D:\\Work\\MongoDB\\mongodb-6.0.21\\log\\mongod.log # 重启后如何记录日志，如果为true则将日志添加到尾部，如果为false则备份日志并创建新文件，默认为false logAppend: truenet: # 设置MongoDB的端口 port: 27017 # 设置可以访问的ip地址，多个用逗号分隔 bindIp: 127.0.0.1storage: # 进程存储数据目录，对mongod进程有效，对mongos进程无效 dbPath: D:\\Work\\MongoDB\\mongodb-6.0.21\\db 2.3 服务使用管理员身份打开cmd命令行，执行命令安装服务： cmd1sc create MongoDB binPath= &quot;D:\\Work\\MongoDB\\mongodb-6.0.21\\bin\\mongod.exe --service --config=D:\\Work\\MongoDB\\mongodb-6.0.21\\mongod.conf&quot; start= &quot;auto&quot; Displayname= &quot;MongoDB&quot; 如果想要删除服务，需要执行命令： cmd1sc delete MongoDB 打开服务，在列表找到刚刚创建的MongoDB服务，右键执行启动。 创建服务的好处就是可以让服务运行在后台，不需要通过命令行保持运行。 3 连接工具从5.0.0开始，取消了自带的命令行工具。 因为在命令行编写语句时需要注意换行的问题，所以建议使用其他工具连接数据库。 官方推荐的工具下载地址：下载地址 建议使用Navicat工具，兼容其他数据库，使用方便。 打开Navicat并新建连接： 点击测试连接提示连接成功，点击确定保存连接。 双击新建的连接，并点击新建查询，即可编写语句并执行。 4 权限验证在未使用权限验证的情况下任何人都可以访问数据库，存在安全风险，建议通过配置增加权限验证。 修改mongod.conf配置文件，增加配置： mongod.conf123security: # 开启强制身份验证，需要配置用户名和密码信息 authorization: enabled 修改配置文件后需要重启MongoDB数据库服务。 使用命令进入admin数据库： bson1use admin; 使用命令创建root用户： bson1db.createUser(&#123; user: &quot;root&quot;, pwd: &quot;123456&quot;, roles: [ &quot;root&quot; ] &#125;); 修改连接，将验证方式改为Password表示通过账号密码登录，修改验证数据库为admin，填写账号密码，测试连接并保存。 重新连接并新建查询，执行查看数据库列表： bson1show dbs;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"入门","slug":"E00-数据库/E01-MongoDB/001-基础/001-入门","date":"2025-03-17T05:09:18.000Z","updated":"2025-06-21T09:07:49.979Z","comments":true,"path":"posts/20250317/130918/","permalink":"https://momashanhe.com/posts/20250317/130918/","excerpt":"摘要：本文学习了数据库的定义和分类，以及MongoDB数据库的基本知识。","text":"摘要：本文学习了数据库的定义和分类，以及MongoDB数据库的基本知识。 环境 Windows 10 企业版 LTSC 21H2MongoDB 6.0.21 1 数据库1.1 定义数据库是按照数据结构来组织、存储和管理数据的仓库。 程序是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行中的数据都会丢失。所以需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性。而数据库就是数据持久化的最佳选择。 比较简单的数据库就是类似LowDB这种使用文本存储的数据库，使用比较简单，单功能也比较有限。 1.2 分类如果按数据模型分类，可以将数据库分为关系型数据库和非关系型数据库。 1.2.1 关系型数据库通常适用SQL（Structured Query Language）表示。 以表格的形式组织数据，表格之间通过关系相连，使用SQL语言进行数据操作。 常见的数据库有：MySQL、Oracle、SQL Server、PostgreSQL等等。 适用于需要复杂查询和事务处理的场景，比如银行系统和企业资源规划系统等等。 1.2.2 非关系型数据库通常使用NoSQL（Not only SQL）表示。 非关系型数据库根据存储形式不同还可以进一步分类。 1.2.2.1 键值存储数据库以键值对的形式存储数据，键是唯一的，值可以是任意类型的数据。 常见的数据库有：Redis、Riak。 适用于需要快速读写操作的场景，比如缓存系统和会话存储。 1.2.2.2 文档型数据库以文档的形式存储数据，文档可以是JSON和XML等格式，每个文档都是独立的。 常见的数据库有：MongoDB、CouchDB。 适用于需要灵活的数据结构和快速的读写操作，比如内容管理系统和实时分析系统。 1.2.2.3 列族数据库以列族为单位存储数据，适合存储大量稀疏数据。 常见的数据库有：HBase、Cassandra。 适用于需要处理海量数据和高写入速率的场景，如物联网数据存储、日志分析。 1.2.2.4 图数据库以图的形式存储数据，擅长处理实体之间的关系。 常见的数据库有：Neo4j、OrientDB。 适用于需要处理复杂关系的数据，如社交网络、知识图谱。 2 简介2.1 概述MongoDB是一种流行的开源文档型数据库，属于NoSQL数据库的一种。它以其灵活的数据模型、高性能和可扩展性而闻名，特别适合处理大量结构化和非结构化数据的应用程序。 官网网站： 官网地址：https://www.mongodb.com/ 文档地址：https://www.mongodb.com/zh-cn/docs/ 2.2 特点MongoDB数据库的特点如下： 高可用性：通过复制集（Replica Set）机制，实现数据的自动备份和故障转移。复制集由多个节点组成，包括一个主节点和多个从节点，数据在这些节点之间自动同步。 模式自由：使用动态模式（Schema-less）架构，同一集合中的文档可拥有不同属性，开发过程中可随时调整结构，减少迁移成本。 高性能：利用内存映射文件加速数据访问，支持多种索引类型（如复合、全文、地理空间）。 水平扩展：支持分片（Sharding）技术，允许将数据集拆分成多个部分，每个部分存储在不同的服务器上，从而提高系统的处理能力和存储容量。 复杂查询：支持复杂的查询表达式和操作符，包括聚合（Aggregation）、文本搜索（Text Search）和地理空间查询（Geospatial Queries）等，使得数据的检索和处理更加方便。 事务支持：在4.0版本后支持跨文档事务，满足一致性要求较高的场景，但需权衡性能。 多语言驱动：支持多种编程语言的驱动，比如Ruby、Java、C#、JavaScript、C、C++、PHP、Perl和Python等，方便开发者在不同的编程环境中使用。 2.3 术语MongoDB使用BSON（Binary JSON）格式存储数据，是一种类似JSON的二进制形式的存储格式，具有更高的存储效率和处理速度。每个文档都可以包含不同数量和类型的属性，使得数据模型更加灵活。 MongoDB被称为“最像关系型数据库的NoSQL数据库”，其术语对比如下： SQL术语 SQL说明 MongoDB术语 MongoDB说明 database 数据库 database 数据库 table 表 collection 集合 row 行 document 文档 column 字段 field 属性 index 索引 index 索引 primary key 主键 primary key 主键，默认将_id作为主键 数据库用于存储集合，集合用于合并文档，文档则是数据的基本单位，由键值对组成，类似于JSON对象。 在MongoDB中，数据库和集合都不需要手动创建，在创建文档时，如果文档所在的集合或者数据库不存在，则会自动创建数据库或者集合，不需要预先定义固定的模式，非常灵活。 2.4 业务场景具体的应用场景： 社交场景，存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人，地点等功能。 游戏场景，存储游戏用户信息，用户的装备，积分等直接以内嵌文档的形式存储，方便查询，高效率存储和访问。 物流场景，存储订单信息，订单状态在运送过程中会不断更新，以内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。 物联网场景，存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。 视频直播，存储用户信息，点赞互动信息等。 这些应用场景中，数据操作方面的共同点有： 数据量大。 写入操作频繁。 价值较低的数据，对事务性要求不高。 在架构选型上，除了上述三个特点之外，还要考虑下面这些问题： 应用不需要事务及复杂JOIN支持。 应用需要快速迭代开发，数据模型无法确定。 应用需要2000-3000以上的读写QPS。 应用需要TB甚至PB级别数据存储。 应用需要快速水平扩展。 应用需要高可用，存储的数据不能丢失。 应用需要大量的地理位置查询，文本查询。 如果有1个符合，可以考虑使用MongoDB，如果2个及以上的符合，选择使用MongoDB绝不会后悔。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"}]},{"title":"使用LowDB数据库","slug":"C00-前端/C04-Node/003-数据库/001-使用LowDB数据库","date":"2025-03-16T04:42:42.000Z","updated":"2025-06-21T08:57:43.267Z","comments":true,"path":"posts/20250316/124242/","permalink":"https://momashanhe.com/posts/20250316/124242/","excerpt":"摘要：本文学习了什么是LowDB数据库，如何在Node项目中实现对数据的增删改查。","text":"摘要：本文学习了什么是LowDB数据库，如何在Node项目中实现对数据的增删改查。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12LowDB 1.0.0 1 初识1.1 简介LowDB是一个轻量级的本地JSON数据库，专为Node环境设计。它使用简单的JSON文件作为数据存储，提供了一个方便的API来读写数据。 1.2 特点主要特点： 简单易用：API设计简洁直观，上手容易。 轻量级：整个库非常小巧，不会给项目增加太多负担。 灵活性：支持自定义存储适配器，可以轻松切换存储方式。 Lodash支持：内置Lodash，提供强大的数据操作能力。 类型安全：提供TypeScript支持，增强代码的可靠性。 2 安装使用npm install lowdb@1.0.0命令安装。 因为最新版本需要通过ES模块引入，所以需要安装早起版本以便能通过CommonJS模块引入。 3 使用3.1 初始化初始化数据库： app.js12345678910// 引入模块const low = require(&#x27;lowdb&#x27;);const path = require(&#x27;path&#x27;);const FileSync = require(&#x27;lowdb/adapters/FileSync&#x27;);// 指定数据文件const file = path.resolve(__dirname, &#x27;db.json&#x27;);// 创建同步适配器const adapter = new FileSync(file);// 创建LowDB实例const db = low(adapter); 在命令行执行node app.js命令会在当前目录生成个db.json文件，存储了默认数据： db.json12345&#123; &quot;posts&quot;: [], &quot;user&quot;: &#123;&#125;, &quot;count&quot;: 0&#125; 默认数据： js1db.defaults(&#123;posts: [], user: &#123;&#125;, count: 0 &#125;).write(); 3.2 增删改查3.2.1 增加写入数据： js1234// 从尾部写入db.get(&#x27;posts&#x27;).push(&#123;id: 1, title: &#x27;天气不错&#x27;&#125;).write();// 从头部写入db.get(&#x27;posts&#x27;).unshift(&#123;id: 2, title: &#x27;天气不错&#x27;&#125;, &#123;id: 3, title: &#x27;天气不好&#x27;&#125;).write(); 3.2.2 删除删除数据： js123456// 删除对象属性db.get(&#x27;user&#x27;).unset(&#x27;name&#x27;).write();// 删除列表单条或多条db.get(&#x27;posts&#x27;).remove(&#123;id: 1&#125;).write();// 删除列表所有数据db.get(&#x27;posts&#x27;).remove().write(); 3.2.3 修改修改数据： js1234// 设置对象属性db.get(&#x27;user&#x27;).set(&#x27;sex&#x27;, &#x27;男&#x27;).set(&#x27;name&#x27;, &#x27;张三&#x27;).write();// 设置列表记录db.get(&#x27;posts&#x27;).find(&#123;id: 1&#125;).assign(&#123;title: &#x27;天气很好&#x27;&#125;).write(); 3.3.4 查询查询单条数据： js12let result = db.get(&#x27;posts&#x27;).find(&#123;id: 1&#125;).value();console.log(result);// &#123; id: 1, title: &#x27;天气不错&#x27; &#125; 查询多条数据： js123456let result = db.get(&#x27;posts&#x27;).filter(&#123;title: &#x27;天气不错&#x27;&#125;).value();console.log(result);// [// &#123; id: 2, title: &#x27;天气不错&#x27; &#125;,// &#123; id: 1, title: &#x27;天气不错&#x27; &#125;// ] 查询所有数据： js1234567let result = db.get(&#x27;posts&#x27;).value();console.log(result);// [// &#123; id: 2, title: &#x27;天气不错&#x27; &#125;,// &#123; id: 3, title: &#x27;天气不好&#x27; &#125;,// &#123; id: 1, title: &#x27;天气不错&#x27; &#125;// ] 排序： js1234567let result = db.get(&#x27;posts&#x27;).orderBy(&#x27;id&#x27;, &#x27;asc&#x27;).value();console.log(result);// [// &#123; id: 1, title: &#x27;天气很好&#x27; &#125;,// &#123; id: 2, title: &#x27;天气不错&#x27; &#125;,// &#123; id: 3, title: &#x27;天气不好&#x27; &#125;// ] 查询数据条数： js12let count = db.get(&#x27;posts&#x27;).size().value();console.log(count);// 3","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"},{"name":"LowDB","slug":"LowDB","permalink":"https://momashanhe.com/tags/LowDB/"}]},{"title":"Express","slug":"C00-前端/C04-Node/002-框架/001-Express","date":"2025-03-12T06:05:23.000Z","updated":"2025-06-21T08:57:43.267Z","comments":true,"path":"posts/20250312/140523/","permalink":"https://momashanhe.com/posts/20250312/140523/","excerpt":"摘要：本文学习了Express框架，包括安装和简单使用，以及如何防盗链和使用模板引擎渲染页面等等。","text":"摘要：本文学习了Express框架，包括安装和简单使用，以及如何防盗链和使用模板引擎渲染页面等等。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12Express 4.16.1EJS 3.1.10Formidable 3.5.2 1 初识Express是一个基于Node平台的极简且灵活的Web应用框架，它提供了强大且丰富的功能，如路由定义、中间件使用、静态文件服务等，帮助开发者快速构建Web应用和API接口。 官方网址：https://www.expressjs.com.cn/ 2 安装创建项目目录并使用npm init命令初始化。 使用npm install express命令安装Express框架。 在项目根目录创建app.js文件： app.js1234567891011121314// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 创建路由app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;hello&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 在命令行执行node app.js命令启动服务，在浏览器访问http://127.0.0.1:3000/请求服务。 3 路由3.1 概念路由是指根据不同的URL路径和请求方法，将请求映射到相应的处理函数。 在Express中，路由定义是应用的核心部分，它决定了如何响应客户端的请求。 3.2 初体验语法： js1app.method(path, handler) 参数： app：是Express的一个实例。 method：小写的请求方法。 path：服务器上的路径，多个路径需要传入路径数组。 handler：路由匹配时执行的函数。 示例： js12345678910111213141516171819202122232425// 创建get默认路由app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;index&#x27;);&#125;);// 创建get路由app.get(&#x27;/home&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;home&#x27;);&#125;);// 创建post路由app.post(&#x27;/login&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;login&#x27;);&#125;);// 创建公共路由，允许所有请求方法app.all(&#x27;/search&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;search&#x27;);&#125;);// 匹配所有路由规则app.all(&#x27;*&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); res.end(&#x27;404&#x27;);&#125;); 3.3 路由参数路由参数是指在定义路由时，在路径中指定的动态部分，用于捕获URL中的特定值。这些参数可以被路由处理函数访问，用于根据动态值生成响应。 路由参数在路径中以:开头，后面跟参数名称，用来获取URL中对应位置的数据。 示例： js1234567891011121314151617const users = [&#123;id:&#x27;1&#x27;, name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;2&#x27;, name:&#x27;李四&#x27;, sex:&#x27;女&#x27;&#125;];// 路由参数app.get(&#x27;/search/:id/:name&#x27;, (req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); // 获取路由参数 let params = req.params; console.log(&#x27;路由参数: &#x27; + JSON.stringify(params)); // 根据路由参数查询数据 let user = users.find(user =&gt; user.id == params.id &amp;&amp; user.name == params.name); if (user) &#123; console.log(&#x27;查询用户: &#x27; + JSON.stringify(user)); res.end(JSON.stringify(user)); &#125; else &#123; console.log(&#x27;查无此人&#x27;); res.end(&#x27;查无此人&#x27;); &#125;&#125;); 在浏览器访问http://127.0.0.1:3000/search/1/张三请求服务，控制台信息： bash12路由参数: &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;&#125;查询用户: &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125; 3.4 优化请求参数在原生http模块的基础上增加了获取请求信息的方式： js12345678910// 获得请求协议类型console.log(req.protocol);// 获取请求URL中的路径console.log(req.path);// 获得请求URL中的查询字符串console.log(req.query);// 获得请求头的数据console.log(req.get(&#x27;host&#x27;));// 获得请求路由参数console.log(req.params); 3.5 优化响应参数在原生http模块的基础上增加了设置响应内容的方式： js123456// 设置响应状态码，默认是200res.status(200);// 设置响应头res.set(&#x27;Content-Test&#x27;, &#x27;test&#x27;);// 设置响应体，无需设置UTF-8中文也不会乱码res.send(&#x27;搜索&#x27;); 也支持支持链式调用： js12// 同时设置响应状态码、响应头、响应体res.status(200).set(&#x27;Content-Test&#x27;, &#x27;test&#x27;).send(&#x27;搜索&#x27;); 不能同时使用Node原生方式和Express新增方式返回响应。 除了使用send方法，还支持其他响应设置： js12345678910111213141516171819202122232425// 获取路由参数let params = req.params;// 根据路由参数设置响应switch (params.type) &#123; case &#x27;redirect&#x27;: // 设置重定向 res.redirect(&#x27;http://www.baidu.com&#x27;); break; case &#x27;download&#x27;: // 设置下载 res.download(path.resolve(__dirname, &#x27;index.html&#x27;)); break; case &#x27;json&#x27;: // 设置JSON res.json(&#123; id:&#x27;1&#x27;, name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125; ); break; case &#x27;file&#x27;: // 设置文件，根据文件后缀自动设置MIME类型 res.sendFile(path.resolve(__dirname, &#x27;index.html&#x27;)); break; default: // 设置默认方式 res.send(&#x27;不支持的响应类型&#x27;); break;&#125; 4 中间件4.1 概念中间件是一种回调函数，可以访问请求对象、响应对象以及指向下一个中间件。 中间件用于执行各种任务，如日志记录、身份验证、数据解析等。 4.2 分类按照使用位置，可以分为全局中间件和路由中间件： 全局中间件：定义在应用里，对所有路由生效。 路由中间件：定义在路由上，对当前路由生效。 按照处理类型，可以分为静态中间件和动态中间件： 静态中间件：对静态资源生效，静态中间件一般都是全局中间件。 动态中间件：对非静态的资源生效。 按照创建类型，可以分为自定义中间件和内置中间件： 内置中间件：内置的中间件，比如静态中间件。 自定义中间件：自定义或者第三方创建的中间件。 4.3 使用4.3.1 全局中间件示例： js12345678910111213141516171819202122232425262728// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 创建方法作为中间件，接收参数function operateLog(req, res, next) &#123; // 记录日志 let date = new Date().toLocaleString(); let path = req.path.slice(1); console.log(`操作日志: $&#123;date&#125; $&#123;path&#125;`); // 继续执行后续的中间件和路由 next();&#125;// 调用方法作为中间件app.use(operateLog);// 新增操作app.all(&#x27;/insert&#x27;, (req, res) =&gt; &#123; res.send(&#x27;新增成功&#x27;);&#125;);// 查询操作app.all(&#x27;/select&#x27;, (req, res) =&gt; &#123; res.send(&#x27;查询成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 4.3.2 路由中间件示例： js1234567891011121314151617181920212223242526// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 创建方法作为中间件，接收参数function insertLog(req, res, next) &#123; // 记录日志 let date = new Date().toLocaleString(); let path = req.path.slice(1); console.log(`新增日志: $&#123;date&#125; $&#123;path&#125;`); // 继续执行后续的中间件和路由 next();&#125;// 新增操作，调用方法作为路由中间件app.all(&#x27;/insert&#x27;, insertLog, (req, res) =&gt; &#123; res.send(&#x27;新增成功&#x27;);&#125;);// 查询操作app.all(&#x27;/select&#x27;, (req, res) =&gt; &#123; res.send(&#x27;查询成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 4.3.3 静态中间件示例： js123456789101112131415// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 使用内置的static()方法作为中间件，指定静态文件目录app.use(express.static(require(&#x27;path&#x27;).resolve(__dirname, &#x27;home&#x27;)));// 其他请求app.all(&#x27;*&#x27;, (req, res) =&gt; &#123; res.send(&#x27;处理成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 如果访问的是静态文件目录的文件资源，会通过静态中间件找到文件并返回。如果访问的是其他资源，会判断其他路由并返回。 在浏览器访问http://127.0.0.1:3000/默认会在静态资源目录寻找index.html文件，所以可以将index.html文件作为首页。 默认情况下使用public目录作为静态文件目录。 4.3.4 组合中间件示例： js123456789101112131415161718192021222324// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 静态资源使用静态中间件app.use(express.static(require(&#x27;path&#x27;).resolve(__dirname, &#x27;home&#x27;)));// 创建自定义中间件let check = (req, res, next) =&gt; &#123; console.log(); if (req.query.password == 123456) &#123; next(); &#125; else &#123; res.send(&#x27;密码验证失败&#x27;); &#125;&#125;// 其他请求使用自定义中间件app.all(&#x27;*&#x27;, check, (req, res) =&gt; &#123; res.send(&#x27;处理成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 组合匹配的情况下，按照代码顺序匹配路由。 4.4 解析请求体支持两种方式解析请求体： 使用express.urlencoded(&#123;extended: false&#125;)获得解析application/x-www-form-urlencoded格式请求体的中间件。 使用express.json()获得解析application/json格式请求体的中间件。 使用： js1234567891011121314151617// 引入模块const express = require(&#x27;express&#x27;);// 创建实例const app = express();// 使用中间件解析请求体app.use(express.urlencoded(&#123;extended: false&#125;));app.use(express.json());// 解析后会在req的body中添加请求数据app.post(&#x27;/login&#x27;, (req, res) =&gt; &#123; console.log(req.body); res.send(&#x27;处理成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 4.5 模块化将路由分成多个模块，统一进行导入和使用。 示例： app.js1234567891011121314151617181920// 引入模块const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);// 创建实例const app = express();// 导入路由器模块const userRouter = require(path.resolve(__dirname, &#x27;routes/userRouter.js&#x27;));const adminRouter = require(path.resolve(__dirname, &#x27;routes/adminRouter.js&#x27;));// 设置全局中间件，挂载路由器app.use(userRouter);app.use(adminRouter);// 处理业务app.all(&#x27;*&#x27;, function (req, res) &#123; res.send(&#x27;处理成功&#x27;);&#125;)// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 编写userRouter.js文件，示例： userRouter.js12345678910// 引入模块const express = require(&#x27;express&#x27;);// 创建路由器const router = express.Router();// 处理业务router.get(&#x27;/login&#x27;, (req, res) =&gt; &#123; res.send(&#x27;登录&#x27;);&#125;);// 暴露路由module.exports = router; 编写adminRouter.js文件，示例： adminRouter.js12345678910// 引入模块const express = require(&#x27;express&#x27;);// 创建路由器const router = express.Router();// 处理业务router.get(&#x27;/setting&#x27;, (req, res) =&gt; &#123; res.send(&#x27;设置&#x27;);&#125;);// 暴露路由module.exports = router; 在挂载路由器模块的时候，如果该模块拥有共同访问前缀，可以在挂载的时候进行设置： js123// 设置全局中间件，挂载路由器，使用前缀app.use(&#x27;/user&#x27;, userRouter);app.use(&#x27;/admin&#x27;, adminRouter); 使用前缀后，访问的时候需要拼接前缀访问。 4.6 错误处理在Express中，路由的回调方法中除了可以传入req对象和res对象，还支持传入next方法，使用next方法处理路由错误。 4.6.1 异步代码错误异步代码中的错误需要使用next方法手动处理，默认会将请求挂起直至超时： js12345678910111213141516171819202122// 引入模块const express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);// 创建实例const app = express();// 处理请求，传入next处理错误app.get(&#x27;/read&#x27;, (req, res, next) =&gt; &#123; fs.readFile(&#x27;./info.txt&#x27;, (err, data) =&gt; &#123; if (err) &#123; // 使用next将错误返回前端并打印到控制台 next(err); // 避免执行后续逻辑 return; &#125; res.send(data.toString()); &#125;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 4.6.2 同步代码错误同步代码中发生的错误不需要手动处理，默认会将错误返回前端并打印到控制台： js123456789101112131415// 引入模块const express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);// 创建实例const app = express();// 处理请求app.get(&#x27;/read&#x27;, (req, res) =&gt; &#123; let data = fs.readFileSync(&#x27;./info.txt&#x27;); res.send(data.toString());&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 也可以手动捕获错误并使用next方法处理错误： js123456789101112131415161718192021// 引入模块const express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);// 创建实例const app = express();// 处理请求，传入next处理错误app.get(&#x27;/read&#x27;, (req, res, next) =&gt; &#123; // 使用try-catch捕获错误 try &#123; let data = fs.readFileSync(&#x27;./info.txt&#x27;); res.send(data.toString()); &#125; catch (err) &#123; // 使用next将错误返回前端并打印到控制台 next(err); &#125;&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 4.6.3 错误处理中间件错误处理中间件需要四个参数，三个参数的中间件将被解释为常规中间件，无法处理错误。 在路由方法中或者在常规中间件中如果使用next方法处理了错误，会忽略之后的常规中间件，只调用错误处理中间件。 示例： js1234567app.use((err, req, res, next) =&gt; &#123; console.error(err.stack); res.status(500).json(&#123; error: &#x27;服务器内部错误&#x27;, message: err.message, &#125;);&#125;); 注意要让错误处理中间件最后执行： 对于全局中间件来说，根据从上到下的执行规则，要将错误处理中间件写在最下面，保证经过所有路由后再执行错误处理中间件。 对于局部中间件来说，根据从左到右的执行规则，要将错误处理中间件挂载到路由链的末尾，保证最后执行。 5 防盗链为了防止外部网站盗用网站资源，可以对网站的资源做防盗链处理，防止直接复制图片地址进行下载。 请求头里的referer参数会携带当前域名和协议及其端口进行请求，根据这个特点就可以进行防盗链处理。 示例： js123456789101112131415161718192021222324252627282930313233343536373839404142434445// 引入模块const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);// 创建实例const app = express();// 拦截列表const extArr = [&#x27;.jpg&#x27;, &#x27;.jpeg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;bmp&#x27;];const urlArr = [&#x27;127.0.0.1&#x27;];// 使用中间件防盗链app.use((req, res, next) =&gt; &#123; // 判断是否属于资源文件 if (!extArr.includes(path.extname(req.url))) &#123; next(); return; &#125; // 获得referer参数 const referer = req.get(&#x27;referer&#x27;); if (referer) &#123; // 如果存在referer参数，判断referer的host是否为本机 let url = new URL(referer); if (urlArr.includes(url.hostname)) &#123; next(); return; &#125; &#125; else &#123; // 如果不存在referer参数，判断accept参数是否以image起始 const accept = req.get(&#x27;accept&#x27;); if (accept &amp;&amp; !accept.startsWith(&#x27;image&#x27;)) &#123; next(); return; &#125; &#125; res.status(404).send(&#x27;本资源涉嫌盗链，请访问原网站&#x27;);&#125;);// 使用中间件处理静态资源app.use(express.static(path.resolve(__dirname, &#x27;home&#x27;)));// 使用路由处理动态数据app.all(&#x27;*&#x27;, (req, res) =&gt; &#123; res.send(&#x27;处理成功&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 6 模板引擎6.1 概念模板引擎是分离用户界面和业务数据的一种技术，可以将后端的JS文件和前端的HTML文件结合起来，生成最终的网页或视图，发送给客户端。 模板引擎用于将前端和后端分离，但现在已经能够通过其他技术做到分离了，所以模版引擎用得较少了。 Express支持多种常用的模板引擎，以下是几种常见的模板引擎及其特点： EJS（Embedded JavaScript）：EJS使用纯JS语法作为模板语言，易于上手和学习，支持逻辑控制和模板继承等功能。 Pug（原名Jade）：Pug是一种类似于缩进的模板语言，使用简洁的语法来定义HTML结构，减少了标签的书写，适合编写简洁和易读的模板。 Handlebars：Handlebars提供了灵活的模板语法，支持条件判断、循环、局部块等功能，适合构建复杂的模板结构。 6.2 EJS6.2.1 简介纯JS语法的模板语言，支持直接在标签内编写代码逻辑。 6.2.2 安装官网： 英文官方 中文 使用npm install ejs命令安装。 6.2.3 使用创建views目录存放模板文件，并在views目录中创建welcome.ejs模板文件： welcome.ejs1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;欢迎 &lt;%= user %&gt;&lt;/p&gt; &lt;p&gt;课程：&lt;/p&gt; &lt;% if (classes &amp;&amp; classes.length &gt; 0) &#123; %&gt; &lt;ul&gt; &lt;% for (item of classes) &#123; %&gt; &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;% &#125; %&gt; &lt;/body&gt;&lt;/html&gt; 在路由中指定EJS作为模板引擎，并使用EJS渲染模板文件： js123456789101112131415161718192021// 引入模块const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);// 创建实例const app = express();// 设置模板引擎app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);// 设置模板文件目录app.set(&#x27;views&#x27;, path.resolve(__dirname, &#x27;views&#x27;));// 处理业务app.get(&#x27;/welcome&#x27;, function (req, res) &#123; // 读取数据 let data = &#123;user:&#x27;张三&#x27;, classes:[&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]&#125;; // 渲染数据 res.render(&#x27;welcome&#x27;, data);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 在浏览器访问http://127.0.0.1:3000/welcome会看到渲染后的页面。 7 文件上传7.1 安装使用npm install formidable命令安装。 7.2 使用使用formidable的formidable方法创建表单对象并指定文件存储位置，然后使用表单对象的parse方法解析上传文件，得到存储的地址并返回前端。 示例： app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 引入模块const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);const formidable = require(&#x27;formidable&#x27;);// 创建实例const app = express();// 设置模板引擎app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);// 设置模板文件目录app.set(&#x27;views&#x27;, path.resolve(__dirname, &#x27;views&#x27;));// 模板文件路由app.get(&#x27;/info&#x27;, (req, res) =&gt; &#123; res.render(&#x27;info&#x27;);&#125;);// 文件上传路由app.post(&#x27;/info&#x27;, (req, res, next) =&gt; &#123; // 创建表单对象 const form = formidable.formidable(&#123; // 文件保存路径 uploadDir: path.resolve(__dirname, &#x27;uploads&#x27;), // 保留文件扩展名 keepExtensions: true, // 过滤器 filter: (&#123;name, mimetype&#125;) =&gt; &#123; // 只允许图片类型 return mimetype &amp;&amp; mimetype.includes(&#x27;image&#x27;); &#125;, &#125;); // 使用表单对象解析上传文件 form.parse(req, (err, fields, files) =&gt; &#123; // 处理错误 if (err) &#123; next(err); return; &#125; // 解析上传文件 let urls = Object.fromEntries( Object.entries(files).map( ([name, value]) =&gt; [name, value.map(file =&gt; `/uploads/$&#123;file.newFilename&#125;`)] ) ); // 打印并返回 console.log(fields); console.log(urls); res.send(JSON.stringify(&#123;fields, urls&#125;)); &#125;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:3000/&#x27;);&#125;); 在views目录中创建info.ejs模板文件： info.ejs1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/info&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;address&quot;&gt;居住地：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;address&quot; name=&quot;address&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;portrait&quot;&gt;头像：&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;portrait&quot; name=&quot;portrait&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 8 会话管理8.1 Cookie8.1.1 设置示例： js12345678910111213// 创建设置Cookie请求路由app.get(&#x27;/info/setCookie&#x27;, (req, res) =&gt; &#123; // 设置Cookie res.cookie(&#x27;service&#x27;, &#x27;info&#x27;, &#123; maxAge: 600000, path: &#x27;/info&#x27;, httpOnly: true, secure: false, sameSite: &#x27;strict&#x27; &#125;); // 返回响应 res.send(&#x27;&lt;h1&gt;设置成功&lt;/h1&gt;&#x27;);&#125;); 参数： maxAge：设置过期时间，单位是毫秒。 path：设置作用路径。 httpOnly：是否禁止JS脚本访问，只允许HTTP请求访问，设置为true可以避免XSS攻击。 secure：是否只在HTTPS连接下发送。 sameSite：控制发送级别，发送防止CSRF攻击，可选值为Strict&#x2F;Lax&#x2F;None。 8.1.2 读取读取Cookie需要使用cookie-parser中间件，使用npm install cookie-parser命令安装。 示例： js123456789101112131415161718// 引入模块const cookieParser = require(&#x27;cookie-parser&#x27;);// 启用中间件app.use(cookieParser());// 创建读取Cookie请求路由app.get(&#x27;/info/getCookie&#x27;, (req, res) =&gt; &#123; // 读取Cookie let service = req.cookies.service; // 返回响应 if (service) &#123; res.send(` &lt;h1&gt;读取成功&lt;/h1&gt; &lt;p&gt;服务名：$&#123;service&#125;&lt;/p&gt; `); &#125; else &#123; res.send(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125;&#125;); 8.1.3 删除示例： js12345678// 创建删除Cookie请求路由app.get(&#x27;/info/delCookie&#x27;, (req, res) =&gt; &#123; // 删除Cookie res.clearCookie(&#x27;service&#x27;, &#123; path: &#x27;/info&#x27; &#125;); res.send(&#x27;&lt;h1&gt;删除成功&lt;/h1&gt;&#x27;);&#125;); 8.2 Session8.2.1 设置使用Session需要使用express-session中间件，使用npm install express-session命令安装。 存储Session到MongoDB数据库需要使用connect-mongo中间件，使用npm install connect-mongo命令安装。 示例： js123456789101112131415161718192021222324252627282930// 引入模块const express = require(&#x27;express&#x27;);const session = require(&#x27;express-session&#x27;);const mongo = require(&#x27;connect-mongo&#x27;);// 创建实例const app = express();// 启用中间件app.use(session(&#123; name: &#x27;sid&#x27;, secret: &#x27;salt&#x27;, saveUninitialized: false, resave: true, cookie: &#123; maxAge: 600000, path: &#x27;/info&#x27;, httpOnly: true, secure: false, sameSite: &#x27;strict&#x27; &#125;, store: mongo.create(&#123; mongoUrl: &#x27;mongodb://127.0.0.1:27017/test&#x27; &#125;),&#125;));// 创建设置Session请求路由app.get(&#x27;/info/setSession&#x27;, (req, res) =&gt; &#123; // 设置Session req.session.service = &#x27;info&#x27;; // 返回响应 res.send(&#x27;&lt;h1&gt;设置成功&lt;/h1&gt;&#x27;);&#125;); 参数： name：设置在Cookie中传输SessionId使用的名字，默认是sid。 secret：用于加密的字符串，也称为加盐。 saveUninitialized：是否为每次请求存储Session信息，默认为false，只给建立了Session的请求存储，设置为true可以给匿名用户存储Session信息。 resave：是否每次请求都存储Session信息，设置为true可以在每次请求时存储Session信息，避免超时导致Session失效。 cookie：设置Cookie的回传信息。 store：设置存储Session的数据库信息。 8.2.2 读取示例： js1234567891011121314// 创建读取Session请求路由app.get(&#x27;/info/getSession&#x27;, (req, res) =&gt; &#123; // 读取Session let service = req.session.service; // 返回响应 if (service) &#123; res.send(` &lt;h1&gt;读取成功&lt;/h1&gt; &lt;p&gt;服务名：$&#123;service&#125;&lt;/p&gt; `); &#125; else &#123; res.send(&#x27;&lt;h1&gt;读取失败&lt;/h1&gt;&#x27;); &#125;&#125;); 8.2.3 删除示例： js123456789101112131415161718// 创建删除Session请求路由app.get(&#x27;/info/delSession&#x27;, (req, res) =&gt; &#123; // 删除Session req.session.destroy(err =&gt; &#123; if (err) &#123; res.send(` &lt;h1&gt;删除失败&lt;/h1&gt; &lt;p&gt;失败原因：$&#123;err&#125;&lt;/p&gt; `); &#125; else &#123; // 删除Cookie res.clearCookie(&#x27;service&#x27;, &#123; path: &#x27;/info&#x27; &#125;); res.send(&#x27;&lt;h1&gt;删除成功&lt;/h1&gt;&#x27;); &#125; &#125;);&#125;); 9 快速构建使用npm install express-generator -g命令全局安装构建工具。 安装后可以执行express -h命令查看帮助。 使用express -e 目录名设置构建项目的目录。 进入目录后执行npm install命令重新安装项目所需要的依赖。 查看package.json文件查看命令，启动项目。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"},{"name":"Express","slug":"Express","permalink":"https://momashanhe.com/tags/Express/"}]},{"title":"网络通信","slug":"C00-前端/C04-Node/001-基础/009-网络通信","date":"2025-03-10T07:10:12.000Z","updated":"2025-06-21T08:57:45.035Z","comments":true,"path":"posts/20250310/151012/","permalink":"https://momashanhe.com/posts/20250310/151012/","excerpt":"摘要：本文解释了网络通信的背景知识，以及如何在Node项目中使用网络通信功能。","text":"摘要：本文解释了网络通信的背景知识，以及如何在Node项目中使用网络通信功能。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 概念1.1 网络通信网络通信就是在两个或两个以上的设备之间传输数据。 计算机网络将分布在不同地理区域的计算机与外部设备连成一个巨大的网络系统，从而使众多的计算机可以方便地互相传递信息。 实现网络通信需要解决两个问题： 如何准确地定位网络上一台或多台主机，如何定位主机上的特定的应用。 找到主机后如何可靠高效地进行数据传输。 解决办法： 使用IP地址和端口号识别网络上的每个设备。 使用网络通讯协议保证设备之间数据传输的安全可靠。 说明： IP地址：网络设备唯一的数字标识，解决了设备在网络上的识别问题。 域名：为了方便记忆IP地址而创建的概念，一个IP地址可以对应多个域名，一个域名只能对应一个IP地址。 域名解析服务（DNS，Domain Name Service）：在实际传输数据前将域名解析为IP地址的功能。 域名解析服务器（DNS，Domain Name Server）：实现域名解析的服务器，当用户在浏览器输入域名时，浏览器首先通过DNS服务器将域名转换为IP地址，然后在浏览器根据IP地址进行实际的数据传输。 端口：计算机上每个应用进行网络通信的唯一标识，解决了应用在计算机上的识别问题。 网络通讯协议：规定了网络上的设备传输数据的格式。 1.2 网络模型网络模型规定了网络上的计算机之间以何种规则进行通信。 常见的网络模型对比如下： OSI七层网络模型 TCP/IP四层网络模型 TCP/IP五层网络模型 网络协议 工作设备 应用层 应用层 应用层 HTTP HTTPS FTP SMTP POP3 计算机及应用 表示层 会话层 传输层 传输层 传输层 TCP UDP 四层交换机 四层路由器 网络层 网络层 网络层 IP ICMP ARP RARP 三层交换机 路由器 网关 数据链路层 网络接口层 数据链路层 Ethernet PPP 交换机 网桥 物理层 物理层 USB 中继器 集线器 1.3 HTTP协议HTTP全称为Hyper Text Transport Protocol，中文名称为超文本传输协议。 HTTP是一种基于TCP&#x2F;IP的应用层通信协议，协议详细规定了浏览器和万维网服务器之间互相通信的规则。 协议中主要规定了两个方面的内容： 客户端：用来向服务器发送数据，可以将发送的数据称为请求报文。 服务端：向客户端返回数据，可以将返回的数据称为响应报文。 1.4 请求报文请求报文是客户端向服务器发送的请求信息，用于在客户端和服务器之间进行通信，是HTTP协议的重要组成部分。 组成部分： 请求行：包含请求方法、请求的资源路径和HTTP协议版本。 请求头：包含客户端发送给服务器的额外信息，如客户端类型、接受的媒体类型等。 空行：用于分隔请求头和请求体。 请求体：可选部分，用于包含要发送给服务器的数据，如表单数据、JSON数据等。 示例： txt1234567891011POST /login HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)Accept: text/html,application/xhtml+xmlAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 29username=JohnDoe&amp;password=12345 1.4.1 请求行请求行由三部分组成： POST是请求方法，表示以何种方法请求获取指定的资源，比如GET&#x2F;POST&#x2F;PUT&#x2F;DELETE等。 /login是URL统一资源定位符，表示请求资源的位置。 HTTP/1.1是协议版本，表示使用的协议版本。 常见的请求方法： 请求方法 功能 传参位置 安全性 使用场景 GET 获取资源 参数在URL中 较低 获取数据，如搜索用户 POST 提交数据创建或更新资源 参数在请求体中 较高 提交数据，如表单提交用户信息 PUT 上传全部数据更新资源 参数在请求体中 较高 更新整个资源，如更新用户信息 DELETE 删除资源 参数在URL中或请求体中 较低 删除资源，如删除用户 1.4.2 请求头常见的请求头： Host：表示请求的主机名，即服务器的域名。 User-Agent：表示客户端的用户代理信息，包括浏览器类型、版本、操作系统等，用于服务器识别客户端的环境。 Accept：表示客户端可以接受的媒体类型。 Accept-Language：表示客户端可以接受的语言。 Accept-Encoding：表示客户端可以接受的编码方式。 Connection：表示客户端希望在请求完成后的连接方式。使用keep-alive表示保持连接，使用close表示关闭连接。 Content-Type：表示请求体中的数据类型是表单数据。 Content-Length：表示请求体的长度，使用字节作为单位。 1.4.3 空行空行用于分隔请求头和请求体。 1.4.4 请求体如果是GET请求，通常不包含请求体。如果是POST或PUT请求，可能会包含表单数据、JSON数据等，用于向服务器提交信息。 传参限制： 如果是在URL传参，受URL长度限制，参数长度最大为2K。 如果是在请求体传参，参数长度没有限制，但长度过长会受网速影响导致页面加载异常。 1.5 响应报文响应报文是服务器在接收到客户端的请求后，向客户端返回的响应信息。 组成部分： 状态行：包含HTTP协议版本、状态码和状态消息，用于告知客户端请求的处理结果。 响应头：包含服务器发送给客户端的额外信息，如服务器类型、内容类型、内容长度等。 空行：用于分隔响应头和响应体。 响应体：可选部分，包含服务器返回给客户端的资源内容，如HTML页面、JSON数据等。 示例： txt12345678HTTP/1.1 200 OKDate: Tue, 15 Nov 2022 12:34:56 GMTServer: Apache/2.4.41 (Ubuntu)Content-Type: application/json; charset=UTF-8Content-Length: 75Connection: keep-alive&#123;&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;Data retrieved successfully&quot;, &quot;data&quot;: &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;&#125;&#125; 1.5.1 状态行状态行由三部分组成： HTTP/1.1是协议版本，表示使用的协议版本。 200是状态码，表示请求的结果，比如200表示成功等。 OK是状态消息，表示对状态码的文本描述，比如OK表示成功等。 状态码的含义可以在网站上查看：HTTP 响应状态码 1.5.2 响应头常见的响应头： Date：表示服务器发送响应的日期和时间。 Server：表示服务器的软件信息。 Content-Type：表示响应体的内容类型和编码方式。 Content-Length：表示响应体的长度，使用字节作为单位。 Connection：表示服务器希望在发送完响应后的连接方式。使用keep-alive表示保持连接，使用close表示关闭连接。 1.5.3 空行空行用于分隔响应头和响应体。 1.5.4 响应体如果是HTML页面，就解析并显示页面。如果是JSON数据，就解析并处理数据。 2 使用使用Node中内置的http模块，可以实现网络通信的功能。 2.1 步骤2.1.1 创建服务语法： js1http.createServer([options][, requestListener]) 返回： Object对象，封装了HTTP服务信息。 参数： options：配置对象，封装了多个服务配置，可选。 requestListener：请求监听器，封装了请求和响应的方法，可选。 示例： js12345678910111213// 引入模块const http = require(&#x27;http&#x27;);// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 获得请求方法 console.log(req.method); // 获得请求URL，只包含路径和查询字符串，不包含协议和域名 console.log(req.url); // 获得请求头，属性名被转为小写 console.log(req.headers); // 获得请求头中的属性值 console.log(req.headers.host);&#125;); 2.1.2 监听服务语法： js1server.listen([port[, host[, backlog]]][, callback]) 参数： port：监听端口号。 host：监听主机地址。 backlog：监听日志。 callback：监听回调方法。 示例： js12345// 监听服务server.listen(9000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:9000/&#x27;);&#125;); 2.1.3 获得请求获得请求： js1234567891011// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 获得请求方法 console.log(req.method); // 获得请求URL，只包含路径和查询字符串，不包含协议和域名 console.log(req.url); // 获得请求头，属性名被转为小写 console.log(req.headers); // 获得请求头中的属性值 console.log(req.headers.host);&#125;); 获得请求URL的路径和字符串有两种方式： 使用类使用模块使用URL类获得请求URL的信息： js12345678910111213// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 实例化URL类 const url = new URL(req.url, &#x27;http://127.0.0.1:9000&#x27;); // 获得请求URL console.log(url); // 获得请求URL中的路径 console.log(url.pathname); // 获得请求URL中的查询字符串 console.log(url.search); // 获得请求URL中的查询字符串中指定属性名对应的属性值 console.log(url.searchParams.get(&#x27;name&#x27;));&#125;);使用url模块获得请求URL的信息： js12345678910111213// 引入模块const url = require(&#x27;url&#x27;);// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 获得请求URL console.log(url.parse(req.url)); // 获得请求URL中的路径 console.log(url.parse(req.url).pathname); // 获得请求URL中的查询字符串 console.log(url.parse(req.url).query); // 获得请求URL中的查询字符串中指定属性名对应的属性值 console.log(url.parse(req.url, true).query.name);&#125;); 这种方式已经过时了，不建议使用。 使用文件流读取请求体数据： js123456789101112// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 获得请求体，使用文件流读取 let body = &#x27;&#x27;; req.on(&#x27;data&#x27;, chunk =&gt; &#123; body += chunk; &#125;); // 获得请求体，读取后的处理 req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(body); &#125;);&#125;); 使用querystring模块获得请求体的信息： js12345678910111213141516// 引入模块const querystring = require(&#x27;querystring&#x27;);// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 获得请求体，使用文件流读取 let body = &#x27;&#x27;; req.on(&#x27;data&#x27;, chunk =&gt; &#123; body += chunk; &#125;); // 获得请求体，读取后的处理 req.on(&#x27;end&#x27;, () =&gt; &#123; // 解析表单数据 const formData = querystring.parse(body); console.log(formData); &#125;);&#125;); 2.1.4 返回响应设置响应信息： js12345678910111213// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 设置响应状态码，默认是200 res.statusCode = 200; // 设置响应状态码描述，默认是OK res.statusMessage = &#x27;OK&#x27;; // 设置响应头 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=UTF-8&#x27;); // 设置响应体，可以不用或使用多次write方法 res.write(&#x27;&lt;h1&gt;成功&lt;/h1&gt;&#x27;); // 设置响应体，必须使用并且只能使用一次end方法 res.end();&#125;); 使用更简洁的方式设置响应信息： js1234567// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 同时设置响应状态码和响应头 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); // 设置响应体，必须使用并且只能使用一次end方法 res.end(&#x27;&lt;h1&gt;成功&lt;/h1&gt;&#x27;);&#125;); 2.2 整合2.2.1 简单使用示例： server.js123456789101112131415161718192021222324252627282930313233343536373839// 引入模块const http = require(&#x27;http&#x27;);// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 忽略特殊请求 if (req.url == &#x27;/favicon.ico&#x27;) &#123; res.end(); return; &#125; // 获得请求信息 console.log(req.method); console.log(req.url); console.log(req.headers); console.log(req.headers.host); // 实例化URL类 const url = new URL(req.url, &#x27;http://127.0.0.1:9000&#x27;); // 获得URL信息 console.log(url); console.log(url.pathname); console.log(url.search); console.log(url.searchParams.get(&#x27;name&#x27;)); // 使用文件流读取请求体 let body = &#x27;&#x27;; req.on(&#x27;data&#x27;, chunk =&gt; &#123; body += chunk; &#125;); // 解析请求体 req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(body); // 返回成功响应 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;成功&lt;/h1&gt;&#x27;); &#125;);&#125;);// 监听服务server.listen(9000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:9000/&#x27;);&#125;); 在命令行执行node server.js命令启动服务，在浏览器访问http://127.0.0.1:9000/请求服务。 注意： 在命令行使用node server.js启动服务。 在命令行按下Ctrl + C停止服务。 当服务启动后，更新代码后必须重启服务才能生效。 端口号被占用报错： bash1Error: listen EADDRINUSE: address already in use :::9000 端口号被占用解决办法： 关闭当前正在运行监听端口的服务，推荐使用这种方式。 使用其他端口号。 默认端口： HTTP协议默认端口是80，可以省略。 HTTPS协议的默认端口是443，可以省略。 2.2.2 前后交互后端示例： server.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 引入模块const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const querystring = require(&#x27;querystring&#x27;);// 创建服务let server = http.createServer((req, res) =&gt; &#123; // 忽略特殊请求 if (req.url == &#x27;/favicon.ico&#x27;) &#123; res.end(); return; &#125; // 匹配访问路径 if (req.url == &#x27;/info&#x27;) &#123; if (req.method == &#x27;GET&#x27;) &#123; // 读取文件 fs.readFile(path.resolve(__dirname, &#x27;info.html&#x27;), (err, data) =&gt; &#123; if (err) &#123; // 返回文件读取失败 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;文件读取失败&lt;/h1&gt;&#x27;); &#125; else &#123; // 返回文件内容 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(data); &#125; &#125;); &#125; if (req.method == &#x27;POST&#x27;) &#123; // 获得请求体，使用文件流读取 let body = &#x27;&#x27;; req.on(&#x27;data&#x27;, chunk =&gt; &#123; body += chunk; &#125;); // 获得请求体，读取后的处理 req.on(&#x27;end&#x27;, () =&gt; &#123; // 解析表单数据 const formData = querystring.parse(body); console.log(formData); // 返回成功响应 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(` &lt;h1&gt;成功&lt;/h1&gt; &lt;p&gt;用户名：$&#123;formData.username&#125;&lt;/p&gt; &lt;a href=&quot;/info&quot;&gt;返回&lt;/a&gt; `); &#125;); &#125; &#125; else &#123; // 返回页面不存在 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); res.end(&#x27;&lt;h1&gt;页面不存在&lt;/h1&gt;&#x27;); &#125;&#125;);// 监听服务server.listen(9000, () =&gt; &#123; console.log(&#x27;服务已经启动&#x27;); console.log(&#x27;http://127.0.0.1:9000/&#x27;);&#125;); 前端示例： info.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/info&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在命令行执行node server.js命令启动服务，在浏览器访问http://127.0.0.1:9000/info请求服务。 3 网页加载3.1 原理网页资源的加载都是循序渐进的，首先获取HTML的内容，然后发送获取其他资源的请求，比如CSS、JS、图片等。 资源分类： 静态资源是指那些内容固定不变的文件，如HTML、CSS、JS、图片等。这些文件在创建后，内容不会随着用户请求或时间的变化而改变。 动态资源是指那些内容会根据用户请求、时间或其他条件变化的资源。它们通常由服务器端的程序生成，动态资源的内容在每次请求时可能会不同。 3.2 网站根目录网站根目录是指在网站文件结构中最高层级的目录，它包含了网站的所有文件和子目录。 当用户在浏览器中输入网站的域名时，服务器会从网站根目录中查找默认的首页文件，然后将其发送给用户。 3.3 URL路径网址中的URL路径分为绝对路径和相对路径： 绝对路径是指从网站的根目录开始的完整路径，它包含了从根目录到目标资源的所有层级信息。绝对路径以/开头，表示从根目录开始。 相对路径是指相对于当前页面或资源的位置的路径。它不以/开头，而是根据当前页面的位置来确定目标资源的位置。 3.4 媒体类型媒体类型（MIME，Multipurpose Internet Mail Extensions）是一种标准，用来表示文档、文件或字节流的性质和格式。它在互联网通信中广泛使用，特别是在HTTP协议中，用于指定请求和响应的内容类型。 MIME类型由两个主要部分组成，它们之间用/分隔： 类型（Type）：表示媒体的通用类别，例如文本、图像、音频、视频等。 子类型（Subtype）：指定类型中的具体格式或编码方式，例如html、css、png等。 下面是常见的MIME类型： 类型 子类型 MIME类型 文本 纯文本文件 text/plain 文本 HTML页面 text/html 文本 CSS样式 text/css 文本 JS脚本 text/javascriptapplication/javascript 图像 JPEG图像 image/jpeg 图像 PNG图像 image/png 图像 GIF图像 image/gif 图像 SVG矢量图像 image/svg+xml 音频 MP3音频 audio/mpeg 音频 WAV音频 audio/wav 音频 AAC音频 audio/aac 视频 MP4视频 video/mp4 视频 MPEG视频 video/mpeg 应用 PDF文档 application/pdf 应用 JSON数据 application/json 应用 XML数据 application/xml 应用 ZIP压缩 application/zip 应用 JS脚本 application/javascript 混合 表单数据，常见于文件上传 multipart/form-data 未知 未知类型，建议独立存储 application/octet-stream","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"路径管理","slug":"C00-前端/C04-Node/001-基础/008-路径管理","date":"2025-03-09T12:59:46.000Z","updated":"2025-06-21T08:57:45.320Z","comments":true,"path":"posts/20250309/205946/","permalink":"https://momashanhe.com/posts/20250309/205946/","excerpt":"摘要：本文学习了如何在编写代码时规范使用路径。","text":"摘要：本文学习了如何在编写代码时规范使用路径。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NVM 1.1.12 1 概念在处理路径时，涉及到两个概念： 相对路径：以当前工作目录为起点的路径，表示从当前目录到目标文件或目录的相对位置。示例： 使用./file.txt表示当前目录下的file.txt文件，也可以使用file.txt表示，可以省略前面的./符号。 使用../file.txt表示当前目录的上级目录下的file.txt文件，不能省略前面的../符号。 绝对路径：从根目录开始的完整路径，表示从根目录到目标文件或目录的确切位置。示例： 在Windows系统中，使用D:\\file.txt表示D盘根目录下的file.txt文件。 在Linux系统中，使用/file.txt表示根目录下的file.txt文件。 不同操作系统在管理路径存在差异： 在Linux系统中，使用/表示根目录，将/作为目录的间隔符号。 在Windows系统中，使用D:\\表示D盘根目录，将\\作为目录的间隔符号。但是在一些编程语言里兼容了Linux系统的规则，支持使用/表示当前盘的根目录，支持将/作为目录的间隔符号。 2 问题在涉及路径的开发过程中，如果使用相对路径，会导致相同的代码在不同路径执行得到结果不一致。 创建file目录作为当前目录，在当前目录创建file.js文件和file.txt文件，在file.js文件编写代码： file.js123const fs = require(&#x27;fs&#x27;);let data = fs.statSync(&#x27;./file.txt&#x27;);console.log(data); 在当前目录执行命令node file.js成功，因为当前目录存在file.txt文件，在上级目录执行node file.js失败，因为上级目录没有file.txt文件，应该在上级目录执行node file/file.js。 为了解决这个问题，建议使用绝对路径，保证代码执行的结果和预期一致： 使用__filename变量可以获得代码文件绝对路径。 使用__dirname变量可以获得代码文件所在目录的绝对路径。 修改当前目录的file.js文件，使用__dirname变量拼接file.txt文件的绝对路径： file.js1234567const fs = require(&#x27;fs&#x27;);console.log(__filename);// D:\\Home\\momashanhe\\file\\file.jsconsole.log(__dirname);// D:\\Home\\momashanhe\\filelet path = __dirname + &#x27;/file.txt&#x27;;console.log(path);// D:\\Home\\momashanhe\\file/file.txtlet data = fs.statSync(path);console.log(data); 无论是在当前目录还是在上级目录执行，都会在file.js文件所在的目录查找file.txt文件。 在拼接时建议使用/作为分隔符，不能使用\\作为分隔符，因为\\单独使用表示转义字符，需要使用转义后的\\\\表示\\作为分隔符： file.js12345const fs = require(&#x27;fs&#x27;);let path = __dirname + &#x27;\\\\file.txt&#x27;;console.log(path);// D:\\Home\\momashanhe\\file\\file.txtlet data = fs.statSync(path);console.log(data); 3 使用Node中内置的path模块简化了对路径的操作。 3.1 拼接路径语法： js1path.resolve([...paths]) 返回： String对象。 参数： paths：文件路径，支持多个拼接。如果参数是绝对路径，则清空前面的参数，拼接后面的参数。 示例： js1234const path = require(&#x27;path&#x27;);console.log(path.resolve(__dirname, &#x27;file.txt&#x27;));// D:\\Home\\momashanhe\\file\\file.txtconsole.log(path.resolve(&#x27;/momashanhe&#x27;, &#x27;file&#x27;, &#x27;file.txt&#x27;));// D:\\Home\\momashanhe\\file\\file.txtconsole.log(path.resolve(&#x27;/momashanhe&#x27;, &#x27;/file&#x27;, &#x27;file.txt&#x27;));// D:\\file\\file.txt 3.2 获取分隔符语法： js1path.sep 返回： String对象。 示例： js12const path = require(&#x27;path&#x27;);console.log(path.sep);// \\ 3.3 解析路径语法： js123path.basename(path[, suffix])// 获取路径基础名称path.dirname(path)// 获取路径目录名称path.extname(path)// 获取路径扩展名称 返回： String对象。 参数： path：文件路径。 suffix：要删除的可选后缀。 示例： js1234const path = require(&#x27;path&#x27;);console.log(path.basename(&#x27;D:\\\\Home\\\\momashanhe\\\\file\\\\file.txt&#x27;));// file.txtconsole.log(path.dirname(&#x27;D:\\\\Home\\\\momashanhe\\\\file\\\\file.txt&#x27;));// D:\\Home\\momashanhe\\fileconsole.log(path.extname(&#x27;D:\\\\Home\\\\momashanhe\\\\file\\\\file.txt&#x27;));// .txt 3.4 解析路径返回对象语法： js1path.parse(path) 返回： Object对象，封装了对象信息。 参数： path：文件路径。 示例： js123456789const path = require(&#x27;path&#x27;);console.log(path.parse(&#x27;D:\\\\Home\\\\momashanhe\\\\file\\\\file.txt&#x27;));// &#123;// root: &#x27;D:\\\\&#x27;,// dir: &#x27;D:\\\\Home\\\\momashanhe\\\\file&#x27;,// base: &#x27;file.txt&#x27;,// ext: &#x27;.txt&#x27;,// name: &#x27;file&#x27;// &#125; 3.5 解析对象返回路径语法： js1path.format(pathObject) 返回： String对象。 参数： pathObject：文件对象。 示例： js123456const path = require(&#x27;path&#x27;);console.log(path.format(&#123; dir: &#x27;D:\\\\Home\\\\momashanhe\\\\file&#x27;, base: &#x27;file.txt&#x27;&#125;));// D:\\Home\\momashanhe\\file\\file.txt","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"文件系统","slug":"C00-前端/C04-Node/001-基础/007-文件系统","date":"2025-03-06T15:54:29.000Z","updated":"2025-06-21T08:57:44.501Z","comments":true,"path":"posts/20250306/235429/","permalink":"https://momashanhe.com/posts/20250306/235429/","excerpt":"摘要：本文学习了Node处理文件和目录的相关接口，包括读取、写入、复制，以及移动和重命名。","text":"摘要：本文学习了Node处理文件和目录的相关接口，包括读取、写入、复制，以及移动和重命名。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 概念文件系统是计算机用于管理数据的一种系统，负责在存储设备上进行文件的存储、检索和更新操作。 2 使用Node中内置了fs模块，可以对计算机中的数据进行操作。 2.1 文件写入2.1.1 异步写入主线程不会等待异步线程，执行效率高。 语法： js1fs.writeFile(file, data[, options], callback) 参数： file：文件名。 data：待写入的数据。 options：选项，可选。 callback：回调方法。 示例： js12345678910const fs = require(&#x27;fs&#x27;);fs.writeFile(&#x27;./info.txt&#x27;, &#x27;异步写入数据&#x27;, err =&gt; &#123; // 写入失败传入错误对象，写入成功传入null if (err) &#123; console.error(&#x27;异步写入失败: &#x27; + err); return; &#125; console.log(&#x27;异步写入成功&#x27;);&#125;);console.log(&#x27;主方法执行结束&#x27;); 可以在选项中使用flag标志： 标志 说明 是否创建文件 r 此标志打开文件进行读取 否 r+ 此标志打开文件进行读写 否 w+ 此标志打开文件进行读写，并将流定位在文件开头 是 a+ 此标志打开文件进行读写，并将流定位在文件末尾 是 示例： js12345678910const fs = require(&#x27;fs&#x27;);fs.writeFile(&#x27;./info.txt&#x27;, &#x27;异步写入数据&#x27;, &#123; flag:&#x27;a+&#x27; &#125;, err =&gt; &#123; // 写入失败传入错误对象，写入成功传入null if (err) &#123; console.error(&#x27;异步写入失败: &#x27; + err); return; &#125; console.log(&#x27;异步写入成功&#x27;);&#125;);console.log(&#x27;主方法执行结束&#x27;); 2.1.2 同步写入主线程等待同步线程，程序执行过程易于理解。 语法： js1fs.writeFileSync(file, data[, options]) 参数与writeFile()方法一致，只是没有callback参数。 示例： js1234const fs = require(&#x27;fs&#x27;);fs.writeFileSync(&#x27;./info.txt&#x27;, &#x27;同步写入数据&#x27;);console.log(&#x27;同步写入成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 2.1.3 异步追加写入语法： js1fs.appendFile(path, data[, options], callback) 参数： path：文件路径。 data：待写入的数据。 options：选项，可选。 callback：回调方法。 示例： js123456789const fs = require(&#x27;fs&#x27;);fs.appendFile(&#x27;./info.txt&#x27;, &#x27;异步追加写入数据&#x27;, err =&gt; &#123; if (err) &#123; console.error(&#x27;异步追加写入失败: &#x27; + err); return; &#125; console.log(&#x27;异步追加写入成功&#x27;);&#125;);console.log(&#x27;主方法执行结束&#x27;); 2.1.4 同步追加写入语法： js1fs.appendFileSync(path, data[, options]) 参数：与appendFile()方法一致，只是没有callback参数。 示例： js1234const fs = require(&#x27;fs&#x27;);fs.appendFileSync(&#x27;./info.txt&#x27;, &#x27;同步追加写入数据&#x27;);console.log(&#x27;同步追加写入成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 2.1.5 流式写入程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数，适用于大文件写入或者频繁写入的场景。 语法： js1fs.createWriteStream(path[, options]) 返回： Object对象，封装了文件流。 参数： path：文件路径。 options：选项，可选。 示例： js1234567const fs = require(&#x27;fs&#x27;);let ws = fs.createWriteStream(&#x27;./info.txt&#x27;);ws.write(&#x27;123&#x27;);ws.write(&#x27;456&#x27;);ws.end();console.log(&#x27;流式写入成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 2.2 文件读取2.2.1 异步读取语法： js1fs.readFile(path[, options], callback) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js12345678910const fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;./info.txt&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.error(&#x27;异步读取失败: &#x27; + err); return; &#125; console.log(&#x27;异步读取成功&#x27;); console.log(data.toString());&#125;);console.log(&#x27;主方法执行结束&#x27;); 2.2.2 同步读取语法： js1fs.readFileSync(path[, options]) 返回： Buffer对象，封装了文件内容。 参数：与readFile()方法一致，只是没有callback参数。 示例： js12345const fs = require(&#x27;fs&#x27;);let data = fs.readFileSync(&#x27;./info.txt&#x27;);console.log(&#x27;同步读取成功&#x27;);console.log(data.toString());console.log(&#x27;主方法执行结束&#x27;); 2.2.3 流式读取流式读取可以减少打开关闭文件的次数，适用于大文件读取或者频繁读取的场景。 语法： js1fs.createReadStream(path[, options]) 返回： Object对象，封装了文件流。 参数： path：文件路径。 options：选项，可选。 示例： js123456789const fs = require(&#x27;fs&#x27;);let rs = fs.createReadStream(&#x27;./info.txt&#x27;);rs.on(&#x27;data&#x27;, trunk =&gt; &#123; console.log(trunk.toString());&#125;);rs.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;流式读取成功&#x27;);&#125;)console.log(&#x27;主方法执行结束&#x27;); 2.3 文件复制示例： js1234567891011const fs = require(&#x27;fs&#x27;);let rs = fs.createReadStream(&#x27;./img.jpg&#x27;);let ws = fs.createWriteStream(&#x27;./img_back.jpg&#x27;);rs.on(&#x27;data&#x27;, trunk =&gt; &#123; ws.write(trunk);&#125;);rs.on(&#x27;end&#x27;, () =&gt; &#123; ws.end(); console.log(&#x27;流式复制成功&#x27;);&#125;)console.log(&#x27;主方法执行结束&#x27;); 也可以使用pipe()方法进行复制： js12345const fs = require(&#x27;fs&#x27;);let rs = fs.createReadStream(&#x27;./img.jpg&#x27;);let ws = fs.createWriteStream(&#x27;./img_back.jpg&#x27;);rs.pipe(ws);console.log(&#x27;主方法执行结束&#x27;); 2.4 文件重命名和移动文件重命名和移动可以用同一个方法实现，也有异步和同步两种方式，同步方法比异步方法少了callback参数。 语法： js12fs.rename(oldPath, newPath, callback)fs.renameSync(oldPath, newPath) 参数： oldPath：原文件路径。 newPath：新文件路径。 callback：回调方法。 示例： js1234567891011const fs = require(&#x27;fs&#x27;);fs.rename(&#x27;./info.txt&#x27;, &#x27;./info_new.txt&#x27;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;异步重命名失败: &#x27; + err); return; &#125; console.log(&#x27;异步重命名成功&#x27;);&#125;);// fs.renameSync(&#x27;./info.txt&#x27;, &#x27;./info_new.txt&#x27;);// console.log(&#x27;同步重命名成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 2.5 文件删除文件删除也有异步和同步两种方式，同步方法比异步方法少了callback参数。 语法： js12fs.unlink(path, callback)fs.unlinkSync(path) 参数： path：文件路径。 callback：回调方法。 示例： js1234567891011const fs = require(&#x27;fs&#x27;);fs.unlink(&#x27;./info.txt&#x27;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;异步删除失败: &#x27; + err); return; &#125; console.log(&#x27;异步删除成功&#x27;);&#125;);// fs.unlinkSync(&#x27;./info.txt&#x27;);// console.log(&#x27;同步删除成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 从14.14.0版本开始，还可以使用rm()和rmSync()方法实现。 语法： js12fs.rm(path[, options], callback)fs.rmSync(path[, options]) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js1234567891011const fs = require(&#x27;fs&#x27;);fs.rm(&#x27;./info.txt&#x27;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;异步删除失败: &#x27; + err); return; &#125; console.log(&#x27;异步删除成功&#x27;);&#125;);// fs.rmSync(&#x27;./info.txt&#x27;);// console.log(&#x27;同步删除成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 2.6 目录管理2.6.1 创建目录语法： js12fs.mkdir(path[, options], callback)fs.mkdirSync(path[, options]) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js1234567891011const fs = require(&#x27;fs&#x27;);fs.mkdir(&#x27;./info&#x27;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;异步创建目录失败: &#x27; + err); return; &#125; console.log(&#x27;异步创建目录成功&#x27;);&#125;);// fs.mkdirSync(&#x27;./info&#x27;);// console.log(&#x27;同步创建目录成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 支持递归创建目录： js123456789const fs = require(&#x27;fs&#x27;);fs.mkdir(&#x27;./info/1/2/3&#x27;, &#123; recursive:true &#125;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;递归创建目录失败: &#x27; + err); return; &#125; console.log(&#x27;递归创建目录成功&#x27;);&#125;);console.log(&#x27;主方法执行结束&#x27;); 2.6.2 读取目录语法： js12fs.readdir(path[, options], callback)fs.readdirSync(path[, options]) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js12345678910111213const fs = require(&#x27;fs&#x27;);fs.readdir(&#x27;./info&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.error(&#x27;异步读取目录失败: &#x27; + err); return; &#125; console.log(&#x27;异步读取目录成功&#x27;); console.log(data);&#125;);// let data = fs.readdirSync(&#x27;./info&#x27;);// console.log(&#x27;同步读取目录成功&#x27;);// console.log(data);console.log(&#x27;主方法执行结束&#x27;); 2.6.3 删除目录语法： js12fs.rmdir(path[, options], callback)fs.rmdirSync(path[, options]) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js1234567891011const fs = require(&#x27;fs&#x27;);fs.rmdir(&#x27;./info&#x27;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;异步删除目录失败: &#x27; + err); return; &#125; console.log(&#x27;异步删除目录成功&#x27;);&#125;);// fs.rmdirSync(&#x27;./info&#x27;);// console.log(&#x27;同步删除目录成功&#x27;);console.log(&#x27;主方法执行结束&#x27;); 支持递归删除目录： js123456789const fs = require(&#x27;fs&#x27;);fs.rmdir(&#x27;./info&#x27;, &#123; recursive:true &#125;, (err) =&gt; &#123; if (err) &#123; console.error(&#x27;递归删除目录失败: &#x27; + err); return; &#125; console.log(&#x27;递归删除目录成功&#x27;);&#125;);console.log(&#x27;主方法执行结束&#x27;); 由于该方法已经被标记为过期了，建议使用rm()和rmSync()方法实现。 2.7 查看资源状态语法： js12fs.stat(path[, options], callback)fs.statSync(path[, options]) 参数： path：文件路径。 options：选项，可选。 callback：回调方法。 示例： js12345678910111213const fs = require(&#x27;fs&#x27;);fs.stat(&#x27;./info.txt&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.error(&#x27;异步查看资源状态失败: &#x27; + err); return; &#125; console.log(&#x27;异步查看资源状态成功&#x27;); console.log(data);&#125;);// let data = fs.statSync(&#x27;./info.txt&#x27;);// console.log(&#x27;同步查看资源状态成功&#x27;);// console.log(data);console.log(&#x27;主方法执行结束&#x27;); 判断资源类型： 使用isFile()命令判断资源是否文件。 使用isDirectory()命令判断资源是否目录。 示例： js123456789101112const fs = require(&#x27;fs&#x27;);fs.stat(&#x27;./info.txt&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.error(&#x27;异步查看资源状态失败: &#x27; + err); return; &#125; console.log(&#x27;异步查看资源状态成功&#x27;); console.log(data); console.log(&#x27;判断资源是否文件: &#x27; + data.isFile()); console.log(&#x27;判断资源是否目录: &#x27; + data.isDirectory());&#125;);console.log(&#x27;主方法执行结束&#x27;);","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"缓冲器","slug":"C00-前端/C04-Node/001-基础/006-缓冲器","date":"2025-03-06T11:04:56.000Z","updated":"2025-06-21T08:57:43.677Z","comments":true,"path":"posts/20250306/190456/","permalink":"https://momashanhe.com/posts/20250306/190456/","excerpt":"摘要：本文学习了Node的缓冲器，包括其特点和使用。","text":"摘要：本文学习了Node的缓冲器，包括其特点和使用。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 概念缓冲器即Buffer，是一个类似于数组的对象，用于表示固定长度的字节序列。 Buffer的本质是一段内存空间，用于处理二进制数据，所以常在文件操作、网络通信、图像处理等场景中使用。 2 特点Buffer大小固定且无法调整。 Buffer中每个元素的大小为1字节，1个字节能够存储8个比特的二进制数据，也就是2的8次方，即从0到255。 3 使用Node中创建Buffer的方式主要如下几种： js123456789101112// 创建了一个长度为10字节的Buffer，相当于申请了10字节的内存空间，每个字节的值为0let buf_1 = Buffer.alloc(10);console.log(buf_1);// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;// 创建了一个长度为10字节的Buffer，创建速度比上面的快，使用Unsafe说明可能存在旧的数据影响执行结果let buf_2 = Buffer.allocUnsafe(10000);console.log(buf_2);// &lt;Buffer 80 a5 ab ae ... more bytes&gt;// 通过字符串创建let buf_3 = Buffer.from(&#x27;hello&#x27;);console.log(buf_3);// &lt;Buffer 68 65 6c 6c 6f&gt;// 通过数组创建let buf_4 = Buffer.from([1, 2, 3, 4, 5]);console.log(buf_4);// &lt;Buffer 01 02 03 04 05&gt; 打印的结果是基于十六进制显示的，这是为了节省显示的空间。 使用toString()方法将Buffer转为字符串： js123let buf = Buffer.from(&#x27;hello&#x27;);console.log(buf);// &lt;Buffer 68 65 6c 6c 6f&gt;console.log(buf.toString());// hello 通过使用显式的字符编码，可以在Buffer实例与字符串之间进行相互转换，默认使用utf8字符编码。： js123456let buf_1 = Buffer.from(&#x27;hello&#x27;, &#x27;utf8&#x27;);console.log(buf_1);// &lt;Buffer 68 65 6c 6c 6f&gt;console.log(buf_1.toString(&#x27;utf8&#x27;));// hellolet buf_2 = Buffer.from(&#x27;hello&#x27;, &#x27;base64&#x27;);console.log(buf_2);// &lt;Buffer 85 e9 65&gt;console.log(buf_2.toString(&#x27;base64&#x27;));// hello 使用数组下标读取和设置Buffer元素： js12345let buf = Buffer.from(&#x27;hello&#x27;);console.log(buf);// &lt;Buffer 68 65 6c 6c 6f&gt;console.log(buf[0]);// 104，即h字母在utf8编码中对应的十进制数字是104buf[0] = 360;// 对应二进制为000101101000，一个元素存储一个字节，即八个比特，左边的高位被舍弃console.log(buf[0]);// 104，左边的高位在舍弃后，等同于104","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"管理工具","slug":"C00-前端/C04-Node/001-基础/005-管理工具","date":"2025-03-06T04:17:36.000Z","updated":"2025-06-21T09:32:44.736Z","comments":true,"path":"posts/20250306/121736/","permalink":"https://momashanhe.com/posts/20250306/121736/","excerpt":"摘要：本文学习了Node的管理工具，包括NPM和NVM，以及NRM，还介绍了Yarn管理工具，并比较了NPM和Yarn的区别。","text":"摘要：本文学习了Node的管理工具，包括NPM和NVM，以及NRM，还介绍了Yarn管理工具，并比较了NPM和Yarn的区别。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 概述1.1 NPM（Node Package Manager）NPM是Node的默认包管理工具，用于安装、更新、卸载和管理JS包。它还支持依赖管理、脚本运行等功能，并且是Node安装时自带的一部分。 包是特殊的模块，将根目录包含package.json文件的模块称为包，并且包通常由多个模块组成。 1.2 NRM（NPM Registry Manager）NRM是NPM的镜像源管理工具，用于快速切换NPM的镜像源。由于NPM默认的镜像源在国外，访问速度可能较慢，NRM可以帮助开发者切换到国内镜像源，从而提高包的下载速度。 1.3 NVM（Node Version Manager）NVM是Node版本管理工具，用于在同一台机器上安装、管理和切换多个Node版本。它解决了不同项目对不同Node版本的需求，避免版本冲突。 2 NPM2.1 查看版本和配置信息在安装Node时会自动安装NPM工具。 使用npm -v命令查看NPM的版本： bash123momashanhe@localhost momashanhe $ npm -v9.3.1momashanhe@localhost momashanhe $ 使用npm config list命令查看Node和NPM的版本信息及其他信息。 2.2 包管理2.2.1 初始化包创建包对应的目录，使用npm init命令初始化包： bash1234567891011121314momashanhe@localhost momashanhe $ npm init...Press ^C at any time to quit.package name: (momashanhe)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)...momashanhe@localhost momashanhe $ 支持交互式的创建package.json文件，该文件是包的配置文件，每个包都必须存在： package.json1234567891011&#123; &quot;name&quot;: &quot;momashanhe&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 文件内容说明如下： name是包名，默认是目录名。 version是包版本，默认从1.0.0开始。 description是包的描述，说明包有什么功能。 main是包的入口文件，默认是目录下的index.js文件。 scripts是脚本配置，用于执行脚本。 author是包的作者。 license是包的开源证书。 注意事项： 包名不能使用中文和大写。 版本要求x.x.x的格式，并且全为数字。 可以手动创建package.json文件，只要有这个文件就可以将该目录作为包。 可以使用npm init -y或npm init --yes跳过交互快速创建package.json文件，使用这种方式要求目录不能使用中文和大写。 2.2.2 搜索包搜索包的方式有两种： 在命令行使用npm search 关键字搜索包含指定关键字的包。 在NPM网站搜索：https://www.npmjs.com/ 也可以使用npm view 包名 versions命令搜索包版本。 2.2.3 下载并安装包下载和安装包需要在包目录中执行，需要有package.json文件。 使用npm install 包名命令下载并安装包，也可以使用npm add 包名命令。 支持多个包同时下载和安装，只需要将多个包名用空格分开即可。 在下载并安装后，会在当前包目录下增加两个资源： node_modules用于存放下载的包。 package-lock.json用于锁定包依赖的精确版本，确保在不同环境中安装依赖时结果完全一致。 依赖指的是当前包安装的其他包，可以认为当前包依赖了其他包，将其他包看做是当前包的依赖包。 在安装指定包时，安装命令会在node_modules目录先安装指定包的依赖包，然后再安装指定包。 如果需要指定包的版本，可以使用npm install 包名@版本命令下载并安装指定版本的包。 默认使用国外的镜像源，使用npm get registry命令查看当前使用的镜像源。 使用npm config set registry https://registry.npmmirror.com/命令设置为淘宝镜像源可以加速下载。 使用npm config set registry https://registry.npmjs.org/命令设置为默认的官方镜像源。 2.2.4 使用包使用包的方式同使用模块一样： js1require(&#x27;模块&#x27;); 导入模块后就能使用暴露的资源了，在导入时遵循以下流程： 2.2.5 根据环境安装在安装包时可以将包安装到不同的环境： 生产环境：默认安装的环境就是生产环境，支持在生产环境和开发环境使用，可以使用npm install 包名 -S命令指定，其中的-S是--save的简写。 开发环境：开发环境的包仅支持在开发环境使用，在生产环境会被忽略，需要使用npm install 包名 -D命令指定，其中的-D是--save-dev的简写。 在package.json文件中存储的位置也不一样： 生产环境：包信息存储在dependencies属性中。 开发环境：包信息存储在devDependencies属性中。 2.2.6 根据作用范围安装在安装包时可以选择安装位置： 本地安装：将包安装到当前包的node_modules目录，默认安装到本地。 全局安装：将包安装到全局的node_modules目录，使用npm install 包名 -g命令安装到全局，其中的-g是--global的简写。 查看安装列表： 本地安装：使用npm list命令可以查看安装在本地的包有哪些。 全局安装：使用npm list -g命令可以查看安装在全局的包有哪些。 查看安装目录： 本地目录：使用npm root命令可以查看本地的node_modules目录。 全局目录：使用npm root -g命令可以查看全局的node_modules目录。 全局安装的包可以在任何目录执行，本地安装的包只能在本地目录中执行。 全局安装的包版本由NPM管理，不会在项目的package.json文件中体现。这意味着全局安装的包可能在不同项目之间共享，但也可能因为版本冲突而导致问题。 2.2.7 删除包删除包需要在包目录中执行，需要有package.json文件。 使用npm uninstall 包名命令删除依赖包，也可以使用npm remove 包名命令。 使用npm uninstall 包名 -g命令删除全局依赖包。 2.2.8 重新安装包在上传提交项目代码到Git仓库时，不会提交node_modules目录，因为该目录占用的磁盘空间比较大，并且该目录可以重新生成。 当下载项目后，就需要执行npm install命令重新安装依赖包，重新生成node_modules目录。 2.3 命令别名通过配置命令别名可以更简单的执行命令，只需要配置package.json文件中的scripts属性： package.json1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node index.js&quot;&#125;, 即可通过npm run 别名命令执行，其作用和别名对应的命令一样。 注意： 最后一个别名后面不需要有逗号，非最后一个别名后面必须要有逗号。 别名对应的命令有自动向上查找的功能，只要上级目录是包目录并且有对应的资源就能执行。 当别名是start时，可以直接通过npm start命令执行，这是其他命令别名没有的执行方式，所以常用start别名启动项目。 对于新项目，可以通过scripts属性查看项目的一些命令。 2.4 版本管理在使用NPM管理包的版本时，使用的是x.x.x格式： 第一个数字是主版本，当进行了不兼容的API修改时，需要更新主版本。 第二个数字是次版本，当添加了向下兼容的新功能时，应该更新次版本。 第三个数字是补丁版本，当进行了向下兼容的问题修正时，应该更新补丁版本。 除了常规的版本外，NPM还支持使用特定的符号来指定版本范围或选择策略： 使用^1.2.3表示只允许安装主版本相同的其他版本，仅允许安装1.x.x的任何版本。 使用~1.2.3表示只允许安装次版本相同的其他版本，仅允许安装1.2.x的任何版本。 使用*表示允许安装任意版本的版本，这是不推荐的，因为可能导致安装到不兼容的版本。 使用&gt;1.2.3表示只允许安装指定版本之后的其他版本。 使用&lt;1.2.3表示只允许安装指定版本之前的其他版本。 精确控制版本： 在NPM的5版本之前，如果需要记录包的精确版本，需要使用npm shrinkwrap命令生成npm-shrinkwrap.json文件用于记录包的精确版本。 在NPM的5版本中，加入了新特性，在初始化包时会创建package-lock.json文件，每次安装包时都会记录包的精确版本。 2.5 发布服务包可以将自己开发的工具包发布到NPM服务上，方便自己和其他开发者使用： 创建包目录并完成初始化，起一个有意义的包名，否则会被NPM识别为垃圾包，不允许发布。 在包中创建index.js文件，编写代码，使用module.exports暴露数据。 访问NPM官网注册账号，并使用邮箱激活账号。 确保正在使用的镜像源是官方的镜像源，否则无法发布到NPM服务器。 使用npm login命令登录到NPM服务器，填写用户名和密码，以及邮箱收到的验证码。 使用npm publish命令将包发布到NPM服务器。 2.6 更新服务包后续可以对自己发布的包进行更新，操作步骤如下： 更新包中的代码。 测试代码功能是否正常可用。 更新package.json文件中的版本，参考版本更新规则。 使用npm publish命令将包发布到NPM服务器。 2.7 删除服务包NPM官方建议如果是为了鼓励用户升级，或者不想维护了，可以考虑使用deprecate命令。 如果在发布后72小时内，需要满足条件： 没有其他包依赖。 只有一个维护者。 如果在发布后超过了72小时，需要满足条件： 没有其他包依赖。 只有一个维护者。 每周小于300下载量。 某些条件可能随时间发生变化，建议参考官方文档：https://docs.npmjs.com/policies/unpublish 删除服务包有两种方式，一种是在NPM官网上删除包，一种是通过命令行的方式。 通过命令行删除： 删除指定版本：使用npm unpublish 包名@版本删除指定版本的包。 删除全部版本：使用npm unpublish 包名 -f命令删除全部版本的包，其中的-f是--force的简写。 如果使用了2FA验证，还需要在命令后面增加--otp=2FA验证码参数，只要2FA验证码正确后才能删除。 注意： 删除是不可逆的，一旦删除将无法撤销。 即使删除了包的某个版本，在以后发布版本的时候，也不能发布该版本，必须发布新版本。 如果删除包的所有版本，则要等到24小时后才能重新发布该包。 3 NPX3.1 作用对于只在某个项目中使用的包，如果也将其安装到全局目录，势必会造成全局目录的混乱和冗余。 如果将包安装到本地目录，在使用包里的命令时就不能在命令行直接执行，需要指明所在的目录才能执行。 使用NPX的主要目的就是为了解决在将包安装到本地目录后，调用包里的命令时不能在命令行直接执行的问题。 在安装了NPX以后，对于安装在本地目录的包，也可以在命令行通过NPX直接执行包里的命令。 另外，如果既没有在全局安装，也没用在本地安装，在通过NPX使用的时候，会自动从远程下载，并将包进行临时安装，在使用后会自动删除临时安装的包。 3.2 下载安装从NPM的5.2.0版本开始，安装NPM的时候会同时将NPX自动安装，不需要手动安装。 也可以使用npm install npx -g命令手动安装。 3.3 原理使用NPX执行命令的原理： 查找本地目录中是否有指定的命令，如果有就直接使用，如果没有就继续查找。 查找全局目录中是否有指定的命令，如果有就直接使用，如果没有就继续查找。 查找远程仓库中是否有指定的命令，如果有就临时安装，如果没有就返回错误。 3.4 使用使用npx 命令执行指定命令。 使用npx --no-install 命令执行指定命令，如果本地目录没有就返回作错误，不从远程仓库安装。 使用npx --ignore-existing 命令执行指定命令，强制从远程仓库安装，忽略本地目录中安装的包。 使用npx -p 命令1 -p 命令2安装多个命令。 4 NRM4.1 下载安装除了在NPM使用命令修改配置切换镜像源，还可以使用NRM切换，更推荐使用这种方式。 NRM依赖NPM，可以管理NPM使用的镜像源。 使用npm install nrm -g命令将NRM安装到全局目录。 4.2 常用命令4.2.1 查看镜像源安装后可以使用nrm ls命令查看镜像源： bash123456789momashanhe@localhost momashanhe $ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/ taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ huawei ------- https://repo.huaweicloud.com/repository/npm/momashanhe@localhost momashanhe $ 4.2.2 切换镜像源使用nrm use taobao命令切换到淘宝的镜像源，淘宝是国内的镜像源，可以提高下载包的速度： bash123momashanhe@localhost momashanhe $ nrm use taobao SUCCESS The registry has been changed to &#x27;taobao&#x27;.momashanhe@localhost momashanhe $ 再次查看镜像源列表，正在使用的镜像源会在前面添加*符号进行提示： bash123456789momashanhe@localhost momashanhe $ nrm ls npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/* taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ huawei ------- https://repo.huaweicloud.com/repository/npm/momashanhe@localhost momashanhe $ 需要注意的是，淘宝的镜像源是只读的，只能下载和安装包，不能上传包。如果想要上传包，还需要切换回原来的镜像源进行上传。 5 NVM5.1 下载安装NVM主要用于管理Node和NPM版本的工具，用来切换不同版本的Node和NPM以便适配不同的软件开发工具。 NVM仅支持Linux系统和Mac系统，如果想在Windows系统使用，需要使用和NVM类似的nvm-windows软件。 GitHub下载地址：nvm-windows 下载nvm-setup.exe并安装即可。 重新打开命令行，输入命令查询版本： bash123momashanhe@localhost momashanhe $ nvm -v1.1.12momashanhe@localhost momashanhe $ 在安装NVM后，会将Node的原安装目录迁移到NVM的安装目录，并在Node的原安装目录的父级目录创建一个指向新安装目录的链接。 使用nvm root命令可以查看NVM下载安装Node的目录，在该目录下有Node的原安装目录。 5.2 常用命令5.2.1 查看已安装使用nvm list命令查看已安装的Node列表： bash123momashanhe@localhost momashanhe $ nvm list * 18.14.0 (Currently using 64-bit executable)momashanhe@localhost momashanhe $ 5.2.2 查看可安装使用nvm list available命令查看可以安装的Node列表： bash123456789101112momashanhe@localhost momashanhe $ nvm list available| CURRENT | LTS | OLD STABLE | OLD UNSTABLE ||--------------|--------------|--------------|--------------|| 23.6.0 | 22.11.0 | 0.12.14 | 0.11.12 || 23.5.0 | 20.18.3 | 0.12.13 | 0.11.11 || 23.4.0 | 20.18.2 | 0.12.12 | 0.11.10 || 23.3.0 | 20.18.1 | 0.12.11 | 0.11.9 || 23.2.0 | 20.18.0 | 0.12.10 | 0.11.8 || 23.1.0 | 20.17.0 | 0.12.9 | 0.11.7 || 23.0.0 | 20.16.0 | 0.12.8 | 0.11.6 |...momashanhe@localhost momashanhe $ 5.2.3 安装Node使用nvm install 版本命令安装指定版本的Node： bash1234567momashanhe@localhost momashanhe $ nvm install 23.1.0Downloading node.js version 23.1.0 (64-bit)...Extracting node and npm...Completenpm v10.9.0 installed successfully....momashanhe@localhost momashanhe $ 5.2.4 切换Node使用nvm use 版本命令切换指定版本的Node： bash123momashanhe@localhost momashanhe $ nvm use 23.1.0Now using node v23.1.0 (64-bit)momashanhe@localhost momashanhe $ 5.2.5 卸载Node使用nvm uninstall 版本命令卸载指定版本的Node： bash123momashanhe@localhost momashanhe $ nvm uninstall 23.1.0Uninstalling node v23.1.0... donemomashanhe@localhost momashanhe $ 6 Yarn6.1 下载安装Yarn是由Facebook、Google、Exponent和Tilde联合推出了一个新的JS包管理工具，目的是为了弥补NPM的一些缺陷。 官网地址：https://yarnpkg.com/ Yarn的优点： 并行安装：使用NPM安装软件包时采用顺序执行。使用Yarn安装软件包时采用并行执行，提高了性能。 离线模式：使用NPM再次安装已经安装过的软件包时需要从网络下载。使用Yarn再次安装已经安装过的软件包时直接从缓存中获取，节省了时间。 输出简洁：使用NPM打印的输出信息比较冗长，不容易识别报错的信息。使用Yarn打印的输出信息比较简洁，只打印出必要的信息，更加易读。 使用NPM命令安装Yarn到全局： bash123momashanhe@localhost momashanhe $ npm install yarn -gadded 1 package in 949msmomashanhe@localhost momashanhe $ 6.2 常用命令6.2.1 查看版本和配置信息使用yarn -v命令查看NPM的版本： bash123momashanhe@localhost momashanhe $ yarn -v1.22.22momashanhe@localhost momashanhe $ 使用yarn config list命令查看配置信息。 6.2.2 初始化包使用yarn init命令或yarn init -y命令初始化包。 6.2.3 下载并安装包使用yarn add 包名命令下载并安装包，默认安装到生产环境。 使用yarn add 包名 -S命令下载并安装包，安装到生产环境，支持开发环境和生产环境使用。 使用yarn add 包名 -D命令下载并安装包，安装到开发环境，仅支持开发环境使用。 使用yarn global add 包名命令安装到全局。 使用yarn list命令可以查看安装在本地的包有哪些。 使用yarn global list命令可以查看安装在全局的包有哪些。 使用yarn bin命令可以查看本地的bin目录。 使用yarn global bin命令可以查看全局的bin目录。 需要将全局的bin目录配置到环境变量，这样才能使用全局安装的包附带的命令。 默认使用国外的镜像源，使用yarn config get registry命令查看当前使用的镜像源。 使用yarn config set registry https://registry.npmmirror.com/命令设置为淘宝镜像源可以加速下载。 使用yarn config set registry https://registry.yarnpkg.com命令设置为默认的官方镜像源。 6.2.4 删除包使用yarn remove 包名命令删除依赖包。 使用yarn global remove 包名命令删除全局依赖包。 6.2.5 重新安装包使用yarn命令重新安装依赖包，重新生成node_modules目录。 6.2.6 命令别名在package.json文件中配置好命令别名后，使用yarn 别名命令执行，不需要使用run参数。 6.2.7 发布服务包使用yarn login命令登录到NPM服务器，填写用户名和密码，以及邮箱收到的验证码。 使用yarn publish命令将包发布到NPM服务器。 6.2.8 更新服务包使用yarn publish命令将包发布到NPM服务器。 6.2.9 删除服务包Yarn不支持删除服务包，建议使用NPM删除服务包。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"模块化","slug":"C00-前端/C04-Node/001-基础/004-模块化","date":"2025-03-06T02:08:22.000Z","updated":"2025-06-21T08:57:43.345Z","comments":true,"path":"posts/20250306/100822/","permalink":"https://momashanhe.com/posts/20250306/100822/","excerpt":"摘要：本文学习了Node的模块化，比较了CommonJS模块和ES模块的区别，以及缓存和分类。","text":"摘要：本文学习了Node的模块化，比较了CommonJS模块和ES模块的区别，以及缓存和分类。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 概念模块是一个封装了特定功能的独立文件以便在其他文件中引入和使用，模块化是将一个复杂的程序文件依据一定规则或规范拆分成多个文件的过程。如果在开发时是按照模块开发的，那么整个项目就是模块化项目。 模块的内部数据是私有的，可以暴露内部数据让其他模块引用。 每个文件都可以作为一个模块，默认处于独立的作用域内。每个模块都包含一组相关的函数、对象或变量，通过这种方式，可以使用结构化的方法来管理大型应用程序，让代码更加清晰和易于维护。 Node支持以下几种模块： 内置模块：Node自带的模块，如fs、http、path等。 用户自定义模块：由开发者创建的模块。 第三方模块：通过命令安装的模块，如express、lodash等。 2 使用在使用模块时遵循CommonJS模块规范，简称CJS模块，也支持ES模块规范，简称EJS模块。 2.1 CommonJS模块2.1.1 导入模块导入模块的方式： js1require(&#x27;路径&#x27;); 注意事项： 导入自己创建的模块时，导入时路径建议写相对路径，不能省略./和../。 导入内置模块或第三方模块时，导入时直接写模块的名字即可，可以省略./和../。 导入的文件类型说明： 导入JS和JSON文件时可以不用写后缀，导入C和C++编写的Node扩展文件也可以不写后缀，但是一般用不到。 导入其他类型的文件会以JS文件进行处理。 导入文件夹会先检测该文件夹下的package.json文件中main属性对应的文件，如果对应的文件存在则导入，如果对应的文件不存在会报错。如果package.json文件不存在，或者main属性不存在，则会尝试导入文件夹下的index.js文件和index.json文件，如果还是没找到，就会报错。 如果要使用第三方模块，需要先试用npm install 模块名命令进行安装，然后才能在代码里导入。 2.1.2 暴露模块如果需要让外部模块使用模块内的数据，就需要将模块内的数据暴露出去。 模块暴露数据的方式有两种： js12module.exports = 数据;exports.属性名 = 属性值; 两种方式的区别： module.exports是导出对象的真正引用，exports是导出对象的快捷方式。 不能直接赋值exports = 数据，这样会导致断开exports对module.exports的引用。 如果暴露的属性名重复的话，后面的会覆盖前面的。 2.1.3 示例暴露模块： tool.js12let sex = &#x27;男&#x27;;exports.sex = sex; 导入模块： test.js12let tools = require(&#x27;./tools.js&#x27;);console.log(tools.sex);// 男 2.2 ES模块如果要在Node中使用ES模块，包括使用import加载和export输出，就需要将文件扩展名设置为mjs表示这是一个ES模块，启用严格模式。 如果不想修改文件的扩展名，也可以在项目的package.json文件中将type字段指定为module表示将JS都作为ES模块。一旦设置了以后，该目录里面的JS脚本都会被解释用ES模块。如果此时还想在项目中使用CommonJS模块，就需要将文件扩展名改为cjs表示这是一个CommonJS模块。 注意，ES模块与CommonJS模块尽量不要混用，一个项目里面尽量统一一种规范。 2.3 比较语法上面： CommonJS模块使用require()加载和module.exports输出。 ES模块使用import加载和export输出。 用法上面： CommonJS模块的require()是同步加载，后面的代码必须等待这个命令执行完，才会执行。 ES模块的import则是异步加载。或者更准确地说，ES模块有一个独立的静态解析阶段，依赖关系的分析是在那个阶段完成的，最底层的模块第一个执行。 加载方式： 扩展名为mjs的文件总是以ES模块加载。 扩展名为cjs的文件总是以CommonJS模块加载。 扩展名为js的文件加载取决于package.json里面type字段的设置，默认使用CommonJS模块加载。 2.4 混用2.4.1 CommonJS模块加载ES模块不能在CommonJS模块中使用require()加载ES模块，否则会报错，可以使用import()加载ES模块。 在mjs文件中暴露ES模块： tool.mjs12const sex = &#x27;男&#x27;;export &#123; sex &#125;; 在js文件CommonJS模块中使用import()加载mjs文件ES模块： test.js1234(async () =&gt; &#123; let tools = await import(&#x27;./tools.mjs&#x27;); console.log(tools.sex);// 男&#125;)(); 不能使用require()加载ES模块的原因是CommonJS的模块是同步加载，而ES模块内部使用的是顶层await命令，导致无法被同步加载。 2.4.2 ES模块加载CommonJS模块ES模块的import可以加载CommonJS模块。 在js文件中暴露CommonJS模块： tool.js12const sex = &#x27;男&#x27;;exports.sex = sex; 在mjs文件ES模块中使用import加载js文件CommonJS模块： test.mjs12import tools from &#x27;./tools.js&#x27;;console.log(tools.sex);// 男 3 缓存Node会缓存已加载的模块，而不必每次都重新加载。 如果要重新加载模块，可以删除缓存： test.js123delete require.cache[require.resolve(&#x27;./tools.js&#x27;)];let tools = require(&#x27;./tools.js&#x27;);console.log(tools.sex);// 男 4 分类根据模块的来源、作用范围可以分为4钟类别： 内置模块：Node内置的模块，无需额外安装，通过require(模块名)引入。 自定义模块：开发者创建的模块，通过require(路径)引入。 本地模块：通过npm install 模块安装在本地node_modules目录的第三方模块，通过require(模块名)引入。 全局模块：通过npm install 模块 -g安装在全局node_modules目录的第三方模块，通过require(模块名)引入。 将内置模块以外的3种模块称为文件模块。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"初体验","slug":"C00-前端/C04-Node/001-基础/003-初体验","date":"2025-03-05T14:17:45.000Z","updated":"2025-06-21T08:57:45.227Z","comments":true,"path":"posts/20250305/221745/","permalink":"https://momashanhe.com/posts/20250305/221745/","excerpt":"摘要：本文学习了如何使用Node编写和运行程序。","text":"摘要：本文学习了如何使用Node编写和运行程序。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 编写新建hello.js文件并输入内容保存： hello.js1console.log(&#x27;hello world&#x27;); 该命令的作用是在控制台打印一行字符串。 2 运行在VSCode编辑器中打开文件，并在终端里使用node命令运行文件： bash123momashanhe@localhost momashanhe $ node hello.js hello worldmomashanhe@localhost momashanhe $ 回车后，能够在终端中看到打印的字符串。 3 注意事项Node中不能使用浏览器提供的BOM和DOM等API，可以使用Node提供的后端API。 在浏览器中如果要使用全局对象，需要使用window对象。在Node中如果要使用全局对象，需要使用global对象。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"安装","slug":"C00-前端/C04-Node/001-基础/002-安装","date":"2025-02-24T02:27:46.000Z","updated":"2025-06-21T09:32:44.092Z","comments":true,"path":"posts/20250224/102746/","permalink":"https://momashanhe.com/posts/20250224/102746/","excerpt":"摘要：本文学习了Node的下载和安装。","text":"摘要：本文学习了Node的下载和安装。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 下载下载网站： 英文官方 中文 软件分为LTS和Current两个版本： LTS：即Long Term Support，长期稳定版本，版本号较老，但胜在稳定。 Current：当前最新版本，版本号最新，能体验新特性，但可能有BUG存在。 建议下载适合自己操作系统和架构的LTS版本进行安装，下载得到的是后缀为.msi的文件。 如果需要下载历史版本可以访问官网提供的下载页：历史版本 2 安装双击下载的文件安装即可。 注意这里不需要勾选，继续下一步即可： 安装结束后打开base命令行，输入node -v命令查询版本： bash123momashanhe@localhost momashanhe $ node -vv18.14.0momashanhe@localhost momashanhe $","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"比较for-in和for-of两种遍历方式","slug":"C00-前端/C03-JS/002-技巧/004-比较for-in和for-of两种遍历方式","date":"2025-02-20T02:19:44.000Z","updated":"2025-06-21T08:57:46.870Z","comments":true,"path":"posts/20250220/101944/","permalink":"https://momashanhe.com/posts/20250220/101944/","excerpt":"摘要：本文比较了JS中for-in和for-of两种遍历方式有什么区别，以及使用场景。","text":"摘要：本文比较了JS中for-in和for-of两种遍历方式有什么区别，以及使用场景。 1 介绍1.1 for-in使用for-in可以遍历对象所有属性，基于原型链，不能保证按顺序遍历，支持遍历对象属性。 示例： js12345678let arr = [1,2,3];for (let key in arr) &#123; console.log(key + &#x27; &gt; &#x27; + arr[key]);&#125;let person = &#123;&#x27;name&#x27;:&#x27;张三&#x27;, &#x27;sex&#x27;:&#x27;男&#x27;&#125;;for (let key in person) &#123; console.log(key + &#x27; &gt; &#x27; + person[key]);&#125; 1.2 for-of使用for-of可以遍历所有可迭代对象，能保证按顺序遍历，不支持遍历对象属性。 示例： js1234let arr = [1,2,3];for (let value of arr) &#123; console.log(value);&#125; 2 总结使用for-in可以遍历对象属性，在遍历时可以获取到索引下标，根据索引下标进行遍历，不能保证按照顺序遍历。 如果需要遍历对象属性，或者需要获取索引下标，可以使用for-in的方式。 使用for-of可以遍历可迭代对象，在遍历时直接获取值，能保证按照顺序遍历。 如果需要按顺序遍历，并且不是遍历对象属性，也不需要索引下标，可以使用for-of的方式。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"简写优化技术","slug":"C00-前端/C03-JS/002-技巧/003-简写优化技术","date":"2025-02-20T01:27:07.000Z","updated":"2025-06-21T08:57:46.613Z","comments":true,"path":"posts/20250220/092707/","permalink":"https://momashanhe.com/posts/20250220/092707/","excerpt":"摘要：本文学习了JS中可以简写和优化的代码。","text":"摘要：本文学习了JS中可以简写和优化的代码。 1 多个条件在多个条件的判断语句中可以使用include()方法简写： js12345678// 简写前if (x === &#x27;abc&#x27; || x === &#x27;def&#x27; || x === &#x27;ghi&#x27; || x ===&#x27;jkl&#x27;) &#123; // 代码逻辑&#125;// 简写后if ([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;].includes(x)) &#123; // 代码逻辑&#125; 2 判断语句在简单的判断语句中可以使用三元运算符简写： js123456789// 简写前let result = &#x27;未知&#x27;;if (score &gt;= 60) &#123; result = &#x27;及格&#x27;;&#125; else &#123; result = &#x27;不及格&#x27;;&#125;// 简写后let result = score &gt;= 60 ? &#x27;及格&#x27; : &#x27;不及格&#x27;; 支持嵌套条件的场景： js12345678910111213// 简写前let result = &#x27;未知&#x27;;if (score &gt;= 60) &#123; if (score &gt;= 90) &#123; result = &#x27;优秀&#x27;; &#125; else &#123; result = &#x27;及格&#x27;; &#125;&#125; else &#123; result = &#x27;不及格&#x27;;&#125;// 简写后let result = score &gt;= 60 ? score &gt;= 90 ? &#x27;优秀&#x27; : &#x27;及格&#x27; : &#x27;不及格&#x27;; 3 声明多个变量在声明多个变量时可以简写： js12345// 简写前let a = 1;let b = 2;// 简写后let a = 1, b = 2; 4 非空判断在判断变量是否为空时可以简写： js12345678910// 简写前let result = &#x27;error&#x27;;if (x !== null &amp;&amp; x !== undefined &amp;&amp; x !== &#x27;&#x27;) &#123; result = x;&#125;// 简写后let result = &#x27;error&#x27;;if (x) &#123; result = x;&#125; 继续简写： js1234567// 简写前let result = &#x27;error&#x27;;if (x) &#123; result = x;&#125;// 简写后let result = x || &#x27;error&#x27;; 5 Switch判断简写在使用Switch判断语句时可以简写： js12345678910111213141516171819// 简写前switch (data) &#123; case 1: test1(); break; case 2: test2(); break; case 3: test3(); break;&#125;// 简写后var test = &#123; 1: test1, 2: test2, 3: test3&#125;;test[data] &amp;&amp; test[data]();","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"简介","slug":"C00-前端/C04-Node/001-基础/001-简介","date":"2025-02-14T02:28:20.000Z","updated":"2025-06-21T08:57:43.345Z","comments":true,"path":"posts/20250214/102820/","permalink":"https://momashanhe.com/posts/20250214/102820/","excerpt":"摘要：本文介绍了Node是什么，与浏览器的区别，以及其优势和作用。","text":"摘要：本文介绍了Node是什么，与浏览器的区别，以及其优势和作用。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1NVM 1.1.12 1 介绍Node是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。 Node采用Google开发的V8引擎运行JavaScript代码，使用事件驱动、非阻塞和异步IO模型等技术来提高性能，可优化应用程序的传输量和规模。 简单来说，Node是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端。 2 与JavaScript和浏览器的区别JavaScript是一种高级编程语言，严格来说是指ECMAScript，不包含BOM和DOM。 浏览器提供了JavaScript的运行环境，包括全局对象、BOM、DOM等工具方便JavaScript脚本的解析和执行，浏览器是客户端的一种。 浏览器都有两个引擎：一个是渲染引擎，一个是JavaScript解析执行引擎。比如Chrome浏览器的V8引擎就是专门用来解析和执行JavaScript代码的。 Node是一个开源的、跨平台的JavaScript运行环境，允许JavaScript在服务器端运行。 以前的JavaScript只能在客户端运行，Node将Chrome浏览器里的V8引擎移植到自己的环境当中，在这个环境之上构建了一系列的底层API，提供了一些特定环境的编程接口。 虽然Node不提供BOM和DOM等客户端用到的API，但提供了丰富的服务端API，这些API是对ECMAScript的扩展，使得JavaScript能够在服务器端进行高效的开发工作。 3 优势服务端的运行环境有很多，比如Tomcat，但Node具有其他运行环境没有的优势。 3.1 非阻塞IO模型和事件驱动架构Node采用非阻塞IO模型和事件驱动架构，这是其核心优势之一。 在传统的服务器端编程中，当一个请求需要进行IO操作时，采用的是阻塞IO模型。例如，当读取文件时，服务器会阻塞当前线程，直到操作完成。 而Node通过非阻塞IO模型，允许服务器在等待IO操作完成时继续处理其他请求。例如，当请求需要读取文件时，Node不会阻塞线程，而是将读取操作交给底层系统，同时继续处理其他请求。当文件读取完成时，会触发一个事件，通知服务器继续处理该请求的后续逻辑。 这种非阻塞IO和事件驱动的机制使得Node能够高效地处理大量并发请求，特别适合构建高性能的网络应用。 3.2 语言统一性Node使用JavaScript作为开发语言，这意味着开发者可以在服务器端和客户端使用相同的语言进行编程。 这种语言的统一性降低了学习成本，使得前端开发者能够更容易地进入后端开发领域，也使得代码的复用性更高，开发者可以将一些公共逻辑在客户端和服务器端共享。 3.3 丰富的生态系统Node使用NPM作为包管理器，NPM提供了庞大的JavaScript库和模块生态系统，开发者可以轻松找到所需的工具和框架。 3.4 轻量级和快速开发Node的轻量级特性和丰富的框架使得开发者能够快速开发和部署应用。 4 作用开发服务器应用：开发运行在服务器上的程序。 开发工具类应用：Webpack，Vite，Babel。 开发桌面端应用：Electron，VSCode，Figma，Postman。 5 官方文档官方文档地址：https://nodejs.cn/api/v18/index.html","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"}]},{"title":"异步编程","slug":"C00-前端/C03-JS/002-技巧/002-异步编程","date":"2025-01-21T02:25:47.000Z","updated":"2025-06-21T08:57:46.679Z","comments":true,"path":"posts/20250121/102547/","permalink":"https://momashanhe.com/posts/20250121/102547/","excerpt":"摘要：本文学习了常见的几种实现异步。","text":"摘要：本文学习了常见的几种实现异步。 1 回调函数在微任务队列出现之前，JS实现异步的主要方式就是通过回调函数，即通过AJAX请求的回调函数实现异步调用。 示例： js12345678910$.ajax(&#123; url:&#x27;/api/getData&#x27;, type:&#x27;get&#x27;, dataType:&#x27;json&#x27;, success:function(res) &#123; if (res.success) &#123; alert(&#x27;调用成功&#x27;); &#125; &#125;&#125;); 这种异步调用不能控制顺序，如果想在第一个回调函数执行后再执行第二个回调函数，就需要将第二个回调函数嵌套在第一个回调函数中，这种回调函数中嵌套回调函数的情况就叫做回调地狱。 2 PromisePromise作为典型的微任务之一，它的出现可以使JS达到异步执行的效果。 示例： js1234567891011function adder(arg) &#123; return new Promise((resolve) =&gt; &#123; resolve(++arg); &#125;)&#125;function sum() &#123; adder(1) .then(val =&gt; adder(val)) .then(val =&gt; console.log(val));&#125;sum();// 3 3 GeneratorGenerator和Promise都是在ES6新增的，Generator返回的是一个Iterator对象。 示例： js12345678function * add(arg) &#123; console.log(++arg);// 2 yield arg; console.log(++arg);// 3&#125;let iterator = add(1);console.log(iterator.next());// &#123;value: 2, done: false&#125;console.log(iterator.next());// &#123;value: undefined, done: true&#125; 4 async和awaitasync和await是ES7提出的关于异步的终极解决方案，进一步简化了Promise的代码。 示例： js1234567891011121314function adder(arg) &#123; return new Promise((resolve) =&gt; &#123; resolve(++arg); &#125;)&#125;async function sum() &#123; // adder(1) // .then(val =&gt; adder(val)) // .then(val =&gt; console.log(val)) let val = await adder(1); val = await adder(val); console.log(val);&#125;sum();// 3","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"https://momashanhe.com/tags/AJAX/"}]},{"title":"AJAX","slug":"C00-前端/C03-JS/003-扩展/002-AJAX","date":"2025-01-17T03:58:18.000Z","updated":"2025-07-01T01:21:38.361Z","comments":true,"path":"posts/20250117/115818/","permalink":"https://momashanhe.com/posts/20250117/115818/","excerpt":"摘要：本文学习了AJAX的原理和使用。","text":"摘要：本文学习了AJAX的原理和使用。 1 简介AJAX是异步的JS和XML，即：Asynchronous JavaScript And XML。 AJAX的目的是在不发生页面跳转的情况下，使用异步载入内容并改写页面内容的技术。 AJAX可以简单的理解为通过JS向服务器发送请求。 AJAX这门技术很早就被发明，但是直到2005年被谷歌的大量使用，才在市场中流行起来，可以说Google为AJAX的推广起到到推波助澜的作用。 2 同步和异步2.1 同步处理在AJAX出现之前，访问互联网时一般都是同步请求，也就是当一个页面向服务器发送一个请求时，在服务器响应结束之前，整个页面是不能操作的，直观上来看是卡住的或者是正在加载中的。 这就带来了非常糟糕的用户体验。首先，同步请求时，用户只能等待服务器的响应，而不能做任何操作。其次，如果请求时间过长可能会给用户一个卡死的感觉。最后，同步请求的最大缺点，就是即使整个页面中只有一小部分内容发生改变也要刷新整个页面。 2.2 异步处理异步处理指的是在浏览网页的同时，通过AJAX向服务器发送请求，发送请求的过程中浏览网页的行为并不会收到任何影响，甚至主观上感知不到在向服务器发送请求。当服务器正常响应请求后，响应信息会直接发送到AJAX中，AJAX可以根据服务器响应的内容做一些操作。 使用AJAX的异步请求基本上完美的解决了同步请求带来的问题。首先，发送请求时不会影响到用户的正常访问。其次，即使请求时间过长，用户不会有任何感知。最后，AJAX可以根据服务器的响应信息局部的修改页面，而不需要整个页面刷新。 3 工作原理3.1 XMLHttpRequest对象如果需要向服务器发送请求，就需要使用HTTP协议，需要通过JS向服务器发送一个请求报文。 浏览器为开发人员提供了XMLHttpRequest对象，用于封装请求报文，浏览器向服务器发送的请求信息全部都需要封装到该对象中。 3.2 获取XMLHttpRequest对象由于浏览器之间的差异，不同浏览器中获取XMLHttpRequest的方式不同，但总的来说一共有三种方式： js123var xhr = new XMLHttpRequest();// 目前主流浏览器都支持var xhr = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;);// IE6支持的方式var xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);// IE5.5以下支持的方式 使用兼容方式获取XMLHttpRequest对象： js123456789101112function createXMLHttpRequest()&#123; if (typeof XMLHttpRequest === &#x27;undefined&#x27;) &#123; window.XMLHttpRequest = function () &#123; try &#123; return new window.ActiveXObject(&#x27;Msxml2.XMLHTTP.6.0&#x27;); &#125; catch (e) &#123;&#125; try &#123; return new window.ActiveXObject(&#x27;Msxml2.XMLHTTP.3.0&#x27;); &#125; catch (e) &#123;&#125; try &#123; return new window.ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;); &#125; catch (e) &#123;&#125; try &#123; return new window.ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); &#125; catch (e) &#123;&#125; throw new Error(&#x27;This browser does not support XMLHttpRequest.&#x27;); &#125;; &#125; return new XMLHttpRequest();&#125; 3.3 使用XMLHttpRequest对象3.3.1 发送请求如果需要将请求发送到服务器，可以使用XMLHttpRequest对象的open方法和send方法。 3.3.1.1 使用open方法使用open方法规定请求的类型、URL以及是否异步处理请求。 格式： js1open(method,url,async) 参数： method：发送请求的HTTP类型(GET，POST，PUT，DELETE)，必须大写。 uri：XMLHttpRequest对象把请求发送到的服务器相应的URI。 async：是否请求是异步的，缺省值为true（异步）。 3.3.1.2 使用send方法使用send方法将请求发送到服务器。 格式： js1send(string) 参数： string：仅用于POST请求，并且POST请求在发送数据之前还需要设置请求头。 3.3.2 获取响应如果要获取服务器的响应，需要使用responseText或者responseXML属性。 如果响应返回的数据是文本就使用responseText，如果响应返回的数据是XML就使用responseXML。 状态相关的属性有readyState和status。 3.3.2.1 readyStatereadyState描述XMLHttpRequest对象的状态，从0到4变化： 0表示未初始化，XMLHttpRequest对象已创建，但还未初始化。 1表示服务器连接已建立。 2表示请求已接收，响应未接收。 3表示响应正在接收。 4表示响应已接收。 readyState的值在发生改变时，XMLHttpRequest对象会激发一个readystatechange事件，可以在readystatechange事件中设置回调。 3.3.2.2 statusstatus描述HTTP状态码，当且仅当readyStatus的值为3或4时，这个属性才可以用： 200表示一切正常（OK）。 304表示没有被修改（Not Modified）。 403表示禁止访问（Forbidden）。 404表示没找到页面（Not Found）。 500表示内部服务器出错（Internal Service Error）。 3.4 举例使用GET方式： js12345678var xhr = getXMLHttpRequest();xhr.open(&#x27;get&#x27;, &#x27;AJAXServlet?name=xxx&#x27;, true);xhr.send();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; document.getElementById(&#x27;div_area&#x27;).innerHTML = xhr.responseText; &#125;&#125;; 使用POST方式： js123456789var xhr = getXMLHttpRequest();xhr.open(&#x27;post&#x27;, &#x27;AJAXServlet&#x27;, true);xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);xhr.send(&#x27;email=xxx@163.com&#x27;);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; document.getElementById(&#x27;div_area&#x27;).innerHTML = xhr.responseText; &#125;&#125;; 4 JQuery对AJAX的封装JQuery中提供了一些方法，封装了原生的AJAX。 4.1 get方法格式： js1jQuery.get(url, [data], [callback], [type]) 参数： url：发送请求的URL地址。 data：发送到服务器的数据，支持k=v&amp;k=v字符串和&#123;k:v,k:v&#125;对象两种格式。 callback：载入成功时回调函数。 type：预期服务器返回的数据类型，支持xml、html、script、json、text、_default等类型。 示例： js123456$.get(&#x27;$&#123;pageContext.request.contextPath&#125;/getPassword&#x27;, &#123;&#x27;username&#x27;:&#x27;admin&#x27;&#125;, function(data) &#123; $(&#x27;#password&#x27;).html(data);// 123456 &#125;, &#x27;json&#x27;); 4.2 post方法格式： js1jQuery.post(url, [data], [callback], [type]) 参数： url：发送请求的URL地址。 data：发送到服务器的数据，支持k=v&amp;k=v字符串和&#123;k:v,k:v&#125;对象两种格式。 callback：载入成功时回调函数。 type：预期服务器返回的数据类型，支持xml、html、script、json、text、_default等类型。 示例： js123456$.post(&#x27;$&#123;pageContext.request.contextPath&#125;/getPassword&#x27;, &#123;&#x27;username&#x27;:&#x27;admin&#x27;&#125;, function(data) &#123; $(&#x27;#password&#x27;).html(data);// 123456 &#125;, &#x27;json&#x27;); 4.3 底层方法封装好的get方法和post方法可扩展性差，不能实现定制化开发，所以JQuery提供了底层的方法。 格式： js1jQuery.ajax(url,[settings]) 参数： url：发送请求的url地址。 type：请求方式，POST或者GET，默认GET。 async：请求是同步还是异步，默认为true，true表示同步，false表示异步。 cache：是否缓存页面，适用于GET请求，默认为true，true表示缓存，false表示不缓存。 data：发送到服务器的数据，支持k=v&amp;k=v字符串和&#123;k:v,k:v&#125;对象两种格式。 processData：是否将对象类型的数据拼接为键值对字符串，默认为true，true表示拼接，false表示不拼接。 contentType：发送到服务器的数据类型，默认是application&#x2F;x-www-form-urlencoded类型，支持JSON&#x2F;XML&#x2F;HTML&#x2F;TXT等类型。 dataType：预期服务器返回的数据类型，支持JSON&#x2F;XML&#x2F;HTML&#x2F;TXT等类型。 success：请求成功时的回调函数。 error：请求失败时的回调函数。 complete：请求完成后的回调函数，成功或失败之后都会调用。 statusCode：一组数值的HTTP代码和函数对象，当响应时调用了相应的代码。 示例： js12345678910111213141516171819202122232425$.ajax(&#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/getPassword&#x27;, type: &#x27;POST&#x27;, async: true, cache: false, data: &#x27;id=1&amp;name=hello&#x27;, dataType: &#x27;json&#x27;, success: function (data) &#123; $(&#x27;#password&#x27;).html(data); &#125;, error: function () &#123; alert(&#x27;请求错误了&#x27;); &#125;, complete: function () &#123; alert(&#x27;请求完成了&#x27;); &#125;, statusCode: &#123; 200: function () &#123; alert(&#x27;操作完成&#x27;); &#125;, 500: function () &#123; alert(&#x27;服务器错误&#x27;); &#125; &#125;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"JQuery","slug":"JQuery","permalink":"https://momashanhe.com/tags/JQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"https://momashanhe.com/tags/AJAX/"}]},{"title":"JQuery","slug":"C00-前端/C03-JS/003-扩展/001-JQuery","date":"2025-01-17T03:51:22.000Z","updated":"2025-06-21T08:57:46.083Z","comments":true,"path":"posts/20250117/115122/","permalink":"https://momashanhe.com/posts/20250117/115122/","excerpt":"摘要：本文学习了JQuery库，包括选择器、文档处理、事件、效果，以及AJAX调用。","text":"摘要：本文学习了JQuery库，包括选择器、文档处理、事件、效果，以及AJAX调用。 1 简介JQuery这个名字由JS和Query组合而成，但并非官方定义的全称。 JQuery是一个流行的JS库，旨在简化HTML文档遍历、事件处理、动画和AJAX交互等网页开发任务。尽管名字中有“Query”，它并不用于数据库查询，而是专注于提供易于使用的API来操作DOM（文档对象模型）和实现各种前端功能。 JQuery设计的宗旨是写更少的代码，做更多的事情。 2 引入JQuery库实际上就是一个JS文件，只需要在网页中直接引入这个文件就可以了。 从官网引入： html1&lt;script src=&quot;jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt; 因为网络原因，建议从CDN引入： html1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt; 也可以下载JQuery文件并放置在项目中，然后通过script元素引用。 3 语法3.1 基础语法JQuery语法是通过选取HTML元素，并对选取的元素执行某些操作。 基础语法： js1$(selector).action(); 美元$符号定义JQuery，选择器selector用于查询HTML元素，方法action()执行对元素的操作。 3.2 核心JQuery库为window对象定义了一个$函数JQuery()，也可以写作$()。 JQuery()函数会根据参数数据类型的不同做不同的工作，返回一个JQuery封装的伪数组对象。 3.2.1 四种参数形式JQuery()函数中可以存放的四种参数形式，返回的均是JQuery对象。 3.2.1.1 选择器字符串格式为： js1$(选择器字符串) 通过相应选择器获取对应的DOM对象，然后将这些DOM封装到一个JQuery对象中并返回： js1var $div = $(&#x27;div&#x27;);// 选取所有div元素节点并返回，将这些DOM节点封装到JQuery对象 3.2.1.2 DOM对象格式为： js1$(DOM对象) 将该DOM对象封装成JQuery对象并返回： js12var div = document.getElementsByTagName(&#x27;div&#x27;);var $div = $(div);// 将DOM对象转化为JQuer对象 3.2.1.3 HTML文本字符串格式为： js1$(HTML文本字符串) 根据传入的文本创建好HTML元素并封装成JQuery对象返回： js1var $div = $(&#x27;&lt;div class=&quot;one&quot;&gt;one&lt;div&gt;&#x27;);// 创建一个类名为one的div元素且将其封装成一个JQuery对象 3.2.1.4 匿名函数格式为： js1$(匿名函数) 当文档结构加载完毕之后JQuery函数调用匿名函数： js12$(function()&#123; &#125;);// 文档结构加载完毕后执行function函数中的代码$(document).ready(function()&#123; &#125;);// 将document节点转化为JQuery对象，在调用对象ready()方法实现文档加载完毕后再执行函数内代码 3.2.2 JQuery对象和DOM对象JQuery对象是JQuery独有的，JQuery对象无法使用DOM对象的任何方法。同样的，DOM对象也不能使用JQuery里的任何方法。 JQuery对象和DOM对象的转化： JQuery对象转化为DOM对象：js1$(&#x27;div&#x27;)[0];// 在JQuery对象后面添加数值下标即可选择其获取到的JQuery类数组对象中相应位置存放的DOM对象 DOM对象转化为JQuery对象：js12var div = document.getElementsByTagName(&#x27;div&#x27;);// 多个div返回的是一个DOM类数组对象var $div = $(div);// 将DOM对象作为JQuery函数的参数即可将该DOM对象转化为JQuery对象 JQuery对象的操作实际上就是对JQuery数组中DOM对象的批量操作。 3.3 选择器3.3.1 基本选择器基本选择器： 分类 示例 说明 id选择器 $('#username') 匹配id属性为username的第一个元素。 class选择器 $('.red') 匹配class属性包含red的所有元素。 标签选择器 $('span') 匹配标签名为span的所有元素。 多选择器 $('#username,.red, span, div') 匹配多个选择器匹配的所有元素。 全部选择器 $('*') 匹配页面上的所有元素。 3.3.2 层次选择器层次选择器： 分类 示例 说明 匹配子元素 $('form>input') 在所有form元素的子元素中匹配input元素。 匹配后代元素 $('form input') 在所有form元素的后代元素中匹配input元素，后代元素包括子元素和孙子元素。 匹配之后相邻的兄弟元素 $('label+input') 在所有label元素后相邻的兄弟元素中匹配input元素。 匹配之后的兄弟元素 $('label~input') 在所有label元素后的兄弟元素中匹配input元素。 3.3.3 过滤选择器过滤选择器主要是通过特定的过滤规则来筛选出所需的DOM元素，该选择器都以:开头。 过滤选择器： 分类 示例 说明 匹配第一个元素 $('tr:first') 匹配第一个tr元素。 匹配最后一个元素 $('tr:last') 匹配最后一个tr元素。 匹配偶数索引元素 $('tr:even') 匹配所有索引值为偶数的tr元素，从0开始计数。 匹配奇数索引元素 $('tr:odd') 匹配所有索引值为奇数的tr元素，从0开始计数。 匹配等于指定索引的元素 $('tr:eq(3)') 匹配索引值等于3的tr元素，从0开始计数。 匹配大于指定索引的元素 $('tr:gt(3)') 匹配所有索引值大于3的tr元素，从0开始计数。 匹配小于指定索引的元素 $('tr:lt(3)') 匹配所有索引值小于3的tr元素，从0开始计数。 匹配不被指定的元素 $('tr:not(:eq(3))') 匹配索引值不等于3的tr元素，从0开始计数。 子元素过滤选择器： 分类 示例 说明 匹配指定的子元素 $('td:nth-child(3)') 在所有父元素的第3个子元素中，匹配td元素。 匹配指定的第一个子元素 $('td:first-child()') 在所有父元素的第一个子元素中，匹配td元素。 匹配指定的最后一个子元素 $('td:last-child()') 在所有父元素的最后一个子元素中，匹配td元素。 属性过滤选择器： 分类 示例 说明 匹配指定属性的元素 $('input[name]') 匹配name属性存在的input元素。 匹配属性和指定属性值相同的元素 $('input[name=\"username\"]') 匹配name属性的属性值和username相同的input元素。 匹配属性和指定属性值不同的元素 $('input[name!=\"username\"]') 匹配name属性的属性值和username不同的input元素。 匹配属性以指定属性值开始的元素 $('input[name^=\"user\"]') 匹配name属性的属性值以user开始的input元素。 匹配属性以指定属性值结束的元素 $('input[name$=\"user\"]') 匹配name属性的属性值以user结束的input元素。 匹配属性包含指定属性值的元素 $('input[name*=\"user\"]') 匹配name属性的属性值包含user的input元素。 表单过滤选择器： 分类 示例 说明 匹配输入框元素 $(':input') 匹配所有input元素，即匹配所有输入框元素。 匹配文本框元素 $(':text') 匹配所有type属性值为text的input元素。 匹配密码框元素 $(':password') 匹配所有type属性值为password的input元素。 匹配单选框元素 $(':radio') 匹配所有type属性值为radio的input元素。 匹配复选框元素 $(':checkbox') 匹配所有type属性值为checkbox的input元素。 匹配按钮元素 $(':button') 匹配所有type属性值为button的input元素。 匹配提交按钮元素 $(':submit') 匹配所有type属性值为submit的input元素。 匹配重置按钮元素 $(':reset') 匹配所有type属性值为reset的input元素。 表单对象属性过滤选择器： 分类 示例 说明 匹配禁用的表单元素 $('input:disabled') 匹配所有disabled属性值为true的input元素。 匹配启用的表单元素 $('input:enabled') 匹配所有disabled属性值为false的input元素。 匹配选中的选项元素 $('input:checked') 匹配选中的input选项元素，包括单选框和复选框。 匹配选中的下拉项元素 $('select option:selected') 匹配选中的option选项元素。 匹配所有隐藏元素 $('div:hidden') 匹配所有隐藏的div元素。 3.4 文档处理3.4.1 插入节点插入节点： 分类 示例 说明 插入到内部尾部 $('p').append(插入内容) 向p元素内部的尾部插入指定内容，插入内容作为子节点。 插入到内部头部 $('p').prepend(插入内容) 向p元素内部的头部插入指定内容，插入内容作为子节点。 插入到外部尾部 $('p').after(插入内容) 向p元素外部的尾部插入指定内容，插入内容作为兄弟节点。 插入到外部头部 $('p').before(插入内容) 向p元素外部的头部插入指定内容，插入内容作为兄弟节点。 3.4.2 删除节点删除节点： 分类 示例 说明 删除子节点 $('div').empty() 删除div元素的子节点和内容节点，保留div元素本身。 删除节点 $('div').remove() 删除div元素，包括div元素本身，以及div元素的子节点和内容节点。 3.4.3 查找节点查找节点： 分类 示例 说明 查找节点 $('div').find('span') 在div元素中查找span元素，即匹配div元素的span后代元素。 遍历节点 $('div').each(function(index,element)&#123; &#125;) 遍历div元素，使用index表示当前下标，使用element表示当前元素。 如果是匿名函数，还可以使用$&#123;this&#125;代替element表示当前元素。 3.4.4 修改节点内容操作： 分类 示例 说明 获取文本内容 $('#welcome').text() 获取id属性为welcome的元素的文本内容。 修改文本内容 $('#welcome').text('欢迎') 修改id属性为welcome的元素的文本内容为欢迎。 值操作： 分类 示例 说明 获取value属性 $('#username').val() 获取id属性为username的元素的文本内容。 修改value属性 $('#username').val('佚名') 修改id属性为username的元素的文本内容为佚名。 属性操作： 分类 示例 说明 获取指定属性 $('#username').attr('readonly') 获取id属性为username的元素的readonly属性。 修改指定属性 $('#username').attr('readonly',true) 修改id属性为username的元素的readonly属性为true。 删除指定属性 $('#username').removeAttr('readonly') 删除id属性为username的元素的readonly属性。 类操作： 分类 示例 说明 增加指定类 $('#username').addClass('username') 给id属性为username的元素增加username类。 删除指定类 $('#username').removeClass('username') 给id属性为username的元素删除username类。 样式操作： 分类 示例 说明 获取指定样式 $('#username').css('color') 获取id属性为username的元素的color样式。 修改指定样式 $('#username').css('color','red') 修改id属性为username的元素的color样式为red。 3.5 事件常用事件： 分类 示例 说明 加载 $(document).ready(function()&#123; &#125;) 在页面加载DOM结构后执行方法。 点击 $('#submit').click(function()&#123; &#125;) 当id属性为submit的元素在点击时执行方法。 获得焦点 $('#username').focus(function()&#123; &#125;) 当id属性为username的元素在获得焦点时执行方法。 失去焦点 $('#username').blur(function()&#123; &#125;) 当id属性为username的元素在失去焦点时执行方法。 改变 $('#username').change(function()&#123; &#125;) 当id属性为username的元素在获得焦点后改变值时执行方法，也会在元素失去焦点时执行方法。 表单提交 $('#form').submit(function()&#123; &#125;) 当id属性为form的表单元素在提交时执行方法。 3.6 效果常用效果： 分类 示例 说明 显示 $('#username').show() 显示id属性为username的元素。 隐藏 $('#username').hide() 隐藏id属性为username的元素。 切换 $('#username').toggle() 切换id属性为username的元素的可见性。 3.7 AJAX发送get请求： js123$.get(url, &#123;name:&#x27;John&#x27;,location:&#x27;Boston&#x27;&#125;, function(data)&#123; alert(&#x27;Data Loaded: &#x27; + data);&#125;) 发送post请求： js123$.post(url, &#123;name:&#x27;John&#x27;,location:&#x27;Boston&#x27;&#125;, function(data)&#123; alert(&#x27;Data Loaded: &#x27; + data);&#125;) 发送ajax请求： js123456789101112$.ajax(&#123; url: url, type: &#x27;POST&#x27;, dataType: &#x27;json&#x27;, data: &#123;name:&#x27;John&#x27;,location:&#x27;Boston&#x27;&#125;, success: function(msg)&#123; alert(&#x27;Success&#x27;); &#125;, error: function(msg)&#123; alert(&#x27;Error&#x27;); &#125;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"JQuery","slug":"JQuery","permalink":"https://momashanhe.com/tags/JQuery/"}]},{"title":"使用Babel解决兼容问题","slug":"C00-前端/C03-JS/002-技巧/001-使用Babel解决兼容问题","date":"2024-08-02T06:55:26.000Z","updated":"2025-06-21T08:57:46.464Z","comments":true,"path":"posts/20240802/145526/","permalink":"https://momashanhe.com/posts/20240802/145526/","excerpt":"摘要：本文学习了如何使用Babel解决ES5之后的版本的兼容问题。","text":"摘要：本文学习了如何使用Babel解决ES5之后的版本的兼容问题。 1 说明Babel是一个工具链，主要用于将采用ES5以后的语法编写的代码转换为ES5语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 官网地址：https://www.babeljs.cn/ 2 使用进行初始化： bash1npm init --yes 安装相关的开发依赖，默认安装到本地： bash1npm install babel-cli babel-preset-env browserify -D 说明： babel-cli：命令行工具 babel-preset-env：预设包，进行转换 browserify：打包工具，比webpack更简单 进行转换： bash1npx babel 原路径 -d 新路径 --presets=babel-preset-env 说明： 本地安装的命令不能直接执行，可以通过npx执行，也可以输入完整的路径执行。全局安装的命令可以直接执行。 在未设置配置文件的情况下，需要使用--presets指定配置。 进行打包： bash1npm browserify 转换后的新文件 -o 打包后的新文件 网页中只要引用最后打包后的新文件即可，在修改原JS文件后，需要重新执行打包的命令。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Babel","slug":"Babel","permalink":"https://momashanhe.com/tags/Babel/"}]},{"title":"ES规范","slug":"C00-前端/C03-JS/001-基础/004-ES规范","date":"2024-07-18T07:24:38.000Z","updated":"2025-06-21T08:57:47.067Z","comments":true,"path":"posts/20240718/152438/","permalink":"https://momashanhe.com/posts/20240718/152438/","excerpt":"摘要：本文学习了ECMAScript的基本知识，包括简介和历史版本以及新特性。","text":"摘要：本文学习了ECMAScript的基本知识，包括简介和历史版本以及新特性。 1 简介1.1 定义ECMAScript是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范。 JavaScript是ECMAScript的实现，一般情况下，ECMAScript和JavaScript表达的是同一个意思。 严格来说，JavaScript包含三个部分： ECMAScript：核心，通用标准，简写为ES DOM：文档对象模型，操作网页 BOM：浏览器对象模型，操作浏览器 1.2 历史版本ES5：2009年发布ES6：2015年发布，也称为ES2015ES7：2016年发布，也称为ES2016ES8：2017年发布，也称为ES2017ES9：2018年发布，也称为ES2018ES10：2019年发布，也称为ES2019 2 ES52.1 严格模式在ES5中新增了严格模式，其作用是： 使得JS在更严格的条件下运行 消除JS语法的一些不合理、不严谨之处，减少一些怪异行为 消除JS代码运行的一些不安全之处，保证代码运行的安全 使用方式是在JS的第一行： js1&#x27;use strict&#x27;; 需要记住的几个变化： 声明定义变量必须用var关键字：js12&#x27;use strict&#x27;;age = 18;// 页面报错 禁止自定义的函数中的this关键字指向全局对象：js12345&#x27;use strict&#x27;;function Person(age) &#123; this.age = age&#125;Person(18);// 页面报错 创建eval作用域：js1234&#x27;use strict&#x27;;var age = 16;eval(&#x27;var age = 18;&#x27;);// 使用eval()方法可以执行传入的命令，有风险，不建议使用console.log(age);// 16 只在eval作用域有效，不会污染全局变量 2.2 JSON支持JSON是一种轻量级的数据交换模式，用于传输数据。 ES5提供了对JSON的支持： js1234567891011var obj = &#123; age: 18&#125;console.log(obj);// &#123;age: 18&#125;console.log(typeof obj);// objectvar jsonStr = JSON.stringify(obj);console.log(jsonStr);// &#123;&quot;age&quot;:18&#125;console.log(typeof jsonStr);// string 将对象或数组转为JSON字符串var jsonObj = JSON.parse(jsonStr);console.log(jsonObj);// &#123;age: 18&#125;console.log(typeof jsonObj);// object 将JSON字符串转为对象或数组 2.3 Object扩展增加了一种创建对象的方式，支持通过将指定对象作为原型的方式创建对象： js1234567var obj = &#123; age: 18&#125;var newObj = &#123;&#125;console.log(newObj.__proto__);// &#123;__proto__: null&#125;newObj = Object.create(obj);console.log(newObj.__proto__);// &#123;age: 18&#125; 增加操作属性的方法： js12345var obj = &#123; age: 18&#125;Object.defineProperty(obj, &#x27;age&#x27;, &#123;value : 16&#125;)console.log(obj.age);// 16 2.4 Array扩展查询元素在数组中的下标： js123var arr = [1, 2, 3, 2, 1];console.log(arr.indexOf(2));// 1 指定元素在数组中首次出现的下标console.log(arr.lastIndexOf(2));// 3 指定元素在数组中最后出现的下标 遍历数组： js1234var arr = [1, 2, 3, 2, 1];arr.forEach(function (item, index) &#123; console.log(&#x27;[&#x27; + index + &#x27;]&#x27;, item);&#125;); 对数组进行处理： js12345var arr = [1, 2, 3, 2, 1];var newArr = arr.map(function (item, index) &#123; return item + 10;&#125;);console.log(newArr); 对数组进行过滤： js12345var arr = [1, 2, 3, 2, 1];var newArr = arr.filter(function (item, index) &#123; return item &gt; 1;&#125;);console.log(newArr); 对数组进行判断，只要有一项满足就返回true，否则返回false，类似短路或运算： js123var arr = [1, 2, 3, 2, 1];var result = arr.some(item =&gt; &#123; item &gt; 2 &#125;);console.log(result);// true 对数组进行判断，只要有一项不满足就返回false，否则返回true，类似短路与运算： js123var arr = [1, 2, 3, 2, 1];var result = arr.every(item =&gt; &#123; item &lt; 3 &#125;);console.log(result);// false 2.5 Function扩展将函数的this对象修改为指定的对象： js12345678910111213141516var age = 18;function fun(age) &#123; this.age = age; console.log(this + &#x27; age = &#x27; + this.age);&#125;fun(20);// [object Window] age = 20console.log(age);// 20var obj = &#123;&#125;;// 修改方法的this对象，返回新方法var newFun = fun.bind(obj, 12);console.log(obj.age);// undefinedconsole.log(obj);// &#123;&#125;// 执行新方法newFun();// [object Object] age = 12console.log(obj.age);// 12console.log(obj);// &#123;age: 12&#125; 也可以直接执行新方法，需要在方法后面增加()，相当于call()方法： js1234567891011var age = 18;function fun(age) &#123; this.age = age; console.log(this + &#x27; age = &#x27; + this.age);&#125;fun(20);// [object Window] age = 20console.log(age);// 20var obj = &#123;&#125;;// 修改方法的this对象，并执行新方法，相当于fun.call(obj, 16)fun.bind(obj, 16)();// [object Object] age = 16console.log(obj);// &#123;age: 16&#125; 3 ES63.1 声明变量使用let关键字声明变量： 方式 作用域 重复声明 声明提升 使用var关键字声明变量 属于全局变量 可以重复声明 存在变量提升 使用let关键字声明变量 属于局部变量，会创建一个块级作用域 不能重复声明 不会预处理，不存在提升 使用const关键字声明的变量被称为常量，和let关键字类似，唯一的区别是不支持修改变量的值。 为了更好的区分常量，其标识符一般使用大写。 3.2 解构赋值按照一定模式，从数组或者对象中提取值，对变量进行赋值，这被称为解构赋值。 对象解构可以同时获取对象多个属性，但是要求属性名一致，使用&#123;&#125;包裹，按属性赋值： js12345678let obj = &#123; age:18, sex:&#x27;男&#x27;&#125;;let &#123;age, sex&#125; = obj;// 获取多个属性console.log(age, sex);// 18 &#x27;男&#x27;let &#123;age: objAge, sex: objSex&#125; = obj;// 解构同时使用别名console.log(objAge, objSex);// 18 &#x27;男&#x27; 数组解构可以同时获取多个元素，对变量名没有要求，使用[]包裹，按下标顺序赋值： js123let arr = [1, 2, 3, 2, 1];let [a, b, , , c, d] = arr;console.log(a, b, c, d);// 1 2 1 undefined 3.3 模板字符串使用模板字符串可以简化字符串的拼接，支持在字符串中使用变量、对象、表达式、方法的返回值。 对于模板字符串需要使用``包裹，在字符串中的模板需要使用$&#123;&#125;包裹： js1234567891011121314let obj = &#123; age:18, sex:&#x27;男&#x27;&#125;;console.log(`个人信息：年龄：$&#123;obj.age&#125;性别：$&#123;obj.sex&#125;以上数据真实有效`);// 支持换行function fun() &#123; return &#x27;test&#x27;;&#125;console.log(`获取返回值：$&#123;fun()&#125;`);// 支持获取返回值let arr = [1, 2, 3, 2, 1];console.log(`数组内容：$&#123;arr&#125;`);// 支持变量和数组 3.4 简化对象在定义对象时，可以直接写入变量和函数作为对象的属性方法，这样的书写更加简洁： js123456789let age = 18;let sex = &#x27;男&#x27;;let test = function() &#123;console.log(&#x27;test&#x27;);&#125;let obj = &#123; age, sex, test&#125;;console.log(obj);// &#123;age: 18, sex: &#x27;男&#x27;, test: ƒ&#125; 3.5 箭头函数使用() =&gt; &#123;&#125;箭头函数简化了函数的定义和调用，特点： js12345678910// 没有参数，不能省略箭头左侧的()符号，一条语句，可以省略箭头右侧的`&#123;&#125;`符号let fun1 = () =&gt; console.log(&#x27;test&#x27;);fun1();// test// 一个参数，可以省略箭头左侧的`()`符号，一条语句，可以省略return关键字，默认将结果作为返回值let fun2 = str =&gt; &#x27;str = &#x27; + str;console.log(fun2(&#x27;test&#x27;));fun2(&#x27;hello&#x27;);// str = test// 多个参数，不能省略箭头左侧的()符号，多条语句，不能省略箭头右侧的`&#123;&#125;`符号，不能省略return关键字let fun3 = (age,sex) =&gt; &#123;let obj = &#123;age, sex&#125;; return obj&#125;;console.log(fun3(18,&#x27;男&#x27;));// &#123;age: 18, sex: &#x27;男&#x27;&#125; 3.6 扩展运算符扩展运算符就是使用...变量名作为变量，在特定场景下具有收集和扩展的功能。 使用扩展运算符的收集功能可以实现可变参数，必须将可变参数放在参数列表最后的位置： js1234function fun(a,b,...c) &#123; console.log(a,b,c);&#125;fun(1,2,3,4,5);// 1 2 [3, 4, 5] 使用扩展运算符的扩展功能可以更加方便的操作数组： js1234let arr1 = [1,2,3];let arr2 = [4,5];let arr3 = [...arr1,...arr2];console.log(arr3);// [1, 2, 3, 4, 5] 还可以将伪数组转为真数组： js1234let home = document.getElementsByTagName(&#x27;div&#x27;);let arr = [...home];console.log(home);// HTMLCollection [div]console.log(arr);// [div] 3.7 参数默认值在定义函数时，支持设置参数的默认值，当没有传入参数时，会使用定义的默认值： js1234function fun(str = &#x27;test&#x27;) &#123; console.log(&#x27;hello&#x27;, str)&#125;fun();// hello test 3.8 Symbol新增Symbol原始数据类型，用于解决命名冲突的问题，主要用于需要保证属性名唯一的场景。 Symbol属于第七种数据类型，其他六种是：Object，String，Number，Boolean，Null，Undefined。 创建Symbol类型的数据，因为不是对象，所以不能使用new关键字： js123let s = Symbol();console.log(s);// Symbol()console.log(typeof s);// symbol 支持在创建时传入参数作为标识符，支持其他类型数据，包括对象： js1234let s1 = Symbol(&#x27;test&#x27;);console.log(s1);// Symbol(test)let s2 = Symbol(&#123;age:18,sex:&#x27;男&#x27;&#125;);console.log(s2);// Symbol([object Object]) 在ES10中，增加了description属性，用于获取传入的参数： js12let s = Symbol(&#x27;test&#x27;);console.log(s.description);// test 即使创建了相同的Symbol数据，两个数据也是不同的，这就是Symbol的唯一性： js12console.log(Symbol() == Symbol());// falseconsole.log(Symbol(&#x27;test&#x27;) == Symbol(&#x27;test&#x27;));// false 如果想要创建相同的数据，需要使用Symbol.for()创建： js1234console.log(Symbol === Symbol.for());// falseconsole.log(Symbol.for() === Symbol.for());// trueconsole.log(Symbol === Symbol.for(&#x27;test&#x27;));// falseconsole.log(Symbol.for(&#x27;test&#x27;) === Symbol.for(&#x27;test&#x27;));// true 通过Symbol.for()创建数据时会先从全局按照参数获取，如果获取到了就返回数据，如果没有获取到就会创建数据并注册到全局。 使用Symbol.keyFor()获取全局中的参数： js12let s = Symbol.for(&#x27;test&#x27;);console.log(Symbol.keyFor(s));// test 将Symbol作为对象的属性： js123456789let name = Symbol(&#x27;name&#x27;);let obj = &#123; [name]: &#x27;test&#x27;// 在创建对象时创建Symbol数据作为属性&#125;;let sex = Symbol(&#x27;sex&#x27;);obj[sex] = &#x27;男&#x27;;// 给对象手动设置Symbol数据作为属性let age = Symbol(&#x27;age&#x27;);Object.defineProperty(obj, age, &#123;value : 18&#125;);// 通过defineProperty方法设置Symbol数据作为属性console.log(obj);// &#123;Symbol(name): &#x27;test&#x27;, Symbol(sex): &#x27;男&#x27;, Symbol(age): 18&#125; 虽然Symbol属性是共有属性，但是在遍历对象时，不会出现在for循环中，也不会被Object的keys()方法和getOwnPropertyNames()方法获取，同样也不会被JSON.stringify()返回。 可以通过Object的getOwnPropertySymbols()方法获取，只能获取Symbol属性： js123456let obj = &#123; [Symbol(&#x27;name&#x27;)]: &#x27;test&#x27;, [Symbol(&#x27;sex&#x27;)]: &#x27;男&#x27;, age: 18&#125;;console.log(Object.getOwnPropertySymbols(obj));// [Symbol(name), Symbol(sex)] 也可以使用Reflect.ownKeys()方法获取所有类型的属性名： js123456let obj = &#123; [Symbol(&#x27;name&#x27;)]: &#x27;test&#x27;, [Symbol(&#x27;sex&#x27;)]: &#x27;男&#x27;, age: 18&#125;;console.log(Reflect.ownKeys(obj));// [&#x27;age&#x27;, Symbol(name), Symbol(sex)] 3.9 Promise引入Promise用于解决异步编程的问题，使用构造函数封装异步操作并可以获取其成功或失败的结果。 Promise对象代表一个异步操作，有三种状态： pending：进行中 fulfilled：已成功 rejected：已失败 在执行完成后，Promise的状态会变成fulfilled（已成功）或者rejected（已失败），这种改变称为resolved（定型），并且一旦发生定型，结果就不会再次发生改变。 创建对象： js123456789101112let promise = new Promise(function(resolve, reject) &#123; // 异步操作 let value;// 返回值 let error;// 错误 let result = true;// 异步操作结果 if (result)&#123; resolve(value);// 异步操作成功 &#125; else &#123; reject(error);// 异步操作失败 &#125;&#125;); 调用then()方法执行操作： js12345promise.then(function(value) &#123; console.log(value);// 得到异步操作成功的返回值&#125;, function (error)&#123; console.log(error);// 得到异步操作失败的返回值&#125;); 调用catch()方法捕获异常： js123promise.catch(function(reason) &#123; console.log(reason);// 得到异步操作异常的返回值&#125;); 相当于调用then()方法，属于then()方法的语法糖： js123promise.then(undefined, function(error) &#123; console.log(error);// 得到异步操作失败的返回值&#125;); 3.10 Iterator迭代器Iterator是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署了Iterator接口就可以完成遍历操作。 可以使用新的遍历命令for-of循环，部署了Iterator接口的数据接口可以通过for-of循环进行遍历。 和for-in循环相比，通过for-of循环的是value键值，而for-in循环的是index键名。 原生具备Iterator接口的数据，即不需要改动就可以使用for-of循环的有：Array、Arguments、Set、Map、String、TypedArray、NodeList。 非原生的数据可以通过自定义Iterator接口使用for-of循环。 原生Iterator接口： js12345678910111213141516171819202122232425let names = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;];// for-infor (let index in names) &#123; // 0 张三 // 1 李四 // 2 王五 console.log(index + &#x27; &#x27; + names[index]);&#125;// for-offor (let value of names) &#123; // 张三 // 李四 // 王五 console.log(value);&#125;// iterator.next()let iterator = names[Symbol.iterator]();for(var item = iterator.next(); item.done != true; item = iterator.next()) &#123; // &#123;value: &#x27;张三&#x27;, done: false&#125; // &#123;value: &#x27;李四&#x27;, done: false&#125; // &#123;value: &#x27;王五&#x27;, done: false&#125; console.log(item);&#125;// &#123;value: undefined, done: true&#125;console.log(item); 自定义Iterator接口： js1234567891011121314151617181920212223242526272829303132333435363738let person = &#123; name: &#x27;张三&#x27;, home: [&#x27;北京市&#x27;, &#x27;北京市&#x27;, &#x27;东城区&#x27;], [Symbol.iterator]()&#123; // 索引变量 let index = 0; // 保存this let _this = this; return &#123; next: function ()&#123; if(index &lt; Object.keys(_this).length)&#123; let result = &#123; value: _this[Object.keys(_this)[index]], done: false &#125; // 下标自增 index ++; // 返回结果 return result; &#125;else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125; &#125; &#125;&#125;// iterator.next()let iterator = person[Symbol.iterator]();for(var item = iterator.next(); item.done != true; item = iterator.next()) &#123; // &#123;value: &#x27;张三&#x27;, done: false&#125; // &#123;value: Array(3), done: false&#125; console.log(item);&#125;// &#123;value: undefined, done: true&#125;console.log(item); 3.11 Generator生成器Generator是一种异步编程解决方案，语法行为与传统函数完全不同。 在创建时需要使用*符号创建，用于和普通函数区分： js123function * gen() &#123; console.log(&#x27;hello&#x27;);&#125; 在调用时返回的是迭代器Iterator对象，所以需要使用next()方法调用： js12let iterator = gen();iterator.next();// hello 在创建时，可以使用yield对函数中的内容进行分割，在调用next()方法执行时，会按照yield分割执行，并返回yield后面的值： js123456789101112function * gen() &#123; console.log(&#x27;打印&#x27;); yield &#x27;返回&#x27; console.log(&#x27;打印&#x27;);&#125;let iterator = gen();// 打印// &#123;value: 返回, done: false&#125;console.log(iterator.next());// 打印// &#123;value: undefined, done: true&#125;console.log(iterator.next()); 在调用时，支持传入参数，需要在方法中接收yield的值： js123456789101112function * gen() &#123; console.log(&#x27;打印&#x27;); let param = yield &#x27;返回&#x27; console.log(&#x27;打印&#x27; + param);&#125;let iterator = gen();// 打印// &#123;value: 返回, done: false&#125;console.log(iterator.next());// 打印// &#123;value: undefined, done: true&#125;console.log(iterator.next(&#x27;参数&#x27;)); 3.12 Set新增Set对象用于存储不重复的数据列表，默认实现了Iterator接口，支持存储不同类型的数据。 使用： js12345678910111213141516171819let s = new Set();// 使用add()方法添加s.add(1);s.add(&#x27;2&#x27;);let arr = [3, 4, 5]s.add(arr);console.log(s);// Set(3) &#123;1, &#x27;2&#x27;, Array(3)&#125;// 使用has()方法判断是否存在console.log(s.has(arr));// true// 使用size查询数据个数console.log(s.size);// 3// 使用forEach()方法遍历s.forEach(v =&gt; console.log(v));// 1 2 (3) [3, 4, 5]// 使用delete()方法删除s.delete(arr);console.log(s);// Set(2) &#123;1, &#x27;2&#x27;&#125;// 使用clear()方法删除所有数据s.clear();console.log(s);// Set(0) &#123;size: 0&#125; 3.13 Map新增Map对象用于存储键值对，默认实现了Iterator接口，支持存储不同类型的键和值。 Map和Object一样，都可以存储对象的属性名和属性值，区别是Object的属性名只能是String类型或Symbol类型，而Map的键可以使任意类型。 使用： js123456789101112131415161718192021let m = new Map();// 使用set()方法添加m.set(1, 1);m.set(&#x27;2&#x27;, &#x27;2&#x27;);let arr = [3, 4, 5]m.set(arr, arr);console.log(m);// Map(3) &#123;1 =&gt; 1, &#x27;2&#x27; =&gt; &#x27;2&#x27;, Array(3) =&gt; Array(3)&#125;// 使用get()方法通过键获取值console.log(m.get(arr));// (3) [3, 4, 5]// 使用has()方法判断是否存在console.log(m.has(arr));// true// 使用size查询键值对个数console.log(m.size);// 3// 使用forEach()方法遍历m.forEach((k, v) =&gt; console.log(k + &#x27; = &#x27; + v));// 1 = 1 2 = 2 3,4,5 = 3,4,5// 使用delete()方法删除m.delete(arr);console.log(m);// Map(2) &#123;1 =&gt; 1, &#x27;2&#x27; =&gt; &#x27;2&#x27;&#125;// 使用clear()方法删除所有数据m.clear();console.log(m);// Map(0) &#123;size: 0&#125; 3.14 Class引入了类的概念，作为对象的模板，需要使用class关键字声明。 使用： js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Human &#123; // 使用constructor关键字声明构造方法 constructor(name) &#123; this.name = name; &#125; // 声明对象方法 hello() &#123; console.log(&#x27;我是&#x27;, this.name); &#125; test() &#123; console.log(&#x27;父类&#x27;); &#125; home() &#123; console.log(&#x27;地球&#x27;); &#125; // 使用static关键字声明静态属性，不能通过对象调用，只能通过类调用 static eat = &#x27;食物&#x27;; // 通过set关键字定义设置属性的方法 set age(age) &#123; console.log(&#x27;设置年龄&#x27;, age); &#125; // 通过get关键字定义获取属性的方法 get age() &#123; console.log(&#x27;读取年龄&#x27;); return 100; &#125;&#125;// 使用extends可以继承父类，自动拥有父类定义的属性和方法class Worker extends Human &#123; // 创建子类的对象方法 work() &#123; console.log(&#x27;工作&#x27;); &#125; // 重写父类的方法，默认调用的是子类重写的方法，使用super关键字调用父类的方法 test() &#123; console.log(&#x27;子类&#x27;); super.home(); &#125;&#125;let h = new Human(&#x27;人类&#x27;);h.hello();// 我是 人类console.log(h.name);// 人类console.log(h.eat);// undefinedconsole.log(Human.eat);// 食物let w = new Worker(&#x27;工人&#x27;);w.hello();// 我是 工人w.work();// 工作w.test();// 子类 地球h.age = 100;// 设置年龄 100h.age;// 读取年龄 3.15 数值扩展引入了二进制和八进制的新写法： js12console.log(0b100);// 4 二进制以0b开头，二进制100对应十进制4console.log(0o100);// 64 八进制以0o开头，八进制100对应十进制64 定义最小精度，其值接近于2.22×10^(-16)，即2.22乘以10的-16次方。 当无法准确的描述数值时，就会产生精度问题，比如无法通过二进制准确的表示0.1，再比如无法通过十进制表示1&#x2F;3，等等。 当两个数的差值小于Number.EPSILON时，就认为两个数值是相等的： js12345console.log(0.1 + 0.2 === 0.3);// falsefunction equal(left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;console.log(equal(0.1 + 0.2, 0.3));// true 检测数值是否是有限数： js12console.log(Number.isFinite(1));// trueconsole.log(Number.isFinite(1/0));// false 检测数值是否为NaN： js123console.log(Number.isFinite(1));// trueconsole.log(Number.isFinite(NaN));// falseconsole.log(Number.isFinite(null));// false 检测数值是否为整数： js12console.log(Number.isInteger(1));// trueconsole.log(Number.isInteger(1.1));// false 将字符串转为整数和浮点数： js12console.log(Number.parseInt(&#x27;123test456&#x27;));// 123console.log(Number.parseFloat(&#x27;0.123test456&#x27;));// 0.123 检测数值是整数、负数还是零： js123console.log(Math.sign(10));// 1console.log(Math.sign(0));// 0console.log(Math.sign(-10));// -1 将数值的小数部分抹掉： js1console.log(Math.trunc(1.1));// 1 3.16 数组扩展查找数组元素，返回找到的第一个元素： js1234let arr = [1,2,3,4,5]console.log(arr.find(e =&gt; e &gt; 1));// 2console.log(arr.find(e =&gt; e &gt; 5));// undefinedconsole.log(arr.find((e, i, array) =&gt; e &gt; 1));// 2 3.17 对象方法扩展判断两个值是否完全相等： js123console.log(Object.is(10, 10));// trueconsole.log(Object.is(NaN, NaN));// trueconsole.log(NaN === NaN);// false 对象的合并，当旧对象中有新对象中没有的时候，会进行合并，否则会直接覆盖： js123456789let oldObj = &#123; name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125;let newObj = &#123; name: &#x27;李四&#x27;, age: 18&#125;console.log(Object.assign(oldObj, newObj));// &#123;name: &#x27;李四&#x27;, sex: &#x27;男&#x27;, age: 18&#125; 操作原型对象： js12345678910let human = &#123; eat: &#x27;食物&#x27;&#125;let worker = &#123; work: &#x27;打工&#x27;&#125;console.log(worker.__proto__);// &#123;...&#125;Object.setPrototypeOf(worker, human);console.log(worker.__proto__);// &#123;eat: &#x27;食物&#x27;&#125;console.log(worker.__proto__ == Object.getPrototypeOf(worker));// true 3.18 模块化3.18.1 说明模块化是指将一个大的程序文件拆成许多小的文件，然后进行组合。 优势： 防止命名冲突：不同的模块之间可以使用相同名称的变量，彼此互不干扰。 代码复用：模块可以对外提供接口，相同的功能可以使用同一接口。 高维护性：模块之间独立运行，单个模块出现问题不会影响所有模块，模块支持单独升级。 模块化规范比较： CommonJSAMDCMDES6专用于服务器端，默认不支持在浏览器执行。 在服务器端使用，基于Node使用。在浏览器端使用，使用Browserify编译打包JS文件，这个工具也是JS常用的打包工具。专用于浏览器端，模块的加载时异步的。 在浏览器端使用，基于Require.js使用。专用于浏览器端，模块的加载时异步的，并且在模块使用时才会加载和执行。 在浏览器端使用，基于Sea.js使用。专用于浏览器端。 在浏览器端使用，使用Babel将ES6编译为兼容ES5的代码，使用Browserify编译打包JS文件。 3.18.2 导出方式使用export关键字将变量或方法导出。 分别导出，在JS文件中分别指定导出的变量或方法： test.js1234export let hello = &#x27;hello&#x27;;export function test() &#123; console.log(&#x27;test&#x27;);&#125; 统一导出，使用export关键字要导出的变量和方法集中导出： test.js12345let hello = &#x27;hello&#x27;;function test() &#123; console.log(&#x27;test&#x27;);&#125;export &#123;hello, test&#125; 统一导出提供的并不是对象，所以导出的不是对象的简写形式，而是导出的标记，可以认为是名称。 默认导出，将要导出的变量和方法封装为对象： test.js12345678let hello = &#x27;hello&#x27;;function test() &#123; console.log(&#x27;test&#x27;);&#125;export default &#123; hello, test&#125; 默认导出提供的是对象，导出的内容是对象的简写形式，这一点和统一导出不同。 3.18.3 导入方式使用import关键字将其他模块导出的变量或方法导入进来，同时设置script元素的type属性的值为module表示引入的是模块JS文件，并不是普通的JS文件。 全部导入，使用*将导出的全部变量和方法导入到页面： test.html12345&lt;script type=&quot;module&quot;&gt;import * as test from &#x27;./test.js&#x27;;console.log(test.hello);test.test();&lt;/script&gt; 命名导入，指定导入的变量和方法： test.html12345&lt;script type=&quot;module&quot;&gt;import &#123; hello, test &#125; from &#x27;./test.js&#x27;;console.log(hello);test();&lt;/script&gt; 使用命名导入可以使用分别导出和统一导出的变量和方法，不能直接使用默认导出的变量和方法。 默认导入，可以使用默认导出的变量和方法： test.html12345678&lt;script type=&quot;module&quot;&gt;// import * as test from &#x27;./test.js&#x27;;// console.log(test.default.hello);// test.default.test();import test from &#x27;./test.js&#x27;;console.log(test.hello);test.test();&lt;/script&gt; 如果默认导出的只有一个变量或方法，那么默认导入的就是该变量或方法，不需要通过对象获取。 如果有大量模块需要引入，可以新建JS文件用于引入模块，然后将此文件引入到HTML文件： app.js1import * as test from &#x27;./test.js&#x27;; 在HTML文件中引入JS文件： test.html1&lt;script src=&quot;./app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 4 ES74.1 数组增强判断数组是否包含某个数据： js123let nums = [1, 2, 3];console.log(nums.includes(1));// trueconsole.log(nums.includes(4));// false 4.2 指数操作符引入**指数运算符，用来实现幂运算，功能与Math.pow结果相同： js12console.log(2 ** 4);// 16console.log(Math.pow(2, 4));// 16 5 ES85.1 async和await5.1.1 async函数async函数会将返回值封装为Promise对象： js12345async function fun() &#123; console.log(&#x27;fun&#x27;);&#125;let result = fun();console.log(result);// Promise &#123;&lt;fulfilled&gt;: undefined&#125; 当函数执行成功时返回的是fulfilled状态的Promise对象，当函数执行失败时返回的是rejected状态的Promise对象。 当函数返回的是Promise对象时，不会再次封装，会将返回对象直接返回。 5.1.2 await表达式await表达式必须写在async函数中，并且await右侧的表达式一般为Promise对象。 await返回的是Promise成功的值，需要使用手动捕获Promise失败的值。 使用： js12345678910111213141516171819let promise = new Promise(function(resolve, reject) &#123; console.log(&#x27;promise&#x27;); if (true)&#123; resolve(&#x27;success&#x27;); &#125; else &#123; reject(&#x27;error&#x27;); &#125;&#125;);async function fun() &#123; console.log(&#x27;fun&#x27;); try &#123; let result = await promise; console.log(result); &#125; catch (e) &#123; console.log(e); &#125;&#125;let result = fun();console.log(result);// Promise &#123;&lt;fulfilled&gt;: undefined&#125; 5.2 对象方法扩展获取对象的属性名和属性值： js1234567891011let person = &#123; name: &#x27;test&#x27;, sex: &#x27;男&#x27;&#125;;console.log(Object.keys(person));// [&#x27;name&#x27;, &#x27;sex&#x27;]console.log(Object.values(person));// [&#x27;test&#x27;, &#x27;男&#x27;]console.log(Object.entries(person));// [Array(2), Array(2)]let map = Object.entries(person);// [&#x27;name&#x27;, &#x27;test&#x27;]// [&#x27;sex&#x27;, &#x27;男&#x27;]map.forEach(obj =&gt; console.log(obj)); 获取对象属性信息： js12345678let person = &#123; name: &#x27;test&#x27;, sex: &#x27;男&#x27;&#125;;// name: &#123;value: &#x27;test&#x27;, writable: true, enumerable: true, configurable: true&#125;// sex: &#123;value: &#x27;男&#x27;, writable: true, enumerable: true, configurable: true&#125;// [[Prototype]]: Objectconsole.log(Object.getOwnPropertyDescriptors(person)); 6 ES96.1 Rest和Spreadrest参数与spread扩展运算符在ES6中已经引入，不过ES6中只针对于数组。 使用rest参数： js1234567891011// function test(&#123;name, sex&#125;) &#123;// console.log(name);// console.log(sex);// &#125;function test(&#123;...args&#125;) &#123; console.log(args);&#125;test(&#123; name: &#x27;张三&#x27;, sex: &#x27;男&#x27;,&#125;); 使用spread扩展运算符： js1234567891011let attr1 = &#123; name: &#x27;张三&#x27;&#125;let attr2 = &#123; sex: &#x27;男&#x27;&#125;let attr3 = &#123; age: &#x27;18&#x27;&#125;let person = &#123;...attr1, ...attr2, ...attr3&#125;console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;, age: &#x27;18&#x27;&#125; 6.2 正则扩展6.2.1 捕获分组ES9允许使用符号?&lt;name&gt;获取捕获结果，可读性更强。 在ES9之前捕获结果，通过下标查看捕获分组，下标为0的元素是完整的匹配内容： js1234567var reg = /(123)(a.a)/g;var result;while(result = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // 123 a4a // 123 a5a console.log(result[1], result[2]);&#125; 在ES9之后捕获结果： js1234567var reg = /(?&lt;first&gt;123)(?&lt;last&gt;a.a)/g;var result;while(result = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // 123 a4a // 123 a5a console.log(result.groups.first, result.groups.last);&#125; 6.2.2 反向断言通过正则表达式的?=符号进行正向断言，根据后面的判断是否返回前面的数据： js1234let test = &#x27;测试123正向456断言&#x27;;let reg = /\\d+(?=正向)/;// 根据后面的内容是否正向，返回前面的数字let result = reg.exec(test);console.log(result[0]);// 123 通过正则表达式的?&lt;=符号进行反向断言，根据前面的判断是否返回后面的数据： js1234let test = &#x27;测试123反向456断言&#x27;;let reg = /(?&lt;=反向)\\d+/;// 根据前面的内容是否反向，返回后面的数字let result = reg.exec(test);console.log(result[0]);// 456 6.2.3 dotAll模式使用.匹配除回车外的任何单字符，如果使用了s就可以匹配包括回车在内的任何单字符： js123456789101112131415161718192021let test = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;这是第1个a标签&lt;/a&gt; &lt;p&gt;这是第1个p标签&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;这是第2个a标签&lt;/a&gt; &lt;p&gt;这是第2个p标签&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;`;var reg = /&lt;a&gt;(.*?)&lt;\\/a&gt;\\s+&lt;p&gt;(.*?)&lt;\\/p&gt;/g;// 使用之前的方式，通过\\s+过滤空格和换行，匹配两个标签中的内容var result;while (result = reg.exec(test)) &#123; console.log(result[1] + &#x27; &gt;&gt;&gt; &#x27; + result[2]);&#125;var reg = /&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/gs;// 使用dotAll模式，通过s让.包含任何单字符，匹配两个标签中的内容while (result = reg.exec(test)) &#123; console.log(result[1] + &#x27; &gt;&gt;&gt; &#x27; + result[2]);&#125; 7 ES107.1 创建对象通过二维数组创建对象： js12345let person = Object.fromEntries([ [&#x27;name&#x27;, &#x27;张三&#x27;], [&#x27;sex&#x27;, &#x27;男&#x27;]]);console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125; 通过Map创建对象： js12345let map = new Map();map.set(&#x27;name&#x27;, &#x27;张三&#x27;);map.set(&#x27;sex&#x27;, &#x27;男&#x27;);let person = Object.fromEntries(map);console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125; Object类的fromEntries()方法是entries()方法的反向操作。 7.2 字符串扩展新增支持清除字符串空格的方法： js123let str = &#x27; hello &#x27;;console.log(str.trimStart());// 清除左侧空格console.log(str.trimEnd());// 清除右侧空格 7.3 数组扩展将高维数组转为低维数组，支持设置向下转变的维度数目，默认向下转变1个维度： js12345var arr = [1,2,[3,4]];console.log(arr.flat());// [1, 2, 3, 4]var arr = [1,2,[3,4,[5,6]]];console.log(arr.flat());// [1, 2, 3, 4, [5, 6]]console.log(arr.flat(2));// [1, 2, 3, 4, 5, 6] 在map()方法的基础上，增加了flatMap()方法，用于将结果向下维度转换处理： js123var arr = [1,2];var result = arr.flatMap(item =&gt; [item * 10]);console.log(result);// [10, 20] 7.4 Symbol扩展支持在创建Symbol对象的时候传入描述内容： js12var s = Symbol(&#x27;测试&#x27;);console.log(s.description);// 测试 8 ES118.1 私有属性在属性前面添加#符号表示该属性是私有属性： js1234567891011class Person &#123; name; #age; constructor(name, age) &#123; this.name = name; this.#age = age; &#125;&#125;let p = new Person(&#x27;张三&#x27;, 18);console.log(p);// Person &#123;name: &#x27;张三&#x27;, #age: 18&#125;console.log(p.#age);// 报错 8.2 Promise扩展新增Promise的allSettled()静态方法，接收Promise数组作为入参，将结果封装为Promise返回，状态为成功，值为数组的每个Promise执行的状态和结果： js12345678910111213141516171819202122232425262728293031323334353637let p1result = false;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (p1result) &#123; resolve(&#x27;p1成功&#x27;); &#125; else &#123; reject(&#x27;p1失败&#x27;); &#125; &#125;, 100);&#125;);let p2result = true;let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (p2result) &#123; resolve(&#x27;p2成功&#x27;); &#125; else &#123; reject(&#x27;p2失败&#x27;); &#125; &#125;, 100);&#125;);// 方法永远返回成功Promise.allSettled([p1, p2]).then(function (value)&#123; console.log(&#x27;allSettled执行成功&#x27;); // &#123;status: &#x27;rejected&#x27;, reason: &#x27;p1失败&#x27;&#125; // &#123;status: &#x27;fulfilled&#x27;, value: &#x27;p2成功&#x27;&#125; value.forEach((result) =&gt; console.log(result));&#125;, function (error)&#123; console.log(&#x27;allSettled执行失败 &#x27; + error);&#125;);// 只要有一个失败，方法就返回失败Promise.all([p1, p2]).then(function (value)&#123; console.log(&#x27;all执行成功&#x27;); value.forEach((result) =&gt; console.log(result));&#125;, function (error)&#123; // all执行失败 p1失败 console.log(&#x27;all执行失败 &#x27; + error);&#125;); 和Promise的all()静态方法不同，allSettled()方法不论数组里的结果是否成功，始终返回成功，all()会在数组里的结果存在失败时，返回失败。 8.3 字符串扩展新增字符串matchAll()方法，用于正则表达式，其结果和正则表达式的exec()方法相同： js123456789101112131415161718var reg = /(123)(a.a)/g;// 使用match()方法var matchResult = &#x27;123a4a123a5a&#x27;.match(reg);console.log(matchResult);// [&#x27;123a4a&#x27;, &#x27;123a5a&#x27;]// 使用matchAll()方法var matchAllResult = &#x27;123a4a123a5a&#x27;.matchAll(reg);for (let r of matchAllResult) &#123; // [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] // [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined] console.log(r);&#125;// 使用matchAll()方法var execResult;while(execResult = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] // [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined] console.log(execResult);&#125; 8.4 可选链操作符使用?.可选链操作符可以代替繁琐的层级判断是否为空的操作： js12345678910111213function test(config) &#123; // 直接使用，如果不存在会报错 console.log(config.db.url); // 层级判断，存在才获取 console.log(config &amp;&amp; config.cache &amp;&amp; config.cache.url) // 简化操作，使用可选链操作符判断 console.log(config?.cache?.url)&#125;test(&#123; db: &#123; url: &#x27;192.168.1.10&#x27; &#125;&#125;); 8.5 模块化扩展在导入模块时支持动态导入，可以实现按需加载模块，即在用到某个模块时再导入，而不是在加载时全部导入，可以提高加载效率。 使用import()方法传入文件路径即可导入指定文件，返回Promise对象，该对象的值是文件对应的导出的对象： test.html123456789101112&lt;script type=&quot;module&quot;&gt;// 全部导入// import * as test from &#x27;./test.js&#x27;;// 动态导入let btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = function() &#123; import(&#x27;./test.js&#x27;).then(test =&gt; &#123; console.log(test.hello); test.test(); &#125;);&#125;&lt;/script&gt; 8.6 BigInt新增数据类型BigInt用于表示大整型数字： js123456789101112// 大整型数字使用字母n作为数字结尾let n = 1024n;console.log(n);// 1024nconsole.log(typeof n);// bigintconsole.log(BigInt(0));// 0n 支持将整型数字转为大整型数字，并且只支持转换整型数字// 使用大整型数字解决大数字运算，只支持大整型数字之间的运算，需要先将整型数字转为大整型数字let max = Number.MAX_SAFE_INTEGER;console.log(max + 1);// 9007199254740992console.log(max + 2);// 9007199254740992console.log(BigInt(max) + BigInt(1));// 9007199254740992nconsole.log(BigInt(max) + BigInt(2));// 9007199254740993n 8.7 绝对全局对象新增全局变量globalThis指向全局变量： js1console.log(globalThis);// Window &#123;...&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"多线程","slug":"C00-前端/C03-JS/001-基础/003-多线程","date":"2024-07-12T07:42:39.000Z","updated":"2025-06-21T08:57:46.966Z","comments":true,"path":"posts/20240712/154239/","permalink":"https://momashanhe.com/posts/20240712/154239/","excerpt":"摘要：本文学习了如何使用Web Work实现多线程的功能。","text":"摘要：本文学习了如何使用Web Work实现多线程的功能。 1 简介在JS中采用的是单线程机制，不需要考虑复杂的同步问题，但也无法同时处理两件任务，无法发挥计算能力。 为了满足多线程的需求，H5规范提供了JS多线程的实现，这种技术称为Web Work。 Web Work的作用就是为JS创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者在后台运行，主线程和Worker线程互不干扰，在Worker线程执行结束后会将结果返回给主线程。 Worker线程一旦创建成功就会运行，并且不会被主线程的交互动作打断，虽然有利于响应主线程的操作，但是长时间运行也会导致CPU资源的浪费，所以需要在使用后及时关闭Worker线程。 相比较在主线程执行函数，使用分线程函数会慢一些。分线程的优势是可以在不阻塞主线程的情况下，执行函数。 此外，使用Worker线程还有一些限制： DOM限制，Worker线程和主线程的this对象不一样，无法使用window对象，以及alert()等方法，只能使用navigator对象和location对象。 通信限制，Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 兼容限制，不是所有的浏览器都支持。 跨域限制，不支持跨域加载JS文件。 即使通过Web Worker技术，也不能修改DOM，只有主线程可以修改，所以JS单线程的本质并没有变化。 2 使用在主线程中使用构造函数创建Worker分线程，传入执行的JS文件： main.js1var worker = new Worker(&#x27;worker.js&#x27;); 在主线程中给Worker对象的onmessage属性绑定函数，用于接收Worker分线程的消息： main.js123worker.onmessage = function (event) &#123; console.log(&#x27;主线程接收分线程返回的数据: &#x27; + event.data);&#125; 在主线程中调用Worker对象的postMessage()方法，给Worker分线程传输参数： main.js1worker.postMessage(&#x27;I am main&#x27;); 在分线程要执行的JS文件中，使用onmessage属性接收主线程的信息，使用postMessage()方法给主线程传递结果： worker.js1234var onmessage = function(event) &#123; console.log(&#x27;主线程接收分线程返回的数据: &#x27; + event.data);&#125;postMessage(&#x27;I am worker&#x27;); 在使用Worker分线程后，需要及时关闭： 在主线程调用Worker对象的worker.terminate()方法关闭。 在分线程要执行的JS文件中调用close()方法关闭。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"高级","slug":"C00-前端/C03-JS/001-基础/002-高级","date":"2024-07-08T03:31:51.000Z","updated":"2025-06-21T09:32:45.069Z","comments":true,"path":"posts/20240708/113151/","permalink":"https://momashanhe.com/posts/20240708/113151/","excerpt":"摘要：本文总结了JS中易混淆的概念，并学习了JS的线程、事件、存储以及防抖和节流。","text":"摘要：本文总结了JS中易混淆的概念，并学习了JS的线程、事件、存储以及防抖和节流。 1 数据类型的判断1.1 typeof使用typeof关键字，得到字符串类型的返回结果： js12345678910// 基本类型console.log(typeof &#x27;123&#x27;);// stringconsole.log(typeof 123);// numberconsole.log(typeof false);// booleanconsole.log(typeof null);// objectconsole.log(typeof undefined);// undefined// 对象|数组|日期|包装类型，均返回objectconsole.log(typeof &#123;test:123&#125;);// object// 方法返回functionconsole.log(typeof function()&#123;&#125;);// function 凡是通过对象的方式创建的变量，其使用typeof得到的都是object字符串。 另外，基本数据类型中的null使用typeof判断也会得到object字符串。 1.2 instanceof使用instanceof关键字判断右侧显示调用的原型是否在左侧隐式调用的原型链上： js123456789101112131415161718192021222324252627// 基本类型，左侧非对象，没有原型链，直接返回falseconsole.log(&#x27;123&#x27; instanceof String);// falseconsole.log(123 instanceof Number);// falseconsole.log(false instanceof Boolean);// falseconsole.log(null instanceof Object);// falseconsole.log(undefined instanceof Object);// false// 对象返回trueconsole.log(&#123;test:123&#125; instanceof Object);// true// 数组返回trueconsole.log([1,2,3] instanceof Array);// true// 日期返回trueconsole.log(new Date() instanceof Date);// true// 包装类型返回trueconsole.log(new String(&#x27;123&#x27;) instanceof String);// trueconsole.log(new Number(123) instanceof Number);// trueconsole.log(new Boolean(false) instanceof Boolean);// true// 构造方法console.log(Object instanceof Function);// true Object.__proto__ == Function.prototypeconsole.log(Function instanceof Function);// true Function.__proto__ == Function.prototypeconsole.log(Object instanceof Object);// true Object.__proto__.__proto__ == Object.prototypeconsole.log(Function instanceof Object);// true Function.__proto__.__proto__ == Object.prototypefunction Func() &#123;&#125;var func = new Func();console.log(func instanceof Func);// true func.__proto__ == Func.prototypeconsole.log(func instanceof Object);// true func.__proto__.__proto__ == Object.prototypeconsole.log(Func instanceof Function);// true Func.__proto__ == Function.prototypeconsole.log(Func instanceof Object);// true Func.__proto__.__proto__ == Object.prototype 在创建对象时，会将显示调用赋值给隐式调用。在修改了显示调用的引用地址后，显示调用和隐式调用得到的原型对象将不再相同。 2 函数2.1 创建方式创建函数： js123function func() &#123; console.log(this);&#125; 创建匿名函数并赋值给变量： js123var func = function() &#123; console.log(this);&#125; 创建函数对象： js1var func = new Function(&quot;console.log(this);&quot;); 创建构造函数： js123function Func() &#123; console.log(this);&#125; 创建箭头函数： js1var func = () =&gt; &#123;console.log(this);&#125;; 2.2 调用方式创建函数并调用： js123456789101112131415161718// 创建函数function func() &#123; console.log(this);&#125;// 直接调用函数func();// 创建构造函数function Func() &#123; console.log(this);&#125;// 调用构造函数new Func();// 创建对象方法function Person() &#123; this.func = function() &#123;console.log(this);&#125;&#125;// 调用对象方法new Person().func(); 2.3 回调函数回调函数在定义以后不需要主动调用，当某个事件触发时才会调用。 常见的回调函数： 定时函数，包括使用setTimeout()方法和setInterval()方法传入的函数 DOM事件触发的函数，比如onclick()方法绑定的函数 AJAX请求回调函数 生命周期回调函数 3 this关键字任何函数本质上都是通过某个对象来调用的，所有函数内部都有一个this变量，它的值是调用函数的当前对象。 明确this的值： js123456789101112131415161718192021function func() &#123; console.log(this);&#125;func();// Window &#123;&#125; 直接调用函数，this指向window对象var func = new Function(&quot;console.log(this);&quot;);func();// Window &#123;&#125; 直接调用函数对象，this指向window对象function Func() &#123; console.log(this);&#125;var func = new Func();// Func &#123;&#125; 调用构造函数，this指向新创建的对象function Person() &#123; this.func = function() &#123;console.log(this);&#125;&#125;new Person().func();// Person &#123;&#125; 调用对象方法，this指向调用方法的对象var func = () =&gt; &#123;console.log(this);&#125;;func();// Window &#123;&#125; 调用箭头函数，this指向定义函数的环境var func = function() &#123; console.log(this);&#125;func.call(new String());// String &#123;&#x27;&#x27;&#125; 使用call和apply调用函数，this指向入参指定的对象console.log(this);// Window &#123;&#125; 在全局作用域中，this指向window对象 4 执行上下文和执行上下文栈4.1 执行上下文代码按生命周期分为两种： 全局代码：在全局任意位置有效 局部代码：仅在某段代码内有效，比如代码块、函数等，局部代码内可以使用全局代码 执行上下文分为全局执行上下文和函数执行上下文两种。 全局执行上下文： 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理： 将全局变量的声明提升，赋值为undefined，添加为window的属性 将全局函数添加为window的方法 将this对象赋值为window 开始执行全局代码 函数执行上下文： 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象 对局部数据进行预处理： 将传入的实参赋值到函数定义的实参，添加为执行上下文的属性 对函数的arguments内部属性赋值实参列表，添加为执行上下文的属性 将局部变量的声明提升，赋值为undefined，添加为执行上下文的属性 将函数内声明的函数添加为执行上下文的方法 将this对象赋值为调用函数的对象 开始执行函数体代码 在计算代码执行产生的上下文时，函数每次被调用都会生成一个函数执行上下文，在代码执行时会生成一个全局执行上下文。 4.2 执行上下文栈在创建执行上下文之前，JS引擎会创建一个栈来存储管理所有的执行上下文对象： 在确定全局执行上下文后，将其压入到栈中 在创建函数执行上下文后，将其压入到栈中 在当前函数执行完后，将栈顶的对象移除 在所有代码执行完后，栈中只剩下全局执行上下文 5 作用域和作用域链5.1 作用域作用域是某段代码所在的区域，使用目的是为了隔离变量，不同的作用域之间，同名变量不会有冲突，比如覆盖。 按照代码的声明周期可以将作用域分为三种： 全局作用域：全局代码区域 函数作用域：在函数中的代码区域 块作用域：在代码块中的区域，ES6之后才有这个概念 相对于上下文来说，作用域是静止的，在编写代码时就确定了，作用域的确定时间要早于上下文的创建时间。 在统计作用域的数量时，每个函数作为一个函数作用域，整个代码作为一个全局作用域。在ES6以后，每个代码块是一个块作用域。 5.2 作用域链作用域链是在发生函数嵌套时产生的，使用目的是为了查找变量，特别是当发生了变量冲突时确定变量的值。 在发生函数嵌套时，外层函数作为上级，内层函数作为下级，作用域链的查找方向是从下往上的。 6 闭包在发生函数嵌套时，并且内部函数引用了外部函数的变量或函数，就会在内部函数产生闭包： js12345678function outer() &#123; var num = 0; function inner() &#123; console.log(num); &#125; inner();&#125;outer(); 闭包是在创建函数执行上下文时产生的对象，作为内部函数的属性，封装了在内部函数中使用的外部函数的变量或函数。 使用闭包的流程： 第一步，执行内部函数定义时产生闭包： 第二步，在执行内部函数时，会将闭包对象作为函数执行上下文的变量： 闭包的作用： 延长局部变量的生命周期，局部变量在外部函数执行完后, 仍然存活在内存中 允许在外部函数之外，通过内部函数修改外部函数的局部变量 闭包的生命周期： 在执行内部函数定义时产生，即在创建内部函数执行上下文时产生 在内部函数被视为垃圾对象时死亡，即不存在指向内部函数的变量引用 闭包会产生内存泄漏的可能，外部函数执行后，局部变量未能被马上释放： js12345678910function outer() &#123; var num = 0; function inner() &#123; console.log(++num); &#125; return inner;&#125;var inner = outer();inner();// 1inner();// 2 解决办法： 尽量少用闭包 在使用闭包后及时手动将内部函数的引用清空，释放局部变量：js1234567891011function outer() &#123; var num = 0; function inner() &#123; console.log(++num); &#125; return inner;&#125;var inner = outer();inner();// 1inner = null;inner();// 报错 7 对象7.1 创建创建对象的几种方式： 直接创建：js12345678var obj = &#123; name: &#x27;张三&#x27;, setName: function(name) &#123; this.name = name; &#125;&#125;;obj.setName(&#x27;李四&#x27;);console.log(obj);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过Object构造函数创建：js1234567var obj = new Object();obj.name = &#x27;张三&#x27;;obj.setName = function(name) &#123; this.name = name;&#125;obj.setName(&#x27;李四&#x27;);console.log(obj);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过工厂模式创建：js123456789101112function createPerson(name) &#123; var person = &#123; name: name, setName: function(name) &#123; this.name = name; &#125; &#125;; return person;&#125;var person = createPerson(&#x27;张三&#x27;);person.setName(&#x27;李四&#x27;);console.log(person);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过自定义构造函数创建，推荐：js123456789function Person(name) &#123; this.name = name; this.__proto__.setName = function(name) &#123; this.name = name; &#125;;&#125;var person = new Person(&#x27;张三&#x27;);person.setName(&#x27;李四&#x27;);console.log(person);// Person &#123;name: &#x27;李四4&#x27;&#125; 7.2 继承当需要在一个类中使用另一个类的属性和方法时，将没有相关属性和方法的类称为子类，将具有相关属性和方法的类称为父类，子类的属性和方法继承自父类。 使用原型链继承： js123456789101112131415161718// 定义父类function Parent() &#123; this.parent = &#x27;parent property&#x27;;&#125;// 定义子类function Child() &#123; this.child = &#x27;child property&#x27;;&#125;// 将父类的对象赋值给子类的显示调用的原型，这样子类的对象就可以通过隐式调用的原型访问父类定义的属性和方法Child.prototype = new Parent()// 子类显示调用的原型指向了父类的对象，其constructor属性也指向了父类的构造方法，所以还需要改为子类的构造方法Child.prototype.constructor = Child// 创建子类的实例var child = new Child()// 通过子类调用父类的方法console.log(child.parent);// parent property// 通过子类调用自身的方法console.log(child.child);// child property 使用父类的构造方法继承： js12345678910111213// 定义父类function Parent(name) &#123; this.name = name;&#125;// 定义子类function Child(name) &#123; // 调用父类的构造方法，将父类的属性设置到子类的对象上 Parent.call(this, name);&#125;// 创建子类的实例var child = new Child(&#x27;张三&#x27;)// 查看子类的属性console.log(child.name);// 张三 组合继承，同时使用原型链和构造函数： js1234567891011121314151617181920// 定义父类function Parent() &#123; this.parent = &#x27;parent property&#x27;;&#125;// 定义子类function Child() &#123; this.child = &#x27;child property&#x27;; // 调用父类的构造方法，将父类的属性设置到子类的对象上 Parent.call(this, name);&#125;// 将父类的对象赋值给子类的显示调用的原型，这样子类的对象就可以通过隐式调用的原型访问父类定义的属性和方法Child.prototype = new Parent()// 子类显示调用的原型指向了父类的对象，其constructor属性也指向了父类的构造方法，所以还需要改为子类的构造方法Child.prototype.constructor = Child// 创建子类的实例var child = new Child()// 通过子类调用父类的方法console.log(child.parent);// parent property// 通过子类调用自身的方法console.log(child.child);// child property 8 线程进程： 进程是程序的一次执行，是程序在计算机中运行的实体。 进程是系统进行资源分配的最小单位，每个进程都有各自独立的内存空间，各个进程互不干扰。 线程： 线程是进程的子任务，是进程实际的运作单位。 线程是CPU调度的最小单位，线程有独立的栈空间和局部变量，但没有独立的内存空间，一个进程内的多个线程共享进程的存储空间。 JS采用的是单线程机制，作为浏览器脚本语言，主要用途是与用户互动以及操作DOM，使用单线程不需要考虑复杂的同步问题。 使用多线程的系统可以更好的利用CPU资源，提高CPU的运行效率，但也会因为需要频繁创建销毁线程导致占用了一部分性能。 线程池： 线程池可以复用线程，减少线程创建和销毁的次数，减少了性能浪费，提高程序的运行效率。 线程池可以控制线程的最大并发数，避免过高的并发量导致系统卡死。 9 事件定时器的调用问题： js1234567891011var time = Date.now();setTimeout(function(name) &#123; console.log(&#x27;1秒后打印 &#x27; + name); console.log(Date.now() - time);&#125;, 1000, &#x27;test&#x27;);setTimeout(function(name) &#123; console.log(&#x27;2秒后打印 &#x27; + name); console.log(Date.now() - time);&#125;, 2000, &#x27;test&#x27;);for(var i = 0; i &lt; 2000000000; i++) &#123;&#125; 第一个定时函数不是在1秒后执行的，第二个定时函数不是在2秒后执行的，并且两个定时函数是同时执行的。 这是因为JS是单线程的，定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行。 JS引擎执行基本流程： 执行初始化代码，包括对变量赋值、执行普通方法、执行代码、设置定时器、绑定监听事件、发送请求 执行回调函数，包括定时器回调、事件回调、请求回调 事件管理模块： 定时模块，处理定时任务绑定的回调函数 DOM模块，处理DOM元素绑定的回调函数 AJAX模块，处理请求返回触发的回调函数 事件管理模型运转流程： 在执行初始化代码时，将事件回调函数交给对应的模块管理 当事件发生时，管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后，才会遍历读取回调队列中的回调函数执行 10 存储WebStorage是一种新的浏览器存储机制，旨在克服传统Cookie存储方式的一些限制。 WebStorage包括LocalStorage和SessionStorage。 通用的API： setItem(key, value)：保存数据，如果键名已存在，则更新其对应的值。 getItem(key)：根据键名读取数据。 removeItem(key)：根据键名删除数据。 clear()：删除所有数据。 key(index)：获取某个索引位置的键名。 10.1 LocalStorage即本地存储，数据是持久化的，即使关闭浏览器窗口或浏览器后，数据也不会消失，除非主动删除。 存储数据大小通常为5MB，并且只能存储字符串类型的数据，复杂类型的需要转为JSON字符串存储。 适用于需要长期存储的数据，例如缓存静态资源、前端数据库存储介质等。 10.2 SessionStorage即会话存储，数据是非持久化的，仅在本次会话期间（URL不变）有效，关闭浏览器窗口后数据会被销毁。 存储数据大小通常为5MB，并且只能存储字符串类型的数据，复杂类型的需要转为JSON字符串存储。 适用于存储会话级别的信息，例如用户在表单中输入的内容，以便在页面刷新后能够恢复。 11 防抖和节流11.1 防抖确保在指定的时间间隔内，无论连续触发了多少次事件，只有最后一次事件会在该间隔结束后执行。 防抖的应用场景： 在输入内容时触发的检查，或者在输入内容时触发的显示建议。 在调整窗口大小时触发的统计请求。 防抖的简单实现： js1234567891011121314151617// 选中元素const username = document.getElementById(&#x27;username&#x27;);// 绑定事件username.addEventListener(&#x27;input&#x27;, debounce(work, 300));// 防抖处理function debounce(func, wait) &#123; let timeout; return function (event) &#123; const context = this; clearTimeout(timeout); timeout = setTimeout(() =&gt; func.call(context, event), wait); &#125;;&#125;// 业务逻辑function work(event) &#123; console.log(&#x27;防抖调用请求&#x27;);&#125; 11.2 节流确保在指定的时间间隔内，无论触发了多少次事件，只有第一次事件会被执行，后续事件在这个间隔内都不会执行。 防抖的应用场景： 在点击按钮时触发的重复请求。 在移动鼠标时触发的高频请求。 节流的简单实现： js123456789101112131415161718// 绑定事件window.addEventListener(&#x27;scroll&#x27;, throttle(work, 300));// 节流处理function throttle(func, wait) &#123; let lastTime = 0; return function (event) &#123; const context = this; const now = Date.now(); if (now - lastTime &gt;= wait) &#123; lastTime = now; func.call(context, event); &#125; &#125;;&#125;// 业务逻辑function work(event) &#123; console.log(&#x27;节流调用请求&#x27;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"入门","slug":"C00-前端/C03-JS/001-基础/001-入门","date":"2024-06-27T07:59:26.000Z","updated":"2025-07-01T01:41:01.426Z","comments":true,"path":"posts/20240627/155926/","permalink":"https://momashanhe.com/posts/20240627/155926/","excerpt":"摘要：本文介绍了JS中常用的概念、基础语法、对象以及两种对象模型。","text":"摘要：本文介绍了JS中常用的概念、基础语法、对象以及两种对象模型。 1 简介1.1 是什么JS全称：JavaScript。 JS是一种脚本语言，命名和Java没有任何关系，用于给网页设置行为，比如点击、弹窗等等。 官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn 1.2 发展历史JavaScript是由网景公司在1995年发明的，起初命名为LiveScript，后来由于Sun公司的介入更名为了JavaScript。 在1996年，微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript。 于是在市面上存在两个版本的JavaScript，网景公司的JavaScript和微软的JScript，为了确保不同的浏览器上运行的JavaScript标准一致，几个公司定制了通用标准，名命为ECMAScript。 在一般情况下，会将这ECMAScript和JavaScript认作同一个意思，实际上JavaScript的含义要大一些，一个完整的JavaScript实现应该由以下三个部分构成： ECMAScript：通用的标准，通常简写为ES。 DOM：文档对象模型，操作网页。 BOM：浏览器对象模型，操作浏览器。 严格来说JavaScript是指ECMAScript，本身不包含BOM和DOM，因为JavaScript运行在浏览器上，所以浏览器提供了BOM和DOM。 2 基础2.1 编写位置因为JS是运行在浏览器中的，因此需要在网页中编写JS代码。 和CSS类似，JS也有三种位置可以选择。 2.1.1 行内脚本直接写在元素内部，通过一些特殊的交互属性设置交互行为。 示例： hello.html1&lt;button onclick=&quot;alert(&#x27;点击测试&#x27;);&quot;&gt;按钮&lt;/button&gt; 这种方式使用简单，但是功能比较少，并且和网页的结构耦合，不能体现出结构和行为分离的思想，也不利于维护，不建议使用这种方式。 使用alert()函数可以将传入的参数通过弹窗显示在页面上。 2.1.2 内部脚本将JS提取出来，写在页面内部的script元素中。 示例： hello.html123&lt;script type=&quot;text/javascript&quot;&gt;alert(&#x27;测试&#x27;);&lt;/script&gt; 理论上可以将script元素放在页面的任何位置，建议放到head元素中。另外，也可以省略type属性。 和行内样式相比，这种方式编写的结构和行为分离，样式也能复用，但也没有做到完全分离。 2.1.3 外部脚本将JS进一步提取，写在单独的JS文件中，在HTML页面中使用元素引用外部的JS文件。 创建后缀为.js格式的JS文件： hello.js1alert(&#x27;测试&#x27;); 在HTML页面的head元素中引用CSS文件： hello.html1&lt;script src=&quot;./hello.js&quot;&gt;&lt;/script&gt; 这种方式可维护高，并且做到了结构和行为分离，也能被其他页面复用，建议使用这种方式。 2.2 大小写敏感JavaScript是严格区分大小写的，在编写代码是要注意。 2.3 注释JavaScript的注释分为单行注释和多行注释： 单行注释：js12// 注释内容alert(&#x27;测试&#x27;); 多行注释：js12/* 注释内容 */alert(&#x27;测试&#x27;); 3 语法3.1 标识符所谓标识符，就是指变量、函数、属性的名字，以及函数的参数。 标识符可以是按照下列格式规则组合起来的一或多个字符： 第一个字符必须是字母、下划线_或美元符号$。 其他字符可以是字母、下划线、美元符号或数字。 按照惯例，ECMAScript标识符采用驼峰命名法，但是JavaScript中的标识符不能是关键字和保留字符。 关键字： function void return this new with var instanceof typeof switch case default if else do while for in continue break try catch throw finally delete debugger true false null 保留字符： import export package public protected private interface class enum extends implements super let yield static const 其他不建议使用的标识符： synchronize volatile abstract final native transient float double long int short byte char boolean throws arguments eval goto undefined encodeURI decodeURI decodeURIComponent encodeURICOmponent isFinite isNaN parseFloat parseInt NaN Number String Boolean Object Date Array JSON RegExp Infinity Function Math Error RangeError SyntaxError ReferenceError TypeError EvalError URIError 3.2 数据类型数据类型决定了一个数据的特征，比如123和&#39;123&#39;，直观上看这两个数据都是123，但实际上前者是一个数字，而后者是一个字符串。 对于不同的数据类型在进行操作时会有很大的不同。JavaScript中一共有五种基本数据类型： 字符串型（String） 数值型（Number） 布尔型（Boolean） null型（Null） undefined型（Undefined） 这五种之外的类型都称为Object，所以总的来看JavaScript中共有六种数据类型。 使用typeof关键字检查数据可以得到数据的类型，返回结果是字符串类型： 使用typeof 字符串判断会返回string 使用typeof 数值判断会返回number 使用typeof 布尔型判断会返回boolean 使用typeof null判断会返回object 使用typeof undefined判断会返回undefined 3.2.1 String在JavaScript中字符串使用String类型表示，都需要使用引号引起来，可以使用单引号，也可以使用双引号，但必须成对匹配，不能混搭使用。 在某些情况下，如果想要将特殊的字符作为字符串，需要使用转义字符\\，也可以使用HTML中的实体： 使用&amp;lt;表示&lt;，使用&amp;gt;表示&gt; 使用\\&#39;表示&#39;，使用\\&quot;表示&quot; 使用\\n表示换行符 使用\\t表示制表符，可以实现缩进的效果 使用\\\\表示\\ 转换为String有三种方式： 使用toString()方法：js123456789var i = 1;alert(typeof i);// numberalert(typeof i.toString());// stringvar m = null;alert(m.toString());// 页面报错，Null类型的变量不能调用方法alert(typeof m.toString());// 页面报错，Null类型的变量不能调用方法var n = undefined;alert(n.toString());// 页面报错，Undefined类型的变量不能调用方法alert(typeof n.toString());// 页面报错，Undefined类型的变量不能调用方法 使用String()方法：js123456789var i = 1;alert(typeof i);// numberalert(typeof String(i));// stringvar m = null;alert(String(m));// nullalert(typeof String(m));// stringvar n = undefined;alert(String(n));// undefinedalert(typeof String(n));// string 拼接字符串：js123456789var i = 1;alert(typeof i);// numberalert(typeof i + &#x27;1&#x27;);// stringvar m = null;alert(m + &#x27;&#x27;);// nullalert(typeof m + &#x27;&#x27;);// stringvar n = undefined;alert(n + &#x27;&#x27;);// undefinedalert(typeof n + &#x27;&#x27;);// string 3.2.2 Number在JavaScript中所有的数值都是Number类型，包括整数和浮点数： 使用Number.MAX_VALUE表示数值的最大值，使用Number.MIN_VALUE表示数值大于0的最小值。 使用Infinity表示超出数值最大值的正无穷，使用-Infinity表示负无穷。 使用NaN表示非数字的数值，即Not a number。 在对Infinity和-Infinity以及NaN使用typeof判断时，也能得到number的结果。 有三个方法可以把变量转换为数值： 使用Number()方法可以用来将变量转换为数值：js123456789101112131415var i = &#x27;1&#x27;;alert(typeof i);// stringalert(typeof Number(i));// numbervar a = true;alert(Number(a));// 1 true会返回1，false会返回0alert(typeof Number(a));// numbervar x = &#x27;1x&#x27;;alert(Number(x));// NaN 非数值字符串会返回NaNalert(typeof Number(x));// numbervar m = null;alert(Number(m));// 0 null会返回0alert(typeof Number(m));// numbervar n = undefined;alert(Number(n));// NaN undefined会返回NaNalert(typeof Number(n));// number 使用parseInt()方法可以用来将字符串转换为整数：js123456789101112var i = &#x27;1&#x27;;alert(typeof i);// stringalert(typeof parseInt(i));// numbervar f = &#x27;1.5&#x27;;alert(parseInt(f));// 1 开头为数值的字符串会返回开头的整数部分，开头非数值的字符串会返回NaNalert(typeof parseInt(f));// numbervar x = &#x27;1x&#x27;;alert(parseInt(x));// 1 开头为数值的字符串会返回开头的整数部分，开头非数值的字符串会返回NaNalert(typeof parseInt(x));// numbervar b = false;alert(parseInt(b));// NaN 非字符串会先转为字符串，开头非数值的字符串会返回NaNalert(typeof parseInt(b));// number 使用parseFloat()方法可以用来将字符串转换为浮点数：js123456789var i = &#x27;1.5&#x27;;alert(typeof i);// stringalert(typeof parseFloat(i));// numbervar x = &#x27;1.5x&#x27;;alert(parseFloat(x));// 1.5 开头为数值的字符串会返回开头的浮点数部分，开头非数值的字符串会返回NaNalert(typeof parseFloat(x));// numbervar b = false;alert(parseFloat(b));// NaN 非字符串会先转为字符串，开头非数值的字符串会返回NaNalert(typeof parseFloat(b));// number 在对浮点数进行计算时，可能会得到一个不精确的结果，所以在处理浮点数的运算时，需要使用特殊的方式保证得到的结果尽量精确，这里以后再说。 3.2.3 Boolean在JavaScript中使用Boolean类型表示布尔型的数据，其取值只有true和false两种。 使用Boolean()方法可以用来将变量转换为布尔值： js123456789101112var i = NaN;alert(Boolean(i));// false 非NaN且非0的数值会返回false，正数和负数会返回true，Infinity和-Infinity也会返回truealert(typeof Boolean(i));// booleanvar x = &#x27;&#x27;;alert(Boolean(x));// false 空字符串会返回false，非空字符串会返回truealert(typeof Boolean(x));// booleanvar m = null;alert(Boolean(m));// false null会返回falsealert(typeof Boolean(m));// booleanvar n = undefined;alert(Boolean(n));// false undefined会返回falsealert(typeof Boolean(n));// boolean 3.2.4 Null使用Null表示空对象。 可以显示的将对象赋值为null来强制将对象设置为Null类型： js123var person = null;alert(person);// nullalert(typeof person);// object 3.2.5 Undefined使用Undefined表示声明但未赋值的变量。 js123var person;alert(person);// undefinedalert(typeof person);// undefined 3.3 变量变量的作用是给某一个值或对象标注名称。 使用var关键字声明变量： js1var i; 对声明的变量进行赋值： js1i = 1; 在声明变量时赋值： js1var i = 1; 支持对多个变量同时声明和赋值： js12var x, y, z = &#x27;z&#x27;;var m = 1, n = 2, l = 3; 3.3.1 重复声明JavaScript允许对变量进行重复声明和赋值，也允许声明为不同的数据类型： js12var i = 1;var i = &#x27;i&#x27;; 在ES6以后，还可以使用let声明变量： js1let i = 1; 通过var声明的变量称为全局变量，支持修改值和类型，支持重复声明。通过let声明的变量称为局部变量，局部变量支持修改值和类型，但不支持重复声明，建议在代码块中使用。 3.3.2 常量在ES6以后，使用const声明常量： js1const i = 1; 和var与let声明的变量相比，常量一经声明和赋值，就不再支持修改值和类型，也不支持重复声明。 3.4 运算符通过运算符可以对一个或多个值进行运算，并获取运算结果。 优先级： . [] new () ++ -- ! ~ * / % + - < >> >>>>>= &= ^= |= , 3.4.1 算数运算符在JavaScript中提供了以下几种算数运算符： 使用+进行加法或拼接运算，如果拼接的是一个字符串，会将计算结果转为字符串 使用-进行减法运算，如果涉及数值，会将结果转为数值 使用*进行乘法运算，如果涉及数值，会将结果转为数值 使用/进行除法运算，如果涉及数值，会将结果转为数值 使用%进行取模运算 自增和自减运算符： 使用++进行自增运算，根据运算符位置分为前置++i和后置i++：js1234var i = 0;alert(++i);// 1 前置获取的是自增后的值alert(i++);// 1 后置获取的是自增前的值alert(i);// 2 使用--进行自增运算，根据运算符位置分为前置--i和后置i--：js1234var i = 2;alert(--i);// 1 前置获取的是自减后的值alert(i--);// 1 后置获取的是自减前的值alert(i);// 0 3.4.2 逻辑运算符在JavaScript中提供了以下三种逻辑运算符： 使用!表示逻辑非，用于对布尔值进行取反，对于非布尔值的变量会先将其转换为布尔值再取反。 使用&amp;&amp;表示逻辑与，只有两个值都为true时，整个运算为true，返回第二个值。该运算符属于短路与，当第一个值为false时，整个运算为false，返回第一个值，不会判断第二个值。 使用||表示逻辑或，只有两个值都为false时，整个运算为false，返回第二个值。该运算符属于短路或，当第一个值为true时，整个运算为true，返回第一个值，不会判断第二个值。 3.4.3 赋值运算符在JavaScript中使用=进行赋值运算，可以使用简写： 使用+=先计算后赋值，i += 5等同i = i + 5 使用-=先计算后赋值，i -= 5等同i = i - 5 使用*=先计算后赋值，i *= 5等同i = i * 5 使用/=先计算后赋值，i /= 5等同i = i / 5 使用%=先计算后赋值，i %= 5等同i = i % 5 3.4.4 比较运算符通过比较运算符可以比较两个变量的大小关系： 使用&gt;大于号判断左侧的变量是否大于右侧的变量，成立返回true，否则返回false。 使用&lt;小于号判断左侧的变量是否小于右侧的变量，成立返回true，否则返回false。 使用==等号判断两侧的变量是否相等，如果类型不一样，会先进行自动类型转换再比较，相等返回true，否则返回false。 使用===全等号判断两侧的变量是否相等，相等返回true，否则返回false。不会进行自动类型转换。 使用!=不等号判断两侧的变量是否不等，如果类型不一样，会先进行自动类型转换再比较，不等返回true，否则返回false。 使用!==不全等号判断两侧的变量是否不等，不等返回true，否则返回false。不会进行自动类型转换。 对于非数值的变量进行比较判断时，会将变量转换为数值再比较，但当两侧的变量都是字符串时，会根据字符串的Unicode编码进行比较。 3.4.5 条件运算符条件运算符也称为三元运算符，语法： js1条件表达式?语句1:语句2; 运算逻辑： 条件运算符在执行时，首先对条件表达式进行求值。 如果该值为true，则执行语句1，并返回执行结果。如果该值为false，则执行语句2，并返回执行结果。 如果条件表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。 3.4.6 移位运算符移位运算符一般用于数值类型的变量，作用在数值补码的所有位，按位运算： 使用&amp;进行按位与运算，两个数值的相对位都为1，结果的对应位为1，否则结果的对应位为0 使用|进行按位或运算，两个数值的相对位都为0，结果的对应位为0，否则结果的对应位为1 使用^进行按位异或运算，两个数值的相对位不相同，结果的对应位为1，否则结果的对应位为0 使用~进行按位非运算，对数值的每位都进行反转 使用&lt;&lt;进行带符号左移运算，每位左移，右边补0。 使用&gt;&gt;进行带符号右移运算，每位右移，左边补0，符号位使用原来的。 使用&gt;&gt;&gt;进行无符号右移运算，每位右移，左边补0，符号位补0。 移位运算改变的是数值的补码。对于正数来说，数值的原码是其补码。对于负数来说，数值的反码+1是其补码。 3.5 语句和代码块表达式和运算符类似于单词和短语，语句是一条完整的命令，通常使用;结尾。 可以使用&#123;&#125;将多条语句包裹起来，称为代码块，只具有分组和排版的作用，没有其他意义。 3.6 条件语句3.6.1 if-else语句如果if中的条件成立，返回布尔值为true，则执行if后面代码块里的操作语句，否则执行else后面代码块里的操作语句： js12345if (条件表达式) &#123; 条件成立的操作&#125; else &#123; 条件不成立的操作&#125; 在if和else后面的代码块中，支持嵌套其他语句，如果嵌套的还是if-else语句，可以简写： js1234567if (条件表达式1) &#123; 条件1成立的操作语句&#125; else if (条件表达式2) &#123; 条件1不成立但条件2成立的操作语句&#125; else &#123; 条件1和条件2都不成立的操作语句&#125; 3.6.2 switch-case语句也称为条件分支语句，会将switch后面的值同每个case后面的值相比较，相等就执行case后面的操作语句： js1234567891011121314switch (值) &#123; case 值1: 操作语句1 break; case 值2: 操作语句2 break; case 值3: 操作语句3 break; default: 操作语句 break;&#125; 其中的break用于终止判断，如果没有break会在执行完当前case的操作语句后，继续判断后面case的值，直到遇到break或者判断结束。 如果所有switch的值和case后面的值都不相等，则执行default后面的操作语句。 3.7 循环语句不管使用那种循环语句，都需要在适当位置跳过循环和终止循环： 跳过循环：跳过本次循环，不执行后面的操作语句，直接进行条件判断，进行下一次循环，使用continue实现，一般在条件语句中使用：js1234567循环操作语句代码块 &#123; 操作语句1 if (条件表达式) &#123; continue; &#125; 操作语句2&#125; 终止循环：跳出循环，终止整个循环的执行，执行循环后面的代码，使用break实现，一般在条件语句中使用：js1234567循环操作语句代码块 &#123; 操作语句1 if (条件表达式) &#123; break; &#125; 操作语句2&#125; 3.7.1 while语句如果while后面的条件成立，则执行代码块中的操作语句，执行后重复判断是否成立，如果成立，则重复执行操作语句，只有当不成立时才终止循环： js123while (条件表达式) &#123; 条件成立的操作语句&#125; 还可以使用do-while语句，这种方式会先执行操作语句，然后再循环判断条件是否成立，以及循环执行操作语句，最终终止循环： js123do &#123; 条件成立的操作语句&#125; while (条件表达式) 相比较而言，while语句会先判断再执行，do-while语句会先执行再判断，能够保证至少执行一次操作语句。 但不管使用那种循环语句，都需要做好终止循环的判断逻辑，否则会导致死循环，严重情况会导致系统没有足够的资源而崩溃。 3.7.2 for语句使用for语句可以更加明显的设置循环终止条件，但因此也显得比较繁琐： js123for(初始化语句; 条件表达式; 更新语句) &#123; 条件成立的操作语句&#125; 先执行初始化语句，可以省略，将初始化语句放在for循环前面执行。然后判断条件是否成立，可以省略，但需要在操作语句中控制终止循环的条件，类似while语句，否则会导致死循环。如果条件成立，会执行操作语句，否则终止循环。在操作语句执行结束后，执行更新语句，对循环条件更新，并循环判断条件是否成立，如果成立则循环执行操作语句，否则终止循环。 除了for语句代码块中的操作语句外，其他三个部分都是可以省略的，省略后就类似while语句了，需要手动控制循环。 3.8 嵌套循环循环语句支持嵌套，在一个循环语句中支持嵌套另一个循环语句。 使用continue和break可以处理当前循环语句的循环逻辑，如果想处理上层循环语句的循环逻辑，需要配合label标签使用： js123456789101112label1:for(初始化语句; 条件表达式; 更新语句) &#123; 循环1的操作语句 label2: for(初始化语句; 条件表达式; 更新语句) &#123; 循环2的操作语句 for(初始化语句; 条件表达式; 更新语句) &#123; 循环3的操作语句 break label1; &#125; &#125;&#125; 使用label给循环打标签，在continue和break后面使用标签控制要操作的循环。 示例： js123456789101112131415161718192021222324252627282930313233343536373839404142// 大学数组var universities = [&#x27;Peking University&#x27;, &#x27;Tsinghua University&#x27;];// 学院数组var colleges = [&#x27;College of Foreign Languages&#x27;, &#x27;College of Mathematics&#x27;, &#x27;College of Software&#x27;];// 专业数组var departments = [];departments[0] = [&#x27;English&#x27;, &#x27;French&#x27;, &#x27;Russian&#x27;];departments[1] = [&#x27;Statistics&#x27;];departments[2] = [&#x27;Software Engineering&#x27;];// 循环大学的标签，命名规范同标识符university:// 循环遍历大学for(let l = 0; l &lt; universities.length; l++) &#123; // 循环学院的标签 college: // 循环遍历学院 for(let m = 0; m &lt; colleges.length; m++) &#123; // 循环专业的标签，因为默认continue和break处理的是当前循环，所以这个标签可以省略 department: // 循环遍历专业 for(let n = 0; n &lt; departments[m].length; n++) &#123; // 如果是英语专业则进行提示 if (departments[m][n] == &#x27;Russian&#x27;) &#123; alert(universities[l] + &#x27;-&#x27; + colleges[m] + &#x27;-&#x27; + departments[m][n]); // 跳过遍历专业，等同于不使用标签 // continue department; // 跳过遍历学院 // continue college; // 跳过遍历大学 continue university; // 终止遍历专业，等同于不使用标签 // break department; // 终止遍历学院 // break college; // 终止遍历大学 // break university; &#125; // 记录已遍历的专业 console.log(universities[l] + &#x27;-&#x27; + colleges[m] + &#x27;-&#x27; + departments[m][n]); &#125; &#125;&#125; 使用console.log()可以将传入的参数打印到页面的控制台上。 4 对象4.1 定义JavaScript中的数据类型有六种，包括五种基本数据类型和一种引用数据类型。 五种基本数据类型： String字符串 Number数值 Boolean布尔值 Null空值 Undefined未定义 使用Object对象来表示引用类型的数据，这是一种复合的数据类型，可以保存多个不同数据类型的属性。 4.2 使用创建对象有两种方式： 先创建，然后对属性赋值：js1234567var student = new Object();student.name = &#x27;张三&#x27;;student.sex = &#x27;男&#x27;;// 不能赋值特殊的属性名// student.&#x27;1 2 3&#x27; = 123;// 可以赋值特殊的属性名student[&#x27;1 2 3&#x27;] = 123; 在创建时对属性赋值：js12345var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;; 访问对象的属性： js12345678910var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;;console.log(student.name);// 张三// 不能访问特殊的属性名// console.log(student.&#x27;1 2 3&#x27;);// 可以访问特殊的属性名console.log(student[&#x27;1 2 3&#x27;]);// 123 删除对象属性： js123456789var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;;console.log(student);// &#123; &#x27;name&#x27;: &#x27;张三&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;1 2 3&#x27;: 123 &#125;delete student[&#x27;name&#x27;];delete student[&#x27;1 2 3&#x27;];console.log(student);// &#123; &#x27;sex&#x27;: &#x27;男&#x27; &#125; 在JavaScript中，对象的属性可以是任意类型的数据，包括对象的属性时另一个对象： js123456789var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;student.friend = &#123; name:&#x27;李四&#x27;, sex:&#x27;男&#x27;&#125;;console.log(student);// &#123; &#x27;name&#x27;: &#x27;张三&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;friend&#x27;: &#123; &#x27;name&#x27;: &#x27;李四&#x27;, &#x27;sex&#x27;: &#x27;男&#x27; &#125; &#125; 可以通过in关键字判断对象是否存在指定属性： js123456var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;console.log(student.age);// undefinedconsole.log(&#x27;age&#x27; in student);// false 可以使用for-in语句循环遍历对象的属性： js12345678var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;for(var attr in student) &#123; console.log(&#x27;属性名 &#x27; + attr); console.log(&#x27;属性值 &#x27; + student[attr]);&#125; 4.3 堆栈JavaScript在运行时数据是保存到栈内存和堆内存当中的。简单来说栈内存保存堆内存中对象的引用和基本类型数据，堆内存保存引用类型数据，也就是对象。 基本数据类型和引用数据类型的区别： 对于基本数据类型的变量来说，在栈上创建栈内存用于存储数据，每个变量都是独立的栈内存，变量的修改互不影响：js1234var m = 100;var n = 100;m = 200;console.log(n);// 100 对于引用数据类型的变量来说，在堆上创建堆内存用于存储对象，在栈上创建栈内存用于存储堆内存中对象的引用，对具有相同引用的对象的修改会互相影响：js1234567var zs = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;var student = zs;student.age = 20;console.log(zs.age);// 20 在进行比较运算时的区别： 在比较基本类型数据的时候，比较的是栈内存中的值。 在比较引用类型数据的时候，比较的是栈内存中的引用地址。即使两个对象有完全相同的属性，但因为在堆内存是两个对象，就导致引用地址不同，两个对象也不同：js123456789var m = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;var n = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;console.log(m == n);// false 4.4 垃圾回收垃圾回收（GC，Garbage Collection），是一种回收不再使用的对象内存的机制。 当一个对象没有任何的变量或属性对它进行引用，会导致无法操作该对象，这种对象就是一个垃圾，垃圾对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。 JavaScript拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，开发人员不需要也不能进行垃圾回收的操作，只需要将不再使用的对象设置为null即可： js12var obj = new Object();obj = null; 4.5 分类在JavaScript中可以将对象分为内部对象、宿主对象和自定义对象三种。 4.5.1 内部对象内部对象包括String、Number、Boolean、Object、Function、Array、Date、Math、RegExp、Global，以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError。 其中Global和Math这两个对象又被称为内置对象，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 4.5.2 宿主对象宿主对象就是执行JavaScript的环境提供的对象。 对于嵌入到网页中的JavaScript来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭，这会带来浏览器兼容问题，增加开发难度。 浏览器对象有很多，如window和document等等。 4.5.3 自定义对象顾名思义，就是开发人员自己定义的对象。JavaScript允许使用自定义对象，使应用及功能得到扩充。 5 内部对象5.1 函数5.1.1 定义函数是封装了多条语句的代码块，这段代码块会让函数具有某种功能。 函数中的语句不会自动执行，需要在有需要的地方显示调用函数，在被调用时才会执行函数中的语句。 函数是一种Function类型的对象，使用typeof检查： js12var fun = new Function();console.log(typeof fun);// function 当将函数赋值给对象的某个属性时，将这个属性称为方法，即对象的方法对应的类型是函数。 5.1.2 使用创建函数的方式： 使用普通函数，支持多个参数：js1234function func(name) &#123; console.log(&#x27;test &#x27; + name);&#125;func(&#x27;hello&#x27;); 使用函数表达式，创建匿名函数，并将函数赋值给变量：js1234var func = function(name) &#123; console.log(&#x27;test &#x27; + name);&#125;;func(&#x27;hello&#x27;); 使用函数的构造方法，支持多个参数：js12var func = new Function(&#x27;name&#x27;,&quot;console.log(&#x27;test &#x27; + name);&quot;);func(&#x27;hello&#x27;); 使用构造函数，支持多个参数：js1234function Func(name) &#123; console.log(&#x27;test &#x27; + name);&#125;new Func(&#x27;hello&#x27;); 函数的组成部分： 函数名：用于显示调用函数，可以省略函数名使用变量名调用，也可以同时省略函数名和变量名使用函数自调用：js123(function(name) &#123; console.log(name);&#125;)(&#x27;hello&#x27;); 入参：用于将数据传入到函数中进行处理，支持无参和有参，多个参数用,分隔，参数类型支持任意类型。在执行函数时会从左到右自动匹配参数，缺少的参数按照未定义处理：js1234var fun = function(name) &#123; console.log(name);&#125;;fun();// undefined 返回值：用于获取函数处理的结果。使用return关键字返回结果，返回结果支持任意类型，无返回结果按照未定义处理：js1234var fun = function(name) &#123; console.log(name);&#125;;console.log(fun(&#x27;hello&#x27;));// undefined 使用匿名函数自调用（IIFE，Immediately Invoked Function Expression）的好处是隐藏了内部实现，不污染外部命名空间。 5.1.3 作用域作用域通常用于形容变量，指的是变量的有效范围。 在JavaScript中一共有两种作用域： 全局作用域，在script元素内部声明的变量，而不是在某个方法内部声明的变量，都在全局作用域，这种变量称为全局变量。 局部作用域，在方法内部创建的变量，只在方法内部有效，这种变量称为局部变量。 全局变量的特点： 在页面打开时创建，在页面关闭时销毁。 可以直接使用由浏览器创建的window全局对象，代表浏览器的窗口，可以直接使用其属性和方法。 全局变量在页面的任意地方都可以访问。 局部变量的特点： 在方法调用时创建，在方法执行结束后销毁。 只能在方法内部使用。 只有在方法内部使用关键字声明变量，该变量才是局部变量，否则就是全局变量： js1234567891011var name = &#x27;张三&#x27;;var sex = &#x27;男&#x27;;function fun() &#123; console.log(name);// undefined 使用局部变量，声明提升但未初始化 var name = &#x27;李四&#x27;; console.log(sex);// 男 未声明变量，使用全部变量 sex = &#x27;女&#x27;;&#125;fun();console.log(name);// 张三 全局变量未被修改console.log(sex);// 女 全局变量被修改 当全局变量和局部变量名称相同时，在方法中使用的是局部变量： js1234567var name = &#x27;张三&#x27;;function fun() &#123; console.log(name);// undefined 使用局部变量，声明提升但未初始化 var name = &#x27;李四&#x27;;&#125;fun();console.log(name);// 张三 全局变量未被修改 常用的全局函数： js1234// 对URI进行编码console.log(encodeURIComponent(&#x27;localhost:8080/test?name=test&#x27;));// localhost%3A8080%2Ftest%3Fname%3Dtest// 对URI进行解码console.log(decodeURIComponent(&#x27;localhost%3A8080%2Ftest%3Fname%3Dtest&#x27;));// localhost:8080/test?name=test 5.1.4 声明提升在JavaScript中，函数及变量的声明都将被提升到函数的最顶部，变量可以先使用再声明。 在ES6引入let和const的声明方式后，只有var声明的变量才支持声明提升，并且使用函数表达式声明的函数变量也不支持声明提升。 声明提升只是将声明提前了，并没有将初始化的操作提前： js12console.log(name);// undefinedvar name = &#x27;张三&#x27;; 5.1.5 内部属性在函数内部，有两个特殊的对象： arguments：该对象实际上是一个类数组对象，有数组的特性，但本质上是Object对象，用于保存函数的参数，同时该对象还有一个属性callee来表示当前函数。 this：引用的是一个对象，用来表示函数执行的上下文，一般是函数的调用者。根据函数调用方式的不同，引用对象也会有所不同。 通过arguments对象可以获取传入的参数，即使函数没有定义入参： js1234567891011function test() &#123; console.log(arguments);// Arguments [] console.log(arguments instanceof Array);// false console.log(arguments instanceof Object);// true console.log(arguments[0]);// 1 console.log(arguments[1]);// 2 console.log(arguments.length);// 5 console.log(arguments.callee);// function test() &#123;&#125; console.log(arguments.callee == test);// true&#125;test(1, 2, 3, 4, 5); 使用instanceof关键字可以判断左侧的变量是否属于右侧的类型。 5.1.6 构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是，构造函数习惯上首字母大写： js12function Student() &#123;&#125; 在调用函数时，普通函数可以直接调用，构造函数需要使用new关键字调用： js12345678function Student(name, sex) &#123; this.name = name; this.sex = sex;&#125;var student = new Student(&#x27;张三&#x27;, &#x27;男&#x27;);console.log(student);// &#123; &#x27;name&#x27;: &#x27;张三&#x27;, &#x27;sex&#x27;: &#x27;男&#x27; &#125; 构造函数调用var student = Student(&#x27;张三&#x27;, &#x27;男&#x27;);console.log(student);// undefined 普通函数调用，this表示window对象，没有name属性 也可以通过instanceof关键字判断是不是构造函数调用： js1234567891011function Student(name, sex) &#123; if (this instanceof Student) &#123; console.log(&#x27;构造函数调用&#x27;); this.name = name; this.sex = sex; &#125; else &#123; console.log(&#x27;普通函数调用&#x27;); &#125;&#125;new Student(&#x27;张三&#x27;, &#x27;男&#x27;);// 构造函数调用Student(&#x27;张三&#x27;, &#x27;男&#x27;);// 普通函数调用 使用同一个构造函数创建的对象，称为一类对象。所以也将构造函数称为类，同时将通过构造函数创建的对象，称为该类的实例。 5.1.7 原型对象JavaScript是一门面向对象的语言，而且它还是一个基于原型的面向对象的语言。 原型： 所有函数都有prototype属性的对象，称为原型。 所有对象（包括原型和函数，函数也是对象）都有__proto__属性的对象，可以通过这个对象访问其构造方法的原型。 通过函数prototype属性获取原型的方式称为显示调用，通过对象__proto__属性获取原型的方式称为隐式调用。 默认情况下，原型是一个Object对象，该对象只包含constructor属性和__proto__属性。 图示： 说明： 原型的constructor属性指向函数：js12function func() &#123;&#125;console.log(func.prototype.constructor === func);// true 原型的__proto__属性在浏览器里显示为[[Prototype]]属性，对应Object的prototype属性：js12function func() &#123;&#125;console.log(func.prototype.__proto__ === Object.prototype);// true 原型链： 原型链又称为隐式原型链，隐式调用的原型会形成原型链，顶端是Object显示调用的原型，该原型如果继续通过隐式调用获取原型会返回null：js1console.log(Object.prototype.__proto__);// null 所有对象（包括原型和函数，函数也是对象）都是Object的实例，任何对象的原型链都能追溯到Object显示调用的原型：js123function func() &#123;&#125;console.log(func.__proto__ === Function.prototype);// trueconsole.log(func.__proto__.__proto__ === Object.prototype);// true 所有方法（包括Object和Function）都是Function的实例，任何方法隐式调用的原型都是Function显示调用的原型：js123function func() &#123;&#125;console.log(func.__proto__ === Function.prototype);// trueconsole.log(Object.__proto__ === Function.prototype);// true 当访问对象的属性和方法时，首先在对象自身空间中寻找，如果没有，会在原型链上寻找，如果找不到会返回undefined： js123456789function Student() &#123;&#125;Student.prototype.name = &#x27;学生类&#x27;;Student.prototype.age = 18;var student = new Student();student.name = &#x27;学生实例&#x27;;console.log(student.name);// 学生实例console.log(student.age);// 18console.log(student.test);// undefined 在调用toString()方法时，在没有重写的情况下，调用的实际上是Object的原型对象的方法： js12345function Student() &#123;&#125;var student = new Student();console.log(student.toString());// [object Object]console.log(student.hasOwnProperty(&#x27;toString&#x27;));// false 在使用in关键字和for-in语句循环遍历对象的属性时，也会访问原型对象中的属性。 可以使用hasOwnProperty()方法判断对象自身是否包含指定属性： js12345678function Student() &#123;&#125;Student.prototype.name = &#x27;学生类&#x27;;Student.prototype.age = 18;var student = new Student();student.name = &#x27;学生实例&#x27;;console.log(student.hasOwnProperty(&#x27;name&#x27;));// trueconsole.log(student.hasOwnProperty(&#x27;age&#x27;));// false 5.1.8 函数对象方法当将函数作为对象赋值给变量时，这个对象即使函数对象，函数对象可以通过自身调用函数，也可以通过call()方法和apply()方法调用。 通过方法调用时，传入的第一个参数会被作为函数的调用者，即作为函数里的this对象： js12345678var test = function() &#123; console.log(this);&#125;test();// Window &#123;&#125;test.call();// Window &#123;&#125;test.apply();// Window &#123;&#125;test.call(123);// Number &#123;123&#125;test.apply(123);// Number &#123;123&#125; 两个方法的区别在于对入参上的处理： js12345var test = function (...args) &#123; console.log(...args);&#125;;test.call(null, 1, 2, 3);// 入参是可变参数test.apply(null, [1, 2, 3]);// 入参是数组 5.1.9 箭头函数箭头函数是在ES6中添加的一种规范： 省略了function关键字，箭头左侧表示入参，只有当入参只有一个时，才可以省略小括号 省略了return关键字，箭头右侧是返回语句，只有当函数直接返回表达式时，才可以省略大括号 使用： js123456// 使用箭头函数var func = (x) =&gt; x * x;// 使用普通函数var func = function(x) &#123; return x * x;&#125; 如果返回值是对象，需要使用括号包裹： js12var func = (x) =&gt; (&#123;result: x * x&#125;);console.log(func(5));// &#123;result: 25&#125; 5.2 数组5.2.1 定义数组也是对象的一种，数组是一种用于表达有顺序关系的数据的集合的语言结构。 数组和普通对象功能类似，也用来存储多个值。不同的是普通对象使用字符串作为属性名，而数组使用数字来作为索引操作元素。 索引是从0开始的整数，用于获取数组对应位置的数据。 数组可以存放任意类型的数据，可以在一个数组中存放不同类型的数据。 5.2.2 使用创建数组有两种方式： 先创建，然后插入数据：js123456var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;console.log(arr);// [1, 2, 3]console.log(typeof arr);// object 在创建时插入数据：js12345var arr = new Array(1, 2, 3);// 也可以使用这种方式// var arr = [1, 2, 3];console.log(arr);// [1, 2, 3]console.log(typeof arr);// object 删除数组数据： js1234var arr = [1, 2, 3];console.log(arr);// [1, 2, 3]delete arr[1];console.log(arr);// [1, 空, 3] 访问数组数据： js123var arr = [1, 2, 3];console.log(arr[0]);// 1console.log(arr[3]);// undefined 遍历数组数据： 使用for-in循环遍历：js1234var arr = [1, 2, 3];for (var i in arr) &#123; console.log(arr[i]);&#125; 使用forEach循环遍历：js1234var arr = [1, 2, 3];arr.forEach(function(i, e) &#123; console.log(i + &#x27; &gt; &#x27; + e);&#125;); 数组的属性： js1234var arr = [1, 2, 3];console.log(arr.constructor);// Array() &#123;[native code]&#125;console.log(arr.length);// 3console.log(arr.__proto__);// [] 数组的方法： js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var arr = [1, 2, 3];// 删除数组的最后一个元素，并返回删除的元素var del = arr.pop();console.log(del);// 3console.log(arr);// [1, 2]// 向数组的末尾添加元素，并返回数组的新的长度var len = arr.push(4, 5);console.log(len);// 4console.log(arr);// [1, 2, 4, 5]// 删除数组的第一个元素，并返回删除的元素var del = arr.shift();console.log(del);// 1console.log(arr);// [2, 4, 5]// 向数组开头添加元素，并返回新的数组长度var len = arr.unshift(-2, -1);console.log(len);// 5console.log(arr);// [-2, -1, 2, 4, 5]// 颠倒数组顺序arr.reverse();console.log(arr);// [5, 4, 2, -1, -2]// 对数组元素进行排序，默认按照字母顺序arr.sort();console.log(arr);// [-1, -2, 2, 4, 5]// 对数组元素进行排序，指定排序方式arr.sort(function(m, n) &#123; return m - n;&#125;);console.log(arr);// [-2, -1, 2, 4, 5]// 选择指定范围的字符串，前闭后开，不改变原数组，第一个参数是起始位置，第二个参数是结束位置console.log(arr);// [-2, -1, 2, 4, 5]// 空参选择全部var sli = arr.slice();console.log(sli);// [-2, -1, 2, 4, 5]// 一个参数，选择起始位置及其之后的元素var sli = arr.slice(1);console.log(sli);// [-1, 2, 4, 5]// 参数是负数则加上长度计算var sli = arr.slice(-1);console.log(sli);// [5]// 两个参数，选择定位之间的元素var sli = arr.slice(1, 3);console.log(sli);// [-1, 2]// 删除数组中的指定元素，并返回删除的元素，第一个参数是起始位置，第二个参数是删除数量，第三个及以后的参数是插入到起始位置之前的元素console.log(arr);// [-2, -1, 2, 4, 5]// 空参不删除任何元素var spli = arr.splice();console.log(spli);// []// 一个参数，删除起始位置的元素// var spli = arr.splice(1);// console.log(spli);// [-1, 2, 4, 5]// 参数是负数则加上长度计算// var spli = arr.splice(-1);// console.log(spli);// [5]// 两个参数，删除起始位置之后数量的元素// var spli = arr.splice(1, 3);// console.log(spli);// [-1, 2, 4]// 两个参数，删除起始位置之后数量的元素，插入元素到起始位置之前// var spli = arr.splice(1, 3, 0, 1);// console.log(spli);// [-1, 2, 4] 5.3 日期在JavaScript中使用Date对象表示日期： js1234567var now = new Date();console.log(typeof now);// objectconsole.log(now);// Wed Jul 03 2024 10:30:10 GMT+0800 (中国标准时间)now = new Date(&#x27;1/31/2008&#x27;);// 入参支持MM/dd/yyyy日期格式console.log(now);// Thu Jan 31 2008 00:00:00 GMT+0800 (中国标准时间)now = new Date(&#x27;1/31/2008 10:00:00&#x27;);// 入参支持MM/dd/yyyy HH:mm:ss日期时间格式console.log(now);// Thu Jan 31 2008 10:00:00 GMT+0800 (中国标准时间) 日期的属性： js123var now = new Date();console.log(now.constructor);// ƒ Date() &#123;[native code]&#125;console.log(now.__proto__);// &#123;&#125; 日期的方法： js12345678910var now = new Date();console.log(Date.now());// 时间戳，获取从1970年1月1日至今所过的毫秒数console.log(now.getFullYear());// 2024 获取Date对象的年份console.log(now.getDay());// 3 获取Date对象的星期，0表示周日console.log(now.getMonth());// 6 获取Date对象的月份，0表示1月console.log(now.getDate());// 3 获取Date对象在月份的第几日console.log(now.getHours());// 10 获取Date对象的小时，0表示0点和24点console.log(now.getMinutes());// 30 获取Date对象的分钟，0表示0分和60分console.log(now.getSeconds());// 10 获取Date对象的秒数，0表示0秒和60秒console.log(now.getMilliseconds());// 100 获取Date对象的毫秒 5.4 数学相关JavaScript为数学计算封装了一个Math对象，和其他的对象不同，Math不是一个构造函数，属于一个工具类，不用创建对象，里边封装了数学运算相关的属性和方法。 Math的属性： js123456789console.log(typeof Math);// objectconsole.log(Math.E);// 2.718... 获取算术常量e，即自然对数的底数console.log(Math.LN2);// 0.693... 获取2的自然对数console.log(Math.LN10);// 2.302... 获取10的自然对数console.log(Math.LOG2E);// 1.442... 获取以2为底的e的对数console.log(Math.LOG10E);// 0.434... 获取以10为底的e的对数console.log(Math.PI);// 3.141... 获取圆周率console.log(Math.SQRT1_2);// 0.707... 获取2的平方根的倒数console.log(Math.SQRT2);// 1.414... 获取2的平方根 Math的方法： js1234567console.log(Math.abs(-1));// 1 获取绝对值console.log(Math.ceil(-1.2));// -1 向上取整console.log(Math.floor(-1.2));// -2 向下取整console.log(Math.round(-1.2));// -1 四舍五入console.log(Math.random());// 0.5 生成0到1的随机数，不包括0和1console.log(Math.max(0, 1, 2));// 2 获取最大值console.log(Math.min(0, 1, 2));// 0 获取最小值 5.5 包装类JavaScript提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象： String：可以将基本数据类型字符串转换为String对象。 Number：可以将基本数据类型的数字转换为Number对象。 Boolean：可以将基本数据类型的布尔值转换为Boolean对象。 在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，因为对象在栈中存储的是对象的引用，所以在进行比较时会导致与预期不一致的结果： js123console.log(1 == 1);// true 基本数据类型之间的比较使用栈上的值console.log(1 == new Number(1));// true 基本数据类型与包装类之间的比较会发生自动拆箱，比较栈上的值console.log(new Number(1) == new Number(1));// false 包装类之间的比较使用栈上的引用 5.5.1 布尔值布尔值的属性： js123var boo = new Boolean(true);console.log(boo.constructor);// ƒ Boolean() &#123;[native code]&#125;console.log(boo.__proto__);// Boolean &#123;&#125; 布尔值的方法： js12var boo = new Boolean(true);console.log(boo.valueOf());// true 获取原始值 5.5.2 数字数字的属性： js12345var num = new Number(0);console.log(num.constructor);// ƒ Number() &#123;[native code]&#125;console.log(num.__proto__);// Number &#123;&#125;console.log(Number.MIN_VALUE);// 5e-324console.log(Number.MAX_VALUE);// 1.7976931348623157e+308 数字的方法： js1234567891011console.log(Number.isNaN(&#x27;1&#x27;));// false 判断指定参数是否为NaN，只有当参数是数字且为NaN才会返回true，参数非数字和非NaN的数字会返回falseconsole.log(Number.isFinite(1));// false 判断指定参数是否为无穷大console.log(Number.isInteger(1));// true 判断指定参数是否为整数console.log(new Number(1.159).toFixed(2));// 1.16 获取指定小数位数的字符串，采用四舍五入（银行家舍入）策略，无参会返回整数字符串，参数范围是1到100console.log(new Number(1.615).toFixed(2));// 1.61 不是严格的四舍五入，严格四舍五入可以使用Math.round()方法实现，或者缩放某个倍数console.log(new Number(10).toFixed(4));// 10.0000 精度不足时会进行补位，常用于需要统一精度的场景console.log(new Number(1.159).toPrecision(3));// 1.16 获取指定位数的字符串，采用四舍五入（银行家舍入）策略，无参会返回原数字字符串，参数范围是1到100console.log(new Number(1.615).toPrecision(3));// 1.61 不是严格的四舍五入，严格四舍五入可以使用Math.round()方法实现，或者缩放某个倍数console.log(new Number(0.159).toPrecision(2));// 0.16 整数部分为0时，指定位数不包括整数部分console.log(new Number(10).toPrecision(6));// 10.0000 精度不足时会进行补位，常用于需要统一精度的场景console.log(new Number(10).valueOf());// 10 获取原始值 5.5.3 字符串字符串的属性： js1234var str = new String(&#x27;hello&#x27;);console.log(str.constructor);// ƒ String() &#123;[native code]&#125;console.log(str.length);// 5console.log(str.__proto__);// String &#123;&#125; 字符串的方法： js123456789101112131415161718192021var str = new String(&#x27;hello&#x27;);console.log(str.indexOf(&#x27;l&#x27;));// 2 获取首次出现的位置，找不到返回-1console.log(str.indexOf(&#x27;l&#x27;, 3));// 3 获取首次出现的位置，从指定位置开始，包含指定位置console.log(str.lastIndexOf(&#x27;l&#x27;));// 3 获取最后出现的位置，从右往左查找，找不到返回-1console.log(str.lastIndexOf(&#x27;l&#x27;, 2));// 2 获取最后出现的位置，从右往左查找console.log(str.charAt(1));// e 获取指定位置的字符，指定位置超出长度返回空串console.log(str.charCodeAt(1));// 101 获取指定位置的字符编码，即Unicode编码console.log(str.match(&#x27;l&#x27;));// [&#x27;l&#x27;, ...] 查找匹配的字符串，返回匹配的数组，支持正则表达式，找不到返回nullconsole.log(str.search(&#x27;l&#x27;));// 2 获取首次出现的位置，支持正则表达式，找不到返回-1console.log(str.replace(&#x27;l&#x27;, &#x27;&#x27;));// helo 查找首个匹配第一个参数的字符串，并替换为第二个参数指定的字符串，不改变原字符串console.log(str.replaceAll(&#x27;l&#x27;, &#x27;&#x27;));// heo 查找全部匹配第一个参数的字符串，并替换为第二个参数指定的字符串，不改变原字符串console.log(str.concat(&#x27; &#x27;, &#x27;world&#x27;));// hello world 获取拼接字符串，支持可变参数，不改变原字符串console.log(str.slice(1, 3));// el 获取指定范围的字符串，不改变原字符串，第一个参数是起始位置，第二个参数是结束位置，前闭后开console.log(str.slice(1));// ello 获取指定范围的字符串，不改变原字符串，只有一个参数会获取到末尾console.log(str.slice(-1));// o 获取指定范围的字符串，不改变原字符串，负数参数会从后往前查找console.log(str.substring(1, 3));// el 和slice类似，区别是不支持负数参数，负数参数会替换为0，并且参数会自动排序，保证前小后大console.log(str.split());// [&#x27;hello&#x27;] 根据字符将字符串拆分为数组，无参或字符不存在会将整个字符串作为数组的一个元素，支持正则表达式console.log(str.split(&#x27;&#x27;));// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] 空串将每个字符串作为数组的一个元素console.log(str.split(&#x27;ell&#x27;));// [&#x27;h&#x27;, &#x27;o&#x27;] 拆分后指定的字符被删除console.log(str.toLowerCase());// hello 获取小写字符串，不改变原字符串console.log(str.toUpperCase());// HELLO 获取大写字符串，不改变原字符串 5.6 正则表达式5.6.1 定义在JavaScript中使用RegExp对象表示正则表达式，正则表达式是用于从字符串中选择特定字符串的文本。 5.6.2 创建创建正则表达式有两种方式： 使用构造方法创建，第一个参数是表达式，第二个参数是可选的修饰符，如果表达式有特殊字符，需要使用\\进行转义：js123// var patt = new RegExp(pattern, modifiers);var reg = new RegExp(&#x27;123&#x27;);console.log(typeof reg);// object 直接创建，同样需要两个参数，但是使用/分隔：js123// var reg = /pattern/modifiers;var reg = /123/;console.log(typeof reg);// object 如果需要动态创建正则表达式，需要使用构造方法创建。 在创建正则表达式以后，其内部维护了一个lastIndex索引，记录下一次匹配从哪个位置开始。 5.6.3 方法使用test()方法判断是否匹配内容： js123var reg = /123/;var result = reg.test(&#x27;123a4a123a5a&#x27;);// 判断参数是否包含正则表达式匹配的字符串，返回true表示包含，返回false表示不包含console.log(result);// true 使用exec()方法获取匹配内容： js1234567var reg = /123/;var result = reg.exec(&#x27;123a4a123a5a&#x27;);// 返回从参数中匹配到的字符串，返回值是数组对象，对象内容和全局匹配修饰符有关console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(result.length);// 1 返回对象的数组长度console.log(result.index);// 0 返回匹配到的起始位置console.log(result.groups);// undefined 返回匹配到的捕获分组console.log(reg.lastIndex);// 0 未使用全局匹配修饰符时，匹配到就结束了，不会匹配下一个 使用字符串的match()方法获取匹配内容，和正则表达式的exec()方法相同： js123var reg = /123/;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 5.6.4 修饰符修饰符用于对匹配方式进行说明，修饰符可以省略，但修饰符之前的/不能省略： i：执行对大小写不敏感的匹配，默认大小写敏感 g：执行全局匹配，默认匹配到第一个停止 m：执行多行匹配，默认匹配第一行 如果没有使用g全局修饰，会在匹配到第一个停止，返回包含匹配信息的数组对象，并且exec()方法和match()方法获取的结果相同。 如果使用了g全局修饰，会匹配所有满足的内容，但是exec()方法和match()方法获取的结果不同。 使用exec()方法执行有全局修饰的正则表达式，返回从lastIndex开始匹配到的内容数组，匹配一次后返回匹配的内容并暂停： js12345678910var reg = /123/g;var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 3 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 9 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// null 匹配结束console.log(reg.lastIndex);// 0 匹配结束 使用test()方法也会更新lastIndex的值，如果不注意这一点，可能会出问题： js1234567var reg = /123/g;var result = reg.test(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 3 第一次匹配var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 9 第二次匹配var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 0 匹配结束 虽然执行了一次exec()方法，但实际上已经匹配两次了 使用字符串的match()方法执行有全局修饰的正则表达式，返回匹配到的内容数组，匹配全部后结束： js1234var reg = /123/g;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123&#x27;, &#x27;123&#x27;]console.log(reg.lastIndex);// 0 匹配结束 5.6.5 字符串方法字符串中可以使用正则表达式的方法： js1234567var str = new String(&#x27;hello&#x27;);console.log(str.match(/l/));// [&#x27;l&#x27;, index: 2, input: &#x27;hello&#x27;, groups: undefined]console.log(str.match(/l/g));// [&#x27;l&#x27;, &#x27;l&#x27;] 全局匹配会获取全部匹配的内容console.log(str.search(/l/));// 2console.log(str.replace(/l/, &#x27;&#x27;));// heloconsole.log(str.replaceAll(/l/g, &#x27;&#x27;));// heo 替换全部时，修饰符必须有全局匹配console.log(str.split(/ll/));// [&#x27;he&#x27;, &#x27;o&#x27;] 5.6.6 量词表达式中可以使用量词，使用n表示任意字符： js12345678910111213var str = &#x27;hello&#x27;;console.log(str.match(/el+/g));// [&#x27;ell&#x27;] 使用n+匹配包含至少一个n的字符串console.log(str.match(/hl+/g));// null 至少包含一个nconsole.log(str.match(/el*/g));// [&#x27;ell&#x27;] 使用n*匹配包含零个或多个n的字符串console.log(str.match(/hl*/g));// [&#x27;h&#x27;] 可以不包含nconsole.log(str.match(/el?/g));// [&#x27;el&#x27;] 使用n?匹配包含零个或一个n的字符串console.log(str.match(/hl?/g));// [&#x27;h&#x27;] 可以不包含nconsole.log(str.match(/l&#123;2&#125;/g));// [&#x27;ll&#x27;] 使用n&#123;X&#125;匹配包含X个n的字符串console.log(str.match(/l&#123;1,2&#125;/g));// [&#x27;ll&#x27;] 使用n&#123;X,Y&#125;匹配至少包含X个至多包含Y个n的字符串，Y可以省略console.log(str.match(/lo$/g));// [&#x27;lo&#x27;] 使用n$匹配任何结尾为n的字符串console.log(str.match(/^he/g));// [&#x27;he&#x27;] 使用^n匹配任何开头为n的字符串console.log(str.match(/e(?=l)/g));// [&#x27;e&#x27;] 使用?=n匹配任何后面紧跟n的字符串console.log(str.match(/h(?!l)/g));// [&#x27;h&#x27;] 使用?=n匹配任何后面紧跟n的字符串 在具有量词匹配的表达式中，使用贪婪模式和非贪婪模式： js123var str = &#x27;123123&#x27;;console.log(str.match(/1.*3/g));// [&#x27;123123&#x27;] 默认开启贪婪模式，获取能匹配到的最多的内容console.log(str.match(/1.*?3/g));// [&#x27;123&#x27;, &#x27;123&#x27;] 使用?开启非贪婪模式，获取能匹配到的最少的内容 5.6.7 范围表达式中可以使用方括号限制查找某个范围的字符串，实际上比较的是ASCII码： js1234567var str = &#x27;ab12CD&#x27;;console.log(str.match(/[abCD]/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] 查找方括号之间的任何字符console.log(str.match(/[^abCD]/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找不在方括号之间的任何字符console.log(str.match(/[0-9]/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找0-9之间的数字console.log(str.match(/[a-z]/g));// [&#x27;a&#x27;, &#x27;b&#x27;] 查找a-z之间的字符，即小写英文字母console.log(str.match(/[A-Z]/g));// [&#x27;C&#x27;, &#x27;D&#x27;] 查找A-Z之间的字符，即大写英文字母console.log(str.match(/[A-z]/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] 查找A-z之间的字符，即所有英文字母，因为在ASCII码中，大写字母在小写字母前面 5.6.8 特殊字符表达式中可以使用元字符替代特殊字符进行查找： js123456789101112131415console.log(&#x27;ab12_!+&#x27;.match(/./g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找单个字符，除了换行和行结束符console.log(&#x27;ab12_!+&#x27;.match(/\\w/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;] 查找单词字符，包括数字、字母、下划线console.log(&#x27;ab12_!+&#x27;.match(/\\W/g));// [&#x27;!&#x27;, &#x27;+&#x27;] 查找非单词字符console.log(&#x27;ab12_!+&#x27;.match(/\\d/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找数字字符console.log(&#x27;ab12_!+&#x27;.match(/\\D/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找非数字字符console.log(&#x27;ab12_!+&#x27;.match(/\\s/g));// null 查找空白字符，包括空格符、回车符、换行符、换页符、制表符、垂直制表符console.log(&#x27;ab12_!+&#x27;.match(/\\S/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找非空白字符console.log(&#x27;hello world&#x27;.match(/\\bwo/g));// [&#x27;wo&#x27;] 查找单词边界字符，即位于单词开头和结尾的字符console.log(&#x27;hello world&#x27;.match(/\\Blo/g));// [&#x27;lo&#x27;] 查找非单词边界字符console.log(&#x27;&#x27;.match(/\\0/g));// null 查找NULL字符console.log(&#x27;&#x27;.match(/\\n/g));// null 查找换行符console.log(&#x27;&#x27;.match(/\\r/g));// null 查找回车符console.log(&#x27;&#x27;.match(/\\f/g));// null 查找换页符console.log(&#x27;&#x27;.match(/\\t/g));// null 查找制表符console.log(&#x27;&#x27;.match(/\\v/g));// null 查找垂直制表符 5.6.9 捕获分组在正则表达式中使用()有两个作用： 将被包裹的内容进行单独匹配，用于形成捕获分组 括号后的量词会将括号视为整体 在未使用全局修饰的情况下，使用exec()方法获取匹配内容： js123var reg = /(123)(a.a)/;var result = reg.exec(&#x27;123a4a123a5a&#x27;);// 在使用捕获分组时，数组第一个元素是完整的匹配内容，后面的元素是捕获的元素console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 在未使用全局修饰的情况下，使用字符串的match()方法获取匹配内容，和正则表达式的exec()方法相同： js123var reg = /(123)(a.a)/;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 在使用全局修饰的情况下，使用exec()方法获取匹配内容： js12345678910var reg = /(123)(a.a)/g;var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 6 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 12 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// null 匹配结束console.log(reg.lastIndex);// 0 匹配结束 在使用全局修饰的情况下，使用字符串的match()方法获取匹配内容： js1234var reg = /(123)(a.a)/g;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123a5a&#x27;]console.log(reg.lastIndex);// 0 匹配结束 6 文档对象模型6.1 定义文档对象模型（DOM，Document Object Model），在JavaScript中通过DOM操作HTML页面。 DOM将HTML页面映射为一个多节点模型，每个元素和属性都是节点： 文档本身就是文档节点，使用document对象表示，作为window对象的属性存在的，不用获取可以直接使用。 注释是注释节点。 元素是元素节点。 元素内的属性是属性节点。 元素内的文本是文本节点。元素之间的空白也是文本节点。 当网页被加载时，浏览器会创建页面的DOM树： 节点的通用属性： nodeName：代表当前节点的名字，只读属性。元素节点返回大写的标签名，属性节点返回属性名，文本节点返回#text字符串。 nodeType：返回一个整数，这个数值代表着给定节点的类型，只读属性。元素节点返回1，属性节点返回2，文本节点返回3。 nodeValue：返回给定节点的当前值，可读写的属性。元素节点返回null，属性节点返回属性值，文本节点返回文本节点的内容。 6.2 节点6.2.1 文档节点查询元素节点的方法，需要使用文档节点document对象调用： js1234var home = document.getElementById(&#x27;home&#x27;);// 通过元素的id属性查找元素节点home = document.getElementsByName(&#x27;home&#x27;);// 通过元素的name属性查找元素节点，返回多个匹配的节点home = document.getElementsByClassName(&#x27;home&#x27;);// 通过元素的calss属性查找元素节点，返回多个匹配的节点，支持元素节点调用home = document.getElementsByTagName(&#x27;div&#x27;);// 通过元素的标签名查找元素节点，返回多个匹配的节点，支持元素节点调用 除了通过id属性查找返回的是对象外，其余三个返回的均为伪数组： js1234567891011var home = document.getElementById(&#x27;home&#x27;);console.log(home);// &lt;span id=&quot;home&quot;&gt;home-id&lt;/span&gt;home = document.getElementsByName(&#x27;home&#x27;);console.log(home);// NodeList [span]console.log(Array.prototype.slice.call(home));// [span]home = document.getElementsByClassName(&#x27;home&#x27;);console.log(home);// HTMLCollection [span.home]console.log(Array.prototype.slice.call(home));// [span.home]home = document.getElementsByTagName(&#x27;div&#x27;);console.log(home);// HTMLCollection [div]console.log(Array.prototype.slice.call(home));// [div] 文档节点的属性： js1234console.log(document.title);// 获取文档标题console.log(document.URL);// 获取文档URLconsole.log(document.referrer);// 获取文档referrer，即前文档的URLconsole.log(document.domain);// 获取文档域名 使用文档节点操作节点： js12345console.log(document.querySelector(&#x27;#home&#x27;));// 使用CSS选择器查找元素节点，返回第一个元素节点console.log(document.querySelectorAll(&#x27;#home&#x27;));// 使用CSS选择器查找元素节点，返回全部元素节点var newDiv = document.createElement(&#x27;div&#x27;);// 创建元素节点，入参是标签名var newName = document.createAttribute(&#x27;name&#x27;);// 创建属性节点，入参是属性名var newText = document.createTextNode(&#x27;text&#x27;);// 创建文本节点，入参是文本内容 6.2.2 元素节点元素节点的属性： js12345678var home = document.getElementById(&#x27;home&#x27;);console.log(home.children);// 获取当前节点的所有子节点，只获取元素节点console.log(home.childNodes);// 获取当前节点的所有子节点，包括元素节点和非元素节点console.log(home.firstChild);// 获取当前节点的第一个子节点，包括元素节点和非元素节点console.log(home.lastChild);// 获取当前节点的最后一个子节点，包括元素节点和非元素节点console.log(home.parentNode);// 获取当前节点的父节点console.log(home.previousSibling);// 获取当前节点的前一个兄弟节点，包括元素节点和非元素节点console.log(home.nextSibling);// 获取当前节点的后一个兄弟节点，包括元素节点和非元素节点 通过元素节点获取其他节点： 通过firstChild属性获取的第一个节点通常是文本节点 通过getAttributeNode(属性名)方法获取指定属性节点，通常不使用属性节点 获取和修改元素节点的属性： js12345var home = document.getElementById(&#x27;home&#x27;);console.log(home.id);// 获取id属性console.log(home.class);// 获取class属性home.id = &#x27;home-id&#x27;;// 修改id属性home.id = &#x27;home-class&#x27;;// 修改class属性 操作元素节点： js123456789101112131415var home = document.getElementById(&#x27;home&#x27;);// 操作属性console.log(home.getAttribute(&#x27;id&#x27;));// 通过属性名获取属性console.log(home.getAttributeNode(&#x27;id&#x27;));// 通过属性名获取属性节点home.setAttribute(&#x27;name&#x27;, &#x27;home&#x27;);// 通过属性名设置属性home.setAttributeNode(document.createAttribute(&#x27;name&#x27;));// 设置属性节点home.removeAttribute(&#x27;name&#x27;);// 通过属性名删除属性home.removeAttributeNode(home.getAttributeNode(&#x27;name&#x27;));// 删除属性节点// 操作子节点var newDiv = document.createElement(&#x27;div&#x27;);// 创建元素节点var newText = document.createTextNode(&#x27;text&#x27;);// 创建文本节点home.appendChild(newDiv);// 添加子节点，新的字节点会添加到末尾子节点的后面home.insertBefore(newText, home.childNodes[0]);// 添加子节点，新的字节点会添加到首位子节点的前面home.removeChild(home.childNodes[0]);// 删除子节点home.replaceChild(newText, home.childNodes[0]);// 替换子节点 操作元素样式： js12345678910111213var home = document.getElementById(&#x27;home&#x27;);home.style[&#x27;fontSize&#x27;] = &#x27;16px&#x27;;// 修改行内样式console.log(home.style.fontSize);// 获取行内样式，需要将分隔命名转为驼峰命名// 获取元素样式，包括内部样式和外部样式，兼容写法，不支持修改if (window.getComputedStyle) &#123; // 大部分浏览器兼容的方式，第二个参数是伪元素 var fontSize = getComputedStyle(home, null)[&#x27;fontSize&#x27;]; console.log(fontSize);&#125; else &#123; // IE8及以下 var fontSize = home.currentStyle[&#x27;fontSize&#x27;]; console.log(fontSize);&#125; 6.2.3 属性节点属性节点的属性： js12345var home = document.getElementById(&#x27;home&#x27;);var homeName = home.getAttributeNode(&#x27;name&#x27;);console.log(homeName.name);// 获取属性名console.log(homeName.value);// 获取属性值homeName.value = &#x27;name&#x27;;// 设置属性值 6.3 事件6.3.1 使用事件就是用户和浏览器之间的交互行为，比如点击、移动。 事件是元素具备的行为方式，比如click事件表示元素被点击的事件。如果需要在触发事件时执行某些函数，就需要对事件进行绑定，比如onclick属性可以将click事件和函数绑定，当触发click事件时就会执行绑定的函数。 事件可以写在HTML的元素内，也可以写在JavaScript里： 写在HTML的元素里，不建议使用这种方式：html1&lt;span id=&quot;home&quot; onclick=&quot;alert(&#x27;home&#x27;);&quot;&gt; 写在JavaScript里，建议使用这种方式：js1234var home = document.getElementById(&#x27;home&#x27;);home.onclick = function() &#123; alert(&#x27;home&#x27;);&#125; 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数，在事件对象中封装了当前事件相关的一切信息。 在使用IE浏览器时，如果版本小于IE8，响应函数被触发时，浏览器不会传递事件对象，而是将事件对象作为window对象的属性保存。 兼容IE和其他浏览器的方式： js1234567// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);// 传入事件对象，可以省略home.onclick = function(event) &#123; alert(&#x27;home&#x27;);&#125; 常用事件： js1234567891011121314151617var home = document.getElementById(&#x27;home&#x27;);// 鼠标点击时执行home.onclick = function() &#123; alert(&#x27;home&#x27;);&#125;// 元素获取焦点时执行home.onfocus = function() &#123; alert(&#x27;home&#x27;);&#125;// 元素失去焦点时执行home.onblur = function() &#123; alert(&#x27;home&#x27;);&#125;// 页面加载完后执行window.onload = function() &#123; alert(&#x27;home&#x27;);&#125; 使用target属性获取触发事件的元素： js1234567// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; var obj = event.target; alert(obj.tagName);&#125; 6.3.2 传播关于事件的传播网景公司和微软公司有不同的理解： 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素。 W3C综合了两个公司的方案，将事件传播分成了三个阶段： 捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件。 处理阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件。 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件。 IE8及以下的浏览器中没有捕获阶段，其他浏览器在调用方法时处理。 6.3.3 冒泡事件的冒泡，指的是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。 如果不希望发生事件冒泡可以取消冒泡： js12345678910// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;home&#x27;); // 已弃用，不建议 event.cancelBubble = true; // 建议 event.stopPropagation();&#125; 取消冒泡并不会取消元素的默认动作，比如超链接的默认跳转，可以使用preventDefault()方法取消默认动作： js12345678// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;home&#x27;); // 取消跳转，但不能阻止冒泡 event.preventDefault();&#125; 既可以取消冒泡，又可以取消默认动作： js12345678// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;a&#x27;); // 取消跳转，阻止冒泡 return false;&#125; 6.3.4 委派事件的委派，是指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了事件冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。 给列表里的所有元素绑定同一事件： js12345678// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; if (event.target.className == &#x27;li&#x27;) &#123; alert(&#x27;li&#x27;); &#125;&#125; 6.3.5 绑定给元素绑定事件有两种方式： 通过属性绑定，一个属性只能绑定一个函数，后面的会覆盖前面的：js1234var home = document.getElementById(&#x27;home&#x27;);home.onclick = function() &#123; alert(&#x27;home&#x27;);&#125; 通过事件监听函数绑定，一个事件可以绑定多个函数，需要兼容不同的浏览器：js1234567891011121314151617181920212223242526var home = document.getElementById(&#x27;home&#x27;);// 在页面加载后绑定window.onload = function() &#123; bindClick(home, &#x27;click&#x27;, &#x27;first&#x27;); bindClick(home, &#x27;click&#x27;, &#x27;last&#x27;);&#125;;// 通用的绑定方法，将handle()方法绑定到传入的对象上function bindClick(obj, eventStr, name) &#123; if (obj.addEventListener) &#123; // 大部分浏览器兼容的方式，需要使用没有on前缀的事件 obj.addEventListener(eventStr, function() &#123; console.log(this);// 在addEventListener()方法中，this对象是绑定的事件对象 handle(name); &#125;, false);// 如果希望在捕获阶段就触发事件，可以设置为true，一般为false &#125; else &#123; // IE8及以下，需要使用有on前缀的事件 obj.attachEvent(&#x27;on&#x27; + eventStr, function() &#123; console.log(this);// 在attachEvent()方法中，this对象是window对象 handle.call(obj, name);// 调用回调函数，强制将this对象设为绑定的事件对象 &#125;); &#125;&#125;// 通用的执行方法function handle(name) &#123; console.log(name);&#125; 6.4 版本6.4.1 介绍在W3C协会制定的DOM标准中，DOM标准可以分为DOM1，DOM2，DOM3三个版本。 事实上，DOM0级标准是不存在的，所谓DOM0只是DOM历史坐标中的一个参照点。 DOM1主要定义的是HTML和XML文档的底层结构，DOM2和DOM3分别在这个结构的基础上引入更多的交互能力，例如扩展API，也支持了更高级的XML特性。 6.4.2 DOM0网景公司和微软公司分别在1997年的6月和10月发布了DHTML，它们是未形成标准的试验性质的初级阶段的DOM，这个DOM被公认为是DOM0。 浏览器处理事件的时候只有原始事件模型，可以直接在HTML标签上绑定事件，也可以获取DOM节点后绑定事件： 直接在HTML标签上绑定事件：html1&lt;span id=&quot;home&quot; onclick=&quot;alert(&#x27;home&#x27;);&quot;&gt; 获取DOM节点后绑定事件：js1234var home = document.getElementById(&#x27;home&#x27;);home.onclick = function() &#123; alert(&#x27;home&#x27;);&#125; 这种处理事件的方式是使用元素的属性绑定事件和函数，元素的属性只能指向一个函数，所以这种绑定方式只能绑定一个函数。 6.4.3 DOM1在1998年10月1日将DOM1作为W3C推荐标准，其实就是DOM0的规范版本。 在DOM1标准中并没有定义事件相关的内容，只是为基本的文档结构及查询提供了接口。 6.4.4 DOM2在DOM2中，当事件发生时，目标元素的事件处理函数被触发，并且事件传播分为三个阶段进行：捕获阶段、处理阶段、冒泡阶段。 使用事件监听函数绑定事件： js12345678var home = document.getElementById(&#x27;home&#x27;);home.addEventListener( &#x27;click&#x27;, function () &#123; alert(&#x27;home&#x27;); &#125;, false); 这种处理事件的方式是使用监听事件函数绑定事件和函数，在DOM2中某些浏览器会给某些事件开辟事件池，也就是事件的队列，存放事件绑定的函数，当事件触发时依次排序执行事件池里的函数，所以这种绑定方式可以绑定多个函数。 6.4.5 DOM3在DOM3中，又在DOM2事件的基础上添加了更多的事件类型，以及一些内容模型和文档验证。 7 浏览器对象模型7.1 定义浏览器对象模型（BOM，Browser Object Model），允许JavaScript与浏览器交互。 BOM提供了一组对象用于对浏览器进行操作： Window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象。 Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器。 Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面。 History：代表浏览器历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在当次访问时有效。 Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息。 这些BOM对象（全局对象）在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用。 7.2 使用7.2.1 window对象window对象的属性和方法可以省略直接使用。 window对象属性： js12345console.log(window.document);// 返回document对象的只读引用console.log(window.navigator);// 返回navigator对象的只读引用console.log(window.location);// 返回location对象的只读引用console.log(window.history);// 返回history对象的只读引用console.log(window.screen);// 返回screen对象的只读引用 window对象方法： js1234567891011121314151617181920212223// 关闭浏览器窗口close();// 打开新的浏览器窗口open(&#x27;&#x27;,&#x27;_blank&#x27;,&#x27;width=200,height=100&#x27;);// 显示带有消息和确认按钮的警告框alert(&#x27;警告框&#x27;);// 显示带有消息以及确认按钮和取消按钮的对话框confirm(&#x27;确认框&#x27;);// 按照指定的时间执行定时函数var obj = setTimeout(function(name) &#123; console.log(&#x27;3秒后打印 &#x27; + name);&#125;, 3000, &#x27;test&#x27;);// 取消设置的定时函数，在执行前有效clearTimeout(obj);// 按照指定的时间（以毫秒计）重复调用函数var id = 1;var obj = setInterval(function(name) &#123; console.log(id++ + &#x27; &#x27; + name); if (id &gt; 5) &#123; // 取消设置的重复调用函数 clearInterval(obj); &#125;&#125;, 100, &#x27;test&#x27;); 7.2.2 navigator对象navigator对象属性： js1234567console.log(navigator.appName);// 返回浏览器的名称console.log(navigator.appCodeName);// 返回浏览器的代码名console.log(navigator.lappVersioncation);// 返回浏览器的平台和版本信息console.log(navigator.platform);// 返回运行浏览器的操作系统平台console.log(navigator.userAgent);// 返回由客户机发送服务器的代理信息console.log(navigator.language);// 返回浏览器使用的语言console.log(navigator.product);// 返回浏览器使用的引擎（产品） 由于历史原因，navigator对象中的大部分属性都已经不能识别浏览器了，一般只使用userAgent来判断浏览器的信息。 7.2.3 location对象location对象属性： js12345678console.log(location.hash);// 返回URL的锚部分console.log(location.host);// 返回URL的主机名和端口console.log(location.hostname);// 返回URL的主机名console.log(location.href);// 返回完整的URLconsole.log(location.pathname);// 返回的URL路径名console.log(location.port);// 返回URL服务器使用的端口号console.log(location.protocol);// 返回URL协议console.log(location.search);// 返回URL的查询部分 location对象方法： js123location.assign();// 载入新的文档，相当于给location对象赋值location.reload(true);// 重新加载当前页面，相当于刷新，参数为true表示清空缓存location.replace();// 用新的文档替换当前文档，不能使用历史记录，不能使用后退 7.2.4 history对象history对象属性： js1console.log(location.length);// 返回历史列表中的网址数 history对象方法： js123location.back();// 加载历史列表中的前一个URLlocation.forward();// 加载历史列表中的下一个URLlocation.go(1);// 加载历史列表中的某个具体页面，参数大于0时前进，参数小于0时后退 7.2.5 screen对象screen对象属性： js12console.log(screen.height);// 返回屏幕的总高度console.log(screen.width);// 返回屏幕的总宽度","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"移动端适配","slug":"C00-前端/C02-CSS/001-基础/004-移动端适配","date":"2024-05-19T03:17:44.000Z","updated":"2025-06-21T08:57:45.794Z","comments":true,"path":"posts/20240519/111744/","permalink":"https://momashanhe.com/posts/20240519/111744/","excerpt":"摘要：本文探讨了移动端开发中的视口设置、适配不同屏幕的方法以及响应式布局的实现策略。","text":"摘要：本文探讨了移动端开发中的视口设置、适配不同屏幕的方法以及响应式布局的实现策略。 1 背景一般来说，移动端需要在屏幕远小于电脑端时，支持显示几乎相同分辨率的图像，所以移动端的逻辑像素要比电脑端的逻辑像素小。 默认情况下，如果未对网页适配移动端，移动端的浏览器会将视口设置为980px，以确保网页可以在移动端正常访问，此时将980px作为物理像素。 当网页宽度不超过980px时，将980px作为逻辑像素，像素比为980px&#x2F;980px&#x3D;1，网页能正常显示。当网页宽度超过了980px时，将网页宽度作为逻辑像素，像素比为980px&#x2F;网页宽度&lt;1，网页会被缩小。 为了能让移动端正常显示网页，大部分网站都会专门为移动端设计网页。 2 完美视口为了让网页能在移动端合理显示，避免网页被缩小，需要根据网页的逻辑像素和移动端屏幕的最佳像素比调整视口的物理像素，可以在meta元素设置： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=200px&quot;&gt; 设置最佳视口，可以让浏览器根据网页的逻辑像素，自动计算视口最佳的物理像素，实现完美视口： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 设置了视口的物理像素后，当网页的逻辑像素超出后，会使用滚动条加载页面，不会缩放页面，保证文字和内容显示正常。 为了保证页面显示比例不被破坏，可以禁止缩放，保持缩放比例： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; 3 适配不同屏幕虽然设置完美视口能够解决缩放的问题，但不同设备的完美视口是不同的，在某个设备上使用200px能够撑满宽度，但是在其他设备上可能就只显示半屏，所以还需要适配不同的屏幕。 3.1 使用百分比使用百分比代替像素值，依据父元素的内容大小使用百分比。 这种方式可以避免使用像素带来的问题，但是如果父元素设置了边框或者边距，使用起来就比较麻烦。 只能在某些场景下使用，并不是完全取代像素的解决方案。 3.2 使用视口百分比使用视口的百分比代替像素值，单位是vw和vh，分别是水平方向和垂直方向。 在使用时，需要按照视口设置的物理像素，将设计图里的逻辑像素转化为视口百分比。 示例： 第一步，假设网页宽度为750px，计算1px对应的vw：100÷750≈0.1333vw 第二步，假设容器宽度为200px，计算对应的vw：200×0.1333&#x3D;26.6666vw 第三步，使用26.6666vw作为容器宽度，替换200px 这种方式不依赖父元素，能够按照比例适配不同屏幕，但是在计算的时候比较麻烦。 3.3 使用字体倍数使用字体倍数rem代替像素值，rem对应的是根元素的字体大小，这种方式是使用视口百分比的补充。 实例： 第一步，假设网页宽度为750px，计算1px对应的vw：100÷750≈0.1333vw 第二步，为了防止字体过小被浏览器改为默认的12px，建议设置网页根元素的字体大小为40px，计算对应的vw：40×0.1333&#x3D;5.3333vw 第三步，使用5.3333vw作为网页根元素的字体大小，替换40px 第四步，假设容器宽度为200px，使用字体大小将px转为rem：200÷40&#x3D;5rem 第五步，使用5rem作为容器宽度，替换200px 这种方式本质上使用的还是视口百分比，但是在计算的时候使用字体大小计算，更简单一些。 在实际开发中，并不是完全禁止使用px作为单位，如果需要根据屏幕进行缩放，才需要考虑避免使用px带来的问题。 4 响应式布局4.1 匹配媒体查询浏览器可以通过媒体查询得到当前访问浏览器的设备类型，使用@media指定对不同媒体的样式处理，在不同设备访问时得到不同样式。 匹配媒体类型： css123456@media 媒体类型 &#123; div &#123; width: 10px; height: 10px; &#125;&#125; 媒体查询也遵循样式的覆盖原则，所以需要将媒体查询写在正常样式下面，避免被覆盖失效。 常用媒体类型： all：匹配所有设备。 screen：匹配屏幕，包括电脑屏幕、平板屏幕、手机屏幕、等等。 print：匹配打印机，在打印时使用的样式。 示例： css12345@media print &#123; .title &#123; color: #000; &#125;&#125; 完整的媒体类型可以参考文档：MDN媒体类型 4.2 匹配媒体特性除了通过媒体类型设置不同的样式，也可以通过媒体特征匹配不同的样式。 匹配媒体特征： css123456@media (属性名: 属性值) &#123; div &#123; width: 10px; height: 10px; &#125;&#125; 当匹配到指定的特征时，应用指定的样式。 常用媒体特征： 属性名 作用 取值 width 匹配视口宽度，视口宽度匹配时应用样式 长度值 max-width 匹配视口最大宽度，视口宽度小于等于匹配时应用样式 长度值 min-width 匹配视口最小宽度，视口宽度大于等于匹配时应用样式 长度值 height 匹配视口高度，视口高度匹配时应用样式 长度值 max-height 匹配视口最大高度，视口高度小于等于匹配时应用样式 长度值 min-height 匹配视口最小高度，视口高度大于等于匹配时应用样式 长度值 device-width 匹配设备屏幕的宽度，设备屏幕宽度匹配时应用样式 长度值 max-device-width 匹配设备屏幕的最大宽度，设备屏幕宽度小于等于匹配时应用样式 长度值 min-device-width 匹配设备屏幕的最小宽度，设备屏幕宽度大于等于匹配时应用样式 长度值 orientation 检测视口的旋转方向，即屏幕是否横屏 portrait：视口处于纵向，即高度大于等于宽度 landscape：视口处于横向，即宽度大于高度 示例： css12345@media (width: 10px) &#123; .title &#123; color: #000; &#125;&#125; 常见用于区分不同等级屏幕的阈值： 小屏幕：宽度在768px以下。 中屏幕：宽度在769px到992px之间。 大屏幕：宽度在992px到1200px之间。 超大屏幕：宽度在1200px以上。 4.3 匹配复杂条件支持复杂匹配，如果需要同时满足，可以使用运算符连接，如果需要满足任意一个，可以使用逗号分隔。 可以混合使用媒体查询和媒体特征进行匹配。 支持的运算符： and：并且，匹配全部条件。 or：或者，匹配任意条件，支持使用,分隔。 not：否定，匹配相反条件。 only：肯定，用于让IE浏览器忽略设置的条件和样式，避免部分匹配，对现代浏览器无影响。 示例： css12345@media screen and (max-width:768px) &#123; .title &#123; color: #000; &#125;&#125; 在使用时也可以通过指定条件使用不同的样式文件： html1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width:768px)&quot; href=&quot;./index-small.css&quot;&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"Less","slug":"C00-前端/C02-CSS/003-预处理/001-Less","date":"2024-05-19T01:44:23.000Z","updated":"2025-06-21T08:57:45.695Z","comments":true,"path":"posts/20240519/094423/","permalink":"https://momashanhe.com/posts/20240519/094423/","excerpt":"摘要：本文介绍了Less预处理器，它通过变量、嵌套、混合和运算等功能增强CSS，使样式表更加高效和可维护。","text":"摘要：本文介绍了Less预处理器，它通过变量、嵌套、混合和运算等功能增强CSS，使样式表更加高效和可维护。 环境 Windows 10 企业版 LTSC 21H2Less 4.2.2 1 简介1.1 预处理器增强传统CSS（层叠样式表）功能的脚本语言被称为CSS预处理器，它允许开发人员使用变量、嵌套、混合等功能，以更高效和可维护的方式编写CSS代码。CSS预处理器的另一个术语是动态样式表语言。 1.2 常见的预处理器1.2.1 LessLess（Leaner CSS）是一种动态样式语言，它扩展了CSS的功能，提供了变量、嵌套、混合、运算等功能。 Less使用类似于CSS的语法，但具有更简洁的书写方式。 Less可以通过Less编译器将Less文件编译为普通的CSS文件。 Less具有较小的学习曲线，易于上手。 官网：https://less.bootcss.com/ 1.2.2 SassSass是一种成熟且广泛使用的CSS预处理器，它提供了许多强大的功能，如变量、嵌套规则、混合、继承等。 Sass有两种语法：Sass（使用缩进）和 Scss（使用类似于CSS的语法）。 Sass可以通过命令行工具或构建工具编译为普通的CSS文件。 Sass具有强大的功能和灵活性，适用于大型项目。 官网：https://sass.bootcss.com/index.html 1.2.3 ScssScss是Sass的一种语法格式，它使用类似于CSS的语法，但具有Sass的功能和特性。 Scss可以看作是Sass的一种扩展，使用大括号和分号来表示代码块和语句。Scss与Sass兼容，可以在一个项目中同时使用。 官网：https://sass.bootcss.com/index.html 1.2.4 StylusStylus是一种简洁灵活的CSS预处理器，提供了类似于Sass和Less的功能，如变量、嵌套规则、混合、继承等。 Stylus使用类似于Python的缩进语法。 Stylus也可以通过命令行工具或构建工具编译为普通的CSS文件。 Stylus的语法非常简洁，可以减少样式表的代码量。 官网：https://www.stylus-lang.cn/ 1.3 选用LessLess没有去掉任何CSS的功能，而是在现有的语法上增添了许多额外的功能特性，可以看做是CSS的一种增强版，通过Less可以用更少的代码实现更强大的样式。 Sass与Stylus相比于Less功能更为丰富，但对于学习成本以及适应时间，Less稍胜一筹。 2 位置2.1 内部样式写在页面内部的style元素中： hello.html1234567&lt;style type=&quot;text/less&quot;&gt; div &#123; width: 200px; height: 200px; background-color: #d44b4b; &#125;&lt;/style&gt; 2.2 外部样式创建后缀为.less格式的Less文件： hello.less12345div &#123; width: 200px; height: 200px; background-color: #d44b4b;&#125; 在HTML页面的head元素中引用Less文件： hello.html1&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/less&quot; href=&quot;hello.less&quot;&gt; 3 引入3.1 在页面中引入如果是在浏览器环境中开发，可以通过引入Less的核心JS库使用Less的功能。 在官网上下载Less的JS文件，也可以通过GitHub下载：https://github.com/less/less.js/archive/master.zip 使用JS文件对Less进行编译，根据编写位置不同，引入方式也不同：所以，或者： 内部样式外部样式通过内部样式编写，需要在Less代码后引入JS文件： html12345678910&lt;!-- 编写Less代码 --&gt;&lt;style type=&quot;text/less&quot;&gt; div &#123; width: 200px; height: 200px; background-color: #d44b4b; &#125;&lt;/style&gt;&lt;!-- 引入文件 --&gt;&lt;script src=&quot;./less.min.js&quot;&gt;&lt;/script&gt;通过外部样式编写，需要在导入Less文件后引入JS文件： html1234&lt;!-- 导入Less文件 --&gt;&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/less&quot; href=&quot;hello.less&quot;&gt;&lt;!-- 引入文件 --&gt;&lt;script src=&quot;./less.min.js&quot;&gt;&lt;/script&gt; 3.2 通过命令引入如果是在Node环境中开发，可以使用NPM安装Less： bash1npm install less -g 使用命令将Less文件转为CSS文件： bash1lessc hello.less hello.css 4 工具在VSCode中安装Easy Less插件可以在编写Less文件的时候自动创建同名的CSS文件。 5 使用5.1 注释以//开头的是单行注释，不会被编译到CSS中。 以/**/包围的是多行注释，会被编译到CSS中。 5.2 变量5.2.1 变量插值使用@声明变量，作为普通属性使用： less12345@background-color: #f0ffff;span &#123; background-color: @background-color;&#125; 如果将变量作为插值使用，需要使用@&#123;&#125;包裹： less1234567891011121314151617@src: &quot;./style&quot;;@span: span;@color: color;@gold: #ffd700;@brown: #a52a2a;@list: list;@import &quot;@&#123;src&#125;/body.less&quot;;@&#123;span&#125; &#123; @&#123;color&#125;: @gold; background-color: @brown;&#125;.@&#123;list&#125; &#123; @&#123;color&#125;: @gold;&#125; 5.2.2 变量转义某些时候，当需要引入不被识别的字符，或者引入的字符不想被编译，就需要使用转义字符。 转义字符就是在字符串前面加上一个~符号，并将需要转义的字符串放在&quot;&quot;或&#39;&#39;中，转义允许使用任意字符串作为属性或变量值。 示例： less1234567@radius: ~&quot;0px 25px 25px 0 / 0 25px 25px 0px&quot;;.box &#123; width: 100px; height: 100px; border: 1px solid #000; border-radius: @radius;&#125; 在CSS中可以识别/符号，但是在Less中不能识别/符号，所以使用转义处理，在编译时不会编译转义的字符。 5.2.3 延迟加载当一个变量被声明多次，会取最后一次的值，并从当前作用域往外寻找变量： less1234567891011121314151617@color: #ff1493;body &#123; width: 200px; height: 200px; @color: #ff7f50; div &#123; width: 200px; height: 200px; color: @color;// #a52a2a @color: #a52a2a; span &#123; @color: #00ffff; color: @color;// #ffd700 @color: #ffd700; &#125; &#125;&#125; 5.2.4 属性变量可以将其他属性的值作为变量使用： less12345span &#123; border: 1px solid; border-color: #ff7f50; color: $border-color;&#125; 5.3 混合混合就是将一系列属性从一个规则引入到另一个规则集的方式。 创建混合时，如果没有参数，可以省略()不写，建议保留用来区分正常的选择器，并且保留后不会被编译到CSS文件中。 调用混合时，前缀使用.和#都可以，如果没有参数，需要和创建混合时的逻辑一致。 5.3.1 普通混合普通混合： less12345678.border() &#123; border: 1px #ffd700 solid;&#125;div &#123; .border(); background-color: #a52a2a;&#125; 5.3.2 带参数混合带参数的混合，不可以省略部分参数： less123456789.border(@width,@color) &#123; border: @width @color solid;&#125;div &#123; // .border(1px);// RuntimeError .border(1px,#ffd700); background-color: #a52a2a;&#125; 带参数默认值的混合，没有参数时使用默认值，按顺序使用： less12345678.border(@width:1px,@color:#ffd700) &#123; border: @width @color solid;&#125;div &#123; .border(1px); background-color: #a52a2a;&#125; 5.3.3 命名参数混合带参数名称的混合，按参数名称使用，没有参数名称的按顺序使用： less12345678.border(@width:1px,@color:#ffd700) &#123; border: @width @color solid;&#125;div &#123; .border(@color:#ffd700,1px); background-color: #a52a2a;&#125; 5.3.4 包含所有参数使用@arguments使用传入的所有参数： less12345678.border(@width:1px,@color:#ffd700) &#123; border: @arguments solid;&#125;div &#123; .border(1px); background-color: #a52a2a;&#125; 5.3.5 匹配模式在名称和参数名相同的混合中，匹配特定的混合： less1234567891011121314151617181920.size(width,@width:300px) &#123; width: @width; height: 30px;&#125;.size(height,@height:30px) &#123; width: 300px; height: @height;&#125;.size(border,@border:1px) &#123; border: 1px #ffd700 solid;&#125;// 万能匹配，可以匹配任何模式// .size(@_,@size:0) &#123;// display: inline-block;// &#125;div &#123; .size(border);// 默认匹配border中的内容，存在万能匹配时会额外匹配@_中的内容 background-color: #a52a2a;&#125; 5.3.6 命名空间支持通过命名空间选择混合，不同命名空间内的混合可以使用相同的名字： less12345678910111213.border() &#123; .red() &#123; border: 1px #ff2600 solid; &#125; .green() &#123; border: 1px #15ff00 solid; &#125;&#125;div &#123; .border.green(); background-color: #a52a2a;&#125; 5.3.7 条件筛选支持通过when进行筛选，使用and表示且，使用,表示或，使用not表示非： less123456789101112131415.border(@width,@color,@style) when (@color=#ffd700) and (@style=solid) &#123; border: @width @color @style;&#125;.background(@size,@color) when not (@size&lt;12px) &#123; background-color: @color;&#125;.font(@size,@color) when (@size=12px), (@size=14px) &#123; color: @color;&#125;div &#123; .border(1px,#ffd700,solid); .background(12px,#a52a2a); .font(12px,#ffd700);&#125; 5.4 继承5.4.1 并集使用&amp;可以让多个选择器应用同样属性，被应用的必须是CSS选择器，不能是混合： less12345678910111213.border &#123; border: 1px #ffd700 solid;&#125;.border() &#123; border: 1px #ffd700 solid;&#125;div &#123; &amp;:extend(.border);// 继承 .border();// 混合 background-color: #a52a2a;&#125; 编译后： css12345678910.border,div &#123; /* 继承 */ border: 1px #ffd700 solid;&#125;div &#123; /* 混合 */ border: 1px #ffd700 solid; background-color: #a52a2a;&#125; 5.4.2 伪类在编译的时候，会在父子级的选择器之间增加空格： less123456div &#123; background-color: #a52a2a; span &#123; background-color: #ffd700 &#125;&#125; 编译后： css123456div &#123; background-color: #a52a2a;&#125;div span &#123; background-color: #ffd700;&#125; 使用&amp;可以直接拼接，实现伪类选择器： less123456div &#123; background-color: #a52a2a; &amp;:hover &#123; background-color: #ffd700 &#125;&#125; 编译后： css123456div &#123; background-color: #a52a2a;&#125;div:hover &#123; background-color: #ffd700;&#125; 使用&amp;还可以代替父级名称： less123456.list &#123; background-color: #a52a2a; &amp;-span &#123; background-color: #ffd700 &#125;&#125; 编译后： css123456.list &#123; background-color: #a52a2a;&#125;.list-span &#123; background-color: #ffd700;&#125; 5.5 运算支持使用运算结果的值，单位以最左侧数值的单位为准： less123456789101112@size1: (20cm + 10);// 30cm@size2: (20px + 10);// 30px@size3: (20 + 10px);// 30px@size4: (60px / 2cm);// 30px@color: (#446622 / 2);// #223311.size() &#123; background-color: @color;&#125;div &#123; .size();&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Less","slug":"Less","permalink":"https://momashanhe.com/tags/Less/"}]},{"title":"CSS3新特性","slug":"C00-前端/C02-CSS/001-基础/003-CSS3新特性","date":"2024-04-16T07:55:28.000Z","updated":"2025-06-21T08:57:45.988Z","comments":true,"path":"posts/20240416/155528/","permalink":"https://momashanhe.com/posts/20240416/155528/","excerpt":"摘要：本文介绍了CSS3的一些新特性。","text":"摘要：本文介绍了CSS3的一些新特性。 1 简介1.1 概述CSS3是CSS2的升级版本，它在CSS2的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题。 CSS3在未来会按照模块化的方式去发展，官方说明：说明文档 CSS3的新特性如下： 新增了更加实用的选择器，例如伪类选择器和伪元素选择器等。 新增了更好的视觉效果，例如圆角、阴影、渐变等。 新增了丰富的背景效果，例如支持多个背景图片，同时新增了若干个背景相关的属性。 新增了全新的布局方案，即弹性盒子。 新增了Web字体，可以显示用户电脑上没有安装的字体。 增强了颜色，例如HSL、HSLA、RGBA几种新的颜色模式，新增控制元素透明度的属性。 增加了2D变形和3D变形，例如旋转、扭曲、缩放、位移等。 增加动画与过渡效果，让变形更平滑。 1.2 私有前缀W3C标准所提出的某个CSS特性，在被浏览器正式支持之前，需要根据浏览器的内核，通过私有前缀来使用该CSS特性，在浏览器正式支持该CSS特性后，就不需要私有前缀了。 如下代码中的-webkit-就是私有前缀： css12345div &#123; width: 400px; height: 400px; -webkit-border-radius: 20px;&#125; 常见浏览器私有前缀： Chrome浏览器：-webkit- Safari浏览器：-webkit- Firefox浏览器：-moz- Edge浏览器：-webkit- Opera浏览器：-o- IE浏览器：-ms- 查询CSS3兼容性的网站：caniuse 注意： 在编码时，不用过于关注浏览器私有前缀，因为主流浏览器都支持常用的CSS3新特性。 即便是为了老浏览器而加前缀，也可以借助现代的构建工具，比如webpack工具，自动添加私有前缀。 2 增强2.1 新增长度单位新增长度单位： rem：根元素字体大小的倍数，只与根元素字体大小有关，根元素就是html元素 vw：视口宽度的百分之多少，10vw就是视口宽度的10% vh：视口高度的百分之多少，10vh就是视口高度的10% vmax：视口宽高中大的那个的百分之多少 vmin：视口宽高中小的那个的百分之多少 2.2 新增颜色表示CSS3新增了三种颜色设置方式，分别是RGBA、HSL、HSLA，参考：CSS2入门-5-2-颜色 2.3 新增选择器CSS3新增的选择器有伪类选择器和伪元素选择器，参考：CSS2入门-3-4-高级选择器 2.4 新增盒子属性2.4.1 盒子宽高常用属性： 属性名 作用 取值 resize 是否允许用户设置盒子宽高，需要和overflow属性配合使用 none：不允许（默认值） both：允许用户设置盒子宽高 horizontal：只允许用户设置盒子宽度 vertical：只允许用户设置盒子高度 2.4.2 怪异盒子常用属性： 属性名 作用 取值 box-sizing 设置盒模型的类型 content-box：width和height设置的是盒子内容区的大小（默认值） border-box：width和height设置的是盒子总大小（怪异盒子） 2.4.3 盒子阴影常用属性： 属性名 作用 取值 box-shadow 添加阴影 h-shadow：水平阴影的位置，必填，填写数值，可以为负值 v-shadow：垂直阴影的位置，必填，填写数值，可以为负值 blur：可选，模糊距离，填写数值 spread：可选，阴影的外延值，填写数值 color：可选，阴影的颜色，填写颜色代码 inset：可选，将外部阴影改为内部阴影，填写inset固定字符串 none：没有阴影（默认值） 语法： css1box-shadow: 水平位置 垂直位置 模糊距离 外延值 颜色 inset; 注意： 只有先设置blur属性，才能再设置spread属性，只存在spread属性会被当做blur属性。 2.4.4 不透明度常用属性： 属性名 作用 取值 opacity 添加透明效果 0到1之间的小数，0是完全透明，1表示完全不透明 2.5 新增背景属性2.5.1 背景尺寸常用属性： 属性名 作用 取值 background-size 设置背景的尺寸 用长度值指定背景图片宽高，不允许负值 用百分比指定背景图片宽高，不允许负值 auto：背景图片的真实大小（默认值） contain：将背景图片等比缩放，包含在容器内，保证背景在容器内完整显示 cover：将背景图片等比缩放，覆盖到容器内，保证容器内全都有背景显示 2.5.2 背景原点常用属性： 属性名 作用 取值 background-origin 设置背景的原点 padding-box：从padding区域开始显示背景图像（默认值） border-box：从border区域开始显示背景图像 content-box：从content区域开始显示背景图像 2.5.3 背景裁剪常用属性： 属性名 作用 取值 background-clip 设置背景的向外裁剪的区域 border-box：从border区域开始向外裁剪背景（默认值） padding-box：从padding区域开始向外裁剪背景 content-box：从content区域开始向外裁剪背景 text：只在文字上显示背景，前提是color属性值为transparent透明色 2.5.4 背景附着常用属性： 属性名 作用 取值 background-attachment 设置背景在视口内的附着方式，是否跟随页面的滚动条滚动，是否跟随元素的滚动条滚动 scroll：背景相对于元素固定，不跟随元素的滚动条滚动，会跟随页面的滚动条滚动（默认值） fixed：背景相对于视口固定，不跟随元素的滚动条滚动，不跟随页面的滚动条滚动 local：背景相对于元素内容固定，会跟随元素的滚动条滚动，会跟随页面的滚动条滚动 2.5.5 颜色渐变常用属性： 属性名 作用 取值 background-image 设置背景的渐变颜色 linear-gradient：线性渐变，沿直线渐变 radial-gradient：径向渐变，沿弧线渐变 repeating-linear-gradient：循环线性渐变，在没有发生渐变的位置，继续进行线性渐变 repeating-radial-gradient：循环径向渐变，在没有发生渐变的位置，继续进行径向渐变 示例： css12345678910111213141516171819202122/* 线性渐变，默认从上到下渐变 */background-image: linear-gradient(red,yellow,green);/* 线性渐变，使用关键词调整渐变方向 */background-image: linear-gradient(to right top,red,yellow,green);/* 线性渐变，使用角度调整渐变方向 */background-image: linear-gradient(30deg,red,yellow,green);/* 线性渐变，使用像素值调整渐变位置 */background-image: linear-gradient(red 50px,yellow 100px,green 150px);/* 径向渐变，默认从圆心四散 */background-image: radial-gradient(red,yellow,green);/* 径向渐变，使用关键词调整渐变圆心位置 */background-image: radial-gradient(at right top,red,yellow,green);/* 径向渐变，使用像素值调整渐变圆心位置 */background-image: radial-gradient(at 100px 50px,red,yellow,green);/* 径向渐变，使用关键字调整渐变形状为正圆 */background-image: radial-gradient(circle,red,yellow,green);/* 径向渐变，使用像素值调整渐变半径 */background-image: radial-gradient(50px 100px,red,yellow,green);/* 径向渐变，使用像素值调整渐变半径和渐变圆心位置 */background-image: radial-gradient(50px 100px at 100px 50px,red,yellow,green);/* 径向渐变，使用像素值调整渐变位置 */background-image: radial-gradient(red 50px,yellow 100px,green 150px); 2.5.6 复合属性常用属性： 属性名 作用 取值 background 设置背景复合属性 包含全部背景属性，空格分隔 语法： css1background: 颜色 图片地址 重复方式 定位 / 尺寸 原点 裁剪方式; 注意： 原点和裁剪方式的取值相同，如果只写一个值，则表示都设置，如果写了两个值，前面的是原点，后面的是裁剪方式。 尺寸必须写在定位的后面，并且用/分开。 2.5.7 多背景图CSS3允许元素设置多个背景图片。 示例： css1234background: url(images/bg-lt.png) no-repeat left top, url(images/bg-rt.png) no-repeat right top, url(images/bg-lb.png) no-repeat left bottom, url(images/bg-rb.png) no-repeat right bottom; 2.6 新增边框属性2.6.1 边框圆角常用属性： 属性名 作用 取值 border-radius 复合属性，将盒子边框的四个角变为圆角，通过设置半径控制圆角范围 长度值，支持分别设置四个角的不同半径 border-top-left-radius 设置左上角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-top-right-radius 设置右上角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-bottom-left-radius 设置左下角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-bottom-right-radius 设置右下角圆角半径 长度值，支持分别设置水平半径和垂直半径 2.6.2 边框外轮廓常用属性： 属性名 作用 取值 outline-width 外轮廓的宽度 长度值 outline-color 外轮廓的宽度 颜色代码 outline-style 外轮廓的风格 none：无轮廓（默认值） dotted：点状轮廓 dashed：虚线轮廓 solid：实线轮廓 double：双线轮廓 outline-offset 设置外轮廓与边框的距离，正负值都可以设置 长度值 outline 复合属性 可以包含除outline-offset之外的其他样式，空格分隔 2.7 新增文本属性2.7.1 文本阴影常用属性： 属性名 作用 取值 text-shadow 给文本添加阴影 h-shadow：水平阴影的位置，必填，填写数值，可以为负值 v-shadow：垂直阴影的位置，必填，填写数值，可以为负值 blur：可选，模糊距离，填写数值 color：可选，阴影的颜色，填写颜色代码 none：没有阴影（默认值） 语法： css1box-shadow: 水平位置 垂直位置 模糊距离 颜色; 2.7.2 文本换行常用属性： 属性名 作用 取值 white-space 设置文本换行方式 normal：文本超出边界自动换行，文本中的换行被浏览器识别为一个空格（默认值） pre：原样输出，与pre元素的效果相同，超出元素边界不换行 pre-wrap：原样输出，超出元素边界自动换行 pre-line：原样输出，超出元素边界自动换行，只识别文本中的空格，首尾的空格会忽略 nowrap：强制不换行 2.7.3 文本溢出常用属性： 属性名 作用 取值 text-overflow 设置文本内容溢出时的呈现模式 clip：当内联内容溢出时，将溢出部分裁切掉（默认值） ellipsis：当内联内容溢出块容器时，将溢出部分替换为... 注意： 要使得text-overflow属性生效，块容器必须显式定义overflow属性值为非visible的其他值，同时设置white-space属性值为nowrap。 2.7.4 文本修饰常用属性： 属性名 作用 取值 text-decoration 复合属性，升级了文本修饰 包含其他样式，空格分隔 text-decoration-line 设置文本装饰线的位置 none：指定文字无装饰（默认值） underline：指定文字的装饰是下划线 overline：指定文字的装饰是上划线 line-through：指定文字的装饰是贯穿线 text-decoration-style 设置文本装饰线条的形状 solid：实线（默认） double：双线 dotted：点状线条 dashed：虚线 wavy：波浪线 text-decoration-color 设置文本装饰线条的颜色 颜色代码 2.7.5 文本描边常用属性： 属性名 作用 取值 -webkit-text-stroke-width 设置文字描边的宽度 长度值 -webkit-text-stroke-color 设置文字描边的颜色 颜色代码 -webkit-text-stroke 复合属性，设置文字描边宽度和颜色 包含其他样式，空格分隔 注意： 文字描边功能仅webkit内核浏览器支持。 2.8 新增字体属性2.8.1 基本用法可以通过@font-face指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了。 基础语法： css1234@font-face &#123; font-family: &quot;定制字体&quot;; src: url(&quot;webfont.ttf&quot;);&#125; 兼容语法： css12345678910@font-face &#123; font-family: &quot;定制字体&quot;; font-display: swap; src: url(&quot;webfont.eot&quot;); /* IE9 */ src: url(&quot;webfont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), /* IE6-IE8 */ url(&quot;webfont.woff2&quot;) format(&quot;woff2&quot;), url(&quot;webfont.woff&quot;) format(&quot;woff&quot;), /* Chrome, Firefox */ url(&quot;webfont.ttf&quot;) format(&quot;truetype&quot;), /* Chrome, Firefox, Opera, Safari, Android*/ url(&quot;webfont.svg#webfont&quot;) format(&quot;svg&quot;); /* IOS 4.1- */&#125; 2.8.2 定制字体中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制。 可使用阿里Web字体定制工具：阿里Web字体定制 2.8.3 字体图标好处： 相比图片更加清晰，因为字体图标是矢量图，不会在放大后失真。 灵活性高，更方便改变大小、颜色、风格等。 兼容性好，IE也能支持。 常用字体图标库： Font Awesome，优点是版权清晰，缺点是数量比较少，官网地址：Font Awesome 阿里图标，优点是数量多，种类多，缺点是版权不清晰，并且需要登录，官网地址：阿里图标官网 使用图标库： Font Awesome阿里图标使用步骤： 第一步，下载并解压。 第二步，将css和webfonts移动到项目中，css用于声明字体图标名称使用的字体，webfonts中包含了实现图标样式的字体文件。 第三步，将all.css引入到网页中：html1&lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; 第四步，使用图标字体。 使用方式： 方式一，在元素（通常是i元素）中使用class属性，通过样式和名称使用，样式支持简写：html12&lt;i class=&quot;fa-solid fa-car&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-car&quot;&gt;&lt;/i&gt; 方式二，通过CSS样式选择器选中元素后，通过伪元素设置编码和字体使用，支持颜色和外边距等其他样式：css1234567li::before&#123; content: &quot;\\f1b9&quot;; font-family: &quot;Font Awesome 5 Free&quot;; font-weight: 900; color: blue; margin-right: 10px;&#125; 方式三，还可以通过实体的方式使用，不过不太常用：html1&lt;div class=&quot;fas&quot;&gt;&amp;#xf1b9&lt;/div&gt; 图标说明： 免费版的样式有solid和brands，分别代表实心图标和品牌图标，solid样式同类的高级样式还有regular等样式，不过这些高级样式是收费的。 solid样式对应Font Awesome 5 Free字体，brands对应Font Awesome 5 Brands字体。 名称和编码可以在官网查到，每个图标的名称和编码一般是不同的。 阿里图标使用方式： 方式一，下载到本地，参考下载后的说明文档使用即可，方法和Font Awesome类似，也有三种方式。 方式二，在线使用，引入阿里服务器上的文件，其他和下载到本地类似。 2.9 新增对象属性2.9.1 元素位置常用属性： 属性名 作用 取值 object-position 设置对象元素的原点 使用两个维度定位，空格分隔，有多种方式： 1. 使用关键字(水平 垂直)设置位置： 水平：left、center、right 垂直：top、center、bottom 如果只写一个值，另一个方向的值取center 2. 使用坐标(x y)设置图片左上角的位置，以元素左上角为坐标原点： 如果只写一个值，会被当做x坐标，y坐标取center 3. 使用边缘距离设置图片位置，必须有四个值，分为前后两组： 一组代表上下，另一组代表左右，顺序没有要求 每组第一个值代表方向，第二个值代表边距 2.5.3 元素裁剪常用属性： 属性名 作用 取值 object-fit 设置对象元素的向外裁剪的区域 fill：对象被填充，对象将被拉伸以适应内容框（默认值） contain：对象被包含，对象将被保持比例缩放以适应内容框，宽高比不匹配时被添加黑边 cover：对象被覆盖，对象将被保持比例缩放以适应内容框，宽高比不匹配时被裁剪 none：被替换的内容将保持其原有的尺寸 3 变形3.1 2D变形3.1.1 坐标系在学习2D变形和3D变形之前，需要先了解CSS中的坐标系。 原点： 默认在盒子的左上角，包括边框但不包括外边距。 中心： 默认在盒子的几何中心，即两条对角线的交点。 维度： 坐标原点的横向被看作X轴，正值在坐标原点往右，负值在坐标原点往左。 坐标原点的纵向被看作Y轴，正值在坐标原点往下，负值在坐标原点往上。 坐标原点垂直于屏幕的方向被看作Z轴，正值是从坐标原点向屏幕外的方向，负值是从坐标原点向屏幕里的方向。 注意： 因为行内元素不存在宽度和高度，所以2D和3D对行内元素无效。 在3D场景下，因为无法观察Z轴，元素也不存在厚度，所以看到的是元素从3D到2D的投影。 3.1.2 位移常用属性： 属性名 作用 取值 transform 改变元素的位置，参考坐标原点 translateX：设置X轴位移，支持指定长度值和百分比，百分比参考的是自身宽度 translateY：设置Y轴位移，支持指定长度值和百分比，百分比参考的是自身宽度 translate：一个值代表X轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css12transform: translateX(30px) translateY(40px);transform: translate(50%,50%); 和相对定位的比较： 位移与相对定位的相同：都不脱离文档流，不会影响到其它元素。 位移与相对定位的区别：位移的百分比值参考的是其自身，相对定位的百分比值参考的是其父元素。 浏览器针对位移有优化，处理位移的效率比相对定位更高。 位移配合定位，可实现子元素在父元素中同时水平居中和垂直居中： css123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125; 3.1.3 缩放常用属性： 属性名 作用 取值 transform 改变元素的大小，参照中心默认是元素的中心 scaleX：设置X轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scaleY：设置Y轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scale：一个值代表X轴和Y轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css12transform: scaleX(50%) scaleY(50%);transform: scale(50%,50%); 注意： 支持负数，如果设为-1会将原来的元素镜像显示，但几乎不用，因为容易产生误解。 借助缩放，可实现小于12px的文字。 3.1.4 旋转常用属性： 属性名 作用 取值 transform 让元素发生旋转，参照中心默认是元素的中心 rotateZ：设置2D旋转的角度值，绕Z轴旋转，正值顺时针，负值逆时针 rotate：一个值代表2D旋转，正值顺时针，负值逆时针 示例： css12transform: rotateZ(30deg);transform: rotate(30deg); 3.1.5 扭曲常用属性： 属性名 作用 取值 transform 让元素发生拉扯变形 skewX：设置元素在X轴扭曲的角度值，不改变宽度，正值左上角向左同时右下角向右，负值左上角向右同时右下角向左 skewY：设置元素在Y轴扭曲的角度值，不改变高度，正值左上角向上同时右下角向下，负值左上角向下同时右下角向上 skew：一个值代表X轴和Y轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css123transform: skewX(30deg);transform: skewY(30deg);transform: skew(30deg,30deg); 3.1.6 多重变形常用属性： 属性名 作用 取值 transform 复合属性，支持多种变形 包含其他样式，空格分隔 示例： css1transform: translate(50%,50%) scale(50%,50%) rotate(30deg) skew(30deg,30deg); 注意： 如果位移前有缩放，位移的距离需要乘以缩放的倍数，尽量将位移写在前面。 如果位移前有旋转，旋转的参照中心不会受位移影响，尽量将旋转写在后面。 3.1.7 变形原点常用属性： 属性名 作用 取值 transform-origin 设置变形的原点，对于缩放和旋转来说，改变的是参照中心 支持长度值、百分比、关键字，一个值跟类型有关，另一个取中间点，两个值分别代表X轴和Y轴，空格分隔 示例： css1transform-origin: left top; 注意： 变形原点对位移的影响是看不出来效果的，对缩放和旋转的影响是能看出来的，将设置的原点作为参照中心。 如果只设置了长度值或百分比，则表示X轴，Y轴取中间点，如果只设置了关键字，则根据关键字表示X轴或Y轴，另一个取中间点。 3.2 3D变形3.2.1 开启3D空间常用属性： 属性名 作用 取值 transform-style 开启3D空间，元素进行3D变形的前提是父元素开启3D空间 flat：让子元素位于此元素的二维平面内，即2D空间（默认值） preserve-3d：让子元素位于此元素的三维空间内，即3D空间 示例： css123.parent &#123; transform-style: preserve-3d;&#125; 3.2.2 设置景深景深指的是观察者与z=0平面的距离，能让发生3D变形的元素产生透视效果，让元素的投影看起来更加立体。 常用属性： 属性名 作用 取值 perspective 设置景深，需要给父元素设置 none：不指定透视（默认值） 长度值：指定观察者距离z=0平面的距离，负数会被认为是默认值none，最小值是0，趋近于0表示观察者贴近平面 示例： css123.parent &#123; perspective: 200px;&#125; 注意： 如果设置了X轴或Y轴的旋转，可以看到子元素投影受父元素景深的影响。 如果未设置X轴或Y轴的旋转，并且Z轴的位移等于0，相当于2D平面的子元素，不受父元素景深的影响。 如果未设置X轴或Y轴的旋转，并且Z轴的位移大于0，此时子元素在投影前面，随着景深的减少：3.1 当景深大于位移时，观察者贴近子元素，子元素投影变大。3.2 当景深等于或者小于位移时，观察者贴合子元素，子元素投影消失。3.3 当景深小于0时，取值无效，不指定景深，子元素投影相当于2D平面的子元素。 如果未设置X轴或Y轴的旋转，并且Z轴的位移小于0，此时子元素在投影后面，随着景深的减少：4.1 当景深大于0时，观察者贴近子元素，子元素投影变小。4.2 当景深等于0时，观察者贴合2D平面，子元素投影相当于2D平面的一个点。4.3 当景深小于0时，取值无效，不指定景深，子元素投影相当于2D平面的子元素。 3.2.3 设置透视点位置透视点位置就是观察者位置，默认的透视点在元素的中心。 常用属性： 属性名 作用 取值 perspective-origin 设置透视点位置，需要给父元素设置 支持长度值、百分比、关键字，一个值跟类型有关，另一个取中间点，两个值分别代表X轴和Y轴 示例： css123.parent &#123; perspective-origin: left top;&#125; 3.2.4 位移常用属性： 属性名 作用 取值 transform 在2D位移的基础上让元素沿Z轴位移，参考坐标原点 translateZ：设置Z轴位移，只支持长度值，正值向屏幕外，负值向屏幕里 translate3d：三个值分别代表X轴、Y轴、Z轴，逗号分隔，三个值必须同时设置，否则无效 示例： css12transform: translateZ(30px);transform: translate3d(50%,50%,30px); 注意： 在X轴和Y轴的设置支持长度值和百分比，在Z轴的设置只支持长度值，因为元素没有厚度的概念，无法通过百分比确定具体长度值。 只有在父元素的perspective属性值存在且大于0的情况下，才能设置Z轴的位移。 当Z轴的位移大于perspective属性值的时候，元素位移到了观察者后面，即观察者看不到元素。 3.2.5 缩放常用属性： 属性名 作用 取值 transform 在2D缩放的基础上让元素沿Z轴缩放，参考坐标原点 scaleZ：设置Z轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scale3d：三个值分别代表X轴、Y轴、Z轴，逗号分隔，三个值必须同时设置，否则无效 示例： css12transform: scaleZ(0.5);transform: scale3d(0.5,0.5,0.5); 注意： 在Z轴进行缩放，理论上是对元素的厚度进行缩放，但是元素没有厚度的概念，所以其实是让元素更贴近观察者，效果上类似调整景深。 在Z轴放大的效果，类似景深缩小相同倍数的效果，在Z轴缩小的效果，类似景深放大相同倍数的效果。 3.2.6 旋转常用属性： 属性名 作用 取值 transform 在2D旋转的基础上让元素沿X轴和Y轴旋转，参照中心默认是元素的中心 rotateX：设置X轴旋转的角度值，正值顺时针，负值逆时针 rotateY：设置Y轴旋转的角度值，正值顺时针，负值逆时针 rotate3d：前三个值分别代表X轴、Y轴、Z轴，第四个值代表旋转的角度，四个值必须同时设置，否则无效 示例： css12transform: rotateX(30deg) rotateY(30deg);transform: rotate3d(1,1,1,30deg); 注意： 通过rotate3d设置的前三个值描述的是坐标轴的矢量定义，取值是从0到1的矢量值。 即使rotate3d的前三个值超过1的数值，也会进行内部隐式标准化： 比如rotate3d(9,9,9,30deg)相当于rotate3d(1,1,1,30deg)的效果。 比如rotate3d(10,1,0.5,30deg)相当于rotate3d(1,0.1,0.05,30deg)的效果。 3.2.7 多重变形同2D多重变形类似，支持3D参数，建议将位移写前面同时将旋转写后面。 3.2.8 背部可见性将元素在X轴旋转或者Y轴旋转前显示的一面称为正面，将元素在X轴旋转或者Y轴旋转后显示的一面称为背面。 常用属性： 属性名 作用 取值 backface-visibility 设置元素背面在面向用户时是否可见 visible：设置元素背面可见，允许显示正面的镜像（默认值） hidden：设置元素背面不可见 示例： html1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;背部可见性示例&lt;/title&gt; &lt;style&gt; body &#123; perspective: 500px; &#125; .box &#123; position: relative; width: 300px; height: 300px; margin: 100px auto; transform-style: preserve-3d; &#125; .box:hover &#123; transform: rotate3d(0,1,0,180deg); &#125; .box&gt;div &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; text-align: center; line-height: 300px; &#125; .front &#123; background-color: pink; &#125; .back &#123; background-color: coral; /* 预先旋转显示下层元素 */ transform: rotateY(180deg); /* 给上层元素设置背面不可见 */ backface-visibility: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;前面的图片在下层&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;后面的图片在上层&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 注意： 父元素作为盒子，两个子元素分别表示前面和后面，开启定位让两个子元素在同一位置，后面元素在前面元素上层，并且不会随父元素旋转而改变。 上层元素预先旋转：上层元素在父元素旋转前显示正面，上层元素在父元素旋转后显示背面。所以先将上层元素进行旋转显示背面，这样在父元素旋转后就能显示正面。 上层元素背面不可见：将上层元素进行旋转，并且上层元素的背面不可见后，显示下层元素的正面，父元素旋转后，上层元素显示正面，挡住了下层元素，所以下层元素背面是否可见是不影响的。 4 过渡过渡可以在不使用Flash动画，不使用JS的情况下，让元素从一种样式平滑过渡为另一种样式。 常用属性： 属性名 作用 取值 transition-property 定义过渡的属性，只有定义的属性才会有过渡效果 none：不过渡任何属性 all：过渡所有能过渡的属性 属性名：逗号分隔的多个属性名 transition-duration 定义过渡的时间，完成过渡需要的时间，时间越长过渡越平滑 0：没有过渡时间，即不过渡（默认值） 单个时间：所有属性设置相同时间，单位是s或者ms，表示秒或者毫秒 多个时间：给不同的属性设置不同的时间，逗号分隔，过渡时间和过渡属性对应 transition-delay 定义过渡的延迟，触发过渡后多久开始过渡 单位是s或者ms，表示秒或者毫秒 transition-timing-function 定义过渡的类型 ease：平滑过渡（默认值） linear：线性过渡 ease-in：过渡由慢到快 ease-out：过渡由快到慢 ease-in-out：过渡由慢到快再到慢 steps(integer,?)：接受两个参数的步进函数 step-start：等同于steps(1,start) step-end：等同于steps(1,end) cubic-bezie(number,number,number,number)：特定的贝塞尔曲线类型 transition 复合属性，支持多种过渡 包含其他样式，空格分隔，如果时间只有一个，则表示过渡时间，如果时间有两个，则最后一个表示过渡延迟 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。 常见的支持过渡的属性有： 颜色 长度值 百分比 z-index opacity 2D变形属性 3D变形属性 阴影 步进函数： 第一个参数是正整数，指定函数的步数。 第二个参数是start或end，指定每一步的值发生变化的时间点，默认值为end。 贝塞尔曲线： 英文名是Bezier Curve，又称贝兹曲线或贝济埃曲线，可以通过二维坐标系描述曲线。 在线制作贝赛尔曲线：cubic-bezier 5 动画5.1 帧和关键帧一段动画，就是一段时间内连续播放多个画面，每一张画面称为一帧。同样时间内，播放的帧数越多，画面看起来越流畅。 关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的2-3帧，可以理解为和前后有明显差别的帧。 早期要求1秒内最低24帧，现在主流使用的是60帧，对延迟要求高的应用要求120帧或者更高。 5.2 基本使用5.2.1 定义动画定义动画实际上指的是定义一组关键帧，使用@keyframes设置动画名，可以定义多个动画名，但动画名不可以重复。 有两种方式： 第一种，简单方式定义：css12345678910@keyframes 动画名 &#123; from &#123; /*property1:value1*/ /*property2:value2*/ &#125; to &#123; /*property1:value1*/ /*property2:value2*/ &#125;&#125; 第二种，完整方式定义：css1234567891011121314151617181920@keyframes 动画名 &#123; 0% &#123; /*property1:value1*/ &#125; 20% &#123; /*property1:value1*/ &#125; 40% &#123; /*property1:value1*/ &#125; 60% &#123; /*property1:value1*/ &#125; 80% &#123; /*property1:value1*/ &#125; 100% &#123; /*property1:value1*/ &#125;&#125; 5.2.2 给元素应用动画常用属性： 属性名 作用 取值 animation-name 给元素指定具体的动画 动画名 animation-duration 设置动画所需时间 单位是s或者ms animation-delay 设置动画延迟 单位是s或者ms 示例： css12345678.box &#123; /* 指定动画 */ animation-name: testKey; /* 设置动画所需时间 */ animation-duration: 5s; /* 设置动画延迟 */ animation-delay: 0.5s;&#125; 5.3 动画的其他属性常用属性： 属性名 作用 取值 animation-timing-function 设置动画的类型 ease：平滑过渡（默认值） linear：线性过渡 ease-in：过渡由慢到快 ease-out：过渡由快到慢 ease-in-out：过渡由慢到快再到慢 steps(integer,?)：接受两个参数的步进函数 step-start：等同于steps(1,start) step-end：等同于steps(1,end) cubic-bezie(number,number,number,number)：特定的贝塞尔曲线类型 animation-iteration-count 设置动画的播放次数 数值：动画循环次数 infinite：无限循环 animation-direction 设置动画方向 normal：正常方向（默认） reverse：反方向运行 alternate：动画先正常运行再反方向运行，并持续交替运行，要求动画播放至少两次 alternate-reverse：动画先反运行再正方向运行，并持续交替运行，要求动画播放至少两次 animation-fill-mode 设置动画之外的状态 forwards：设置对象状态为动画结束时的状态，要求动画播放有限次数 backwards：设置对象状态为动画开始时的状态，要求动画播放有限次数 animation-play-state 设置动画的播放状态 running：运动（默认） paused：暂停 5.4 复合属性常用属性： 属性名 作用 取值 animation 设置动画复合属性 包含其他样式，空格分隔，如果时间只有一个，则表示动画时间，如果时间有两个，则最后一个表示动画延迟 注意： 设置动画的播放状态的animation-play-state属性一般单独使用，复合使用会导致动画重新播放。 和过渡的区别： 动画不需要事件触发，过渡需要触发。 过渡只有开始和结束两个关键帧，动画可以设置多个关键帧，可以进行更细力度的控制。 6 多列布局专门用于实现类似于报纸的布局。 分列数量相关属性： 属性名 作用 取值 column-count 指定列数 数值 column-width 指定列宽，自动计算列数 长度值 columns 同时指定列宽和列数，复合属性，取列数少的效果（不推荐使用） 包含列宽和列数，空格分隔 分列边框相关属性： 属性名 作用 取值 column-rule-style 设置列与列之间边框的风格 none：无（默认值） solid：实线 dashed：虚线 dotted：点线 double：双实线 column-rule-width 设置列与列之间边框的宽度 长度值 column-rule-color 设置列与列之间边框的颜色 颜色代码，默认黑色 column-rule 设置列与列之间边框，复合属性 包含边框样式，空格分隔 分列其他属性： 属性名 作用 取值 column-gap 设置列边距 长度值 column-span 设置是否跨列 none：不跨列（默认值） all：跨列 注意： 除了column-span属性要在跨列的元素上设置，其他属性都是在父元素上设置的。 7 弹性盒子7.1 简介2009年，W3C提出了一种新的盒子模型，即弹性盒子（Flexible Box），也称为伸缩盒模型，它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序、等等。 截止目前，除了在部分IE浏览器不支持，其他浏览器均已全部支持。 弹性盒子的出现，逐渐演变出了一套新的布局方案，即弹性布局，也称为Flex布局。 布局方式： 传统布局弹性布局传统模型布局分三种模型，并且这三种模型紧密联系： 流动模型（Flow）：默认的网页布局模式，块级元素宽度总是100%，并且自上而下垂直分布，行内元素在包含元素内从左到右水平分布。 浮动模型（Float）：当元素设置了float属性，就会依照浮动的位置进行特定的定位。 层模型（Layer）：当元素设置了position属性，就会依照定位类型进行特定的定位。 因此，传统模型布局主要基于传统盒子模型、display属性、float属性、position属性。弹性布局可以为盒状模型提供最大的灵活性，目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上。 7.2 弹性容器和弹性项目将元素的display属性设为flex或者设为inline-flex就可以将该元素变为弹性容器，其子元素（不包括后代元素）会变为弹性项目。 无论原来是哪种元素（块、行内块、行内），一旦成为了弹性项目，全都会块状化，如果没有设置宽度和高度，默认由内容撑开。 7.3 主轴与侧轴概念： 主轴：项目沿主轴排列，默认方向是水平从左到右。 侧轴：与主轴垂直的就是侧轴，默认方向是垂直从上到下。 主轴换行相关属性： 属性名 作用 取值 flex-direction 设置主轴方向，同时也会影响侧轴方向 row：主轴方向水平从左到右（默认值） row-reverse：主轴方向水平从右到左 column：主轴方向垂直从上到下 column-reverse：主轴方向垂直从下到上 flex-wrap 设置主轴换行方式 nowrap：主轴不换行，允许项目的高度超出容器，不允许项目的宽度超出容器，宽度超出时会压缩容器（默认值） wrap：主轴自动换行，允许项目的高度超出容器，不允许项目的宽度超出容器，宽度超出时会换行 wrap-reverse：主轴自动反转换行，每一行的项目还是从左到右，但是每行的项目是从下到上排列，向上超出容器 flex-flow 复合属性 包含方向和换行，空格分隔 水平对齐相关属性： 属性名 作用 取值 justify-content 设置主轴对齐方式，控制项目水平位置 flex-start：主轴起点对齐（默认值） flex-end：主轴终点对齐 center：水平居中对齐 space-between：主轴水平分散对齐，中间均匀分布，项目紧贴两端（最常用） space-around：中间均匀分布，项目到两端距离与项目之间距离的一半相同 space-evenly：中间均匀分布，项目到两端距离与项目之间距离相同 垂直对齐相关属性： 属性名 作用 取值 align-items 设置侧轴对齐方式，以单个项目作为控制目标，控制项目在单行的垂直位置 flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：垂直居中对齐 baseline：每行项目的第一行文字的基线对齐，后面的大字体项目会向上超出容器高度 stretch：如果项目设置了高度，按照起点对齐，如果项目没有设置高度，将占满整个容器的高度（默认值） align-content 设置侧轴对齐方式，以一行项目作为控制目标，控制一行项目在容器的垂直位置，设置换行后有效 flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：垂直居中对齐 space-between：侧轴垂直分散对齐，中间均匀分布，项目紧贴两端 space-around：中间均匀分布，项目到两端距离与项目之间距离的一半相同 space-evenly：中间均匀分布，项目到两端距离与项目之间距离相同 stretch：如果项目设置了高度，按照起点对齐，如果项目没有设置高度，将占满整个容器的高度（默认值） 垂直对齐显示逻辑： 第一种，对于设置换行但是没有超出容器的项目，将容器高度减去每行项目的最大高度，得到的剩余高度按照行数平均分开，和每行项目的最大高度一起作为行高。 第二种，使用align-items属性将每行最大高度和剩余平均高度作为行高，可以控制项目在行高里的垂直对齐，不能控制每行在容器里的垂直对齐。 第三种，使用align-content属性将每行最大高度作为行高，可以控制每行在容器里的垂直对齐，不能控制项目在行高里的垂直对齐。并且只有设置换行，该属性才会生效，即单行无效。 同时水平居中和垂直居中： 第一步，在父元素开启弹性布局后，在父元素中设置水平居中和垂直居中：css123456.outer &#123; display: flex; justify-content: center; align-items: center; align-content: center;&#125; 第二步，在父元素开启弹性布局后，在子元素中设置外边距自动：css123456789.outer &#123; display: flex; justify-content: center; align-items: center; align-content: center;&#125;.inner &#123; margin: auto;&#125; 7.4 基准长度常用属性： 属性名 作用 取值 flex-basis 设置项目主轴方向的基准长度，主轴横向会让宽度失效，主轴纵向会让高度失效 0：无（默认值） solid：实线 dashed：虚线 dotted：点线 其他长度值：指定长度 flex-grow 设置项目的放大权重，默认为0，即使主轴存在剩余空间，该项目也不放大，前提是主轴存在剩余空间，否则无效 放大权重 flex-shrink 设置项目的缩小权重，默认为1，如果空间不足，该项目将会缩小 缩小权重 flex 复合属性 包含上述属性按照顺序设置，空格分隔： 1. 不放大，缩小，默认基准（默认值）： flex: 0 1 auto; 简写：flex: 0 auto; 2. 不放大，不缩小，默认基准 flex: 0 0 auto; 简写：flex: none; 3. 放大，缩小，默认基准 flex: 1 1 auto; 简写：flex: auto; 4. 放大，缩小，最小长度： flex: 1 1 0px; 简写：flex: 1; 基准长度显示规则： 默认情况下，以内容作为宽度显示。 如果设置项目宽度，以项目宽度显示。 如果设置项目宽度，又设置基准长度，如果内容长度小于基准长度，以基准长度显示，如果内容长度大于基准长度，比较项目宽度和内容长度，以最小值显示。 按权重放大规则： 默认为0，表示不放大。 如果所有项目设置为1，计算公式：项目放大的长度=剩余长度×(1÷项目数量) 如果项目设置的不同，计算公式：项目放大的长度=剩余长度×(当前权重÷&#123;(每个项目权重)求和&#125;) 按权重缩小规则： 默认为1，表示如果项目长度超出，就按权重缩小项目长度，计算公式：项目缩小的长度=超出长度×[(1×项目长度)÷&#123;(1×每个项目长度)求和&#125;] 如果项目设置的不同，计算公式：项目缩小的长度=超出长度×[(当前权重×项目长度)÷&#123;(每个项目权重×每个项目长度)求和&#125;] 7.5 单独对齐常用属性： 属性名 作用 取值 align-self 设置单独项目的对齐方式 参考align-items属性，默认值为auto，表示继承父元素的align-items属性 7.6 项目排序常用属性： 属性名 作用 取值 order 设置项目的排列顺序，数值越小，排列越靠前，默认为0，支持负值 数值 8 BFCBFC，即块级格式化上下文（Block Formatting Context），可以理解为一种功能，当某些情况下元素满足条件时开启。 开启BFC的元素所具有的特点： 元素开启BFC后，其子元素不会再产生外边距塌陷问题。 元素开启BFC后，元素自身不会被其他浮动元素所覆盖。 元素开启BFC后，就算其子元素浮动，元素自身高度也不会塌陷。 开启BFC的方式： 根元素默认开启。 表格相关的元素默认开启。 行内块元素默认开启。 给块元素的overflow属性设置不为visible的值后自动开启。 将元素改为浮动元素后自动开启。 给元素设置绝对定位或固定定位，称为定位元素后自动开启。 弹性布局中的弹性项目自动开启。 多列布局中的多列容器自动开启。 多列布局中的多列项目，将元素的column-span属性的值设置为all后自动开启。 将元素的display属性的值设置为flow-root后自动开启。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"HTML5新特性","slug":"C00-前端/C01-HTML/001-基础/003-HTML5新特性","date":"2024-04-14T14:19:20.000Z","updated":"2025-06-21T08:57:47.350Z","comments":true,"path":"posts/20240414/221920/","permalink":"https://momashanhe.com/posts/20240414/221920/","excerpt":"摘要：本文介绍了HTML5的一些新特性。","text":"摘要：本文介绍了HTML5的一些新特性。 1 简介HTML5是新一代的HTML标准，2014年10月由万维网联盟（W3C）完成标准制定。 HTML5在狭义上是指新一代的HTML标准，在广义上是指整个前端。 官网地址： W3C官网：https://www.w3.org/TR/html/index.html WHATWG官网：https://whatwg-cn.github.io/html/multipage 优势： 针对JS新增了很多可操作的接口。 新增了一些布局元素和全局属性。 新增了多媒体元素，可以很好的替代Flash。 更加侧重语义化，对于SEO更友好。 可移植性好，可以大量应用在移动设备上。 2 新增元素2.1 新增布局元素新增的元素： 标签名 说明 单双 header 整个页面，或部分区域的头部 双标签 footer 整个页面，或部分区域的底部 双标签 nav 导航 双标签 article 文章 双标签 section 章节 双标签 aside 侧边栏 双标签 2.2 新增标量测量元素新增的元素： 标签名 说明 单双 meter 定义已知范围内的标量测量，也被称为尺度 双标签 常用属性： 属性名 作用 取值 high 规定高值 数值 low 规定低值 数值 max 规定最大值 数值 min 规定最小值 数值 optimum 规定最优值 数值 value 规定当前值 数值 2.3 新增进度显示元素新增的元素： 标签名 说明 单双 progress 显示某个任务完成的进度的指示器，一般用于表示进度条 双标签 常用属性： 属性名 作用 取值 max 规定目标值 数值 value 规定当前值 数值 2.4 新增列表元素新增的元素： 标签名 说明 单双 details 用于展示问题和答案，或对专有名词进行解释 双标签 summary 写在details元素的里面，用于指定问题或专有名词 双标签 2.5 新增文本元素新增的元素： 标签名 说明 单双 ruby 包裹需要注音的文字 双标签 rt 注音，写在ruby元素里面 双标签 mark 标记文字，建议用于标记搜索结果中的关键字 双标签 3 表单功能增强3.1 新增通用属性新增属性： 属性名 作用 取值 placeholder 提示文字，适用于文字输入类的表单控件 文字 required 是否必填，适用于除按钮外其他表单控件，表单提交时会验证 无 autofocus 自动获取焦点，适用于所有表单控件，对焦点时首个有效 无 autocomplete 自动完成，适用于文字输入类的表单控件，密码输入框和多行输入框不可用 on：默认值，自动完成 off：不自动完成 pattern 填写正则表达式校验输入内容是否符合表达式，适用于文本输入类表单控件，往往与required属性配合 正则表达式 3.2 输入框类型增强input元素新增类型，对type属性新增的可选值： email：邮箱类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 url：URL类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 number：数字类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 search：搜索类型的输入框，表单提交时不会验证格式。 tel：电话类型的输入框，表单提交时不会验证格式，在移动端使用时，会唤起数字键盘。 range：范围选择框，默认值为50，表单提交时不会验证格式。 color：颜色选择框，默认值为黑色，表单提交时不会验证格式。 date：日期选择框，默认值为空，表单提交时不会验证格式。 month：月份选择框，默认值为空，表单提交时不会验证格式。 week：周选择框，默认值为空，表单提交时不会验证格式。 time：时间选择框，默认值为空，表单提交时不会验证格式。 datetime-local：日期时间选择框，默认值为空，表单提交时不会验证格式。 3.3 新增表单属性form元素新增属性： 属性名 作用 取值 novalidate 表单提交的时候不再进行验证 无 3.4 新增下拉框元素下拉框增强，可以在输入框选择下拉选项。 新增的元素： 标签名 说明 单双 datalist 用于搜索框的关键字提示，类似select元素 双标签 需要配合input元素的list属性使用： html123456789&lt;form action=&quot;#&quot;&gt; 请选择省份：&lt;input type=&quot;text&quot; list=&quot;province&quot;&gt; &lt;datalist id=&quot;province&quot;&gt; &lt;option value=&quot;黑&quot;&gt;黑龙江&lt;/option&gt; &lt;option value=&quot;辽&quot;&gt;辽宁&lt;/option&gt; &lt;option value=&quot;吉&quot;&gt;吉林&lt;/option&gt; &lt;option value=&quot;粤&quot;&gt;广东&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; 4 支持多媒体功能新增的元素： 标签名 说明 单双 audio 表示音频 双标签 video 表示视频 双标签 audio元素常用属性： 属性名 作用 取值 src 音频URL地址 URL地址 controls 向用户显示音频控件，比如播放和暂停按钮 无 muted 音频静音播放 无 autoplay 音频自动播放，媒体参与度超过阈值时才会有效 无 loop 音频循环播放 无 preload 音频预加载，如果使用了autoplay属性，则忽略该属性 none：不预加载音频 metadata：仅预先获取音频的元数据，例如长度 auto：可以下载整个音频文件，即使用户不希望使用它 video元素常用属性： 属性名 作用 取值 src 视频URL地址 URL地址 width 设置视频播放器的宽度 长度值 height 设置视频播放器的高度 长度值 controls 向用户显示视频控件，比如播放和暂停按钮 无 muted 视频静音播放 无 autoplay 视频自动播放，媒体参与度超过阈值时才会有效 无 loop 视频循环播放 无 poster 视频封面 URL地址 preload 视频预加载，如果使用了autoplay属性，则忽略该属性 none：不预加载视频 metadata：仅预先获取视频的元数据，例如长度 auto：可以下载整个视频文件，即使用户不希望使用它 媒体参与度： 启动autoplay属性并不能自动播放，还需要判断媒体参与度。 媒体参与度指的是用户和网页媒体的交互程度，媒体参与度超过阈值以后，才会在启动autoplay属性的前提下激活自动播放。 媒体参与度查询网址：媒体参与度查询 5 新增全局属性新增属性： 属性名 作用 取值 contenteditable 表示元素是否可被用户编辑 true：可编辑 false：不可编辑 draggable 表示元素可以被拖动 true：可拖动 false：不可拖动 hidden 隐藏元素 无 spellcheck 规定是否对元素进行拼写和语法检查 true：检查 false：不检查 contextmenu 规定元素的上下文菜单，在用户鼠标右键点击元素时显示 无 data-* 用于存储页面的私有定制数据 定制数据 6 兼容性处理添加元信息，让浏览器处于最优渲染模式： html1234&lt;!-- 设置IE总是使用最新的文档模式进行渲染 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;!-- 优先使用webkit内核（Chromium）进行渲染，针对360等壳浏览器 --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 使用html5shiv.js让低版本浏览器认识H5元素，但某些元素仍然不能被低版本浏览器识别： html123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;./js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 扩展： lt：小于 lte：小于等于 gt：大于 gte：大于等于 !：逻辑非 示例： html123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]--&gt;&lt;!--[if lt IE 8]&gt;仅IE8以下可见&lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]--&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"}]},{"title":"Emmet语法规则","slug":"C00-前端/C02-CSS/002-技巧/001-Emmet语法规则","date":"2024-04-07T02:47:45.000Z","updated":"2025-06-21T08:57:45.508Z","comments":true,"path":"posts/20240407/104745/","permalink":"https://momashanhe.com/posts/20240407/104745/","excerpt":"摘要：本文学习了如何通过Emmet工具快速编写HTML和CSS代码。","text":"摘要：本文学习了如何通过Emmet工具快速编写HTML和CSS代码。 环境 Visual Studio Code 1.88.1 1 简介Emmet是一个缩写扩展工具，用于快速编写HTML和CSS代码。它最初是为Web开发者设计的，以提高编写代码的效率。 通过Emmet可以快速生成复杂的页面结构，大多数编辑器也支持Emmet规则，但不同的编辑器在快捷键合具体实现上可能不同。 本文使用VSCode编辑器进行学习，需要在输入相应规则后使用Tab键让编辑器通过规则生成代码。并且在输入规则后，编辑器会显示可能用到的规则，十分方便。 2 规则2.1 初始化页面使用!可以生成基础的HTML页面： html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.2 id和class使用#和.可以生成元素，并给生成的元素设置id属性和class属性，类似元素选择器，支持组合使用： html123456&lt;!-- div#main --&gt;&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;!-- div.main --&gt;&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;!-- div#head.box.item --&gt;&lt;div id=&quot;head&quot; class=&quot;box item&quot;&gt;&lt;/div&gt; 2.3 属性使用类似属性选择器的写法可以生成指定属性的元素： html12&lt;!-- div[name=&quot;header&quot;] --&gt;&lt;div name=&quot;header&quot;&gt;&lt;/div&gt; 2.4 关系使用&gt;生成子元素，使用^生成父元素，使用+生成兄弟元素： html1234567891011121314151617181920212223242526272829&lt;!-- div&gt;p --&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- div&gt;p&gt;span --&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- span^div --&gt;&lt;span&gt;&lt;/span&gt;&lt;div&gt;&lt;/div&gt;&lt;!-- div&gt;p&gt;span^p --&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- div&gt;p&gt;span^^p --&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- div+p --&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- div&gt;p+p --&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 2.5 重复使用*生成相同多个元素： html123456789&lt;!-- p*2 --&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- ul&gt;li*3 --&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 2.6 编号使用$的个数表示序号的位数，使用*表示元素的数量，使用@表示从几开始，默认从1开始： html123456789101112131415&lt;!-- p.p$*2 --&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;&lt;/p&gt;&lt;!-- ul&gt;li*3 --&gt;&lt;ul&gt; &lt;li class=&quot;item01&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item02&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item03&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- ul&gt;li.item$$@5*3 --&gt;&lt;ul&gt; &lt;li class=&quot;item05&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item06&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item07&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 2.7 内容使用&#123;&#125;可以指定元素内容： html12&lt;!-- p&#123;好好学习，天天向上。&#125; --&gt;&lt;p&gt;好好学习，天天向上。&lt;/p&gt; 2.8 分组使用()分隔规则，将内部规则作为整体，生成复杂结构时会用到： html123456789101112131415161718192021&lt;!-- div&gt;ul&gt;li#link$*2&gt;a+p --&gt;&lt;div&gt; &lt;ul&gt; &lt;li id=&quot;link1&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;li id=&quot;link2&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;p&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- div&gt;(ul&gt;li#link$*2&gt;a)+p --&gt;&lt;div&gt; &lt;ul&gt; &lt;li id=&quot;link1&quot;&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;link2&quot;&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"进阶","slug":"C00-前端/C02-CSS/001-基础/002-进阶","date":"2024-04-05T06:24:36.000Z","updated":"2025-06-21T09:32:44.189Z","comments":true,"path":"posts/20240405/142436/","permalink":"https://momashanhe.com/posts/20240405/142436/","excerpt":"摘要：本文介绍了CSS的进阶使用，包括长度单位、显示模式、盒子模型以及布局相关技巧。","text":"摘要：本文介绍了CSS的进阶使用，包括长度单位、显示模式、盒子模型以及布局相关技巧。 1 长度单位CSS中主要有以下几种长度单位： px：像素 em：元素字体大小的倍数 %：父元素对应属性的百分比 CSS中设置长度，必须加单位，否则样式无效。 2 显示模式2.1 分类2.1.1 块级元素又称为块元素（block）。 特点： 在页面中独占一行，不会与任何元素共用一行，从上到下排列。 默认宽度：撑满父元素。 默认高度：由内容撑开。 可以通过CSS设置宽高。 相关元素： 主体结构元素：html、body 排版相关元素：h1~h6、div、hr、p、pre、div 列表相关元素：ul、ol、li、dl、dt、dd 表格相关元素：table、tbody、thead、tfoot、caption、tr 表单相关元素：form、option 2.1.2 行内元素又称为内联元素（inline）。 特点: 在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 默认宽度：由内容撑开。 默认高度：由内容撑开。 无法通过CSS设置宽高。 相关元素： 文本：br、span、em、strong、sup、sub、del、ins 标记：label 超链接：a 2.1.3 行内块元素又称为内联块元素（inline-block）。 特点： 在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 默认宽度：由内容撑开。 默认高度：由内容撑开。 可以通过CSS设置宽高。 相关元素： 图片：img 表格：th、td 表单：input、textarea、select、button 框架：iframe 如果按照“是否独占一行”进行分类，行内块元素应该算作行内元素。 2.2 设置显示模式常用属性： 属性名 作用 取值 display 控制元素的显示模式 none：元素会被隐藏 block：元素将作为块级元素显示 inline：元素将作为内联元素显示 inline-block：元素将作为行内块元素显示 示例： css1display: none; 3 盒子模型3.1 概念CSS会把所有的HTML元素都看成一个盒子，所有的样式也都是基于这个盒子。 相关概念： content（内容）：盒子内容，也就是元素内容。 padding（内边距）：盒子内部边距，盒子内容与盒子边框的补白区域。 border（边框）：盒子边框，分隔盒子的内外区域。 margin（外边距）：盒子外部边距，盒子边框与其他盒子的间隔区域。 说明： 盒子的大小&#x3D;内容的大小+内边距的大小+边框的大小。 盒子的外边距不受盒子样式的影响，不会影响盒子的大小，只会影响盒子的位置。 图示如下： 3.2 相关属性3.2.1 盒子内容相关常用属性： 属性名 作用 取值 width 设置内容区域宽度 长度值 max-width 设置内容区域的最大宽度，一般不与width一起使用 长度值 min-width 设置内容区域的最小宽度，一般不与width一起使用 长度值 height 设置内容区域高度 长度值 max-height 设置内容区域的最大高度，一般不与height一起使用 长度值 min-height 设置内容区域的最小高度，一般不与height一起使用 长度值 如果没有设置宽度和高度： 总宽度&#x3D;父盒子content-自身左右margin 内容宽度&#x3D;父盒子content-自身左右margin-自身左右border-自身左右padding 总高度&#x3D;父盒子content-自身上下margin 内容高度&#x3D;父盒子content-自身上下margin-自身上下border-自身上下padding 示例： css12width: 100px;height: 500px; 3.2.2 盒子内边距相关常用属性： 属性名 作用 取值 padding-top 设置上内边距 长度值 padding-right 设置右内边距 长度值 padding-bottom 设置下内边距 长度值 padding-left 设置左内边距 长度值 padding 复合属性 顺时针设置内边距，空格分隔： 1. 四个方向内边距相同： padding: 长度; 2. 上下内边距相同，左右内边距相同： padding: 上下长度 左右长度; 3. 上内边距，左右内边距相同，下内边距： padding: 上长度 左右长度 下长度; 4. 上内边距，右内边距，下内边距，左内边距： padding: 上长度 右长度 下长度 左长度; 说明： 值不能为负数。 行内元素的左右内边距是没问题的，上下内边距不能完美的设置。 示例： css1padding: 10px; 3.2.3 盒子边框相关常用属性： 属性名 作用 取值 border-style 设置边框风格，复合四个方向 none：无（默认值） solid：实线 dashed：虚线 dotted：点线 double：双实线 border-width 设置边框宽度，复合四个方向 长度值，默认3px border-color 设置边框颜色，复合四个方向 颜色代码，默认黑色 border 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 上述的每个属性都能在四个方向上的边框单独设置。 3.2.4 盒子外边距相关常用属性： 属性名 作用 取值 margin-top 设置上外边距 长度值 margin-right 设置右外边距 长度值 margin-bottom 设置下外边距 长度值 margin-left 设置左外边距 长度值 margin 复合属性 顺时针设置外边距，空格分隔： 1. 四个方向外边距相同： margin: 长度; 2. 上下外边距相同，左右外边距相同： margin: 上下长度 左右长度; 3. 上外边距，左右外边距相同，下外边距： margin: 上长度 左右长度 下长度; 4. 上外边距，右外边距，下外边距，左外边距： margin: 上长度 右长度 下长度 左长度; 说明： 行内元素的左右外边距是没问题的，上下外边距不能设置。 上左影响自己的位置，下右影响后面兄弟元素的位置。 值可以为负数，负值允许其他元素进入到元素内部。 值可以设为auto，给块级元素的左右设为auto会让元素水平居中。 示例： css1margin: 10px; 3.3 技巧3.3.1 外边距问题3.3.1.1 外边距塌陷在设置外边距时，第一个子元素的上外边距会作用在父元素上，最后一个子元素的下外边距会作用在父元素上。 问题原因： 历史遗留问题，可以看作早期CSS故意这么处理的。 解决办法： 方案一，给父元素的padding属性设为非0的数字。 方案二，给父元素的border属性设为非0的数字。 方案三，推荐使用，把父元素的overflow属性设为hidden。 3.3.1.2 外边距合并上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加。 这种是正常的，可以把元素外边距设为期望的总和。 3.3.2 内容溢出文本内容过长超出父元素设置的高度会产生纵向内容溢出，子元素宽度过长超出父元素设置的宽度会产生横线内容溢出。 常用属性： 属性名 作用 取值 overflow 设置内容溢出的处理方式 visible：显示（默认值） hidden：隐藏（常用） scroll：显示滚动条，不论内容是否溢出 auto：自动显示滚动条，内容不溢出不显示（常用） 示例： css1overflow: auto; 3.3.3 隐藏元素常用属性： 属性名 作用 取值 visibility 设置元素的可见性 show：元素会被显示（默认值） hidden：元素会被隐藏，会保留占位 display 控制元素的显示模式 none：元素会被隐藏，不保留占位 block：元素将作为块级元素显示 inline：元素将作为内联元素显示 inline-block：元素将作为行内块元素显示 示例： css1display: none; 3.3.4 继承样式元素会自动拥有祖先元素设置的某些样式，并且关系近的优先级高。 可以继承的属性，都是不影响布局的，即都是和盒子模型没关系的。 3.3.5 居中布局让子元素在父元素中水平居中： 子元素为块级元素。给子元素设置：css1margin: auto; 子元素为行内元素和行内块元素。给父元素设置：css1text-align: center; 让子元素在父元素中垂直居中： 子元素为块级元素。给子元素设置：css1margin-top: (父元素盒子内容高度-子元素盒子高度)/2; 子元素为行内元素和行内块元素 给父元素设置：css1line-height: 父元素盒子内容高度; 当子元素字体大小不同时，字体小的子元素会靠下，需要让子元素使用中线对齐，给子元素设置：css1vertical-align: middle; 父元素字体越大子元素越靠下，需要清除父元素字体的影响，给父元素设置：css1font-size: 0px; 3.3.6 消除空白3.3.6.1 消除换行空白行内元素和行内块元素之间的换行会被浏览器解析为一个空白字符。 解决办法： 方案一，去掉换行和空格。 方案二，推荐使用，把父元素字体大小设为0，再给子元素单独设置字体大小。 3.3.6.2 消除基线空白子元素与基线对齐，而基线与盒子底部之间是有一定距离的。 解决办法： 方案一，推荐使用，把子元素的vertical-align属性设为除了baseline以外的其他值，比如top、middel、bottom均可。 方案二，若子元素只有一个，设置子元素的display属性为block，将子元素转为块级元素。 方案三，把父元素字体大小设为0，清除父元素字体的影响，再给子元素单独设置字体大小。 4 浮动效果4.1 介绍浮动最初是用来实现文字环绕图片效果的，现在是主流的页面布局方式之一。 元素浮动的特点： 会脱离文档流。 不管浮动前是什么元素，浮动后默认宽高都是尽可能小的被内容撑开，而且可以设置宽高。 不会独占一行，可以与其他元素共用一行。 不会产生外边距问题，能够完美的设置四个方向的外边距和内边距。 不会有空白问题。 4.2 影响浮动产生的影响： 对父元素的影响：不能撑起父元素的高度，导致父元素高度塌陷，但是父元素的宽度依然束缚浮动元素。 对兄弟元素的影响：不浮动的兄弟元素会占据浮动元素之前的位置，而且是在浮动元素的下层。 解决浮动的影响： 方案一，给父元素指定高度，不能解决对兄弟元素的影响。 方案二，给父元素也设置浮动，不能解决对兄弟元素的影响。 方案三，给父元素的overflow属性设置为hidden，不能解决对兄弟元素的影响。 方案四，推荐使用，如果不是全都浮动，给不浮动的兄弟元素的clear属性设为both，清除浮动效果，解决浮动产生的全部影响。 方案五，如果全都浮动，在最后添加不浮动的块级元素，给不浮动的块级元素的clear属性设为both，原理与方案四相同。 方案六，推荐使用，如果全都浮动，给父元素设置伪元素，通过伪元素清除浮动，原理与方案四相同：css12345父元素::after &#123; content: &quot;&quot;; display: block; clear: both;&#125; 4.3 属性常用属性： 属性名 作用 取值 float 设置元素的浮动方式 left：设置左浮动 right：设置右浮动 none：不浮动（默认值） clear 控制元素的显示模式 left：清除前面左浮动的影响 right：清除前面右浮动的影响 both：清除前面左右浮动的影响 5 定位方式5.1 属性设置定位方式。常用属性： 属性名 作用 取值 position 设置元素的定位方式 static：不开启定位（默认值） relative：开启相对定位 absolute：开启绝对定位 fixed：开启固定定位 sticky：开启粘性定位 开启定位后可以调整元素位置。常用属性： 属性名 作用 取值 left 调整到左侧边缘的距离 长度值 right 调整到右侧边缘的距离，不能和left同时使用 长度值 top 调整到顶部边缘的距离 长度值 bottom 调整到底部边缘的距离，不能和top同时使用 长度值 5.2 分类5.2.1 相对定位参考元素： 基于原来的位置，即基于正常定位的位置进行调整的。 效果： 只设为相对定位，不设置位置，无变化。 设置位置后，根据层级进行元素覆盖。 特点： 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。 不建议和float属性同时使用。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为相对定位之后，不会变成定位元素（宽度和高度由内容决定，可以自由设置）。 5.2.2 绝对定位参考元素： 基于包含块。如果没有脱离文档流，包含块就是父元素，如果脱离文档流，包含块就是最近开启任何定位的祖先元素。 效果： 只设为绝对定位，不设置位置，元素在绝对定位前的位置浮动，后面的元素占用绝对定位前的位置并且被元素覆盖。 设置位置后，根据包含块进行元素覆盖。 特点： 会脱离文档流，会对后面的兄弟元素有影响，会对父元素有影响。 不建议和float属性同时使用，浮动会失效，以绝对定位为主。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为绝对定位之后，都会变成定位元素（宽度和高度由内容决定，可以自由设置）。 使用规则： 在父元素上开启相对定位，在对其他元素没有影响的情况下，支持作为子元素的包含块。 在子元素上开启绝对定位，在包含块为父元素的前提下修改位置。 和浮动的区别： 绝对定位的元素内容会被覆盖，不能环绕元素。 绝对定位的元素会变成定位元素。 绝对定位的元素一般会配合相对定位的包含块一起使用。 5.2.3 固定定位参考元素： 基于视口。对于PC浏览器来说，视口就是浏览器展示内容的界面。 效果： 只设为固定定位，不设置位置，元素在固定定位前的位置浮动，后面的元素占用固定定位前的位置并且被元素覆盖。 设置位置后，根据视口进行元素覆盖，并且页面内容滚动时，固定定位固定在视口相对位置，不随页面内容滚动。 特点： 会脱离文档流，会对后面的兄弟元素有影响，会对父元素有影响。 不建议和float属性同时使用，浮动会失效，以固定定位为主。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为固定定位之后，都会变成定位元素（宽度和高度由内容决定，可以自由设置）。 和绝对定位的区别： 固定定位不使用包含块，不需要父元素配合，不需要和相对定位配合。 固定定位保持在视口显示，不会跟随内容移动而消失。 5.2.4 粘性定位参考元素： 基于滚动元素。根据关系最近的具有滚动机制的祖先元素，即祖先元素必须有滚动条，最远的是body元素。 效果： 只设为粘性定位，不设置位置，无变化。 设置位置后，根据滚动元素进行元素覆盖，并且页面内容滚动时，粘性定位固定在滚动元素相对位置，不随页面内容滚动。 当滚动元素和父元素同时在页面显示时，粘性定位显示，否则粘性定位消失，多个粘性定位会进行元素覆盖。 特点： 不会脱离文档流，是一种专门用于窗口滚动时的新的定位方式。 不建议和float属性同时使用。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为粘性定位之后，不会变成定位元素（宽度和高度由内容决定，可以自由设置）。 滚动机制： 设置元素的高度小于元素内容的高度，继续将元素的overflow属性设为scroll或者auto，就能在元素上显示滚动条。 5.3 层级元素的显示层级： 开启定位的元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况下，后面的元素会覆盖前面的元素。 如果元素被显示层级低的元素覆盖了，可能是因为包含块的显示层级低被其他元素覆盖，导致元素和包含块一起被覆盖。 常用属性： 属性名 作用 取值 z-index 调整元素的显示层级，开启定位的元素有效 无单位的数字，值越大显示层级越高 5.4 定位元素的特殊应用定位元素的宽度和高度由内容决定，不再充满包含块，由此会带来一些问题。 成为定位元素的两种方式： 方式一，元素使用固定定位成为定位元素。 方式二，父元素使用相对定位，元素使用绝对定位成为定位元素。 5.4.1 让定位元素充满包含块在定位元素没有设置宽度和高度的前提下，让定位元素在包含块居中，有以下两种方案： 方案一，计算充满所需要的宽度和高度。 方案二，推荐使用，给定位元素的用于调整定位的属性设置为0：css1234top: 0;right: 0;bottom: 0;left: 0; 5.4.2 让定位元素在包含块居中在定位元素设置宽度和高度的前提下，让定位元素在包含块居中，有以下两种方案： 方案一，设置左右外边距为auto，计算上外边距长度。 方案二，使用折半的方式设置：css1234left: 50%;top: 50%;margin-left: 元素宽度一半的负数;margin-top: 元素高度一半的负数; 方案三，推荐使用，将用于调整定位的属性设置为0，同时设置外边距为auto：css12345top: 0;right: 0;bottom: 0;left: 0;margin: auto; 6 布局6.1 版心在PC端网页中，一般都会有一个固定宽度且水平居中的盒子，来显示网页的主要内容，这是网页的版心。 版心的宽度一般是960像素到1200像素之间。 版心可以是一个，也可以是多个。 6.2 布局名词常用布局名词： 版心：container 顶部导航条：topbar 页头：header、page-header 导航：nav、navigator、navbar 搜索框：search、search-box 横幅：banner 主要内容：content、main 侧边栏：aside、sidebar 页脚：footer、page-footer 6.3 重置默认样式在早期元素默认样式能够快速的绘制网页，但如今网页的设计越来越复杂，这些默认样式会在绘制页面时带来麻烦，而且这些默认样式在不同的浏览器上呈现出来的效果也不一样，所以需要重置这些默认样式。 6.3.1 全局选择器示例： css1234* &#123; margin: 0; padding: 0;&#125; 此种方法在测试时可以用，但实际开发中不会使用，因为在重置样式时，需要对特定元素进行重做，并不是清除所有样式。 6.3.2 重置样式文件将对默认样式的修改写入单独的reset.css文件，在页面中引入默认的CSS文件。 6.3.3 Normalize.cssNormalize.css也是CSS文件，它对默认样式提供了跨浏览器的高度一致性，相比传统的重置样式文件，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 使用方式和重置样式文件一样，需要先在官网下载最新的CSS文件，在页面中引入即可。 官网：http://necolas.github.io/normalize.css/ 相对于重置样式文件来说，重置样式文件侧重于清除样式，Normalize.css侧重于统一样式，有如下优点： 保护了有价值的默认样式，而不是完全去掉它们。 为大部分HTML元素提供高度一致的样式。 新增对HTML5元素的设置。 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"入门","slug":"C00-前端/C02-CSS/001-基础/001-入门","date":"2024-04-02T06:49:27.000Z","updated":"2025-06-21T09:32:44.842Z","comments":true,"path":"posts/20240402/144927/","permalink":"https://momashanhe.com/posts/20240402/144927/","excerpt":"摘要：本文介绍了CSS的语法规范和选择器，三大特性以及常用属性。","text":"摘要：本文介绍了CSS的语法规范和选择器，三大特性以及常用属性。 1 简介CSS全称：Cascading Style Sheets（层叠样式表）。 CSS也是一种标记语言，用于给网页设置样式，比如文字大小、颜色、元素宽高等等。 官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn 2 语法规范2.1 基本语法CSS的语法为： css1234选择器 &#123; 属性名: 属性值; 属性名: 属性值;&#125; 主要由两部分组成： 选择器：匹配要添加样式的元素。 声明块：给匹配到的元素设置具体的样式，声明块由多个声明组成，并使用&#123;&#125;包裹，声明由属性名和属性值组成。 说明： 选择器和声明块之间，声明的属性名和属性值之间，均有一个可以省略的空格，建议不要省略，提高可读性。 声明使用;分号结尾，最后一个声明可以省略，建议不要省略，提高可读性。 2.2 注释CSS中注释的语法为： css1/* 注释内容 */ 2.3 代码风格展开风格，开发时使用，可读性高： css123span &#123; color: red;&#125; 紧凑风格，上线时使用，文件体积小： css1span&#123;color:red;&#125; 在上线时可以使用工具将展开风格转为紧凑风格。 2.4 编写位置2.4.1 行内样式行内样式又称为内联样式，写在元素的style属性中。 示例： hello.html1&lt;p&gt;欢迎学习&lt;span style=&quot;color: red;&quot;&gt;前端&lt;/span&gt;知识&lt;/p&gt; 这种方式编写的CSS没有和HTML分离，不能体现出结构和样式分离的思想，而且样式不能复用，不建议使用这种方式。 2.4.2 内部样式将CSS提取出来，写在页面内部的style元素中。 示例： hello.html12345&lt;style&gt;span &#123; color: red;&#125;&lt;/style&gt; 理论上可以将style元素放在页面的任何位置，建议放到head元素中。 和行内样式相比，这种方式编写的结构和样式分离，样式也能复用，但也没有做到完全分离，并且样式不能在多个页面复用。 2.4.3 外部样式将CSS进一步提取，写在单独的CSS文件中，在HTML页面中使用元素引用外部的CSS文件。 相关的元素： 标签名 说明 单双 link 表示引用文件 单标签 常用属性： 属性名 作用 取值 rel 引用文件和当前文件的关系 目前用到的关系： stylesheet：引用的是样式表 href 引用文件位置 位置 创建后缀为.css格式的CSS文件： hello.css123span &#123; color: red;&#125; 在HTML页面的head元素中引用CSS文件： hello.html1&lt;link rel=&quot;stylesheet&quot; href=&quot;./hello.css&quot;&gt; 这种方式可维护高，并且做到了结构和样式分离，也能被其他页面复用，建议使用这种方式。 2.5 优先级三种方式的优先级：行内样式 &gt; 内部样式 &#x3D; 外部样式 行内样式的优先级最高，内部样式和外部样式的优先级和位置有关，后面的样式会覆盖前面的样式。 三种方式比较： 方式 优点 缺点 使用频率 作用范围 行内样式 优先级高 结构和样式未分离样式不能复用 低 当前元素 内部样式 结构和样式分离样式可以在当前页面复用 结构和样式未彻底分离样式不能在多个页面复用 中 当前页面 外部样式 结构和样式彻底分离样式可以在多个页面复用能够触发浏览器缓存机制 需要引入才能使用 低 多个页面 2.6 书写顺序为了便于阅读和维护，提升浏览器的渲染性能，建议遵从以下顺序书写： 优先级第一的是定位属性：display visibility box-sizing position top&#x2F;left&#x2F;bottom&#x2F;right transform float clear z-index flex-xxx order 优先级第二的是自身属性：width&#x2F;height&#x2F;line-height overflow padding margin background border 优先级第三的是文字样式：font-family font-size font-style font-weight color 优先级第四的是文本属性：text-align vertical-align text-wrap text-indent text-decoration letter-spacing word-spacing white-space text-overflow 优先级第五的是CSS3中新增属性：content box-shadow border-radius transition 3 选择器3.1 基本选择器基本选择器： 通配选择器 元素选择器 属性选择器 类选择器 ID选择器 其他选择器可以参考文档：MDN官方CSS文档 3.1.1 通配选择器匹配所有元素。 语法： css123* &#123; 声明块&#125; 3.1.2 元素选择器匹配元素的标签名和选择器的标签名相同的所有元素。 语法： css123标签名 &#123; 声明块&#125; 3.1.3 类选择器匹配元素的class属性值和选择器的类名相同的所有元素。 语法： css123.类名 &#123; 声明块&#125; 说明： 在类名前增加.符号，表示这是类选择器，用来和其他选择器区分。 一个元素中的class属性最多只有一个，属性值可以有多个，空格分隔。 class属性值不是唯一的，不同的元素可以有相同的属性值。 class属性值按照标准，建议使用英文和数字的组合，并且使用英文开头，多个单词之间使用-短横线和_下划线连接，注意区分大小写。 3.1.4 ID选择器匹配元素的id属性值和选择器的id属性值相同的所有元素。 语法： css123#id值 &#123; 声明块&#125; 说明： 在id值前增加.符号，表示这是ID选择器，用来和其他选择器区分。 一个元素中的id属性最多只有一个，属性值只能有一个。 id属性值是唯一的，不同的元素不能有相同的属性值。 id属性值按照标准，建议使用英文和数字的组合，并且使用英文开头，多个单词之间使用-短横线和_下划线连接，注意区分大小写。 3.1.5 属性选择器匹配元素的属性及属性值和选择器指定的属性及属性值相同的所有元素。 属性选择器可以对元素的所有属性进行匹配，可以实现类选择器和ID选择器的效果。 属性选择器的语法较为复杂，使用[]包裹来区分其他选择器： css12345678910111213141516171819202122232425262728/* 选择具有指定属性名的元素，对属性值没有要求 */[属性名] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是指定属性值的元素 */[属性名=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是以指定属性值开头的元素 */[属性名^=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是以指定属性值结尾的元素 */[属性名$=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值包含指定属性值的元素 */[属性名*=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是用空格分隔的列表，存在指定属性值的列表项的元素 */[属性名~=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是指定属性值的元素或者属性值是以指定属性值拼接&quot;-&quot;开头的元素 */[属性名|=属性值] &#123; 声明块&#125; 说明： 选择器中的属性名不需要&quot;双引号包裹，但是属性值需要&quot;双引号包裹。 3.2 复合选择器复合选择器建立在基本选择器之上，由多个基础选择器，通过不同的方式组合而成。 主要有： 并集选择器 交集选择器 后代选择器 子代选择器 兄弟选择器 伪类选择器 伪元素选择器 3.2.1 并集选择器选择满足任何一个选择器的元素。 语法： css1234基础选择器1,基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用,逗号分隔，建议多个选择器换行编写，提高可读性。 3.2.2 交集选择器选择满足所有选择器的元素。 语法： css123基础选择器1基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器相邻，中间不能有任何符号，也不能有空格和换行。 因为没有任何符号分隔，所以如果有元素选择器的话，需要将其放在首位，否则会被识别为其他选择器的一部分。 3.3 关系选择器3.3.1 后代选择器选择满足后一个选择器是前一个选择器的后代的元素。 语法： css123基础选择器1 基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用空格分隔，子代也属于后代。 3.3.2 子代选择器选择满足后一个选择器是前一个选择器的子代的元素。 语法： css123基础选择器1&gt;基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用&gt;大于号分隔。 3.3.3 兄弟选择器3.3.3.1 相邻兄弟选择器选择满足后一个选择器是前一个选择器下方的相邻兄弟的元素。 语法： css123基础选择器1+基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用+加号分隔。 选择器匹配的元素之间必须是兄弟关系，必须相邻，除了空格和换行，没有其他代码。 可以匹配到多个元素，每个选择器匹配的元素的相邻兄弟元素只有一个。 3.3.3.2 通用兄弟选择器选择满足后一个选择器是前一个选择器下方的所有兄弟的元素。 语法： css123基础选择器1~基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用~加号分隔。 选择器匹配的元素之间必须是兄弟关系，可以有其他代码。 可以匹配到多个元素，每个选择器匹配的元素的兄弟元素可以有多个。 3.4 高级选择器3.4.1 伪类选择器这是CSS3新增功能。 3.4.1.1 伪类普通的元素，如果处于某种特殊状态下，把这种处于特殊状态下的元素称为伪类。 伪类选择器固定以:冒号开头。 3.4.1.2 动态伪类匹配需要用户手动操作才会出现的元素： 使用:link选择未被访问的元素，多用于超链接。 使用:visited选择被访问后的元素，多用于超链接。 使用:hover选择被鼠标悬停的元素。 使用:focus选择获取焦点时的元素，多用于表单元素。 使用:active选择被鼠标按住的元素。 说明： 在使用:link和:visited匹配超链接时，匹配到的是具有href属性的超链接，因为这种超链接才具有访问的功能。 在使用:focus匹配元素时，需要元素拥有获取焦点的功能，否则无效。 如果元素同时存在多个伪类选择器那么后面的样式会替换前面的样式，所以需要按照l-v-h-f-a的顺序，将规则宽松的放前面，将规则严格的放后面。 3.4.1.3 结构伪类匹配在页面结构上处于特殊顺序的元素： 使用:first-child选择元素的父元素的所有子元素中的第一个，即元素的第一个兄弟元素，并且兄弟元素要和元素相同。 使用:last-child选择元素的父元素的所有子元素中的最后一个，即元素的最后一个兄弟元素，并且兄弟元素要和元素相同。 使用:nth-child(n)选择元素的父元素的所有子元素中的第n个，即元素的第n个兄弟元素，并且兄弟元素要和元素相同。 使用:first-of-type选择元素的父元素的和元素相同的子元素中的第一个，即元素的第一个相同的兄弟元素。 使用:last-of-type选择元素的父元素的和元素相同的子元素中的最后一个，即元素的最后一个相同的兄弟元素。 使用:nth-of-type(n)选择元素的父元素的和元素相同的子元素中的第n个，即元素的第n个相同的兄弟元素。 使用:root选择根元素，即html元素。 使用:empty选择内容为空元素，即双标签中开始标签紧跟结束标签的元素或者单标签的元素，双标签的空格和换行也算内容。 说明： 伪类选择器中的n实际上是an+b性质的表达式，a和b都是数字。 0或者小于0都表示不选择任何元素。 n表示选择全部元素。 2n表示选择偶数元素。 2n+1表示选择奇数元素。 -n+5表示选择前5个元素。 n+5表示选择从第5个元素往后的元素，包括第5个元素。 3.4.1.4 否定伪类匹配不满足指定选择器的元素： 使用:not(选择器)选择不满足指定选择器的元素。 说明： 伪类选择器中指定的选择器可以使用伪类选择器。 3.4.1.5 界面伪类匹配在界面上有特殊效果的元素： 使用:checked选择被勾选的元素，多用于单选框和复选框。 使用:enable选择可用的元素，即没有disabled属性的元素，多用于表单元素。 使用:disabled选择不可用的元素，即有disabled属性的元素，多用于表单元素。 3.4.1.6 锚点伪类匹配被作为锚点跳转的元素： 使用:target选择锚点指向的元素。 3.4.1.7 语言伪类匹配被作为锚点跳转的元素： 使用:lang(语言)选择特定语言的元素，即有lang属性并且属性值和伪类选择器中语言相同的元素。 说明： 如果在html元素中使用lang属性，那么html的后代元素也默认使用相同的lang属性。 3.4.2 伪元素选择器说明：CSS3新增功能。 伪元素指的是元素中的一些特殊位置。 伪元素选择器固定以::双冒号开头，但为了兼容之前的版本，使用:冒号开头也能被识别。 常用伪元素选择器： 使用::first-letter选择元素内容中的第一个文字。 使用::first-line选择元素内容中的第一行文字。 使用::selection选择元素内容中被鼠标选中的内容。 使用::placeholder选择输入框的提示文字，多用于输入框和文本域。 使用::before在元素的起始位置，创建一个子元素，需要使用content属性指定内容。 使用::after在元素的结束位置，创建一个子元素，需要使用content属性指定内容。 3.5 优先级使用相同的选择器，选择相同的元素，优先级和位置有关，后面的选择器优先级高。 使用不同的选择器，选择相同的元素，优先级和权重有关，权重高的选择器优先级高比。 3.5.1 简单描述优先级： 行内样式 &gt; ID选择器 &gt; 类选择器 &#x3D; 伪类选择器 &#x3D; 属性选择器 &gt; 元素选择器 &#x3D; 伪元素选择器 &gt; 通配选择器 3.5.2 详细描述优先级： !important &gt; 行内样式 &gt; 按权重计算选择器 &gt; 通配选择器 &gt; 继承的样式 权重计算规则： 每个选择器，都可计算出一组格式为(a,b,c)的权重，说明： a：ID选择器的个数。 b：类选择器、伪类选择器、属性选择器的个数。 c：元素选择器、伪元素选择器的个数。 比较规则： 按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比。 特殊规则： 并集选择器需要被看作多个选择器，只能计算涉及当前元素的选择器的权重，不能计算整个并集选择器的权重。 4 三大特性4.1 层叠性如果发生了样式冲突，会根据选择器优先级进行样式层叠，优先级低的会被优先级高的覆盖。 4.2 继承性元素会自动拥有祖先元素设置的某些样式，继承性也遵循样式优先级，关系近的优先级高。 常见的可继承样式： color font-前缀 text-前缀 line-前缀 可以在MDN网站查询属性是否可被继承。 4.3 优先级选择器相同： !important &gt; 行内样式 &gt; 后面的选择器 &gt; 前面的选择器 &gt; 通配选择器 &gt; 默认的样式 &gt; 继承的样式 选择器不同： !important &gt; 行内样式 &gt; 按权重计算选择器优先级 &gt; 通配选择器 &gt; 默认的样式 &gt; 继承的样式 5 常用属性5.1 像素5.1.1 概念在涉及电子设备的屏幕时，为了更精确的描述图像的清晰度，创建了像素这个新的长度计量单位，使用px表示。 像素是图像最小的单位，图像是由多个像素组成的，每个像素内的颜色是相同的，像素越高的图像看起来画质越清晰，占用空间也越大。 像素是一个相对单位，其与绝对单位的换算和屏幕有关。 5.1.2 尺寸一般情况下，屏幕的尺寸指的是屏幕对角线的长度，通常用英寸（in）作为单位，英寸和厘米的换算： 1英寸 &#x3D; 2.54厘米 在某些情况下，也使用长度和宽度表示尺寸。 5.1.3 分辨率屏幕的分辨率指的是屏幕在横向和纵向上的像素数量。 在同一个设备上，分辨率是固定的，这是厂商在出厂时就设置好了的。 常用的分辨率： 720P：1280×720 1080P：1920×1080 2K：2560×1440 4K：3840*2160 虽然分辨率在出厂时就确定了，但是对于某些操作系统，比如Windows系统，支持修改分辨率，不过上限是屏幕的分辨率。系统在渲染图像的时候会自动计算，将图像里的单个逻辑像素用屏幕上的几个物理像素显示。 5.1.4 像素密度像素密度使用PPI（Pixels Per Inch）作为单位，描述图像的每英寸上的像素数量，也称为图像的采样率。 在尺寸、分辨率、像素密度这三个条件中，已知任何两个条件都可以计算剩余的条件，通过分辨率可以计算得到屏幕对角线上的像素数量，其结果与屏幕对角线的尺寸的比值就是像素密度。 像素并没有固定的大小，所以在尺寸固定的情况下，像素密度越高，分辨率越高，像素越小，画质越清晰。 此外，在将图像输出时，使用DPI（Dots Per Inch）作为单位，描述输出到载体的图像的每英寸上的像素数量。 虽然DPI和PPI类似，都用于描述每英寸上的像素数量，但是PPI用于屏幕上的图像，而DPI常用于输出的图像。 在输出图像时，如果设置的DPI大于PPI，输出的尺寸会小于图像在屏幕上的尺寸，并且不会失真，如果设置的DPI小于PPI，输出的尺寸会大于图像在屏幕上的尺寸，同时会产生失真效果。 另外，对于鼠标来说，高DPI鼠标使用起来更灵活，低DPI鼠标使用起来更沉重。当鼠标从电脑屏幕移动相同距离时，高DPI鼠标在桌子上实际移动的距离要比低DPI鼠标要短。 5.1.5 像素比像素分为物理像素和逻辑像素： 物理像素：设备能控制显示的最小单位，由厂家决定的，常说的1920×1080像素分辨率指的就是物理像素。 逻辑像素：也称为设备独立像素（Device Independent Pixel，DIP），CSS里定义的像素，比如1px指的就是逻辑像素。 设备像素比（Device Pixel Ratio，DPR），指的是屏幕的物理像素与逻辑像素之比，厂商在设备出厂时就已经进行设置，并且禁止用户进行更改。 一般情况下，普通电脑显示屏的DPR默认为1，即一个物理像素相当于一个逻辑像素。 对于手机等设备来说，需要在比电脑小的屏幕上显示相同分辨率的图像，因此手机屏幕的DPR一般会大于1。比如苹果6手机的DPR为2，物理像素分辨率是1334×750，逻辑像素分辨率是667×375，那么一个逻辑像素实际上会占用2×2&#x3D;4个物理像素。 5.2 颜色5.2.1 使用颜色名使用颜色名表示颜色。 语法： css1颜色名; 使用颜色名设置颜色为红色： css1color: red; 这种方式比较简单，但是颜色名有限，不常见的颜色没有颜色名。 可用颜色名参考文档：MDN具名颜色 5.2.2 使用RGB或RGBARGB指的是光的红（Red）绿（Green）蓝（Blue）三原色，RGBA多了一个透明度（Alpha）。 三原色的可选范围是0到255，透明度的可选范围是0到1，0表示全透明，1表示不透明。 语法： css1rgb(红色,绿色,蓝色); 使用RGB设置颜色为红色： css1color: rgb(255,0,0); 使用RGBA设置颜色为半透明红色： css1color: rgba(255,0,0,0.5); 5.2.3 使用HEX或HEXAHEX或HEXA是一种使用RGB或RGBA的十六进制表示的一种方式。 三原色和透明度都使用两位十六进制表示，范围是00到FF，对应数字0到255。 说明： 如果HEX或HEXA表示的颜色，每组两位十六进制都相同，可以简写为一位十六进制。 颜色字母大小写不敏感。 IE浏览器不支持HEXA，只支持HEX。 语法： css1#红色绿色蓝色; 使用HEX设置颜色为红色： css1color: #ff0000; 使用HEXA设置颜色为半透明红色： css1color: #ff000088; 5.2.4 使用HSL或HSLA这是CSS3新增功能。 HSL指的是色相（Hue）、饱和度（Saturation）、亮度（Lightness），HSLA多了一个透明度（Alpha）。 概念： 色相：取值范围是0度到360度，表示颜色的角度。 饱和度：取值范围是0%到100%，表示向色相中对应颜色中添加灰色，0%表示黑白，100%表示彩色。 亮度：取值范围是0%到100%，表色颜色的明亮程度，0%表示没有亮度的黑色，100%表示最高亮度的白色。 色相的度数对应的颜色如下图： 语法： css1hsl(色相,饱和度,亮度); 使用HSL设置颜色为红色： css1color: hsl(0,100%,50%); 使用HSLA设置颜色为半透明红色： css1color: hsl(0,100%,50%,50%); 5.3 字体5.3.1 字体大小常用属性： 属性名 作用 取值 font-size 控制文本字体的大小 长度值 说明： 设置为0会让文本消失。 浏览器有默认字体，不同浏览器默认字体可能不一样大，为了显示统一，建议设置明确大小。 因为CSS的继承性，只需要给body元素设置字体大小，后代元素默认继承祖先元素的字体大小。不建议使用通配选择器，否则会导致在给某个元素的父元素的字体设置大小后，因为通配选择器优先级高于继承，元素优先使用通配选择器设置的大小，并没有使用继承父元素设置的大小。 示例： css1font-size: 16px; 5.3.2 字体族常用属性： 属性名 作用 取值 font-family 控制文本字体的字型 字体名称，多个使用,分隔分隔 分类： 衬线字体：字体线条粗细不一，类似毛笔和钢笔的字体。使用serif表示选择系统可用的衬线字体。 非衬线字体：字体线条宽度一致。使用sans-serif表示选择系统可用的非衬线字体。 说明： 支持使用中文，但有的字体没有提供中文名称，建议使用英文，如果存在空格，需要使用&quot;双引号包裹。 多个字体使用时按照从左到右的顺序查找，系统存在就使用，系统不存在就查找下一个。 如果都不能匹配，会使用操作系统默认字体，不同的操作系统能够使用的字体不同。在Windows系统下使用微软雅黑作为默认字体。 为了保证显示效果统一，通常多个字体都是衬线字体或者非衬线字体，并且可以使用serif或者sans-serif兜底，当前面的字体在系统中不存在时，强制使用系统可用的衬线字体或者非衬线字体进行渲染。 示例： css1font-family: &quot;Microsoft YaHei&quot;,sans-serif; 5.3.3 字体风格常用属性： 属性名 作用 取值 font-style 控制文本字体的风格（是否斜体） normal：正常（默认字体） italic：斜体（先使用斜体字体，如果不存在，才会强制字体倾斜，推荐） oblique：斜体（不使用斜体字体，直接强制字体倾斜） 示例： css1font-style: italic; 5.3.4 字体粗细常用属性： 属性名 作用 取值 font-weight 控制文本字体的粗细 有两种方式： 1. 使用名称设置粗细： lighter：细 normal：正常 bold：粗 bolder：很粗（多数字体不支持，效果同bold） 2. 使用数值设置粗细： 数值的范围是从100到1000，一般来说数值越大字体越粗，具体要看字体设计 100~300等同于lighter 400~500等同于normal 600及以上等同于bold 示例： css1font-weight: 200; 5.3.5 复合写法常用属性： 属性名 作用 取值 font 控制文本字体的多个属性的复合写法 设置多个属性，空格分隔： 1. 字体族必须存在并且是最后一位 2. 字体大小必须存在并且是倒数第二位 3. 其他属性在前即可 语法： css1font: 字体粗细 字体风格 字体大小/行高 字体族; 示例： css1font: normal 200 40px/1.5 &quot;Microsoft YaHei&quot;, sans-serif; 5.4 文本5.4.1 文本颜色常用属性： 属性名 作用 取值 color 控制文本的颜色 颜色名 RGB或RGBA（常用） HEX或HEXA（常用） HSL或HSLA 示例： css1color: #ff0000; 5.4.2 文本划线常用属性： 属性名 作用 取值 text-decoration 控制文本的各种装饰线 支持三种维度设置，空格分隔： 1. 装饰线类型： none：无装饰线（常用） line-through：删除线（常用） underline：下划线（常用） overline：上划线 2. 装饰线样式： dotted：虚线 wavy：波浪线 3. 装饰线颜色： 颜色代码 示例： css1text-decoration: line-through dotted #ff0000; 5.4.3 文本缩进常用属性： 属性名 作用 取值 text-indent 控制文本的缩进 长度值 说明： 正值让文本右移，负值让文本左移。 示例： css1text-indent: 5px; 5.4.4 文本间距常用属性： 属性名 作用 取值 letter-spacing 控制字符之间的距离，包括汉字和标点符号，也包括空格 长度值 word-spacing 控制空格分隔的词语之间的距离，实际控制的是空格占用的距离 长度值 说明： 正值让间距增大，负值让间距缩小。 示例： css12letter-spacing: 5px;word-spacing: 5px; 5.4.5 文本水平对齐常用属性： 属性名 作用 取值 text-align 控制块级元素内容或者单元格元素内容的水平对齐 left：左对齐（默认值） right：右对齐 center：居中对齐 示例： css1text-align: center; 5.4.6 文本字体字体设计用到的参考线： 概念： baseline：基线，以英文字符x下边缘为参考的横线，字符默认是以基线对齐的。 middle：中线，以英文字符x上边缘为参考的横线。 top：顶线，字符的上边缘，所有字符均不会超过上边缘，包括中文。 bottom：底线，字符的下边缘，所有字符均不会超过下边缘，包括中文。 line-height：行高，文字的高度，实际是上下两行基线之间的高度。 说明： 即使可以通过font-size给不同的字体设置统一的大小，不同的字体在页面上显示的大小还是有细微的区别。 不同的字体对相同的字符在垂直方向上的处理也是不同的，有的可能贴近底线，有的可能贴近顶线。 5.4.7 行高常用属性： 属性名 作用 取值 line-height 控制元素内容一行内容的高度 normal：由浏览器根据文字大小决定的默认值 像素：使用像素`px`作为单位设置行高 数字倍数：使用`font-size`的数字倍数设置行高（很常用） 百分比倍数：使用`font-size`的百分比倍数设置行高 说明： 如果设置行高为负数，效果等同设置行高为normal的效果。 如果设置行高为最小值0，效果和字体设计以及元素区块有关。 如果设置行高为字体大小，会因为字体设计的问题，导致相邻两行发生重叠。 建议设置行高为字体的1.5倍，不会发生重叠，也不会间隔太长。 示例： css1line-height: normal; 5.4.8 文本垂直对齐常用属性： 属性名 作用 取值 vertical-align 控制行内元素内容或者单元格元素内容的垂直对齐 baseline：使元素的基线与父元素的基线对齐（默认值） middle：使元素的中线与父元素的中线对齐 top：使元素的顶线与其所在行的顶线对齐 bottom：使元素的底线与其所在行的底线对齐 说明： 只能用于控制行内元素在父元素一行中的垂直对齐，不能控制行内元素在父元素整个元素中的垂直对齐。 示例： css1vertical-align: middle; 5.5 列表控制列表的属性，可以作用在ul、ol、li元素上。 常用属性： 属性名 作用 取值 list-style-type 设置列表符号 none：不显示前面的标识（很常用） square：实心方块 disc：圆形 decimal：数字 lower-roman：小写罗马字 upper-roman：大写罗马字 lower-alpha：小写字母 upper-alpha：大写字母 list-style-position 设置列表符号的位置 inside：在`li`的里面 outside：在`li`的外边 list-style-image 自定义列表符号 url(图片地址) list-style 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1list-style: decimal; 5.6 表格5.6.1 边框可以作用在其他元素上，不仅仅是表格相关的元素。 常用属性： 属性名 作用 取值 border-style 设置边框风格 none：默认值 solid：实线 dashed：虚线 dotted：点线 double：双实线 border-width 设置边框宽度 长度值 border-color 设置边框颜色 颜色代码 border 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1border: none; 5.6.2 表格独有只能作用在table元素上。 常用属性： 属性名 作用 取值 table-layout 设置列宽度 auto：自动，列宽根据内容计算（默认值） fixed：固定列宽，平均分 border-collapse 合并单元格边框 collapse：合并 separate：不合并（默认值） border-spacing 设置单元格间距，这个属性生效的前提是单元格边框不能合并 长度值 empty-cells 隐藏没有内容的单元格，这个属性生效的前提是单元格边框不能合并 show：显示（默认值） hide：隐藏 caption-side 设置表格标题位置 top：在表格上面（默认值） bottom：在表格下面 示例： css1border-collapse: separate; 5.7 背景常用属性： 属性名 作用 取值 background-color 设置背景颜色 默认是transparent background-image 设置背景图片 url(图片地址) background-repeat 设置背景重复方式 repeat：重复，铺满整个元素（默认值） repeat-x：只在水平方向重复 repeat-y：只在垂直方向重复 no-repeat：不重复 background-position 设置背景图位置 使用两个维度定位，空格分隔，有多种方式： 1. 使用关键字(水平 垂直)设置位置： 水平：left、center、right 垂直：top、center、bottom 如果只写一个值，另一个方向的值取center 2. 使用坐标(x y)设置图片左上角的位置，以元素左上角为坐标原点： 如果只写一个值，会被当做x坐标，y坐标取center 3. 使用边缘距离设置图片位置，必须有四个值，分为前后两组： 一组代表上下，另一组代表左右，顺序没有要求 每组第一个值代表方向，第二个值代表边距 background 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1background: transparent; 5.8 鼠标常用属性： 属性名 作用 取值 cursor 设置鼠标光标的样式，也可以自定义鼠标图标 pointer：小手 move：移动图标 text：文字选择器 crosshair：十字架 wait：等待 help：帮助 url(图片地址)：自定义图标 示例： css1cursor: pointer;","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"进阶","slug":"C00-前端/C01-HTML/001-基础/002-进阶","date":"2024-03-14T08:31:25.000Z","updated":"2025-06-21T09:32:44.429Z","comments":true,"path":"posts/20240314/163125/","permalink":"https://momashanhe.com/posts/20240314/163125/","excerpt":"摘要：本文介绍了HTML常见的元素及其特点。","text":"摘要：本文介绍了HTML常见的元素及其特点。 1 文本元素和排版元素相比，文本元素侧重词汇和短语并且一般是行内元素，排版元素侧重文章和段落并且一般是块级元素，而且文本元素通常写在排版元素中。 常用的元素： 标签名 说明 单双 em 表示需要注意的内容 双标签 strong 表示十分重要的内容，语气比em元素更重 双标签 不太常用的元素： 标签名 说明 单双 cite 表示作品标题 双标签 dfn 表示特殊术语或者专属名词 双标签 del 表示想要删除的文本 双标签 ins 表示想要插入的文本 双标签 sub 表示下标 双标签 sup 表示上标 双标签 code 表示代码 双标签 i 表示具有特定含义的文本，多用于呈现字体图标 双标签 省略了一些语义不强、较少使用、能被替代的元素，可以在官方网站上查看全部元素。 2 图片元素2.1 基本结构图片元素用于定义图片资源的位置，以及图片的一些属性，属于行内元素。 常用的元素： 标签名 说明 单双 img 表示图片 单标签 常用属性： 属性名 作用 取值 src 图片路径 路径 alt 图片描述 描述 width 图片宽度，默认使用图片本身的宽度 长度值 height 图片高度，默认使用图片本身的高度 长度值 2.2 路径图片路径也称为图片地址，分为相对路径和绝对路径，以及网络地址： 相对路径：从当前页面文件所在的位置开始，能够访问图片资源的路径。 绝对路径：从当前页面文件所在的磁盘的根目录开始，能够访问图片资源的路径。 网络地址：相对路径和绝对路径都是本地图片，如果是网络图片则需要使用图片的网络地址进行访问。 如果是本地图片，需要注意图片被移动会导致路径失效，如果是网络图片，需要注意在开启防盗链后会导致图片不可访问。 2.3 图片格式2.3.1 jpg说明：扩展名为jpg和jpeg，有损压缩，丢弃了肉眼观察不到的细节。 特点：占用空间较小，不支持透明背景，不支持动态图片。 场景：对图片质量没有极高的要求，适合绝大多数场景。 2.3.2 png说明：扩展名为png，无损压缩，支持图片高质量的保存。 特点：占用空间较大，支持透明背景，不支持动态图片。 场景：对图片质量有一定的要求，或者需要使用有透明背景的图片。 2.3.3 bmp说明：扩展名为bmp，不进行压缩，最大程度保留了图片细节。 特点：占用空间极大，不支持透明背景，不支持动态图片。 场景：对图片细节要求极高的场景，页面中很少使用。 2.3.4 gif说明：扩展名为gif，有损压缩，仅支持256种颜色。 特点：占用空间较小，支持颜色较少，支持透明背景，支持动态图片。 场景：页面中的动态图片。 2.3.5 webp说明：扩展名为webp，同时支持无损压缩和有损压缩，谷歌推出的图片格式，专用于处理页面图片。 特点：占用空间较小，支持透明背景，支持动态图片，需要注意兼容性问题。 场景：页面中的图片，在和jpg在同等大小的情况下能保留更多细节。 2.3.6 base64说明：将图片转换得到的一串特殊的文本，支持通过浏览器打开，但某些看图应用无法打开。 特点：字符串会特别长，并且会占用和图片大小相同的空间。 场景：一些较小的图片，或者需要同页面一起加载的图片。 3 超链接3.1 基本结构用于从当前页面进行跳转，超链接本身属于行内元素。 常用的元素： 标签名 说明 单双 a 表示超链接 双标签 常用属性： 属性名 作用 取值 href 指定要跳转到的具体目标 目标地址 target 控制跳转时如何打开页面 _self：在当前标签页打开，即替换当前页面的地址为目标地址并访问 _blank：在新建标签页打开，当前标签页保留 注意： 虽然a元素是行内元素，但是可以包裹a元素之外的其他元素，包括块级元素和行内元素。 3.2 跳转方式3.2.1 跳转到页面使用href属性指定页面，那么点击超链接会跳转到指定的页面。 使用target属性指定打开目标页面的方式。 3.2.2 跳转到文件使用href属性指定文件，那么点击超链接会跳转到指定的文件。 如果浏览器能打开指定的文件就在浏览器展示，比如图片文件，如果浏览器不能打开指定的文件就引导用户下载，比如压缩文件。 3.2.3 跳转到锚点使用href属性指定锚点，那么点击超链接会跳转到指定的锚点。 锚点可以用#符号与id属性值拼接： html123&lt;a href=&quot;#test&quot;&gt;点击前往测试内容&lt;/a&gt;&lt;!-- 其他内容 --&gt;&lt;p id=&quot;test&quot;&gt;测试内容&lt;/p&gt; 页面自带了一些特殊的锚点，比如跳转到页面顶部： html1&lt;a href=&quot;#top&quot;&gt;点击前往页面顶部&lt;/a&gt; 如果将href属性设为#符号可以跳转到当前页： html1&lt;a href=&quot;#&quot;&gt;占位链接&lt;/a&gt; 如果将href属性设为javascript:;可以不触发跳转： html1&lt;a href=&quot;javascript:;&quot;&gt;占位链接&lt;/a&gt; 3.2.4 跳转到应用使用href属性指定应用，那么点击超链接会跳转到指定的应用。 需要应用支持，比如邮箱： html1&lt;a href=&quot;mailto:momashanhe@163.com&quot;&gt;点击发送邮件&lt;/a&gt; 4 列表4.1 有序列表有顺序或侧重顺序的列表，属于块级元素。 常用的元素： 标签名 说明 单双 ol 表示有序列表的范围 双标签 li 表示列表的一列 双标签 示例： html123456&lt;p&gt;要把大象放冰箱总共分几步&lt;/p&gt;&lt;ol&gt; &lt;li&gt;把冰箱门打开&lt;/li&gt; &lt;li&gt;把大象放进去&lt;/li&gt; &lt;li&gt;把冰箱门关上&lt;/li&gt;&lt;/ol&gt; 4.2 无序列表无顺序或不侧重顺序的列表，属于块级元素。 常用的元素： 标签名 说明 单双 ul 表示无序列表的范围 双标签 li 表示列表的一列 双标签 示例： html1234567&lt;p&gt;我想去的几个城市&lt;/p&gt;&lt;ul&gt; &lt;li&gt;成都&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;li&gt;武汉&lt;/li&gt;&lt;/ul&gt; 4.3 嵌套列表有序列表和无序列表支持嵌套列表。 示例： html123456789101112131415&lt;p&gt;我想去的几个城市&lt;/p&gt;&lt;ul&gt; &lt;li&gt;成都&lt;/li&gt; &lt;li&gt; &lt;span&gt;上海&lt;/span&gt; &lt;ul&gt; &lt;li&gt;外滩&lt;/li&gt; &lt;li&gt;杜莎夫人蜡像馆&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.opg.cn/&quot;&gt;东方明珠&lt;/a&gt;&lt;/li&gt; &lt;li&gt;迪士尼乐园&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;li&gt;武汉&lt;/li&gt;&lt;/ul&gt; 4.4 自定义列表包含术语名称以及术语描述的列表，属于块级元素。 常用的元素： 标签名 说明 单双 dl 表示自定义列表的范围 双标签 dt 表示术语名称 双标签 dd 表示术语描述 双标签 示例： html12345678910&lt;p&gt;如何高效的学习&lt;/p&gt;&lt;dl&gt; &lt;dt&gt;做好笔记&lt;/dt&gt; &lt;dd&gt;笔记是复习的一个抓手&lt;/dd&gt; &lt;dd&gt;笔记可以是电子版，也可以是纸质版&lt;/dd&gt; &lt;dt&gt;多加练习&lt;/dt&gt; &lt;dd&gt;只有敲出来的代码，才是自己的&lt;/dd&gt; &lt;dt&gt;别怕出错&lt;/dt&gt; &lt;dd&gt;错很正常，改正后并记住，就是经验&lt;/dd&gt;&lt;/dl&gt; 5 表格5.1 基本结构一个完整的表格由四部分组成：表格标题、表格头部、表格主体、表格脚注。 表格的某些部分可以省略，各个部分都属于块级元素。 表格结构如图： 常用的元素： 标签名 说明 单双 table 表示表格的范围 双标签 caption 表示表格的标题行 双标签 thead 表示表格头部的范围 双标签 tbody 表示表格主体的范围 双标签 tfoot 表示表格脚注的范围 双标签 tr 表示表格一行的范围，可以用在thead元素、tbody元素、tfoot元素 双标签 th 表示表格头部一格的范围，可以用在thead元素 双标签 td 表示表格主体一格的范围，可以用在tbody元素、tfoot元素 双标签 表格详细结构如图： 示例： html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;table&gt; &lt;!-- 表格标题 --&gt; &lt;caption&gt;学生信息&lt;/caption&gt; &lt;!-- 表格头部 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;民族&lt;/th&gt; &lt;th&gt;政治面貌&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表格主体 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;汉族&lt;/td&gt; &lt;td&gt;团员&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;满族&lt;/td&gt; &lt;td&gt;群众&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;回族&lt;/td&gt; &lt;td&gt;党员&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;赵六&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;壮族&lt;/td&gt; &lt;td&gt;团员&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- 表格脚注 --&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;共计：4人&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 5.2 常用属性table元素常用属性： 属性名 作用 取值 width 设置表格宽度 长度值 height 设置表格最小高度，表格最终高度可能比设置的值大 长度值 border 设置表格边框宽度 长度值 cellspacing 设置单元格之间的间距 长度值 thead元素常用属性： 属性名 作用 取值 height 设置表格头部高度 长度值 align 设置单元格的水平对齐方式 left：左边对齐 right：右边对齐 center：中间对齐 valign 设置单元格的垂直对齐方式 top：顶部对齐 middle：中间对齐 bottom：底部对齐 tbody元素常用属性：与thead元素常用的属性相同。 tfoot元素常用属性：与thead元素常用的属性相同。 tr元素常用属性：与thead元素常用的属性相同。 th元素常用属性： 属性名 作用 取值 width 设置单元格的宽度，同列所有单元格全都受影响 长度值 height 设置单元格的高度，同行所有单元格全都受影响 长度值 align 设置单元格的水平对齐方式 left：左边对齐 right：右边对齐 center：中间对齐 valign 设置单元格的垂直对齐方式 top：顶部对齐 middle：中间对齐 bottom：底部对齐 rowspan 指定要跨的行数 行数 colspan 指定要跨的列数 列数 td元素常用属性：与th元素常用的属性相同。 5.3 跨行跨列常用属性： 属性名 作用 取值 rowspan 指定要跨的行数 行数 colspan 指定要跨的列数 列数 使用属性实现跨行跨列： 原始表格使用colspan跨行使用rowspan跨列示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1-1&lt;/td&gt; &lt;td&gt;2-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1-2&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;1-1&lt;/td&gt; &lt;!-- &lt;td&gt;2-1&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1-2&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot; valign=&quot;middle&quot;&gt;1-1&lt;/td&gt; &lt;td&gt;2-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;1-2&lt;/td&gt; --&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 6 表单6.1 基本元素表单是一个包含交互的区域，用于收集用户提供的数据，整个表单属于块级元素，表单中的控件一般属于行内元素。 常用的元素： 标签名 说明 单双 form 表示表单的范围 双标签 input 表示表单中的控件，存在多种控件类型 单标签 button 表示表单中的按钮，点击可以触发处理表单数据的操作 双标签 textarea 表示文本域，可以存储多行文本 双标签 select 表示下拉框的范围，点击展示下拉框选项 双标签 option 表示下拉框的选项，用在select元素 双标签 label 和表单控件关联，点击元素可使表单控件获得焦点 双标签 fieldset 表示表单元素分组的范围 双标签 legend 表示表单元素分组的标题，用在fieldset元素 双标签 form元素常用属性： 属性名 作用 取值 action 表单提交的地址，需要和后端沟通确定 地址 target 表单提交后，页面的打开方式 _self：在当前标签页打开，即替换当前页面的地址为目标地址并访问 _blank：在新建标签页打开，当前标签页保留 method 表单提交的请求方式 get：默认值，表单数据会附加在URL中发送，一般用于不敏感信息，如分页等 post：表单数据会包含在表单体内发送，用于提交敏感数据，如用户名与密码等 input元素常用属性： 属性名 作用 取值 type 设置控件的类型 text：默认值，普通文本输入框 password：密码输入框 radio：单选框 checkbox：多选框 hidden：隐藏域 submit：提交按钮 reset：重置按钮 button：普通按钮 name 设置控件的数据名称，需要和后端沟通确定 名称 value 设置控件的数据，不同的表单控件有不同的获取方式 数据 disabled 设置控件不可用 无 button元素常用属性： 属性名 作用 取值 disabled 设置按钮不可用 无 type 设置按钮的类型，不同的类型对表单数据的处理方式不同 submit：默认值，提交表单 reset：重置表单 button：普通按钮 textarea元素常用属性： 属性名 作用 取值 name 设置文本域的数据名称 名称 rows 设置文本域默认显示的行数，影响文本域的高度 行数 cols 设置文本域默认显示的列数，影响文本域的宽度 列数 disabled 设置文本域不可用 无 select元素常用属性： 属性名 作用 取值 name 设置下拉框的数据名称 名称 disabled 设置下拉框不可用 无 option元素常用属性： 属性名 作用 取值 value 设置下拉选项的数据，在省略的情况下，会使用下拉选项的元素内容作为数据 数据 selected 设置下拉选项在加载后默认选中 无 disabled 设置下拉选项不可用 无 label元素常用属性： 属性名 作用 取值 for 用于指定要匹配的表单控件 表单控件的id属性值 6.2 常用控件6.2.1 文本输入框最常用的表单控件，支持输入一行文本。 示例： html1请输入文本：&lt;input type=&quot;text&quot;&gt; 常用属性： 属性名 作用 取值 name 设置输入框的数据名称 名称 value 设置输入框的默认值 默认值 maxlength 设置输入框可输入的最大长度 最大长度 6.2.2 密码输入框和文本输入框类似，但是输入的内容会显示为*号，避免密码泄露。 示例： html1请输入密码：&lt;input type=&quot;password&quot;&gt; 常用属性： 属性名 作用 取值 name 设置输入框的数据名称 名称 value 设置输入框的默认值，作为密码时无意义，可以省略 默认值 maxlength 设置输入框可输入的最大长度 最大长度 6.2.3 单选框支持单选的控件。 示例： html123请选择性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男 常用属性： 属性名 作用 取值 name 设置单选框的数据名称，同组控件要保持一致 名称 value 设置单选框提交的数据值，会提交被选中的控件的value属性 数据值 checked 设置单选框在加载后默认选中 无 6.2.4 多选框多选框也称为复选框，支持多选的控件。 示例： html1234请选择爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;抽烟&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;喝酒&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;烫头 常用属性： 属性名 作用 取值 name 设置多选框的数据名称，同组控件要保持一致 名称 value 设置多选框提交的数据值，会提交被选中的控件的value属性，多个值会组成数组 数据值 checked 设置多选框在加载后默认选中 无 6.2.5 隐藏域不会让用户看到的特殊控件，可以在页码代码中看到，通常用于提交特殊数据。 示例： html1&lt;input type=&quot;hidden&quot; name=&quot;tag&quot; value=&quot;100&quot;&gt; 常用属性： 属性名 作用 取值 name 设置隐藏域的数据名称 名称 value 设置隐藏域提交的数据值，通常由操作自动存储，不需要用户处理 数据值 6.2.6 提交按钮用于将表单数据提交到指定地址。 有两种方式： 使用input元素：html1&lt;input type=&quot;submit&quot; value=&quot;提交表单&quot;&gt; 使用button元素：html1&lt;button type=&quot;submit&quot;&gt;提交表单&lt;/button&gt; 6.2.7 重置按钮用于将表单数据清空，恢复到页面加载后的状态。 有两种方式： 使用input元素：html1&lt;input type=&quot;reset&quot; value=&quot;重置表单&quot;&gt; 使用button元素：html1&lt;button type=&quot;reset&quot;&gt;重置表单&lt;/button&gt; 6.2.8 普通按钮用于触发特定操作。 有两种方式： 使用input元素：html1&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; 使用button元素：html1&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt; 6.2.9 文本域用于存储多行文本。 示例： html1请输入多行文本：&lt;textarea name=&quot;msg&quot; rows=&quot;3&quot; cols=&quot;3&quot;&gt;我是文本域&lt;/textarea&gt; 使用textarea元素时不需要使用type属性，其他和input元素的文本输入框一致。 6.2.10 下拉框用于选择下拉选项。 示例： html1234567请选择省份：&lt;select name=&quot;from&quot;&gt; &lt;option value=&quot;黑&quot;&gt;黑龙江&lt;/option&gt; &lt;option value=&quot;辽&quot;&gt;辽宁&lt;/option&gt; &lt;option value=&quot;吉&quot;&gt;吉林&lt;/option&gt; &lt;option value=&quot;粤&quot; selected&gt;广东&lt;/option&gt;&lt;/select&gt; 使用option元素时如果没有设置value属性，会将元素内容作为数据提交。 6.2.11 标记和表单控件关联，点击元素可使表单控件获得焦点，需要配合表单控件使用。 示例： html1&lt;label for=&quot;password&quot;&gt;请输入密码：&lt;/label&gt;&lt;input id=&quot;password&quot; type=&quot;password&quot;&gt; 6.2.12 分组用于对表单元素进行分组，和其他控件不同，分组元素属于块级元素。 示例： html123456789101112&lt;fieldset&gt; &lt;legend&gt;主要信息&lt;/legend&gt; &lt;label for=&quot;username&quot;&gt;账户：&lt;/label&gt; &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; maxlength=&quot;10&quot;&gt; &lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; maxlength=&quot;6&quot;&gt; &lt;br&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; id=&quot;male&quot;&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; id=&quot;female&quot;&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;&lt;/fieldset&gt; 7 框架用于在当前页面加载其他内容，属于行内元素。 在HTML中，将和框架类似的元素称为可替换元素，即这种元素展示的内容是由外部的文件决定的，典型的元素有： 表示框架的iframe元素 表示视频的video元素 表示音频的audio元素 表示图片的img元素 表示外部资源的embed元素，该元素现在已经不建议使用了，可以用上面的元素代替 常用的元素： 标签名 说明 单双 iframe 框架，允许在框架里展示其他内容 双标签 常用属性： 属性名 作用 取值 name 框架名字，可以与其他元素的target属性配合，实现在框架中展示页面的效果 框架名字 src 框架内容，可以是网址，也可以是资源文件地址 框架内容 width 框架宽度 长度值 height 框架高度 长度值 frameborder 是否显示边框 0：默认值，否，不显示边框 1：是，显示边框 示例： html1&lt;iframe src=&quot;https://momashanhe.com&quot;&gt;查看博客&lt;/iframe&gt; 8 全局属性常用属性： 属性名 含义 id 元素唯一标识，一个页面中的id属性值不能重复。可以配合CSS和JS使用，也可以在其他元素中使用 class 元素类名，可以配合CSS和JS使用 style 元素样式，给元素设置CSS样式 title 元素提示，一般超链接和图片用得比较多 lang 元素语言，给元素指定语言，很少使用 一般来说，在html元素中设置lang属性设置语言即可，很少会在其他元素中使用lang属性，除非想要使用其他语言显示某个元素。 虽然这些属性是全局属性，但是在一些特殊元素上使用是没有意义的，不建议使用，也没有必要使用，比如html元素，以及head元素及其内部元素，等一些其他特殊元素。 完整的全局属性可以参考文档：MDN全局属性 9 元数据9.1 基本结构元数据就是描述数据的数据，对于HTML而言，元数据就是描述HTML页面的数据。 常用的元素： 标签名 说明 单双 meta 表示元数据，用在head元素 单标签 9.2 使用示例配置字符编码： html1&lt;meta charset=&quot;UTF-8&quot;&gt; 配置网页自动刷新： html1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10;url=https://momashanhe.com&quot;&gt; 刷新说明： 数字表示秒数，非负整数有效。 url表示地址，省略或地址无效会刷新当前页面。 针对IE浏览器的兼容性配置： html1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 针对移动端的兼容性配置： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 配置网页关键字： html1&lt;meta name=&quot;keywords&quot; content=&quot;英文逗号隔开的一组词语&quot;&gt; 配置网页描述信息： html1&lt;meta name=&quot;description&quot; content=&quot;80字以内的一段话，与网站内容相关&quot;&gt; 针对搜索引擎爬虫配置： html1&lt;meta name=&quot;robots&quot; content=&quot;可选值&quot;&gt; 可选值如下： 值 描述 index 要求搜索爬虫索引此页面 noindex 要求搜索爬虫不索引此页面 follow 要求搜索爬虫跟随此页面上的链接 nofollow 要求搜索爬虫不跟随此页面上的链接 all 和设置index, follow相同 none 和设置noindex, nofollow相同 noarchive 要求搜索引擎不缓存页面内容 nocache 是noarchive的代名词 配置网页作者： html1&lt;meta name=&quot;author&quot; content=&quot;momashanhe&quot;&gt; 配置网页生成工具： html1&lt;meta name=&quot;generator&quot; content=&quot;Visual Studio Code&quot;&gt; 配置网页版权信息： html1&lt;meta name=&quot;copyright&quot; content=&quot;2020-2050©版权所有&quot;&gt; 完整的网页元数据可以参考文档：MDN元数据","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"入门","slug":"C00-前端/C01-HTML/001-基础/001-入门","date":"2024-03-14T06:35:53.000Z","updated":"2025-06-21T09:32:43.923Z","comments":true,"path":"posts/20240314/143553/","permalink":"https://momashanhe.com/posts/20240314/143553/","excerpt":"摘要：本文介绍了HTML相关的一些概念。","text":"摘要：本文介绍了HTML相关的一些概念。 1 简介1.1 软件软件分类： 系统软件：Windows、Linux、MacOS 应用软件：Office、QQ 游戏软件：绝地求生、王者荣耀 其他分类 通常情况下，现在的软件一般由客户端与服务端两个部分组成： 客户端：用户通过客户端来使用软件。 服务端：服务端负责在远程处理业务逻辑。 服务端开发的语言： Java PHP C# Python Node 客户端的形式： 命令行界面：占老的方式，通过命令行来使用软件。 图形化界面：通过点击拖动等来使用软件。比较典型的时Windows中的大部分应用，属于C&#x2F;S架构，即Client&#x2F;Server架构。 网页：通过访问网页来使用软件。所有的网站都属于这个范畴，属于B&#x2F;S架构，即Brower&#x2F;Server架构。 相较于传统的命令行界面和图形化界面，网页具有如下一些优点： 不需要安装 无需更新 跨平台 网页中使用的语言： HTML CSS JS 1.2 网页网站是指在因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的网页集合。 网页是网站中的一“页”，通常是HTML格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常的网页，常见以.htm或.html后缀结尾的文件，因此将其俗称为HTML文件。 HTML全称：HyperText Markup Language（超文本标记语言），含义如下： HyperText（超文本）：指可以加入图片、声音、动画、多媒体等内容，超越了文本限制，也指可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。 Markup（标记）：文本要变成超文本，就需要用到各种标记符号，包括各种元素。 Language（语言）：每一个标记的写法、读音、使用规则，组成了一个标记语言。 HTML不是一种编程语言，而是一种标记语言（Markup Language），标记语言是一套标记标签（Markup Tag）。 1.3 浏览器浏览器是网页显示、运行的平台。常用的浏览器有IE、Firefox、Chrome、Safari和Opera等，称为五大浏览器。 浏览器内核是将文件展示成网页的渲染引擎，负责读取网页内容、整理讯息、计算网页的显示方式并显示页面。 1.4 国际组织1.4.1 IETF全称：Internet Engineering Task Force（国际互联网工程任务组），成立于1985年底，是一个权威的互联网技术标准化组织，主要负责互联网相关技术规范的研发和制定，当前绝大多数国际互联网技术标准均出自IETF。 官网：https://www.ietf.org 1.4.2 W3C全称：World Wide Web Consortium（万维网联盟），创建于1994年，是目前Web技术领域，最具影响力的技术标准机构。共计发布了200多项技术标准和实施指南，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 官网：https://www.w3.org 1.4.3 WHATWF全称：Web Hypertext Application Technology Working Group（网页超文本应用技术工作小组），成立于2004年，是一个以推动网络HTML5标准为目的而成立的组织。由Opera、Mozilla基金会、苹果，等这些浏览器厂商组成。 官网：https://whatwg.org 1.5 发展历史从HTML1.0开始发展，期间经历了很多版本，目前HTML的最新标准是HMTL5，具体发展史如图： 1.6 Web标准Web标准是由W3C组织和其他标准化组织制定的一系列标准的集合。 遵循Web标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 让Web的发展前景更广阔。 内容能被更广泛的设备访问。 更容易被搜寻引擎搜索。 降低网站流量费用。 使网站更易于维护。 提高页面浏览速度。 Web标准主要包括三个方面： 结构（Structure）：用于对网页元素进行整理和分类，主要指的是HTML。 表现（Presentation）：用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为（Behavior）：用于定义网页模型及编写网页交互，主要指的是JS。 Web标准提出的最佳体验方案是结构、样式、行为互相分离，即结构写到HTML文件中、表现写到CSS文件中、行为写到JS文件中。 1.7 官方文档官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn MDN：https://developer.mozilla.org 推荐使用MDN官方文档。 2 概念2.1 标签2.1.1 定义标签又称元素，是HTML的基本组成单位。 标签名不区分大小写，但推荐小写，因为小写更规范。 元素分为双标签和单标签，绝大多数都是双标签： 双标签单标签前面的是开始标签，两个标签中间的是元素内容，后面的是结束标签，结束标签多了一个/符号且不可省略： html1&lt;span&gt;&lt;/span&gt;只有一个标签，不存在元素内容： html1&lt;input /&gt; 标签后面的空格和/符号可以省略： html1&lt;input&gt; 2.1.2 尝试使用鼠标右键新建文本文档，输入以下内容： hello.html1&lt;h1&gt;Hello HTML&lt;/h1&gt; 将文本文档重命名为hello.html后，双击打开，即可看到创建的页面。 2.1.3 基本结构一般情况下，在网页中右键，在菜单的底部可以看到查看页面源代码和检查这两个选项： 查看页面源代码：可以看到程序员编写的页面源码。 检查：浏览器对页面源码经过格式化等处理后的代码。 选择检查后，可以看到页面的基本结构： html123456&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 常用的元素： 标签名 说明 单双 html 页面中最大的元素，称为根元素 双标签 head 用于定义页面的特性，不会展示在页面上，通常是给浏览器或者搜索引擎使用的 双标签 title 用于定义页面的标题，嵌套在head元素中 双标签 body 用于定义页面的内容，会展示在页面上 双标签 使用VSCode工具快速生成页面结构： 第一步，双击打开软件。 第二步，新建文件并保存为.html文件。 第三步，输入!符号并根据提示按下Tab键，会自动生成基本结构。 生成的页面结构如下： html12345678&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 此外，如果想配置网站图标，可以在存放页面的根目录中，使用favicon.ico图片作为网站图标。 2.1.4 关系元素的关系可以分为两类：嵌套和并列。 2.1.4.1 嵌套嵌套指的是不同层次的元素之间的关系，将被嵌套的元素置于嵌套元素之中，要求嵌套元素必须有双标签。 示例： html12345&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 嵌套的元素之间存在父子关系： 父亲元素：对于title元素来说，head元素是其父亲元素。对于head元素来说，html元素是其父亲元素。 儿子元素：对于head元素来说，title元素是其儿子元素。对于html元素来说，head元素是其儿子元素。 祖先元素：对于title元素来说，head元素和html元素都是其祖先元素。父亲元素也是祖先元素的一种。 后代元素：对于html元素来说，head元素和title元素都是其后代元素。儿子元素也是后代元素的一种。 2.1.4.2 并列并列指的是相同层次的元素之间的关系，对元素的标签无要求。 示例： html12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 并列的元素之间存在兄弟关系： 兄弟元素：对于body元素来说，head元素是其兄弟元素。对于head元素来说，body元素是其兄弟元素。 2.2 声明2.2.1 说明用于告知浏览器当前页面的版本。 页面的声明必须写在第一行，并且要写在html元素外面，即和html元素同级且在html元素上面。 格式： html1&lt;!DOCTYPE&gt; DOCTYPE是Document Type Declaration（文档类型声明）的缩写。 声明不是HTML标签，既不是单标签也不是双标签。 声明不区分大小写，可以按照个人习惯选择。 2.2.2 HTML4在HTML4中，确切的说是在HTML4.01及之前版本中，因为基于SGML（Standard Generalized Markup Language，标准通用标记语言），声明可能会指向DTD（Document Type Definition，文档类型定义）文件，这个文件定义了文档的结构和元素规则。 HTML4.01规定了三种不同的声明： Strict：最严格，包含所有元素和属性，不包括表象或过时的元素，框架集frameset是不允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; Transitional：较严格，包含所有元素和属性，包括表象或过时的元素，框架集frameset是不允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; Frameset：最宽松，包含所有元素和属性，包括表象或过时的元素，框架集frameset是允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; 2.2.3 HTML5在HTML5中不再基于SGML，因此不再依赖DTD文件，而是使用更简单的声明。 示例： html1&lt;!DOCTYPE html&gt; 因为声明是向下兼容的，因此可以在HTML5的声明中编写HTML4的代码，但是不能在HTML4的声明中编写HTML5的代码。 2.3 属性属性用于给元素提供附加信息，在双标签中可以将属性写在开始标签中，在单标签中可以将属性写在/符号前。 属性一般由属性名和属性值组成，某些特殊属性也可以只有属性名，其属性值可以省略： 指定属性值省略属性值html1&lt;input type=&quot;password&quot;&gt;html1&lt;input disable&gt; 注意： 不同的元素有不同的属性，存在适用所有元素的通用属性，比如id属性用于在页面上作为元素的唯一标识。 属性名和属性值都是W3C规定好的，不能乱写。 属性名和属性值不区分大小写，推荐使用小写。 属性值的双引号也可以写成单引号，如果没有空格等特殊字符也可以不写，推荐使用双引号。 元素中如果出现同名属性，后面的属性会失效。 2.4 语言设置页面语言可以让浏览器显示对应的翻译提示，也可以方便搜索引擎的优化。 语言可以在html元素中使用lang属性设置，写法如下： html1&lt;html lang=&quot;zh-CN&quot;&gt; 其他语言的设置： zh-CN：中文-中国大陆（简体中文） zh-TW：中文-中国台湾（繁体中文） zh：中文 en-US：英语-美国 en-GB：英语-英国 2.5 字符集计算机本身是二进制的，为了方便使用，在写入时会对输入的数据进行编码，在读取时会对输出的数据进行解码。 在编码和解码时，需要使用字符集进行规范，解码需要使用和编码相同的字符集，否则会导致最终读取出来的内容产生乱码。 常见的字符集如下： ASCII：大写字母、小写字母、数字、一些符号，共计128个。 ISO 8859-1：在ASCII基础上，扩充了一些欧洲字符，比如希腊字符等，共计是256个。 GB2312：继续扩充，收录了6763个常用汉字和682个字符。 GBK：收录了的汉字和符号达到20000多个，支持繁体中文。 UTF-8：包含世界上所有的文字与符号。建议使用。 可以在head元素中通过meta元素配合charset属性指定页面的字符集，让浏览器使用这种字符集对页面内容进行解析： html123&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt; 2.6 注释使用注释可以对页面源码进行解释和说明，并且注释在展示的时候会被过滤掉，但是查看源码是可以看到的。 格式： html1&lt;!-- 注释内容，在页面上不可见 --&gt; 注意： 注释不支持嵌套，不要在注释里嵌套其他注释。 3 基础3.1 排版元素排版元素用于规范页面内容的显示。 常用的元素： 标签名 说明 单双 h1~h6 用于标识页面内容的6个标题级别，从h1到h6级别越来越低，元素里不能嵌套其他排版元素 双标签 p 用于表示页面内容的段落，元素里不能嵌套其他排版元素 双标签 div 无特殊含义，用于整体布局，元素里可以嵌套其他元素，包括排版元素 双标签 span 无特殊含义，用于局部修饰，元素里不能嵌套其他排版元素 双标签 3.2 语义化语义指的是元素的含义，某些元素是有特定含义的，比如p元素的含义是表示段落，某些元素是没有特定含义的，比如span元素。 语义化元素指的是具有特定含义的元素，这种元素有一定的优势： 代码结构清晰，方便阅读，有利于团队合作开发。 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。 有利于搜索引擎优化（SEO）。 在使用语义化元素时，应该关注元素特定含义，不应该关注元素样式，因为样式可以通过CSS进行调整。 常用的元素： 标签名 说明 单双 br 换行，如果只想增加段落间隔，建议使用CSS实现 单标签 hr 分隔，如果只想使用水平线，建议使用CSS实现 单标签 pre 按原文显示，一般用于在页面中嵌入大段代码 双标签 3.3 元素区块在页面上只能独占一行的元素被称为块级元素，比如div元素，在页面上不需要独占一行的元素被称为行内元素，比如span元素。 排版元素属于块级元素，是独占一行的。 一般情况下，在块级元素中可以嵌套块级元素和行内元素，在行内元素中只能嵌套行内元素，但某些特殊的块级元素不能嵌套： 标题元素h1~h6中不支持互相嵌套，也不建议在标题中嵌套其他块级元素。 段落元素p中不支持其他块级元素，建议分段并在段落中使用其他块级元素。 3.4 实体3.4.1 介绍在HTML中存在一些预留字符，比如标签的&lt;字符和&gt;字符。 浏览器默认会将预留字符识别为标签，如果想要在页面内容里使用预留字符，就需要用特殊形式的内容来表示这些预留字符，这种特殊形式的内容称为实体。 比如想要在页面中显示这句话： html1我记得&lt;div&gt;是块级元素 如果在代码中直接写的话，会导致页面将&lt;div&gt;解析为标签，而不是文本内容，解决办法就是使用实体替换预留字符。 再比如想要在页面中显示多个空格： html1这里有 三个空格 但是页面实际上会将多个空格合并为一个空格，想要强制显示多个空格，就需要使用实体。 3.4.2 规则实体的规则： 以&amp;符号开始。 以;符号结束。 如果使用实体名称，格式为&amp;实体名称;，如果使用实体编号，格式为&amp;#实体编号;。 实体名称更方便记忆，能使用实体名称就尽量使用实体名称，但是需要注意： 实体名称对大小写敏感。 并不是所有的预留字符都有实体名称。 部分浏览器可能不支持某些实体名称。 3.4.3 常见常见的预留字符对应的实体名称和实体编号如下： 预留字符 描述 实体名称 实体编号 &#38; 和 amp 38 &#60; 小于号 lt 60 &#62; 大于号 gt 62 &#160; 空格 nbsp 160 &#165; 元 yen 165 &#169; 版权 copy 169 &#174; 商标 reg 174 &#215; 乘号 times 215 &#247; 除号 divide 247 &#34; 双引号 quot 34 &#39; 单引号 无 39 &#96; 反引号 无 96 更多的对应关系可以参考文档：WHATWG实体 3.4.4 解决回到之前的问题，可以使用下面的代码实现： html12我记得&amp;lt;div&amp;gt;是块级元素这里有&amp;nbsp;&amp;nbsp;&amp;nbsp;三个空格","categories":[{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"使用GitHub图床存放博客静态资源","slug":"B00-建站技术/B01-Hexo/002-折腾/007-使用GitHub图床存放博客静态资源","date":"2024-03-10T06:15:20.000Z","updated":"2025-06-21T08:51:12.959Z","comments":true,"path":"posts/20240310/141520/","permalink":"https://momashanhe.com/posts/20240310/141520/","excerpt":"摘要：本文介绍了如何使用GitHub图床存放静态资源，并对静态资源的获取进行加速。","text":"摘要：本文介绍了如何使用GitHub图床存放静态资源，并对静态资源的获取进行加速。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 简介博客暂时还没有服务器进行备案，也不想使用别人的图床，就只能自己打一个比较简陋的了。 使用GitHub作为图床，但是需要注意不要超过1G容量，超过1G的时候需要想办法进行拆分。 使用NPM加速访问，实现CDN的效果。 2 GitHubGitHub官网：https://github.com/ 如果没有注册过GitHub的话，需要注册一个账号。 创建一个用于存储静态资源的仓库。 点击右上角个人头像，在下拉列表中点击Settings进入设置界面。 点击左侧菜单栏底部的Developer Settings进入开发者界面。 点击Personal access tokens选项，然后点击Tokens (classic)菜单，并在右侧点击Generate new token下拉列表中的Generate new token (classic)按钮： 在Note中输入对Token使用的描述，把Expiration设置为No expiration永不过期，然后给下面的Select scopes勾选repo选框： 最后点击底部的Generate token创建Token，并将页面上展示的Token进行复制保存，这个Token只会出现这一次，忘记只能重新生成。 将静态资源文件上传到仓库里。 3 NPM3.1 注册NPM官网：https://www.npmjs.com/ 注册NPM账号： 新账号注册后需要配置2FA认证： txt1You don’t have two-factor authentication (2FA) enabled on your account. Configure 2FA or visit our docs to learn more. 点击2FA认证链接，选择使用Authenticator app的方式认证： 在手机上下载Authenticator并安装，打开后选择扫描QR码然后扫描网页上的二维码，将生成的一次性密码代码输入底部的密码框中。 保存好生成的恢复代码，这里只出现一次，忘记需要重新生成。 3.2 本地仓库进入静态资源的本地仓库，执行以下命名切换回原生源： bash1npm config set registry https://registry.npmjs.org 如果是第一次使用，需要执行命令添加本地NPM用户配置，输入账户和密码以及邮箱即可： bash1npm adduser 如果不是第一次使用，执行登录命令，输入账户和密码以及邮箱即可： bash1npm login 如果命令行提示需要登录，在下面的网址里完成登录即可： bash1Create your account at: 在打包前准备好包名，需要事先确认包名没有重复，可以在NPM官网搜索相应包名，搜不到就说明还没被占用。 执行初始化命令，将仓库打包，按照指示进行配置： bash1npm init 根据实际情况填写，红框内的使用默认就好： 注意名称不要使用带有年月日的数字，不然会被认为垃圾名称发布失败，尽量是用-短横线分隔。 最后输入yes即可。 打包以后就可以发布了，执行命令： bash1npm publish --otp=123456 命令说明： –otp：需要输入Authenticator生成的一次性密码。 发布成功提示： 发布成功后，可以寻找NPM的节点使用，比如可以按照下面的方式使用： url1https://unpkg.com/:package@:version/:file 3.3 升级仓库以后使用静态资源的时候，先在本地试用，然后将静态资源同步到GitHub上，再发布NPM升级包。 使用命令增加NPM版本，版本由3位组成，从左到右分别是： major：主要版本，左边首位，不会向后兼容的重大改动。 minor：次要版本，中间位，向后兼容的新增功能。 patch：补丁版本，右边首位，向后兼容的缺陷修复。 如果需要更新补丁版本，执行如下命令即可，会自动给版本的patch部分加一： bash1npm version patch 然后执行发布命令： bash1npm publish --otp=123456 发布成功后修改使用的版本就可以了。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://momashanhe.com/tags/NPM/"}]},{"title":"博客图床对比","slug":"B00-建站技术/B01-Hexo/002-折腾/006-博客图床对比","date":"2024-03-10T03:31:45.000Z","updated":"2025-06-21T08:49:49.877Z","comments":true,"path":"posts/20240310/113145/","permalink":"https://momashanhe.com/posts/20240310/113145/","excerpt":"摘要：本文对比了个人图床与平台图床，分析了各自的优缺点。","text":"摘要：本文对比了个人图床与平台图床，分析了各自的优缺点。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 对比图床一般用来加速对博客图片的访问，实际上是一种专门存储图片的服务器，大致分为：个人图床，平台图床。 1.1 个人图床由个人搭建的图床，搭建之后将其公开，允许公众使用的图床。 代表： SM.MS图床：土豪兽兽建的图床，2015年开始正式运营，烧风自建的CDN，支持HTTPS地址。 路过图床：老牌图床，2011年开放，提供全球CDN，支持HTTPS地址。 去不图床：杜老师创建的图床，部署在腾讯云上，需要搭配CDN。 1.2 平台图床由大型服务商搭建的图床，安全性要比个人图床好，但也更贵一些，可能会有一些限制。 代表： GitHub：支持存储1G以内图片，稳定可靠，需要额外配置CDN。 腾讯云：稳定可靠，就是贵。 阿里云：稳定可靠，就是贵。 又拍云：需要在网站底部添加LOGO和官网链接，每月10G免费空间，每月10G免费CDN。 七牛云：免费流量不支持HTTPS地址，每月10G免费空间，每月15G免费CDN。 多吉云：域名需要在服务器进行ICP备案，每月10G免费空间，每月20G免费CDN。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"给博客加装Waline评论","slug":"B00-建站技术/B01-Hexo/002-折腾/005-给博客加装Waline评论","date":"2024-03-09T02:08:21.000Z","updated":"2025-06-21T08:51:12.957Z","comments":true,"path":"posts/20240309/100821/","permalink":"https://momashanhe.com/posts/20240309/100821/","excerpt":"摘要：本文介绍了通过使用LeanCloud数据库和Vercel服务器将Waline评论部署到Hexo博客。","text":"摘要：本文介绍了通过使用LeanCloud数据库和Vercel服务器将Waline评论部署到Hexo博客。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 Waline评论1.1 简介详情查看官方文档：Waline官方文档 - 快速上手 2 使用LeanCloud2.1 简介LeanCloud是针对移动应用的一站式云端服务，专注于为应用开发者提供工具和平台。提供包括LeanStorage数据存储、LeanMessage通信服务、LeanAnalytics统计分析、LeanModules拓展模块等四大类型的后端云服务，加速应用开发。 加装Waline评论主要使用LeanCloud的LeanStorage数据存储功能。 LeanCloud中文官网：https://www.leancloud.cn/ 2.2 注册账号并创建应用注册LeanCloud账号，分为中国大陆版和国际版，区别是中国大陆版需要绑定手机、实名认证、备案域名，国际版不需要，这里注册国际版就能满足要求。 国际版注册链接：https://console.leancloud.app/register 输入注册信息，然后在邮箱中验证邮件完成注册。 点击创建应用并选择免费的开发版，创建用于Waline的应用： 进入应用，在左侧的导航栏内进入设置下的应用凭证界面，记录认证信息以便后续使用： 3 使用Vercel3.1 创建项目创建账户并登录到Vercel，在Waline提供的文档里找到快速创建Vercel项目的链接。 快速链接：部署Waline到Vercel 输入GitHub项目名称后会自动在GitHub上创建项目，然后会在Vercel上自动部署，首次部署后需要设置环境变量。 3.2 配置项目进入刚刚创建的项目界面，切换到Settings标签。 在左侧导航栏点击Environment Variables设置，配置LEAN_ID、LEAN_KEY、LEAN_MASTER_KEY三个环境变量，值为上面LeanCloud里的应用凭证里的认证信息： 如果使用LeanCloud国内版，需要额外配置LEAN_SERVER环境变量，值为绑定的域名。 切换到Deployments标签，点击任意一项后面的...并在下拉选项中选择Redeploy，点击弹出界面下方的Redeploy重新部署。 在Domains中的https://xxx.vercel.app地址即为环境ID。 4 前端部署在主题的配置文件中选择Waline作为评论系统。 特殊配置参考官方文档即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://momashanhe.com/tags/LeanCloud/"},{"name":"Waline","slug":"Waline","permalink":"https://momashanhe.com/tags/Waline/"}]},{"title":"","slug":"文章目录","date":"2024-03-07T17:58:27.923Z","updated":"2025-07-01T01:28:48.481Z","comments":true,"path":"posts/20240308/015827/","permalink":"https://momashanhe.com/posts/20240308/015827/","excerpt":"","text":"文章目录A00-生活记录 A01-日记 A02-随笔 A03-总结 A04-影评 A05-书评 A06-工具 A07-股票B00-建站技术 B01-HexoC00-前端 C01-HTML C02-CSS C03-JS C04-NodeD00-后端 D01-JavaE00-数据库 E01-MongoDB E02-MySQLF00-操作系统 F01-Linux","categories":[],"tags":[]},{"title":"给博客加装Twikoo评论","slug":"B00-建站技术/B01-Hexo/002-折腾/004-给博客加装Twikoo评论","date":"2024-03-03T07:21:02.000Z","updated":"2025-06-21T08:51:12.959Z","comments":true,"path":"posts/20240303/152102/","permalink":"https://momashanhe.com/posts/20240303/152102/","excerpt":"摘要：本文介绍了通过使用MongoDB数据库和Vercel服务器将Twikoo评论部署到Hexo博客。","text":"摘要：本文介绍了通过使用MongoDB数据库和Vercel服务器将Twikoo评论部署到Hexo博客。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 Twikoo评论1.1 简介详情查看官方文档：Twikoo官方文档 - 快速上手 2 使用MongoDB2.1 简介MongoDB是一款流行的开源文档型数据库，用于存储文档类型的数据，比如博客产生的评论。 MongoDB中文官网：https://www.mongodb.com/zh-cn/ 如果有云服务器，可以在服务器上使用MongoDB本地数据库，如果没有云服务器，可以使用MongoDB Atlas云数据库。 2.2 注册账号并创建集群注册MongoDB账号，然后在邮箱中验证邮件完成注册。 在Overview界面中可以设置组织名和项目名，然后创建一个集群： 在区域选择界面，选择免费的，提供商Provider选择AWS亚马逊即可，区域Region选择N. Virginia (us-east-1)弗吉尼亚州，也可以选择其他的。 继续设置Name集群名称，默认使用Cluster0作为集群名称，可以自定义，一旦设定不可修改。 继续设置Tag标签，这是可选的。 点击页面下方的Create创建免费集群。 2.3 创建用户进入Database Access界面，创建用户。 选择Password作为认证方式，输入用户和密码，这个用户是用来登录云数据库的，因此密码尽量设置的难一些： 继续设置用户权限，点击Add Built In Role并选择Atlas Admin选项： 点击页面下方的Add User创建用户。 2.4 设置IP地址进入Network Access界面，添加能访问云数据库的IP地址。 点击Allow Access from Anywhere或者在Access List Entry输入0.0.0.0/0表示允许所有IP地址的连接，点击Confirm保存设置： 2.5 查看如何连接进入Database界面，点击集群后面的Connect建立连接，连接方式选择Drivers使用驱动连接： 使用Driver默认的Node作为驱动，使用Version默认的5.5 or later作为版本： 复制下方mongodb+srv开头的字符串，并将&lt;password&gt;修改为创建用户时设置的密码，将这个数据库连接字符串复制并保存，后面需要用到。 点击页面下方的Close关闭退出即可。 3 使用Vercel3.1 创建项目创建账户并登录到Vercel，在Twikoo提供的文档里找到快速创建Vercel项目的链接。 快速链接：部署Twikoo到Vercel 输入GitHub项目名称后会自动在GitHub上创建项目，然后会在Vercel上自动部署，首次部署后会提示需要设置MONGODB_URI环境变量。 3.2 配置项目进入刚刚创建的项目界面，切换到Settings标签。 在左侧导航栏点击Environment Variables设置，在Key中输入MONGODB_URI，在Value中输入前面设置MongoDB保存的数据库连接字符串，点击Save保存： 在左侧导航栏点击Environment Variables设置，将Vercel Authentication设置为Disable，点击Save保存，这是关闭对项目的登录保护，支持任何人访问项目： 切换到Deployments标签，点击任意一项后面的...并在下拉选项中选择Redeploy，点击弹出界面下方的Redeploy重新部署，如果环境配置正确，可以看到提示： 在Domains中的https://xxx.vercel.app地址即为环境ID。 4 前端部署在主题的配置文件中选择Twikoo作为评论系统。 特殊配置参考官方文档即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://momashanhe.com/tags/Twikoo/"}]},{"title":"博客评论系统对比","slug":"B00-建站技术/B01-Hexo/002-折腾/003-博客评论系统对比","date":"2024-03-03T05:12:51.000Z","updated":"2025-06-21T08:49:50.058Z","comments":true,"path":"posts/20240303/131251/","permalink":"https://momashanhe.com/posts/20240303/131251/","excerpt":"摘要：本文对比了三种评论系统：GitHub系列、Vercel系列和云服务器系列，分析了各自的优缺点。","text":"摘要：本文对比了三种评论系统：GitHub系列、Vercel系列和云服务器系列，分析了各自的优缺点。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 对比Hexo支持的评论系统有很多，大致分为：GitHub系列，Vercel系列，云服务器系列。 1.1 GitHub系列这种方式基于GitHub，使用Discussions功能或者Issue功能实现评论。 代表： Giscus：基于GitHub的Discussions功能。 Gitalk：基于GitHub的Issue功能。 Beaudar：基于GitHub的Issue功能。 Utterances：基于GitHub的Issue功能。 优点是使用简单，不用注册额外数据库和服务器。 缺点是数据管理不方便，不能通过数据库维护评论。 出于数据管理方面的考虑，不太推荐这种方式。 1.2 Vercel系列这种方式基于Vercel服务器，借助免费版的Vercel服务器，以及免费版的云数据库，将评论系统部署到Vercel服务器，将评论存储到数据库中。 代表： Twikoo：支持多种部署方式，支持自动填写浏览数和评论数。 Waline：支持多种部署方式，支持自动填写浏览数和评论数。 优点是免费，免费版的资源足够个人使用了，而且有一些额外功能，比如统计浏览数和评论数。 缺点是需要注册相关账户，使用额外功能需要进行额外配置。 在不考虑购买服务器的情况下，推荐这种方式。 1.3 云服务器系列这种方式基于云服务器，需要购买云服务器资源，然后在云服务器上安装数据库，将评论系统部署到云服务器，将评论存储到数据库中。 代表： Artalk：部署在服务器上，功能强大的评论系统。 优点是安全，评论系统提供的功能更为强大。 缺点是需要购买云服务器资源，有一定的开销，并且需要对数据库和服务器有一定的了解。 不差钱的情况下，推荐这种方式。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"使用Vercel托管博客","slug":"B00-建站技术/B01-Hexo/002-折腾/002-使用Vercel托管博客","date":"2024-03-03T03:23:21.000Z","updated":"2025-06-21T08:51:12.959Z","comments":true,"path":"posts/20240303/112321/","permalink":"https://momashanhe.com/posts/20240303/112321/","excerpt":"摘要：本文介绍了Vercel平台的使用，包括注册和部署以及如何设置自定义域名。","text":"摘要：本文介绍了Vercel平台的使用，包括注册和部署以及如何设置自定义域名。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 使用Vercel1.1 简介Vercel是一个云服务平台，可以用于部署静态网站，也用于部署一些没有接口数据交互的动态网站。 对于个人博客，在Vercel上部署类似于在GitHub Pages上进行部署，但是Vercel的访问速度要比GitHub Pages好太多，因此许多博主都将博客部署在Vercel上。 Vercel官网：https://vercel.com/ 1.2 注册在注册时选择私人目的，不要选择商业目的： 选择邮箱注册，在邮箱收到链接后验证完成注册。 1.3 部署支持多种方式部署： 通过本地手动部署通过GitHub Pages博客项目自动部署通过GitHub博客源码项目自动部署这种方式不需要访问GitHub，是通过本地命令的方式进行部署的。 类似于将本地博客部署到GitHub Pages需要安装插件，将本地博客部署到Vercel也需要安装插件。 在博客目录打开bash命令行，安装Vercel插件，需要进行全局安装： bash1npm install vercel -g 执行命令将博客部署到平台，首次执行会登录Vercel平台，然后进行一些设置，可以直接回车使用默认设置： bash1vercel 部署完成后会提示生成的链接，通过链接可以访问博客。 还有一些常用命令，可以在官网学习。 推荐方式之一，从本地可以直接部署到Vercel平台，简单快速。进入Vercel项目管理界面，打开Overview并在右侧点击Add New...下拉列表中的Project选项： 在导入项目管理界面点击Continue with GitHub并在弹出的界面上完成GitHub授权： 在导入项目管理界面可以看到刚刚导入的项目，点击项目后面的Install并在弹出的界面上选择Only select repositories选项，在Select repositories下拉列表中选择GitHub Pages博客项目，点击Install执行安装，输入GitHub密码将项目从GitHub复制到Vercel上。 在导入项目管理界面点击项目右侧的Import，进入设置和部署界面： 设置和部署： 设置Vercel中的项目名，可以使用默认的。 设置框架，自动识别为Other框架，可以使用默认的，因为项目中只有静态文件，不需要使用框架部署。 检查并设置部署命令，可以使用默认配置，点击Deploy在Vercel上进行部署。 等到部署结束，会跳转到祝贺页面，能够看到博客的缩略图，点击即可通过Vercel提供的链接访问博客。 当对GitHub Pages博客项目进行推送时，会触发Vercel的自动部署。 推荐方式之一，不需要对现有流程进行更改，不需要考虑在Vercel上部署带来的一系列问题。进入Vercel项目管理界面，打开Overview并在右侧点击Add New...下拉列表中的Project选项： 在导入项目管理界面点击Continue with GitHub并在弹出的界面上完成GitHub授权： 在导入项目管理界面可以看到刚刚导入的项目，点击项目后面的Install并在弹出的界面上选择Only select repositories选项，在Select repositories下拉列表中选择GitHub博客源码项目，点击Install执行安装，输入GitHub密码将项目从GitHub复制到Vercel上。 在导入项目管理界面点击项目右侧的Import，进入设置和部署界面： 设置和部署： 设置Vercel中的项目名，可以使用默认的。 设置框架，支持自动识别比如Hexo框架，如果不对可以修改。 检查并设置部署命令，可以使用默认配置，点击Deploy在Vercel上进行部署。 等到部署结束，会跳转到祝贺页面，能够看到博客的缩略图，点击即可通过Vercel提供的链接访问博客。 当对GitHub博客源码项目进行推送时，会触发Vercel的自动部署。 不推荐这种方式，在某些情况下会出现问题，将主题项目作为子模块或者子项目，会导致部署后进入博客白屏。 1.4 设置域名进入Vercel项目管理界面，点击创建的博客项目进入项目界面，切换到Settings标签，在左侧导航栏点击Domains设置： 在输入框中输入购买的域名，点击Add添加。 根据提示去域名服务商配置域名解析，将指向GitHub Pages改为指向Vercel。 之后等待域名生效即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"}]},{"title":"给博客添加徽标","slug":"B00-建站技术/B01-Hexo/002-折腾/001-给博客添加徽标","date":"2024-03-03T02:25:43.000Z","updated":"2025-06-21T08:49:49.412Z","comments":true,"path":"posts/20240303/102543/","permalink":"https://momashanhe.com/posts/20240303/102543/","excerpt":"摘要：本文介绍了如何给博客添加自定义徽标。","text":"摘要：本文介绍了如何给博客添加自定义徽标。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 静态徽标1.1 语法徽标生成网站：https://shields.io/ 通过访问特定链接就能生成自定义徽标，特定链接的语法： url1https://img.shields.io/badge/前缀-后缀-颜色?参数 特定链接使用-短横线分隔，如果用到了特殊字符需要转义： 需要空格，则使用_下划线或者%20表示。 需要_下划线，则使用__双下划线表示。 需要-短横线，则使用--双短横线表示。 颜色支持十六进制、RGB、RGBA、HSL、HSLA和CSS进行表达。 样式： 可以使用img标签引用，也可以使用object标签引用： imgobject不支持点击徽标跳转链接，需要包装跳转链接。 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue&quot;&gt;&lt;/a&gt;支持点击徽标跳转链接。 写法： html1&lt;object data=&quot;https://img.shields.io/badge/left-right-blue&quot;&gt;&lt;/object&gt; 1.2 参数1.2.1 类型类型参数名为style，类型参数值支持多种： flatflat-squareplasticfor-the-badgesocial扁平，默认，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue?style=flat&quot;&gt;&lt;/a&gt;方角扁平，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue?style=flat-square&quot;&gt;&lt;/a&gt;塑料质感，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue?style=plastic&quot;&gt;&lt;/a&gt;放大版，同时字母大写，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue?style=for-the-badge&quot;&gt;&lt;/a&gt;后缀改为聊天气泡，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-blue?style=social&quot;&gt;&lt;/a&gt; 1.2.2 标签左侧标签参数名为label，左侧标签颜色参数名为labelColor，右侧标签颜色参数名为color，支持重写左侧标签和自定义两侧标签颜色。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-90EE90?label=edit&amp;labelColor=A9A9A9&amp;color=FF0000&quot;&gt;&lt;/a&gt; 1.2.3 链接链接参数名为link，链接参数值支持自定义链接，用于点击徽标进行跳转。 只有使用object标签才支持跳转，使用img标签需要包装跳转链接。 样式： 写法： html1&lt;a href=&quot;https://shields.io/&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-90EE90&quot;&gt;&lt;/a&gt; 1.2.4 LOGOLOGO参数名为logo，LOGO颜色参数名为logoColor，参数值支持从网站获取。 获取参数值：https://simpleicons.org/ 在上述网站中可以找到支持的LOGO名称和颜色，也可以复制下载SVG格式的图标。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/left-right-90EE90?logo=hexo&amp;logoColor=0E83CD&quot;&gt;&lt;/a&gt; 2 动态徽标2.1 通过URL获取的文件内容语法： url1https://img.shields.io/badge/dynamic/类型?参数 支持的文件类型有： json toml xml yaml 参数沿用静态徽标的参数，并且新增了url参数和query参数，用于指定文件地址和属性名，属性名前使用$.作为前缀。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/badge/dynamic/json?url=https://github.com/badges/shields/raw/master/package.json&amp;query=$.name&quot;&gt;&lt;/a&gt; 2.2 通过URL获取的响应内容语法： url1https://img.shields.io/endpoint?参数 参数沿用静态徽标的参数，并且新增了url参数，用于请求地址。 请求地址需要响应的内容： schemaVersion：版本，必填，总是设置为1。 style：类型，非必填，默认是flat。 label：左侧标签内容，可以设置为空字符串，必填。 message：右侧标签内容，不能设置为空字符串，必填。 labelColor：左侧标签颜色，非必填，默认是grey。 color：右侧标签颜色，非必填，默认是lightgrey。 namedLogo：LOGO对应名字，非必填，默认不传。 logoSvg：LOGO对应的SVG字符串，非必填，默认不传。 logoColor：LOGO颜色，非必填，默认不传。 isError：非必填，默认否。 请求url得到的响应内容： json1&#123; &quot;schemaVersion&quot;: 1, &quot;label&quot;: &quot;is it monday&quot;, &quot;message&quot;: &quot;no&quot;, &quot;color&quot;: &quot;orange&quot; &#125; 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img alt=&quot;shields&quot; src=&quot;https://img.shields.io/endpoint?url=https://shields.redsparr0w.com/2473/monday&quot;&gt;&lt;/a&gt;","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"设置博客主题","slug":"B00-建站技术/B01-Hexo/001-搭建/006-设置博客主题","date":"2024-02-26T14:39:23.000Z","updated":"2025-06-21T08:49:48.937Z","comments":true,"path":"posts/20240226/223923/","permalink":"https://momashanhe.com/posts/20240226/223923/","excerpt":"摘要：本文介绍了如何设置博客主题。","text":"摘要：本文介绍了如何设置博客主题。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 设置主题对于在GitHub上的主题，有四种方式进行设置，四种方式各有优缺点： 下载并解压安装克隆主题作为子模块克隆主题作为子项目下载并解压主题到博客目录的themes目录中。 最简单的方式，特点如下： 是否支持通过命令更新主题：否，需要重新下载。 本地是否存储主题代码：是，可以修改主题。 远程是否存储主题代码：是，保留主题代码。 适用场景： 是否需要使用新版主题：否。 是否会对主题进行更改：是。 安装主题到博客： bash1npm install hexo-theme-themename 最节省空间的方式，特点如下： 是否支持通过命令更新主题：是，支持通过npm install命令更新主题，更新前需要在package.json中将版本号改为*。 本地是否存储主题代码：否，不可以修改主题。 远程是否存储主题代码：否，不保留主题代码。 适用场景： 是否需要使用新版主题：是。 是否会对主题进行更改：否。 通过git submodule add命令将GitHub上的主题项目克隆到本地，作为博客项目的子模块： bash1git submodule add git@github.com:username/hexo-theme-themename.git themes/themename 较为兼容的方式，特点如下： 是否支持通过命令更新主题：是，支持通过git pull命令更新主题。 本地是否存储主题代码：是，可以修改主题。 远程是否存储主题代码：否，不保留主题代码，但是会保留主题子模块链接。 适用场景： 是否需要使用新版主题：是。 是否会对主题进行更改：是。 通过git clone命令将GitHub上的主题项目克隆到本地，作为博客项目的子项目： bash1git clone git@github.com:username/hexo-theme-themename.git themes/themename 建议使用这种方式，特点如下： 是否支持通过命令更新主题：是，支持通过git pull命令更新主题。 本地是否存储主题代码：是，可以修改主题。 远程是否存储主题代码：否，不保留主题代码。 适用场景： 是否需要使用新版主题：是。 是否会对主题进行更改：是。 打开_config.yml配置文件，设置theme的值为主题中指定的名字。 根据主题说明文件，创建_config.themename.yml主题专用配置文件，按照主题说明文档修改配置即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"在文章中插入本地图片","slug":"B00-建站技术/B01-Hexo/001-搭建/005-在文章中插入本地图片","date":"2024-02-26T13:15:23.000Z","updated":"2025-06-21T08:49:48.990Z","comments":true,"path":"posts/20240226/211523/","permalink":"https://momashanhe.com/posts/20240226/211523/","excerpt":"摘要：本文介绍了如何在文章中插入本地图片。","text":"摘要：本文介绍了如何在文章中插入本地图片。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 插入图片进入博客目录，修改_config.yml配置文件，启动资源目录： _config.yml1post_asset_folder: true 在博客目录打开bash命令行，安装插件： bash1npm install hexo-image-link 每次创建博客时，都会创建同名目录，通过相对路径引用同名目录里的图片即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"给文章设置模板和永久链接","slug":"B00-建站技术/B01-Hexo/001-搭建/004-给文章设置模板和永久链接","date":"2024-02-26T12:13:52.000Z","updated":"2025-06-21T08:49:49.319Z","comments":true,"path":"posts/20240226/201352/","permalink":"https://momashanhe.com/posts/20240226/201352/","excerpt":"摘要：本文介绍了如何给文章设置模板和永久链接。","text":"摘要：本文介绍了如何给文章设置模板和永久链接。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 模板进入博客目录，打开scaffolds目录，修改post.md模板，这是默认模板： post.md12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:---摘要：&lt;!-- more --&gt; 进入博客目录，打开scaffolds目录，修改draft.md模板： draft.md123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 2 永久链接修改博客目录下的_config.yml配置文件： _config.yml12url: https://username.com/permalink: posts/:year:month:day/:hour:minute:second/ 把url改为自己的域名即可，这种永久链接的好处是采用文章创建时间里的元素作为永久链接，即使文章路径或者文章标题发生改动，也不会对已生成的链接产生影响。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"将博客源码上传到GitHub","slug":"B00-建站技术/B01-Hexo/001-搭建/003-将博客源码上传到GitHub","date":"2024-02-26T09:26:37.000Z","updated":"2025-06-21T08:49:49.223Z","comments":true,"path":"posts/20240226/172637/","permalink":"https://momashanhe.com/posts/20240226/172637/","excerpt":"摘要：本文介绍了如何将博客源码上传到GitHub。","text":"摘要：本文介绍了如何将博客源码上传到GitHub。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 创建私有源码仓库登录GitHub，创建一个名称为username.source的私有仓库，把username改为GitHub的用户名。 2 创建说明文档和许可证明进入博客目录，创建README.md说明文档，输入对项目的简单介绍，创建LICENSE许可证明，并设置许可类型。 3 同步源码进入博客目录，右键进入bash命令行，执行git init命令初始化Git仓库。 因为GitHub新的仓库默认分支已经改成了main，但本地还是master，所以执行命令将本地分支改为main： bash1git branch -M main 修改.gitignore配置文件： .gitignore12345678910.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.deploy_git*/_multiconfig.yml.github*/ 右键进入bash命令行，设置当前目录用户名和邮箱： bash12git config --local user.name usernamegit config --local user.email username@163.com 添加至暂存： bash1git add . 提交更改并注释： bash1git commit -m &quot;init(博客): 初始化博客&quot; 添加远程仓库： bash1git remote add origin git@github.com:username/username.source.git 推送到远程仓库： bash1git push -u origin main","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"}]},{"title":"将博客部署到GitHub","slug":"B00-建站技术/B01-Hexo/001-搭建/002-将博客部署到GitHub","date":"2024-02-26T07:34:29.000Z","updated":"2025-06-21T08:51:12.959Z","comments":true,"path":"posts/20240226/153429/","permalink":"https://momashanhe.com/posts/20240226/153429/","excerpt":"摘要：本文介绍了如何将博客部署到GitHub，并设置域名解析。","text":"摘要：本文介绍了如何将博客部署到GitHub，并设置域名解析。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 配置GitHub1.1 登录注册并登录GitHub。 1.2 生成SSH公钥打开资源管理器，查看登录用户目录里有没有.ssh目录。 根据目录是否存在： 目录存在目录不存在如果目录存在，说明以前设置过.ssh目录，如果没用了就删掉，如果还有用就需要参考SSH配置多用户，在此先不做介绍了。如果目录不存在，进入上级目录，右键进入bash命令行，执行命令生成SSH秘钥和公钥： bash1ssh-keygen -t rsa -C 个人邮箱 命令说明： -t：指定密钥类型，默认是rsa，可以省略。 -C：设置注释文字，一般会设置为个人邮箱。 执行命令后，会提示置生成的秘钥和公钥名称，默认是id_rsa作为名称，回车使用默认名称。 继续执行，还会提示设置密码和确认密码，回车设置为空。 执行结束会在登录用户目录里生成.ssh目录，打开id_rsa.pub公钥文件并复制内容。 1.3 配置SSH公钥进入GitHub点击个人头像，选择Settings进入设置页面，在左侧找到SSH and GPG keys设置，在顶部的SSH keys模块中，点击右侧的New SSH key按钮新增配置： 在添加配置的页面中，设置Title的配置名称，然后设置Key中的公钥，粘贴刚刚复制的公钥文件内容，然后点击底部的Add SSH key按钮保存配置。 使用命令测试通过SSH能否连接到GitHub： bash1ssh -T git@github.com 如果提示确认输入，就按照提示输入yes然后回车即可连接成功，下次再测试就没有这个提示了，同时在.ssh目录中会增加known_hosts的配置文件。 2 部署GitHub2.1 创建仓库登录GitHub，创建一个名称为username.github.io的公共仓库，把username改为GitHub的用户名。 这种仓库是GitHub Pages仓库，一个用户只能创建一个这种仓库，创建后允许用户将仓库发布为一个静态网站，网址就是username.github.io仓库名称。 2.2 安装插件进入博客目录，右键进入bash命令行，安装部署到GitHub上的插件： bash1npm install hexo-deployer-git 修改博客目录下的_config.yml配置文件，修改底部的deploy配置项，如果没有找到则自己添加： _config.yml12345678# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: github: url: git@github.com:username/username.github.io.git branch: main 2.3 发布进入博客目录，右键进入bash命令行，执行命令清理博客、生成博客、发布博客： bash123hexo cleanhexo generatehexo deploy 发布后如果提示未知身份： 说明需要设置用户名和邮箱，有两种方式： 方式一，全局设置，按照提示设置全局用户名和邮箱：bash12git config --global user.name usernamegit config --global user.email username@163.com 方式二，本地设置，进入博客目录下的.deploy_git发布目录，右键进入bash命令行，设置发布目录的用户名和邮箱：bash12git config --local user.name usernamegit config --local user.email username@163.com 然后重新发布，通过GitHub访问博客：https://username.github.io 3 域名解析3.1 域名通过阿里云或者腾讯云，或者其他服务商，都可以购买域名。 3.2 解析打开cmd命令行，输入命令查询IP地址： cmd1ping username.github.io 进入域名解析页面，配置域名解析： 新增记录，主机记录为@，记录类型为A，记录值为上面查到的IP地址，TTL使用默认的600即可。 新增记录，主机记录为www，记录类型为CNAME，记录值为GitHub访问博客的地址，TTL使用默认的600即可。 3.3 配置进入博客目录下的source目录，新建CNAME文件，注意不要有后缀名，打开后添加域名并保存。 进入仓库页面，点击仓库页面右上角的Settings标签，在左侧菜单栏中找到Pages配置页，找到Custom domain填入域名并保存。 将博客重新发布后就可以通过域名访问了。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"}]},{"title":"本地安装Hexo博客","slug":"B00-建站技术/B01-Hexo/001-搭建/001-本地安装Hexo博客","date":"2024-02-26T03:13:54.000Z","updated":"2025-06-21T08:51:12.959Z","comments":true,"path":"posts/20240226/111354/","permalink":"https://momashanhe.com/posts/20240226/111354/","excerpt":"摘要：本文介绍了Hexo博客框架的安装和使用方法，包括环境配置和初始化博客并新建文章，以及分类和标签的设置。","text":"摘要：本文介绍了Hexo博客框架的安装和使用方法，包括环境配置和初始化博客并新建文章，以及分类和标签的设置。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 简介Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官网：https://hexo.io/zh-cn 2 环境2.1 安装Git由于初始化博客目录需要Git支持，并且Hexo的某些命令需要在bash命令行中执行，因此需要安装Git工具。 下载方式： 方式一，官网下载最新版：https://git-scm.com 方式二，通过GitHub选择2.37.3版本下载，历史版本下载地址：v2.37.3.windows.1&#x2F; 方式三，通过淘宝镜像下载，比GitHub访问速度快：v2.37.3.windows.1&#x2F; 如果不太了解Git工具，可以使用默认设置安装。 安装结束后，右键选择Git Bash Here进入bash命令行。 输入git --version命令查看Git的安装版本： bash123momashanhe@localhost momashanhe $ git --versiongit version 2.37.3.windows.1momashanhe@localhost momashanhe $ 需要注意的是，默认安装的2.37.3版本在初始化本地Git项目的时候，默认创建的分支还是master分支，可以在安装的时候自定义： 2.2 安装NodeHexo基于Node，搭建过程中还需要使用NPM（Node包管理工具，安装Node时默认安装）。 下载方式： 方式一，官网下载最新版：https://nodejs.org/en 方式二，本文使用的是18.14.0版本，下载地址：v18.14.0&#x2F; 使用默认配置安装即可。 在bash命令行输入node -v命令查看Node版本： bash123momashanhe@localhost momashanhe $ node -vv18.14.0momashanhe@localhost momashanhe $ 在bash命令行输入npm -v命令查看NPM版本： bash123momashanhe@localhost momashanhe $ npm -v9.3.1momashanhe@localhost momashanhe $ NPM是包管理工具，通过命令将安装包使用的源设置为淘宝镜像，速度会快一些： bash1npm config set registry https://registry.npmmirror.com 使用命令查看安装使用的源： bash1npm config get registry 2.3 安装Hexo在bash命令行中使用NPM安装Hexo： bash1npm install hexo-cli -g 安装结束后，使用hexo -v命令查看Hexo版本： bash12345678910111213141516171819202122232425momashanhe@localhost momashanhe $ hexo -vhexo-cli: 4.3.1os: win32 10.0.19044node: 18.14.0v8: 10.2.154.23-node.22uv: 1.44.2zlib: 1.2.13brotli: 1.0.9ares: 1.18.1modules: 108nghttp2: 1.51.0napi: 8llhttp: 6.0.10uvwasi: 0.0.14acorn: 8.8.1simdutf: 3.1.0undici: 5.14.0openssl: 3.0.7+quiccldr: 42.0icu: 72.1tz: 2022gunicode: 15.0ngtcp2: 0.8.1nghttp3: 0.7.0momashanhe@localhost momashanhe $ 3 使用3.1 初始化博客目录在电脑中新建博客目录，右键进入bash命令行，使用hexo init命令初始化博客目录： bash12345momashanhe@localhost momashanhe $ hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesINFO Start blogging with Hexo!momashanhe@localhost momashanhe $ 目录结构如下： 3.2 博客预览使用hexo generate命令生成博客内容，也可以简写为hexo g命令： bash1234567891011121314151617momashanhe@localhost momashanhe $ hexo generateINFO Validating configINFO Start processingINFO Files loaded in 224 msINFO Generated: archives/index.htmlINFO Generated: archives/2024/02/index.htmlINFO Generated: archives/2024/index.htmlINFO Generated: index.htmlINFO Generated: css/style.cssINFO Generated: js/script.jsINFO Generated: fancybox/jquery.fancybox.min.cssINFO Generated: fancybox/jquery.fancybox.min.jsINFO Generated: js/jquery-3.6.4.min.jsINFO Generated: css/images/banner.jpgINFO Generated: 2024/02/26/hello-world/index.htmlINFO 11 files generated in 235 msmomashanhe@localhost momashanhe $ 使用hexo server命令启动本地预览，也可以简写为hexo s命令： bash1234momashanhe@localhost momashanhe $ hexo serverINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 根据提示，在浏览器输入地址访问博客：http://localhost:4000/ 可以看到博客的默认界面： 可以同时按下Ctrl+C停止博客。 3.3 新建文章使用hexo new test命令创建标题为test的文章。 执行后在博客目录/source/_posts目录中会自动新增对应的Markdown文件。 也可以指定标题和目录： bash1hexo new post test -p demo/test 可以通过文本编辑器修改文章，保存后在本地预览： bash1hexo clean &amp;&amp; hexo server 3.4 站点设置修改博客目录下的_config.yml配置文件，修改的Site配置项。 4 内容优化4.1 分类进入博客目录，打开bash命令行，添加分类页： bash1hexo new page categories 打开sources/categories/index.md文件，增加分类配置： index.md12345---title: 所有分类date: 2024-02-25 21:45:11type: &quot;categories&quot;--- 使用分类： index.md123---categories:--- 4.2 标签进入博客目录，打开bash命令行，添加标签页： bash1hexo new page tags 打开sources/tags/index.md文件，增加标签配置： index.md12345---title: 所有标签date: 2024-02-25 21:53:29type: &quot;tags&quot;--- 使用标签： index.md123---tags: []--- 4.3 引用使用引用： index.md123---references: []---","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://momashanhe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"https://momashanhe.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://momashanhe.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://momashanhe.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://momashanhe.com/tags/MySQL/"},{"name":"MVCC","slug":"MVCC","permalink":"https://momashanhe.com/tags/MVCC/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Node","slug":"Node","permalink":"https://momashanhe.com/tags/Node/"},{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"https://momashanhe.com/tags/Less/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"},{"name":"LowDB","slug":"LowDB","permalink":"https://momashanhe.com/tags/LowDB/"},{"name":"Express","slug":"Express","permalink":"https://momashanhe.com/tags/Express/"},{"name":"AJAX","slug":"AJAX","permalink":"https://momashanhe.com/tags/AJAX/"},{"name":"JQuery","slug":"JQuery","permalink":"https://momashanhe.com/tags/JQuery/"},{"name":"Babel","slug":"Babel","permalink":"https://momashanhe.com/tags/Babel/"},{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://momashanhe.com/tags/NPM/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://momashanhe.com/tags/LeanCloud/"},{"name":"Waline","slug":"Waline","permalink":"https://momashanhe.com/tags/Waline/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://momashanhe.com/tags/Twikoo/"}]}
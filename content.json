{"meta":{"title":"墨码山河","subtitle":"代码改变世界","description":"代码改变世界","author":"墨码山河","url":"https://momashanhe.com","root":"/"},"pages":[{"title":"分类","date":"2024-02-25T13:45:11.000Z","updated":"2024-03-10T03:45:36.241Z","comments":true,"path":"categories/index.html","permalink":"https://momashanhe.com/categories/index.html","excerpt":"","text":""},{"title":"专栏","date":"2024-02-29T02:12:36.000Z","updated":"2024-08-12T09:04:01.815Z","comments":true,"path":"groups/index.html","permalink":"https://momashanhe.com/groups/index.html","excerpt":"整理归纳，搭建系统。","text":"整理归纳，搭建系统。 建站技术:Hexo:搭建建站技术:Hexo:折腾大前端:HTML:基础大前端:CSS:基础大前端:CSS:技巧大前端:CSS:预处理大前端:JS:基础大前端:JS:技巧"},{"title":"标签","date":"2024-02-25T13:53:29.000Z","updated":"2024-03-10T03:12:38.918Z","comments":true,"path":"tags/index.html","permalink":"https://momashanhe.com/tags/index.html","excerpt":"","text":""},{"title":"建站技术:Hexo:折腾","date":"2024-02-29T12:52:36.000Z","updated":"2024-04-02T06:42:47.900Z","comments":true,"path":"groups/001002/index.html","permalink":"https://momashanhe.com/groups/001002/index.html","excerpt":"","text":""},{"title":"建站技术:Hexo:搭建","date":"2024-02-29T11:50:06.000Z","updated":"2024-04-02T06:42:52.689Z","comments":true,"path":"groups/001001/index.html","permalink":"https://momashanhe.com/groups/001001/index.html","excerpt":"","text":""},{"title":"大前端:CSS:基础","date":"2024-04-02T03:53:12.000Z","updated":"2024-04-05T22:56:15.125Z","comments":true,"path":"groups/102001/index.html","permalink":"https://momashanhe.com/groups/102001/index.html","excerpt":"","text":""},{"title":"大前端:HTML:基础","date":"2024-03-31T00:12:26.000Z","updated":"2024-04-05T06:29:22.369Z","comments":true,"path":"groups/101001/index.html","permalink":"https://momashanhe.com/groups/101001/index.html","excerpt":"","text":""},{"title":"大前端:JS:基础","date":"2024-06-27T08:03:31.000Z","updated":"2024-06-27T08:03:34.383Z","comments":true,"path":"groups/103001/index.html","permalink":"https://momashanhe.com/groups/103001/index.html","excerpt":"","text":""},{"title":"大前端:JS:技巧","date":"2024-08-02T07:02:44.000Z","updated":"2024-08-02T07:03:12.614Z","comments":true,"path":"groups/103002/index.html","permalink":"https://momashanhe.com/groups/103002/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-02-25T14:31:08.000Z","updated":"2024-03-10T03:12:17.376Z","comments":true,"path":"pages/about/index.html","permalink":"https://momashanhe.com/pages/about/index.html","excerpt":"简简单单，平平凡凡。","text":"简简单单，平平凡凡。"},{"title":"留言板","date":"2024-03-08T10:58:49.000Z","updated":"2024-03-10T03:12:22.265Z","comments":true,"path":"pages/board/index.html","permalink":"https://momashanhe.com/pages/board/index.html","excerpt":"遵纪守法，友善发言。","text":"遵纪守法，友善发言。"},{"title":"通讯录","date":"2024-02-25T14:23:13.000Z","updated":"2024-04-22T01:34:50.491Z","comments":true,"path":"pages/friend/index.html","permalink":"https://momashanhe.com/pages/friend/index.html","excerpt":"红尘漫漫，增减随缘。","text":"红尘漫漫，增减随缘。 名片夹大佬大佬的博客Akilarの糖果屋期待您的光临！安知鱼生活明朗，万物可爱xaoxuu风暴前夕BeaCoxOn the way to be a hacker.失联失联的博客测试测试友链测试测试友链测试测试友链测试测试友链 个人名片card12345title: 墨码山河avatar: url: https://momashanhe.com/screenshot: description: 代码改变世界 建议avatar使用分辨率为200px的图片。建议screenshot使用https://image.thum.io/get/width/400/crop/800/allowJPG/wait/20/noanimate/https://momashanhe.com/网站生成的图片。 用户须知 免责声明 本站作者遵守中华人民共和国相关法律，本页内容中的网站链接仅为方便学习而创建，均为其他网站。虽然本站作者会对绝大多数的网站内容进行鉴别，并取消存在风险的网站链接。但因本站作者能力有限，无法判断网站链接指向的网站内容是否存在安全问题，并且无法判断在收录后是否增加了违法内容。故而用户在通过本页内容中的网站链接访问其他网站时，仍然无法避免风险，包括但不限于：网站链接的网站作者更换了网站链接的指向，替换成了其他内容；网站链接的网站作者修改了文章内容，增加了钓鱼网站、广告等其他无效信息；网站链接的服务器被恶意攻击、劫持、注入了其他内容；网站链接的域名到期，被不法分子改做他用；网站链接的规则不完善，对用户的隐私造成了侵害、泄漏。本页内容中的文章链接均为机器自动抓取，本站作者未经过任何审核和筛选，不能保证文章内容的安全可靠。本页内容中的网站链接指向的网站内容如果给用户造成了损失，本站作者深表歉意，建议用户如果发现问题请及时和本站作者联系，避免给更多用户造成损失。"}],"posts":[{"title":"使用Babel解决兼容问题","slug":"100-大前端/103-JS/002-技巧/001-使用Babel解决兼容问题","date":"2024-08-02T06:55:26.000Z","updated":"2024-08-02T07:20:03.756Z","comments":true,"path":"posts/20240802/145526/","permalink":"https://momashanhe.com/posts/20240802/145526/","excerpt":"摘要：本文主要学习了如何使用Babel解决ES5之后的版本的兼容问题。","text":"摘要：本文主要学习了如何使用Babel解决ES5之后的版本的兼容问题。 1 说明Babel是一个工具链，主要用于将采用ES5以后的语法编写的代码转换为ES5语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 官网地址：https://www.babeljs.cn/ 2 使用进行初始化： cmd1npm init --yes 安装相关的开发依赖： cmd1npm i babel-cli babel-preset-env browserify -D 说明： babel-cli：命令行工具 babel-preset-env：预设包，进行转换 browserify：打包工具，比webpack更简单 进行转换： cmd1npx babel 原路径 -d 新路径 --presets=babel-preset-env 说明： 局部安装需要使用npx命令，全局安装可以直接使用babel命令。 在未设置配置文件的情况下，需要使用--presets指定配置。 进行打包： cmd1npm browserify 转换后的新文件 -o 打包后的新文件 网页中只要引用最后打包后的新文件即可，在修改原JS文件后，需要重新执行打包的命令。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"ES学习","slug":"100-大前端/103-JS/001-基础/004-ES学习","date":"2024-07-18T07:24:38.000Z","updated":"2024-08-12T07:05:00.883Z","comments":true,"path":"posts/20240718/152438/","permalink":"https://momashanhe.com/posts/20240718/152438/","excerpt":"摘要：本文主要学习了ECMAScript的基本知识。","text":"摘要：本文主要学习了ECMAScript的基本知识。 1 简介1.1 定义ECMAScript是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范。 JavaScript是ECMAScript的实现，一般情况下，ECMAScript和JavaScript表达的是同一个意思。 严格来说，JavaScript包含三个部分： ECMAScript：核心，通用标准，简写为ES DOM：文档对象模型，操作网页 BOM：浏览器对象模型，操作浏览器 1.2 历史版本ES5：2009年发布ES6：2015年发布，也称为ECMA2015ES7：2016年发布，也称为ECMA2016ES8：2017年发布，也称为ECMA2017ES9：2018年发布，也称为ECMA2018ES10：2019年发布，也称为ECMA2019 2 ES52.1 严格模式在ES5中新增了严格模式，其作用是： 使得JS在更严格的条件下运行 消除JS语法的一些不合理、不严谨之处，减少一些怪异行为 消除JS代码运行的一些不安全之处，保证代码运行的安全 使用方式是在JS的第一行： js1&#x27;use strict&#x27;; 需要记住的几个变化： 声明定义变量必须用var关键字：js12&#x27;use strict&#x27;;age = 18;// 页面报错 禁止自定义的函数中的this关键字指向全局对象：js12345&#x27;use strict&#x27;;function Person(age) &#123; this.age = age&#125;Person(18);// 页面报错 创建eval作用域：js1234&#x27;use strict&#x27;;var age = 16;eval(&#x27;var age = 18;&#x27;);// 使用eval()方法可以执行传入的命令，有风险，不建议使用console.log(age);// 16 只在eval作用域有效，不会污染全局变量 2.2 JSON支持JSON是一种轻量级的数据交换模式，用于传输数据。 ES5提供了对JSON的支持： js1234567891011var obj = &#123; age: 18&#125;console.log(obj);// &#123;age: 18&#125;console.log(typeof obj);// objectvar jsonStr = JSON.stringify(obj);console.log(jsonStr);// &#123;&quot;age&quot;:18&#125;console.log(typeof jsonStr);// string 将对象或数组转为JSON字符串var jsonObj = JSON.parse(jsonStr);console.log(jsonObj);// &#123;age: 18&#125;console.log(typeof jsonObj);// object 将JSON字符串转为对象或数组 2.3 Object扩展增加了一种创建对象的方式，支持通过将指定对象作为原型的方式创建对象： js1234567var obj = &#123; age: 18&#125;var newObj = &#123;&#125;console.log(newObj.__proto__);// &#123;__proto__: null&#125;newObj = Object.create(obj);console.log(newObj.__proto__);// &#123;age: 18&#125; 增加操作属性的方法： js12345var obj = &#123; age: 18&#125;Object.defineProperty(obj, &quot;age&quot;, &#123;value : 16&#125;)console.log(obj.age);// 16 2.4 Array扩展查询元素在数组中的下标： js123var arr = [1, 2, 3, 2, 1];console.log(arr.indexOf(2));// 1 指定元素在数组中首次出现的下标console.log(arr.lastIndexOf(2));// 3 指定元素在数组中最后出现的下标 遍历数组： js1234var arr = [1, 2, 3, 2, 1];arr.forEach(function (item, index) &#123; console.log(&quot;[&quot; + index + &quot;]&quot;, item);&#125;); 对数组进行处理： js12345var arr = [1, 2, 3, 2, 1];var newArr = arr.map(function (item, index) &#123; return item + 10&#125;);console.log(newArr); 对数组进行过滤： js12345var arr = [1, 2, 3, 2, 1];var newArr = arr.filter(function (item, index) &#123; return item &gt; 1&#125;);console.log(newArr); 2.5 Function扩展将函数的this对象修改为指定的对象： js12345678910111213141516var age = 18;function fun(age) &#123; this.age = age; console.log(this + &#x27; age = &#x27; + this.age);&#125;fun(20);// [object Window] age = 20console.log(age);// 20var obj = &#123;&#125;;// 修改方法的this对象，返回新方法var newFun = fun.bind(obj, 12);console.log(obj.age);// undefinedconsole.log(obj);// &#123;&#125;// 执行新方法newFun();// [object Object] age = 12console.log(obj.age);// 12console.log(obj);// &#123;age: 12&#125; 也可以直接执行新方法，需要在方法后面增加()，相当于call()方法： js1234567891011var age = 18;function fun(age) &#123; this.age = age; console.log(this + &#x27; age = &#x27; + this.age);&#125;fun(20);// [object Window] age = 20console.log(age);// 20var obj = &#123;&#125;;// 修改方法的this对象，并执行新方法，相当于fun.call(obj, 16)fun.bind(obj, 16)();// [object Object] age = 16console.log(obj);// &#123;age: 16&#125; 3 ES63.1 声明变量使用let关键字声明变量： 方式 作用域 重复声明 声明提升 使用var关键字声明变量 属于全局变量 可以重复声明 存在变量提升 使用let关键字声明变量 属于局部变量，会创建一个块级作用域 不能重复声明 不会预处理，不存在提升 使用const关键字声明的变量被称为常量，和let关键字类似，唯一的区别是不支持修改变量的值。 为了更好的区分常量，其标识符一般使用大写。 3.2 解构赋值按照一定模式，从数组或者对象中提取值，对变量进行赋值，这被称为解构赋值。 对象解构可以同时获取对象多个属性，但是要求属性名一致，使用&#123;&#125;包裹，按属性赋值： js12345678let obj = &#123; age:18, sex:&#x27;男&#x27;&#125;;let &#123;age, sex&#125; = obj;// 获取多个属性console.log(age, sex);// 18 &#x27;男&#x27;let &#123;age: objAge, sex: objSex&#125; = obj;// 解构同时使用别名console.log(objAge, objSex);// 18 &#x27;男&#x27; 数组解构可以同时获取多个元素，对变量名没有要求，使用[]包裹，按下标顺序赋值： js123let arr = [1, 2, 3, 2, 1];let [a, b, , , c, d] = arr;console.log(a, b, c, d);// 1 2 1 undefined 3.3 模板字符串使用模板字符串可以简化字符串的拼接，支持在字符串中使用变量、对象、表达式、方法的返回值。 对于模板字符串需要使用``包裹，在字符串中的模板需要使用$&#123;&#125;包裹： js1234567891011121314let obj = &#123; age:18, sex:&#x27;男&#x27;&#125;;console.log(`个人信息：年龄：$&#123;obj.age&#125;性别：$&#123;obj.sex&#125;以上数据真实有效`);// 支持换行function fun() &#123; return &quot;test&quot;;&#125;console.log(`获取返回值：$&#123;fun()&#125;`)// 支持获取返回值let arr = [1, 2, 3, 2, 1];console.log(`数组内容：$&#123;arr&#125;`);// 支持变量和数组 3.4 简化对象在定义对象时，可以直接写入变量和函数作为对象的属性方法，这样的书写更加简洁： js123456789let age = 18;let sex = &quot;男&quot;;let test = function() &#123;console.log(&quot;test&quot;)&#125;let obj = &#123; age, sex, test&#125;;console.log(obj)// &#123;age: 18, sex: &#x27;男&#x27;, test: ƒ&#125; 3.5 箭头函数使用() =&gt; &#123;&#125;箭头函数简化了函数的定义和调用，特点： js12345678910// 没有参数，不能省略箭头左侧的()符号，一条语句，可以省略箭头右侧的`&#123;&#125;`符号let fun1 = () =&gt; console.log(&quot;test&quot;);fun1();// test// 一个参数，可以省略箭头左侧的`()`符号，一条语句，可以省略return关键字，默认将结果作为返回值let fun2 = str =&gt; &quot;str = &quot; + str;console.log(fun2(&quot;test&quot;));fun2(&#x27;hello&#x27;);// str = test// 多个参数，不能省略箭头左侧的()符号，多条语句，不能省略箭头右侧的`&#123;&#125;`符号，不能省略return关键字let fun3 = (age,sex) =&gt; &#123;let obj = &#123;age, sex&#125;; return obj&#125;;console.log(fun3(18,&quot;男&quot;));// &#123;age: 18, sex: &#x27;男&#x27;&#125; 3.6 扩展运算符扩展运算符就是使用...变量名作为变量，在特定场景下具有收集和扩展的功能。 使用扩展运算符的收集功能可以实现可变参数，必须将可变参数放在参数列表最后的位置： js1234function fun(a,b,...c) &#123; console.log(a,b,c);&#125;fun(1,2,3,4,5);// 1 2 [3, 4, 5] 使用扩展运算符的扩展功能可以更加方便的操作数组： js1234let arr1 = [1,2,3];let arr2 = [4,5];let arr3 = [...arr1,...arr2];console.log(arr3);// [1, 2, 3, 4, 5] 还可以将伪数组转为真数组： js1234let home = document.getElementsByTagName(&#x27;div&#x27;);let arr = [...home];console.log(home);// HTMLCollection [div]console.log(arr);// [div] 3.7 参数默认值在定义函数时，支持设置参数的默认值，当没有传入参数时，会使用定义的默认值： js1234function fun(str = &quot;test&quot;) &#123; console.log(&quot;hello&quot;, str)&#125;fun();// hello test 3.8 Symbol新增Symbol原始数据类型，用于解决命名冲突的问题，主要用于需要保证属性名唯一的场景。 Symbol属于第七种数据类型，其他六种是：Object，String，Number，Boolean，Null，Undefined。 创建Symbol类型的数据，因为不是对象，所以不能使用new关键字： js123let s = Symbol();console.log(s);// Symbol()console.log(typeof s);// symbol 支持在创建时传入参数作为标识符，支持其他类型数据，包括对象： js1234let s1 = Symbol(&quot;test&quot;);console.log(s1);// Symbol(test)let s2 = Symbol(&#123;age:18,sex:&quot;男&quot;&#125;);console.log(s2);// Symbol([object Object]) 在ES10中，增加了description属性，用于获取传入的参数： js12let s = Symbol(&quot;test&quot;);console.log(s.description);// test 即使创建了相同的Symbol数据，两个数据也是不同的，这就是Symbol的唯一性： js12console.log(Symbol() == Symbol());// falseconsole.log(Symbol(&quot;test&quot;) == Symbol(&quot;test&quot;));// false 如果想要创建相同的数据，需要使用Symbol.for()创建： js1234console.log(Symbol === Symbol.for());// falseconsole.log(Symbol.for() === Symbol.for());// trueconsole.log(Symbol === Symbol.for(&quot;test&quot;));// falseconsole.log(Symbol.for(&quot;test&quot;) === Symbol.for(&quot;test&quot;));// true 通过Symbol.for()创建数据时会先从全局按照参数获取，如果获取到了就返回数据，如果没有获取到就会创建数据并注册到全局。 使用Symbol.keyFor()获取全局中的参数： js12let s = Symbol.for(&quot;test&quot;);console.log(Symbol.keyFor(s));// test 将Symbol作为对象的属性： js123456789let name = Symbol(&quot;name&quot;);let obj = &#123; [name]: &quot;test&quot;// 在创建对象时创建Symbol数据作为属性&#125;;let sex = Symbol(&quot;sex&quot;);obj[sex] = &#x27;男&#x27;;// 给对象手动设置Symbol数据作为属性let age = Symbol(&quot;age&quot;);Object.defineProperty(obj, age, &#123;value : 18&#125;);// 通过defineProperty方法设置Symbol数据作为属性console.log(obj);// &#123;Symbol(name): &#x27;test&#x27;, Symbol(sex): &#x27;男&#x27;, Symbol(age): 18&#125; 虽然Symbol属性是共有属性，但是在遍历对象时，不会出现在for循环中，也不会被Object的keys()方法和getOwnPropertyNames()方法获取，同样也不会被JSON.stringify()返回。 可以通过Object的getOwnPropertySymbols()方法获取，只能获取Symbol属性： js123456let obj = &#123; [Symbol(&quot;name&quot;)]: &quot;test&quot;, [Symbol(&quot;sex&quot;)]: &quot;男&quot;, age: 18&#125;;console.log(Object.getOwnPropertySymbols(obj));// [Symbol(name), Symbol(sex)] 也可以使用Reflect.ownKeys()方法获取所有类型的属性名： js123456let obj = &#123; [Symbol(&quot;name&quot;)]: &quot;test&quot;, [Symbol(&quot;sex&quot;)]: &quot;男&quot;, age: 18&#125;;console.log(Reflect.ownKeys(obj));// [&#x27;age&#x27;, Symbol(name), Symbol(sex)] 3.9 Promise引入Promise用于解决异步编程的问题，使用构造函数封装异步操作并可以获取其成功或失败的结果。 在执行完成后，Promise的状态会变成fulfilled（成功）或者rejected（失败），这种改变称为resolved（定型），并且一旦发生定型，结果就不会再次发生改变。 创建对象： js123456789101112let promise = new Promise(function(resolve, reject) &#123; // 异步操作 let value;// 返回值 let error;// 错误 let result = true;// 异步操作结果 if (result)&#123; resolve(value);// 异步操作成功 &#125; else &#123; reject(error);// 异步操作失败 &#125;&#125;); 执行异步操作： js12345p.then(function (value)&#123; console.log(value);// 异步操作成功执行的方法&#125;, function (error)&#123; console.log(error);// 异步操作失败执行的方法&#125;); 捕获异步操作中的异常： js123p.catch(function (reason)&#123; console.log(reason);// 异步操作出现异常的处理，包括then方法中出现的异常&#125;); 3.10 Iterator迭代器Iterator是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署了Iterator接口就可以完成遍历操作。 可以使用新的遍历命令for...of循环，部署了Iterator接口的数据接口可以通过for...of循环进行遍历。 和for...in循环相比，通过for...of循环的是value键值，而for...in循环的是index键名。 原生具备Iterator接口的数据，即不需要改动就可以使用for...of循环的有：Array、Arguments、Set、Map、String、TypedArray、NodeList。 非原生的数据可以通过自定义Iterator接口使用for...of循环。 原生Iterator接口： js12345678910111213141516171819202122232425let names = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;];// for...infor (let index in names) &#123; // 0 张三 // 1 李四 // 2 王五 console.log(index + &quot; &quot; + names[index]);&#125;// for...offor (let value of names) &#123; // 张三 // 李四 // 王五 console.log(value);&#125;// iterator.next()let iterator = names[Symbol.iterator]();for(var item = iterator.next(); item.done != true; item = iterator.next()) &#123; // &#123;value: &#x27;张三&#x27;, done: false&#125; // &#123;value: &#x27;李四&#x27;, done: false&#125; // &#123;value: &#x27;王五&#x27;, done: false&#125; console.log(item);&#125;// &#123;value: undefined, done: true&#125;console.log(item); 自定义Iterator接口： js1234567891011121314151617181920212223242526272829303132333435363738let person = &#123; name: &quot;张三&quot;, home: [&#x27;北京市&#x27;, &#x27;北京市&#x27;, &#x27;东城区&#x27;], [Symbol.iterator]()&#123; // 索引变量 let index = 0; // 保存this let _this = this; return &#123; next: function ()&#123; if(index &lt; Object.keys(_this).length)&#123; let result = &#123; value: _this[Object.keys(_this)[index]], done: false &#125; // 下标自增 index ++; // 返回结果 return result; &#125;else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125; &#125; &#125;&#125;// iterator.next()let iterator = person[Symbol.iterator]();for(var item = iterator.next(); item.done != true; item = iterator.next()) &#123; // &#123;value: &#x27;张三&#x27;, done: false&#125; // &#123;value: Array(3), done: false&#125; console.log(item);&#125;// &#123;value: undefined, done: true&#125;console.log(item); 3.11 Generator生成器Generator是一种异步编程解决方案，语法行为与传统函数完全不同。 在创建时需要使用*符号创建，用于和普通函数区分： js123function * gen()&#123; console.log(&quot;hello&quot;);&#125; 在调用时返回的是迭代器Iterator对象，所以需要使用next()方法调用： js12let iterator = gen();iterator.next();// hello 在创建时，可以使用yield对函数中的内容进行分割，在调用next()方法执行时，会按照yield分割执行，并返回yield后面的值： js1234567891011121314151617function * gen()&#123; console.log(&quot;hello1&quot;); yield 1 console.log(&quot;hello2&quot;); yield 2 console.log(&quot;hello3&quot;);&#125;// hello1// &#123;value: 1, done: false&#125;let iterator = gen();console.log(iterator.next());// hello2// &#123;value: 2, done: false&#125;console.log(iterator.next());// hello3// &#123;value: undefined, done: true&#125;console.log(iterator.next()); 在调用时，支持传入参数，需要在方法中接收yield的值： js1234567891011121314151617function * gen(arg)&#123; console.log(arg); let arg1 = yield 1 console.log(arg1); let arg2 = yield 2 console.log(arg2);&#125;// arg1// &#123;value: 1, done: false&#125;let iterator = gen(&quot;arg1&quot;);console.log(iterator.next());// arg2// &#123;value: 2, done: false&#125;console.log(iterator.next(&quot;arg2&quot;));// arg3// &#123;value: undefined, done: true&#125;console.log(iterator.next(&quot;arg3&quot;)); 3.12 Set新增Set对象用于存储不重复的数据列表，默认实现了Iterator接口，支持存储不同类型的数据。 使用： js12345678910111213141516171819let s = new Set();// 使用add()方法添加s.add(1);s.add(&#x27;2&#x27;);let arr = [3, 4, 5]s.add(arr);console.log(s);// Set(3) &#123;1, &#x27;2&#x27;, Array(3)&#125;// 使用has()方法判断是否存在console.log(s.has(arr));// true// 使用size查询数据个数console.log(s.size);// 3// 使用forEach()方法遍历s.forEach(v =&gt; console.log(v));// 1 2 (3) [3, 4, 5]// 使用delete()方法删除s.delete(arr);console.log(s);// Set(2) &#123;1, &#x27;2&#x27;&#125;// 使用clear()方法删除所有数据s.clear();console.log(s);// Set(0) &#123;size: 0&#125; 3.13 Map新增Map对象用于存储键值对，默认实现了Iterator接口，支持存储不同类型的键和值。 Map和Object一样，都可以存储对象的属性名和属性值，区别是Object的属性名只能是String类型或Symbol类型，而Map的键可以使任意类型。 使用： js123456789101112131415161718192021let m = new Map();// 使用set()方法添加m.set(1, 1);m.set(&#x27;2&#x27;, &#x27;2&#x27;);let arr = [3, 4, 5]m.set(arr, arr);console.log(m);// Map(3) &#123;1 =&gt; 1, &#x27;2&#x27; =&gt; &#x27;2&#x27;, Array(3) =&gt; Array(3)&#125;// 使用get()方法通过键获取值console.log(m.get(arr));// (3) [3, 4, 5]// 使用has()方法判断是否存在console.log(m.has(arr));// true// 使用size查询键值对个数console.log(m.size);// 3// 使用forEach()方法遍历m.forEach((k, v) =&gt; console.log(k + &#x27; = &#x27; + v));// 1 = 1 2 = 2 3,4,5 = 3,4,5// 使用delete()方法删除m.delete(arr);console.log(m);// Map(2) &#123;1 =&gt; 1, &#x27;2&#x27; =&gt; &#x27;2&#x27;&#125;// 使用clear()方法删除所有数据m.clear();console.log(m);// Map(0) &#123;size: 0&#125; 3.14 Class引入了类的概念，作为对象的模板，需要使用class关键字声明。 使用： js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Human &#123; // 使用constructor关键字声明构造方法 constructor(name) &#123; this.name = name; &#125; // 声明对象方法 hello() &#123; console.log(&quot;我是&quot;, this.name); &#125; test() &#123; console.log(&quot;父类&quot;); &#125; home() &#123; console.log(&quot;地球&quot;); &#125; // 使用static关键字声明静态属性，不能通过对象调用，只能通过类调用 static eat = &quot;食物&quot;; // 通过set关键字定义设置属性的方法 set age(age) &#123; console.log(&quot;设置年龄&quot;, age); &#125; // 通过get关键字定义获取属性的方法 get age() &#123; console.log(&quot;读取年龄&quot;); return 100; &#125;&#125;// 使用extends可以继承父类，自动拥有父类定义的属性和方法class Worker extends Human &#123; // 创建子类的对象方法 work() &#123; console.log(&quot;工作&quot;); &#125; // 重写父类的方法，默认调用的是子类重写的方法，使用super关键字调用父类的方法 test() &#123; console.log(&quot;子类&quot;); super.home(); &#125;&#125;let h = new Human(&quot;人类&quot;);h.hello();// 我是 人类console.log(h.name);// 人类console.log(h.eat);// undefinedconsole.log(Human.eat);// 食物let w = new Worker(&quot;工人&quot;);w.hello();// 我是 工人w.work();// 工作w.test();// 子类 地球h.age = 100;// 设置年龄 100h.age;// 读取年龄 3.15 数值扩展引入了二进制和八进制的新写法： js12console.log(0b100);// 4 二进制以0b开头，二进制100对应十进制4console.log(0o100);// 64 八进制以0o开头，八进制100对应十进制64 定义最小精度，其值接近于2.22×10^(-16)，即2.22乘以10的-16次方。 当无法准确的描述数值时，就会产生精度问题，比如无法通过二进制准确的表示0.1，再比如无法通过十进制表示1&#x2F;3，等等。 当两个数的差值小于Number.EPSILON时，就认为两个数值是相等的： js12345console.log(0.1 + 0.2 === 0.3);// falsefunction equal(left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;console.log(equal(0.1 + 0.2, 0.3));// true 检测数值是否是有限数： js12console.log(Number.isFinite(1));// trueconsole.log(Number.isFinite(1/0));// false 检测数值是否为NaN： js123console.log(Number.isFinite(1));// trueconsole.log(Number.isFinite(NaN));// falseconsole.log(Number.isFinite(null));// false 检测数值是否为整数： js12console.log(Number.isInteger(1));// trueconsole.log(Number.isInteger(1.1));// false 将字符串转为整数和浮点数： js12console.log(Number.parseInt(&quot;123test456&quot;));// 123console.log(Number.parseFloat(&quot;0.123test456&quot;));// 0.123 检测数值是整数、负数还是零： js123console.log(Math.sign(10));// 1console.log(Math.sign(0));// 0console.log(Math.sign(-10));// -1 将数值的小数部分抹掉： js1console.log(Math.trunc(1.1));// 1 3.16 对象方法扩展判断两个值是否完全相等： js123console.log(Object.is(10, 10));// trueconsole.log(Object.is(NaN, NaN));// trueconsole.log(NaN === NaN);// false 对象的合并，当旧对象中有新对象中没有的时候，会进行合并，否则会直接覆盖： js123456789let oldObj = &#123; name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125;let newObj = &#123; name: &#x27;李四&#x27;, age: 18&#125;console.log(Object.assign(oldObj, newObj));// &#123;name: &#x27;李四&#x27;, sex: &#x27;男&#x27;, age: 18&#125; 操作原型对象： js12345678910let human = &#123; eat: &#x27;食物&#x27;&#125;let worker = &#123; work: &#x27;打工&#x27;&#125;console.log(worker.__proto__);// &#123;...&#125;Object.setPrototypeOf(worker, human);console.log(worker.__proto__);// &#123;eat: &#x27;食物&#x27;&#125;console.log(worker.__proto__ == Object.getPrototypeOf(worker));// true 3.17 模块化3.17.1 说明模块化是指将一个大的程序文件拆成许多小的文件，然后进行组合。 优势： 防止命名冲突：不同的模块之间可以使用相同名称的变量，彼此互不干扰。 代码复用：模块可以对外提供接口，相同的功能可以使用同一接口。 高维护性：模块之间独立运行，单个模块出现问题不会影响所有模块，模块支持单独升级。 模块化规范比较： CommonJSAMDCMDES6专用于服务器端，默认不支持在浏览器执行。 在服务器端使用，基于Node.js使用。在浏览器端使用，使用Browserify编译打包JS文件，这个工具也是JS常用的打包工具。专用于浏览器端，模块的加载时异步的。 在浏览器端使用，基于Require.js使用。专用于浏览器端，模块的加载时异步的，并且在模块使用时才会加载和执行。 在浏览器端使用，基于Sea.js使用。专用于浏览器端。 在浏览器端使用，使用Babel将ES6编译为兼容ES5的代码，使用Browserify编译打包JS文件。 3.17.2 导出方式使用export关键字将变量或方法导出。 分别导出，在JS文件中分别指定导出的变量或方法： test.js1234export let hello = &quot;hello&quot;;export function test() &#123; console.log(&quot;test&quot;);&#125; 统一导出，使用export关键字要导出的变量和方法集中导出： test.js12345let hello = &quot;hello&quot;;function test() &#123; console.log(&quot;test&quot;);&#125;export &#123;hello, test&#125; 统一导出提供的并不是对象，所以导出的不是对象的简写形式，而是导出的标记，可以认为是名称。 默认导出，将要导出的变量和方法封装为对象： test.js12345678let hello = &quot;hello&quot;;function test() &#123; console.log(&quot;test&quot;);&#125;export default &#123; hello, test&#125; 默认导出提供的是对象，导出的内容是对象的简写形式，这一点和统一导出不同。 3.17.3 导入方式使用import关键字将其他模块导出的变量或方法导入进来，同时设置script元素的type属性的值为module表示引入的是模块JS文件，并不是普通的JS文件。 全部导入，使用*将导出的全部变量和方法导入到页面： test.html12345&lt;script type=&quot;module&quot;&gt;import * as test from &quot;./test.js&quot;;console.log(test.hello);test.test();&lt;/script&gt; 命名导入，指定导入的变量和方法： test.html12345&lt;script type=&quot;module&quot;&gt;import &#123;hello, test&#125; from &quot;./test.js&quot;;console.log(hello);test();&lt;/script&gt; 使用命名导入可以使用分别导出和统一导出的变量和方法，不能直接使用默认导出的变量和方法。 默认导入，可以使用默认导出的变量和方法： test.html12345678&lt;script type=&quot;module&quot;&gt;// import * as test from &quot;./test.js&quot;;// console.log(test.default.hello);// test.default.test();import test from &quot;./test.js&quot;;console.log(test.hello);test.test();&lt;/script&gt; 如果默认导出的只有一个变量或方法，在默认导入时导入的就是该变量或方法，不需要通过对象获取。 如果有大量模块需要引入，可以新建JS文件用于引入模块，然后将此文件引入到HTML文件： app.js1import * as test from &quot;./test.js&quot;; 在HTML文件中引入JS文件： test.html1&lt;script src=&quot;./app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 4 ES74.1 数组增强判断数组是否包含某个数据： js123let nums = [1, 2, 3];console.log(nums.includes(1));// trueconsole.log(nums.includes(4));// false 4.2 指数操作符引入**指数运算符，用来实现幂运算，功能与Math.pow结果相同： js12console.log(2 ** 4);// 16console.log(Math.pow(2, 4));// 16 5 ES85.1 async和await5.1.1 async函数async函数会将返回值封装为Promise对象： js12345async function fun() &#123; console.log(&quot;fun&quot;);&#125;let result = fun();console.log(result);// Promise &#123;&lt;fulfilled&gt;: undefined&#125; 当函数执行成功时返回的是fulfilled状态的Promise对象，当函数执行失败时返回的是rejected状态的Promise对象。 当函数返回的是Promise对象时，不会再次封装，会将返回对象直接返回。 5.1.2 await表达式await表达式必须写在async函数中，并且await右侧的表达式一般为Promise对象。 await返回的是Promise成功的值，需要使用手动捕获Promise失败的值。 使用： js12345678910111213141516171819let promise = new Promise(function(resolve, reject) &#123; console.log(&quot;promise&quot;); if (true)&#123; resolve(&quot;success&quot;); &#125; else &#123; reject(&quot;error&quot;); &#125;&#125;);async function fun() &#123; console.log(&quot;fun&quot;); try &#123; let result = await promise; console.log(result); &#125; catch (e) &#123; console.log(e); &#125;&#125;let result = fun();console.log(result);// Promise &#123;&lt;fulfilled&gt;: undefined&#125; 5.2 对象方法扩展获取对象的属性名和属性值： js1234567891011let person = &#123; name: &quot;test&quot;, sex: &quot;男&quot;&#125;;console.log(Object.keys(person));// [&#x27;name&#x27;, &#x27;sex&#x27;]console.log(Object.values(person));// [&#x27;test&#x27;, &#x27;男&#x27;]console.log(Object.entries(person));// [Array(2), Array(2)]let map = Object.entries(person);// [&#x27;name&#x27;, &#x27;test&#x27;]// [&#x27;sex&#x27;, &#x27;男&#x27;]map.forEach(obj =&gt; console.log(obj)); 获取对象属性信息： js12345678let person = &#123; name: &quot;test&quot;, sex: &quot;男&quot;&#125;;// name: &#123;value: &#x27;test&#x27;, writable: true, enumerable: true, configurable: true&#125;// sex: &#123;value: &#x27;男&#x27;, writable: true, enumerable: true, configurable: true&#125;// [[Prototype]]: Objectconsole.log(Object.getOwnPropertyDescriptors(person)); 6 ES96.1 Rest和Spreadrest参数与spread扩展运算符在ES6中已经引入，不过ES6中只针对于数组。 使用rest参数： js1234567891011// function test(&#123;name, sex&#125;) &#123;// console.log(name);// console.log(sex);// &#125;function test(&#123;...args&#125;) &#123; console.log(args);&#125;test(&#123; name: &quot;张三&quot;, sex: &quot;男&quot;,&#125;); 使用spread扩展运算符： js1234567891011let attr1 = &#123; name: &quot;张三&quot;&#125;let attr2 = &#123; sex: &quot;男&quot;&#125;let attr3 = &#123; age: &quot;18&quot;&#125;let person = &#123;...attr1, ...attr2, ...attr3&#125;console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;, age: &#x27;18&#x27;&#125; 6.2 正则扩展6.2.1 捕获分组ES9允许使用符号?&lt;name&gt;获取捕获结果，可读性更强。 在ES9之前捕获结果，通过下标查看捕获分组，下标为0的元素是完整的匹配内容： js1234567var reg = /(123)(a.a)/g;var result;while(result = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // 123 a4a // 123 a5a console.log(result[1], result[2]);&#125; 在ES9之后捕获结果： js1234567var reg = /(?&lt;first&gt;123)(?&lt;last&gt;a.a)/g;var result;while(result = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // 123 a4a // 123 a5a console.log(result.groups.first, result.groups.last);&#125; 6.2.2 反向断言通过正则表达式的?=符号进行正向断言，根据后面的判断是否返回前面的数据： js1234let test = &#x27;测试123正向456断言&#x27;;let reg = /\\d+(?=正向)/;// 根据后面的内容是否正向，返回前面的数字let result = reg.exec(test);console.log(result[0]);// 123 通过正则表达式的?&lt;=符号进行反向断言，根据前面的判断是否返回后面的数据： js1234let test = &#x27;测试123反向456断言&#x27;;let reg = /(?&lt;=反向)\\d+/;// 根据前面的内容是否反向，返回后面的数字let result = reg.exec(test);console.log(result[0]);// 456 6.2.3 dotAll模式使用.匹配除回车外的任何单字符，如果使用了s就可以匹配包括回车在内的任何单字符： js123456789101112131415161718192021let test = `&lt;ul&gt; &lt;li&gt; &lt;a&gt;这是第1个a标签&lt;/a&gt; &lt;p&gt;这是第1个p标签&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;这是第2个a标签&lt;/a&gt; &lt;p&gt;这是第2个p标签&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;`;var reg = /&lt;a&gt;(.*?)&lt;\\/a&gt;\\s+&lt;p&gt;(.*?)&lt;\\/p&gt;/g;// 使用之前的方式，通过\\s+过滤空格和换行，匹配两个标签中的内容var result;while (result = reg.exec(test)) &#123; console.log(result[1] + &#x27; &gt;&gt;&gt; &#x27; + result[2]);&#125;var reg = /&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;/gs;// 使用dotAll模式，通过s让.包含任何单字符，匹配两个标签中的内容while (result = reg.exec(test)) &#123; console.log(result[1] + &#x27; &gt;&gt;&gt; &#x27; + result[2]);&#125; 7 ES107.1 创建对象通过二维数组创建对象： js12345let person = Object.fromEntries([ [&#x27;name&#x27;, &#x27;张三&#x27;], [&#x27;sex&#x27;, &#x27;男&#x27;]]);console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125; 通过Map创建对象： js12345let map = new Map();map.set(&#x27;name&#x27;, &#x27;张三&#x27;);map.set(&#x27;sex&#x27;, &#x27;男&#x27;);let person = Object.fromEntries(map);console.log(person);// &#123;name: &#x27;张三&#x27;, sex: &#x27;男&#x27;&#125; Object类的fromEntries()方法是entries()方法的反向操作。 7.2 字符串扩展新增支持清除字符串空格的方法： js123let str = &#x27; hello &#x27;;console.log(str.trimStart());// 清除左侧空格console.log(str.trimEnd());// 清除右侧空格 7.3 数组扩展将高维数组转为低维数组，支持设置向下转变的维度数目，默认向下转变1个维度： js12345var arr = [1,2,[3,4]];console.log(arr.flat());// [1, 2, 3, 4]var arr = [1,2,[3,4,[5,6]]];console.log(arr.flat());// [1, 2, 3, 4, [5, 6]]console.log(arr.flat(2));// [1, 2, 3, 4, 5, 6] 在map()方法的基础上，增加了flatMap()方法，用于将结果向下维度转换处理： js123var arr = [1,2];var result = arr.flatMap(item =&gt; [item * 10]);console.log(result);// [10, 20] 7.4 Symbol扩展支持在创建Symbol对象的时候传入描述内容： js12var s = Symbol(&#x27;测试&#x27;);console.log(s.description);// 测试 8 ES118.1 私有属性在属性前面添加#符号表示该属性是私有属性： js1234567891011class Person &#123; name; #age; constructor(name, age) &#123; this.name = name; this.#age = age; &#125;&#125;let p = new Person(&#x27;张三&#x27;, 18);console.log(p);// Person &#123;name: &#x27;张三&#x27;, #age: 18&#125;console.log(p.#age);// 报错 8.2 Promise扩展新增Promise的allSettled()静态方法，接收Promise数组作为入参，将结果封装为Promise返回，状态为成功，值为数组的每个Promise执行的状态和结果： js12345678910111213141516171819202122232425262728293031323334353637let p1result = false;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (p1result) &#123; resolve(&quot;p1成功&quot;); &#125; else &#123; reject(&quot;p1失败&quot;); &#125; &#125;, 100);&#125;);let p2result = true;let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (p2result) &#123; resolve(&quot;p2成功&quot;); &#125; else &#123; reject(&quot;p2失败&quot;); &#125; &#125;, 100);&#125;);// 方法永远返回成功Promise.allSettled([p1, p2]).then(function (value)&#123; console.log(&quot;allSettled执行成功&quot;); // &#123;status: &#x27;rejected&#x27;, reason: &#x27;p1失败&#x27;&#125; // &#123;status: &#x27;fulfilled&#x27;, value: &#x27;p2成功&#x27;&#125; value.forEach((result) =&gt; console.log(result));&#125;, function (error)&#123; console.log(&quot;allSettled执行失败 &quot; + error);&#125;);// 只要有一个失败，方法就返回失败Promise.all([p1, p2]).then(function (value)&#123; console.log(&quot;all执行成功&quot;); value.forEach((result) =&gt; console.log(result));&#125;, function (error)&#123; // all执行失败 p1失败 console.log(&quot;all执行失败 &quot; + error);&#125;); 和Promise的all()静态方法不同，allSettled()方法不论数组里的结果是否成功，始终返回成功，all()会在数组里的结果存在失败时，返回失败。 8.3 字符串扩展新增字符串matchAll()方法，用于正则表达式，其结果和正则表达式的exec()方法相同： js123456789101112131415161718var reg = /(123)(a.a)/g;// 使用match()方法var matchResult = &#x27;123a4a123a5a&#x27;.match(reg);console.log(matchResult);// [&#x27;123a4a&#x27;, &#x27;123a5a&#x27;]// 使用matchAll()方法var matchAllResult = &#x27;123a4a123a5a&#x27;.matchAll(reg);for (let r of matchAllResult) &#123; // [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] // [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined] console.log(r);&#125;// 使用matchAll()方法var execResult;while(execResult = reg.exec(&#x27;123a4a123a5a&#x27;)) &#123; // [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] // [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined] console.log(execResult);&#125; 8.4 可选链操作符使用?.可选链操作符可以代替繁琐的层级判断是否为空的操作： js12345678910111213function test(config) &#123; // 直接使用，如果不存在会报错 console.log(config.db.url); // 层级判断，存在才获取 console.log(config &amp;&amp; config.cache &amp;&amp; config.cache.url) // 简化操作，使用可选链操作符判断 console.log(config?.cache?.url)&#125;test(&#123; db: &#123; url: &#x27;192.168.1.10&#x27; &#125;&#125;); 8.5 模块化扩展在导入模块时支持动态导入，可以实现按需加载模块，即在用到某个模块时再导入，而不是在加载时全部导入，可以提高加载效率。 使用import()方法传入文件路径即可导入指定文件，返回Promise对象，该对象的值是文件对应的导出的对象： test.html123456789101112&lt;script type=&quot;module&quot;&gt;// 全部导入// import * as test from &quot;./test.js&quot;;// 动态导入let btn = document.getElementById(&#x27;btn&#x27;);btn.onclick = function() &#123; import(&quot;./test.js&quot;).then(test =&gt; &#123; console.log(test.hello); test.test(); &#125;);&#125;&lt;/script&gt; 8.6 BigInt新增数据类型BigInt用于表示大整型数字： js123456789101112// 大整型数字使用字母n作为数字结尾let n = 1024n;console.log(n);// 1024nconsole.log(typeof n);// bigintconsole.log(BigInt(0));// 0n 支持将整型数字转为大整型数字，并且只支持转换整型数字// 使用大整型数字解决大数字运算，只支持大整型数字之间的运算，需要先将整型数字转为大整型数字let max = Number.MAX_SAFE_INTEGER;console.log(max + 1);// 9007199254740992console.log(max + 2);// 9007199254740992console.log(BigInt(max) + BigInt(1));// 9007199254740992nconsole.log(BigInt(max) + BigInt(2));// 9007199254740993n 8.7 绝对全局对象新增全局变量globalThis指向全局变量： js1console.log(globalThis);// Window &#123;...&#125;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"JS多线程","slug":"100-大前端/103-JS/001-基础/003-JS多线程","date":"2024-07-12T07:42:39.000Z","updated":"2024-07-18T07:59:35.603Z","comments":true,"path":"posts/20240712/154239/","permalink":"https://momashanhe.com/posts/20240712/154239/","excerpt":"摘要：本文主要学习了如何使用Web Work实现JS多线程的功能。","text":"摘要：本文主要学习了如何使用Web Work实现JS多线程的功能。 1 简介在JavaScript中采用的是单线程机制，不需要考虑复杂的同步问题，但也无法同时处理两件任务，无法发挥计算能力。 为了满足多线程的需求，H5规范提供了JavaScript多线程的实现，这种技术称为Web Work。 Web Work的作用就是为JavaScript创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者在后台运行，主线程和Worker线程互不干扰，在Worker线程执行结束后会将结果返回给主线程。 Worker线程一旦创建成功就会运行，并且不会被主线程的交互动作打断，虽然有利于响应主线程的操作，但是长时间运行也会导致CPU资源的浪费，所以需要在使用后及时关闭Worker线程。 相比较在主线程执行函数，使用分线程函数会慢一些。分线程的优势是可以在不阻塞主线程的情况下，执行函数。 此外，使用Worker线程还有一些限制： DOM限制，Worker线程和主线程的this对象不一样，无法使用window对象，以及alert()等方法，只能使用navigator对象和location对象。 通信限制，Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 兼容限制，不是所有的浏览器都支持。 跨域限制，不支持跨域加载JavaScript文件。 即使通过Web Worker技术，也不能修改DOM，只有主线程可以修改，所以JavaScript单线程的本质并没有变化。 2 使用在主线程中使用构造函数创建Worker分线程，传入执行的JavaScript文件： main.js1var worker = new Worker(&#x27;worker.js&#x27;); 在主线程中给Worker对象的onmessage属性绑定函数，用于接收Worker分线程的消息： main.js123worker.onmessage = function (event) &#123; console.log(&#x27;主线程接收分线程返回的数据: &#x27; + event.data);&#125; 在主线程中调用Worker对象的postMessage()方法，给Worker分线程传输参数： main.js1worker.postMessage(&#x27;I am main&#x27;); 在分线程要执行的JavaScript文件中，使用onmessage属性接收主线程的信息，使用postMessage()方法给主线程传递结果： worker.js1234var onmessage = function(event) &#123; console.log(&#x27;主线程接收分线程返回的数据: &#x27; + event.data);&#125;postMessage(&#x27;I am worker&#x27;); 在使用Worker分线程后，需要及时关闭： 可以在主线程调用Worker对象的terminate()方法关闭：main.js1worker.terminate(); 在分线程要执行的JavaScript文件中调用close()方法关闭：worker.js1close();","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"JS高级","slug":"100-大前端/103-JS/001-基础/002-JS高级","date":"2024-07-08T03:31:51.000Z","updated":"2024-07-18T07:59:11.916Z","comments":true,"path":"posts/20240708/113151/","permalink":"https://momashanhe.com/posts/20240708/113151/","excerpt":"摘要：本文主要总结了JS中容易混淆的知识点。","text":"摘要：本文主要总结了JS中容易混淆的知识点。 1 数据类型的判断1.1 typeof使用typeof关键字，得到字符串类型的返回结果： js12345678910// 基本类型console.log(typeof &#x27;123&#x27;);// stringconsole.log(typeof 123);// numberconsole.log(typeof false);// booleanconsole.log(typeof null);// objectconsole.log(typeof undefined);// undefined// 对象|数组|日期|包装类型，均返回objectconsole.log(typeof &#123;test:123&#125;);// object// 方法返回functionconsole.log(typeof function()&#123;&#125;);// function 凡是通过对象的方式创建的变量，其使用typeof得到的都是object字符串。 另外，基本数据类型中的null使用typeof判断也会得到object字符串。 1.2 instanceof使用instanceof关键字判断右侧显示调用的原型是否在左侧隐式调用的原型链上： js123456789101112131415161718192021222324252627// 基本类型，左侧非对象，没有原型链，直接返回falseconsole.log(&#x27;123&#x27; instanceof String);// falseconsole.log(123 instanceof Number);// falseconsole.log(false instanceof Boolean);// falseconsole.log(null instanceof Object);// falseconsole.log(undefined instanceof Object);// false// 对象返回trueconsole.log(&#123;test:123&#125; instanceof Object);// true// 数组返回trueconsole.log([1,2,3] instanceof Array);// true// 日期返回trueconsole.log(new Date() instanceof Date);// true// 包装类型返回trueconsole.log(new String(&#x27;123&#x27;) instanceof String);// trueconsole.log(new Number(123) instanceof Number);// trueconsole.log(new Boolean(false) instanceof Boolean);// true// 构造方法console.log(Object instanceof Function);// true Object.__proto__ == Function.prototypeconsole.log(Function instanceof Function);// true Function.__proto__ == Function.prototypeconsole.log(Object instanceof Object);// true Object.__proto__.__proto__ == Object.prototypeconsole.log(Function instanceof Object);// true Function.__proto__.__proto__ == Object.prototypefunction Func() &#123;&#125;var func = new Func();console.log(func instanceof Func);// true func.__proto__ == Func.prototypeconsole.log(func instanceof Object);// true func.__proto__.__proto__ == Object.prototypeconsole.log(Func instanceof Function);// true Func.__proto__ == Function.prototypeconsole.log(Func instanceof Object);// true Func.__proto__.__proto__ == Object.prototype 在创建对象时，会将显示调用赋值给隐式调用。在修改了显示调用的引用地址后，显示调用和隐式调用得到的原型对象将不再相同。 2 函数2.1 创建方式创建函数： js123function func() &#123; console.log(this);&#125; 创建匿名函数并赋值给变量： js123var func = function() &#123; console.log(this);&#125; 创建函数对象： js1var func = new Function(&quot;console.log(this);&quot;); 创建构造函数： js123function Func() &#123; console.log(this);&#125; 创建箭头函数： js1var func = () =&gt; &#123;console.log(this);&#125;; 2.2 调用方式创建函数并调用： js123456789101112131415161718// 创建函数function func() &#123; console.log(this);&#125;// 直接调用函数func();// 创建构造函数function Func() &#123; console.log(this);&#125;// 调用构造函数new Func();// 创建对象方法function Person() &#123; this.func = function() &#123;console.log(this);&#125;&#125;// 调用对象方法new Person().func(); 2.3 回调函数回调函数在定义以后不需要主动调用，当某个事件触发时才会调用。 常见的回调函数： 定时函数，包括使用setTimeout()方法和setInterval()方法传入的函数 DOM事件触发的函数，比如onclick()方法绑定的函数 AJAX请求回调函数 生命周期回调函数 3 this关键字任何函数本质上都是通过某个对象来调用的，所有函数内部都有一个this变量，它的值是调用函数的当前对象。 明确this的值： js123456789101112131415161718192021function func() &#123; console.log(this);&#125;func();// Window &#123;&#125; 直接调用函数，this指向window对象var func = new Function(&quot;console.log(this);&quot;);func();// Window &#123;&#125; 直接调用函数对象，this指向window对象function Func() &#123; console.log(this);&#125;var func = new Func();// Func &#123;&#125; 调用构造函数，this指向新创建的对象function Person() &#123; this.func = function() &#123;console.log(this);&#125;&#125;new Person().func();// Person &#123;&#125; 调用对象方法，this指向调用方法的对象var func = () =&gt; &#123;console.log(this);&#125;;func();// Window &#123;&#125; 调用箭头函数，this指向定义函数的环境var func = function() &#123; console.log(this);&#125;func.call(new String());// String &#123;&#x27;&#x27;&#125; 使用call和apply调用函数，this指向入参指定的对象console.log(this);// Window &#123;&#125; 在全局作用域中，this指向window对象 4 执行上下文和执行上下文栈4.1 执行上下文代码按生命周期分为两种： 全局代码：在全局任意位置有效 局部代码：仅在某段代码内有效，比如代码块、函数等，局部代码内可以使用全局代码 执行上下文分为全局执行上下文和函数执行上下文两种。 全局执行上下文： 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理： 将全局变量的声明提升，赋值为undefined，添加为window的属性 将全局函数添加为window的方法 将this对象赋值为window 开始执行全局代码 函数执行上下文： 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象 对局部数据进行预处理： 将传入的实参赋值到函数定义的实参，添加为执行上下文的属性 对函数的arguments内部属性赋值实参列表，添加为执行上下文的属性 将局部变量的声明提升，赋值为undefined，添加为执行上下文的属性 将函数内声明的函数添加为执行上下文的方法 将this对象赋值为调用函数的对象 开始执行函数体代码 在计算代码执行产生的上下文时，函数每次被调用都会生成一个函数执行上下文，在代码执行时会生成一个全局执行上下文。 4.2 执行上下文栈在创建执行上下文之前，JavaScript引擎会创建一个栈来存储管理所有的执行上下文对象： 在确定全局执行上下文后，将其压入到栈中 在创建函数执行上下文后，将其压入到栈中 在当前函数执行完后，将栈顶的对象移除 在所有代码执行完后，栈中只剩下全局执行上下文 5 作用域和作用域链5.1 作用域作用域是某段代码所在的区域，使用目的是为了隔离变量，不同的作用域之间，同名变量不会有冲突，比如覆盖。 按照代码的声明周期可以将作用域分为三种： 全局作用域：全局代码区域 函数作用域：在函数中的代码区域 块作用域：在代码块中的区域，ES6之后才有这个概念 相对于上下文来说，作用域是静止的，在编写代码时就确定了，作用域的确定时间要早于上下文的创建时间。 在统计作用域的数量时，每个函数作为一个函数作用域，整个代码作为一个全局作用域。在ES6以后，每个代码块是一个块作用域。 5.2 作用域链作用域链是在发生函数嵌套时产生的，使用目的是为了查找变量，特别是当发生了变量冲突时确定变量的值。 在发生函数嵌套时，外层函数作为上级，内层函数作为下级，作用域链的查找方向是从下往上的。 6 闭包在发生函数嵌套时，并且内部函数引用了外部函数的变量或函数，就会在内部函数产生闭包： js12345678function outer() &#123; var num = 0; function inner() &#123; console.log(num); &#125; inner();&#125;outer(); 闭包是在创建函数执行上下文时产生的对象，作为内部函数的属性，封装了在内部函数中使用的外部函数的变量或函数。 使用闭包的流程： 执行内部函数定义时产生闭包： 在执行内部函数时，会将闭包对象作为函数执行上下文的变量： 闭包的作用： 延长局部变量的生命周期，局部变量在外部函数执行完后, 仍然存活在内存中 允许在外部函数之外，通过内部函数修改外部函数的局部变量 闭包的生命周期： 在执行内部函数定义时产生，即在创建内部函数执行上下文时产生 在内部函数被视为垃圾对象时死亡，即不存在指向内部函数的变量引用 闭包会产生内存泄漏的可能，外部函数执行后，局部变量未能被马上释放： js12345678910function outer() &#123; var num = 0; function inner() &#123; console.log(++num); &#125; return inner;&#125;var inner = outer();inner();// 1inner();// 2 解决办法： 尽量少用闭包 在使用闭包后及时手动将内部函数的引用清空，释放局部变量：js1234567891011function outer() &#123; var num = 0; function inner() &#123; console.log(++num); &#125; return inner;&#125;var inner = outer();inner();// 1inner = null;inner();// 报错 7 对象7.1 创建创建对象的几种方式： 直接创建：js12345678var obj = &#123; name: &#x27;张三&#x27;, setName: function(name) &#123; this.name = name; &#125;&#125;;obj.setName(&#x27;李四&#x27;);console.log(obj);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过Object构造函数创建：js1234567var obj = new Object();obj.name = &#x27;张三&#x27;;obj.setName = function(name) &#123; this.name = name;&#125;obj.setName(&#x27;李四&#x27;);console.log(obj);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过工厂模式创建：js123456789101112function createPerson(name) &#123; var person = &#123; name: name, setName: function(name) &#123; this.name = name; &#125; &#125;; return person;&#125;var person = createPerson(&#x27;张三&#x27;);person.setName(&#x27;李四&#x27;);console.log(person);// &#123;name: &#x27;李四&#x27;, setName: ƒ&#125; 通过自定义构造函数创建，推荐：js123456789function Person(name) &#123; this.name = name; this.__proto__.setName = function(name) &#123; this.name = name; &#125;;&#125;var person = new Person(&#x27;张三&#x27;);person.setName(&#x27;李四&#x27;);console.log(person);// Person &#123;name: &#x27;李四4&#x27;&#125; 7.2 继承当需要在一个类中使用另一个类的属性和方法时，将没有相关属性和方法的类称为子类，将具有相关属性和方法的类称为父类，子类的属性和方法继承自父类。 使用原型链继承： js123456789101112131415161718// 定义父类function Parent() &#123; this.parent = &#x27;parent property&#x27;;&#125;// 定义子类function Child() &#123; this.child = &#x27;child property&#x27;;&#125;// 将父类的对象赋值给子类的显示调用的原型，这样子类的对象就可以通过隐式调用的原型访问父类定义的属性和方法Child.prototype = new Parent()// 子类显示调用的原型指向了父类的对象，其constructor属性也指向了父类的构造方法，所以还需要改为子类的构造方法Child.prototype.constructor = Child// 创建子类的实例var child = new Child()// 通过子类调用父类的方法console.log(child.parent);// parent property// 通过子类调用自身的方法console.log(child.child);// child property 使用父类的构造方法继承： js12345678910111213// 定义父类function Parent(name) &#123; this.name = name;&#125;// 定义子类function Child(name) &#123; // 调用父类的构造方法，将父类的属性设置到子类的对象上 Parent.call(this, name);&#125;// 创建子类的实例var child = new Child(&#x27;张三&#x27;)// 查看子类的属性console.log(child.name);// 张三 组合继承，同时使用原型链和构造函数： js1234567891011121314151617181920// 定义父类function Parent() &#123; this.parent = &#x27;parent property&#x27;;&#125;// 定义子类function Child() &#123; this.child = &#x27;child property&#x27;; // 调用父类的构造方法，将父类的属性设置到子类的对象上 Parent.call(this, name);&#125;// 将父类的对象赋值给子类的显示调用的原型，这样子类的对象就可以通过隐式调用的原型访问父类定义的属性和方法Child.prototype = new Parent()// 子类显示调用的原型指向了父类的对象，其constructor属性也指向了父类的构造方法，所以还需要改为子类的构造方法Child.prototype.constructor = Child// 创建子类的实例var child = new Child()// 通过子类调用父类的方法console.log(child.parent);// parent property// 通过子类调用自身的方法console.log(child.child);// child property 8 线程机制进程： 进程是程序的一次执行，是程序在计算机中运行的实体。 进程是系统进行资源分配的最小单位，每个进程都有各自独立的内存空间，各个进程互不干扰。 线程： 线程是进程的子任务，是进程实际的运作单位。 线程是CPU调度的最小单位，线程有独立的栈空间和局部变量，但没有独立的内存空间，一个进程内的多个线程共享进程的存储空间。 JavaScript采用的是单线程机制，作为浏览器脚本语言，主要用途是与用户互动以及操作DOM，使用单线程不需要考虑复杂的同步问题。 使用多线程的系统可以更好的利用CPU资源，提高CPU的运行效率，但也会因为需要频繁创建销毁线程导致占用了一部分性能。 线程池： 线程池可以复用线程，减少线程创建和销毁的次数，减少了性能浪费，提高程序的运行效率。 线程池可以控制线程的最大并发数，避免过高的并发量导致系统卡死。 9 事件机制定时器的调用问题： js1234567891011var time = Date.now();setTimeout(function(name) &#123; console.log(&#x27;1秒后打印 &#x27; + name); console.log(Date.now() - time);&#125;, 1000, &#x27;test&#x27;);setTimeout(function(name) &#123; console.log(&#x27;2秒后打印 &#x27; + name); console.log(Date.now() - time);&#125;, 2000, &#x27;test&#x27;);for(var i = 0; i &lt; 2000000000; i++) &#123;&#125; 第一个定时函数不是在1秒后执行的，第二个定时函数不是在2秒后执行的，并且两个定时函数是同时执行的。 这是因为JavaScript是单线程的，定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行。 JavaScript引擎执行基本流程： 执行初始化代码，包括对变量赋值、执行普通方法、执行代码、设置定时器、绑定监听事件、发送请求 执行回调函数，包括定时器回调、事件回调、请求回调 事件管理模块： 定时模块，处理定时任务绑定的回调函数 DOM模块，处理DOM元素绑定的回调函数 AJAX模块，处理请求返回触发的回调函数 事件管理模型运转流程： 在执行初始化代码时，将事件回调函数交给对应的模块管理 当事件发生时，管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后，才会遍历读取回调队列中的回调函数执行","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"JS入门","slug":"100-大前端/103-JS/001-基础/001-JS入门","date":"2024-06-27T07:59:26.000Z","updated":"2024-08-09T08:35:28.934Z","comments":true,"path":"posts/20240627/155926/","permalink":"https://momashanhe.com/posts/20240627/155926/","excerpt":"摘要：本文主要介绍了JS中常用的概念，以及基本语法。","text":"摘要：本文主要介绍了JS中常用的概念，以及基本语法。 1 简介1.1 是什么JS全称：JavaScript。 JS是一种脚本语言，命名和Java没有任何关系，用于给网页设置行为，比如点击、弹窗等等。 官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn 1.2 发展历史JavaScript是由网景公司在1995年发明的，起初命名为LiveScript，后来由于SUN公司的介入更名为了JavaScript。 在1996年，微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript。 于是在市面上存在两个版本的JavaScript，网景公司的JavaScript和微软的JScript，为了确保不同的浏览器上运行的JavaScript标准一致，几个公司定制了通用标准，名命为ECMAScript。 在一般情况下，会将这ECMAScript和JavaScript认作同一个意思，实际上JavaScript的含义要大一些，一个完整的JavaScript实现应该由以下三个部分构成： ECMAScript：通用的标准，通常简写为ES。 DOM：文档对象模型，操作网页。 BOM：浏览器对象模型，操作浏览器。 2 基础2.1 编写位置因为JS是运行在浏览器中的，因此需要在网页中编写JS代码。 和CSS类似，JS也有三种位置可以选择。 2.1.1 行内脚本直接写在元素内部，通过一些特殊的交互属性设置交互行为。 示例： hello.html1&lt;button onclick=&quot;alert(&#x27;点击测试&#x27;);&quot;&gt;按钮&lt;/button&gt; 这种方式使用简单，但是功能比较少，并且和网页的结构耦合，不能体现出结构和行为分离的思想，也不利于维护，不建议使用这种方式。 说明：alert()是一个函数，可以将传入的参数通过弹窗显示在页面上。 2.1.2 内部脚本将JS提取出来，写在页面内部的script元素中。 示例： hello.html123&lt;script type=&quot;text/javascript&quot;&gt;alert(&#x27;测试&#x27;);&lt;/script&gt; 理论上可以将script元素放在页面的任何位置，建议放到head元素中。另外，也可以省略type属性。 和行内样式相比，这种方式编写的结构和行为分离，样式也能复用，但也没有做到完全分离。 2.1.3 外部脚本将JS进一步提取，写在单独的JS文件中，在HTML页面中使用元素引用外部的JS文件。 创建JS文件，后缀为.js格式。示例： hello.js1alert(&#x27;测试&#x27;); 在HTML页面引用CSS文件。示例： hello.html1&lt;script src=&quot;./hello.js&quot;&gt;&lt;/script&gt; 这种方式可维护高，并且做到了结构和行为分离，也能被其他页面复用，建议使用这种方式。 2.2 大小写敏感JavaScript是严格区分大小写的，在编写代码是要注意。 2.3 注释JavaScript的注释分为单行注释和多行注释： 单行注释：js12// 注释内容alert(&#x27;测试&#x27;); 多行注释：js12/* 注释内容 */alert(&#x27;测试&#x27;); 3 语法3.1 标识符所谓标识符，就是指变量、函数、属性的名字，以及函数的参数。 标识符可以是按照下列格式规则组合起来的一或多个字符： 第一个字符必须是字母、下划线_或美元符号$。 其他字符可以是字母、下划线、美元符号或数字。 按照惯例，ECMAScript标识符采用驼峰命名法，但是JavaScript中的标识符不能是关键字和保留字符。 关键字： function void return this new with var instanceof typeof switch case default if else do while for in continue break try catch throw finally delete debugger true false null 保留字符： import export package public protected private interface class enum extends implements super let yield static const 其他不建议使用的标识符： synchronize volatile abstract final native transient float double long int short byte char boolean throws arguments eval goto undefined encodeURI decodeURI decodeURIComponent encodeURICOmponent isFinite isNaN parseFloat parseInt NaN Number String Boolean Object Date Array JSON RegExp Infinity Function Math Error RangeError SyntaxError ReferenceError TypeError EvalError URIError 3.2 数据类型数据类型决定了一个数据的特征，比如123和&#39;123&#39;，直观上看这两个数据都是123，但实际上前者是一个数字，而后者是一个字符串。 对于不同的数据类型我们在进行操作时会有很大的不同。JavaScript中一共有五种基本数据类型： 字符串型（String） 数值型（Number） 布尔型（Boolean） null型（Null） undefined型（Undefined） 这五种之外的类型都称为Object，所以总的来看JavaScript中共有六种数据类型。 使用typeof关键字检查数据可以得到数据的类型，返回结果是字符串类型： 使用typeof 字符串判断会返回string 使用typeof 数值判断会返回number 使用typeof 布尔型判断会返回boolean 使用typeof null判断会返回object 使用typeof undefined判断会返回undefined 3.2.1 String在JavaScript中字符串使用String类型表示，都需要使用引号引起来，可以使用单引号，也可以使用双引号，但必须成对匹配，不能混搭使用。 在某些情况下，如果想要将特殊的字符作为字符串，需要使用转义字符\\，也可以使用HTML中的实体： 使用&amp;lt;表示&lt;，使用&amp;gt;表示&gt; 使用\\&#39;表示&#39;，使用\\&quot;表示&quot; 使用\\n表示换行符 使用\\t表示制表符，可以实现缩进的效果 使用\\\\表示\\ 转换为String有三种方式： 使用toString()方法：js123456789var i = 1;alert(typeof i);// numberalert(typeof i.toString());// stringvar m = null;alert(m.toString());// 页面报错，Null类型的变量不能调用方法alert(typeof m.toString());// 页面报错，Null类型的变量不能调用方法var n = undefined;alert(n.toString());// 页面报错，Undefined类型的变量不能调用方法alert(typeof n.toString());// 页面报错，Undefined类型的变量不能调用方法 使用String()方法：js123456789var i = 1;alert(typeof i);// numberalert(typeof String(i));// stringvar m = null;alert(String(m));// nullalert(typeof String(m));// stringvar n = undefined;alert(String(n));// undefinedalert(typeof String(n));// string 拼接字符串：js123456789var i = 1;alert(typeof i);// numberalert(typeof i + &#x27;1&#x27;);// stringvar m = null;alert(m + &#x27;&#x27;);// nullalert(typeof m + &#x27;&#x27;);// stringvar n = undefined;alert(n + &#x27;&#x27;);// undefinedalert(typeof n + &#x27;&#x27;);// string 3.2.2 Number在JavaScript中所有的数值都是Number类型，包括整数和浮点数： 使用Number.MAX_VALUE表示数值的最大值，使用Number.MIN_VALUE表示数值大于0的最小值。 使用Infinity表示超出数值最大值的正无穷，使用-Infinity表示负无穷。 使用NaN表示非数字的数值，即Not a number。 在对Infinity和-Infinity以及NaN使用typeof判断时，也能得到number的结果。 有三个方法可以把变量转换为数值： 使用Number()方法可以用来将变量转换为数值：js123456789101112131415var i = &#x27;1&#x27;;alert(typeof i);// stringalert(typeof Number(i));// numbervar a = true;alert(Number(a));// 1 true会返回1，false会返回0alert(typeof Number(a));// numbervar x = &#x27;1x&#x27;;alert(Number(x));// NaN 非数值字符串会返回NaNalert(typeof Number(x));// numbervar m = null;alert(Number(m));// 0 null会返回0alert(typeof Number(m));// numbervar n = undefined;alert(Number(n));// NaN undefined会返回NaNalert(typeof Number(n));// number 使用parseInt()方法可以用来将字符串转换为整数：js123456789101112var i = &#x27;1&#x27;;alert(typeof i);// stringalert(typeof parseInt(i));// numbervar f = &#x27;1.5&#x27;;alert(parseInt(f));// 1 开头为数值的字符串会返回开头的整数部分，开头非数值的字符串会返回NaNalert(typeof parseInt(f));// numbervar x = &#x27;1x&#x27;;alert(parseInt(x));// 1 开头为数值的字符串会返回开头的整数部分，开头非数值的字符串会返回NaNalert(typeof parseInt(x));// numbervar b = false;alert(parseInt(b));// NaN 非字符串会先转为字符串，开头非数值的字符串会返回NaNalert(typeof parseInt(b));// number 使用parseFloat()方法可以用来将字符串转换为浮点数：js123456789var i = &#x27;1.5&#x27;;alert(typeof i);// stringalert(typeof parseFloat(i));// numbervar x = &#x27;1.5x&#x27;;alert(parseFloat(x));// 1.5 开头为数值的字符串会返回开头的浮点数部分，开头非数值的字符串会返回NaNalert(typeof parseFloat(x));// numbervar b = false;alert(parseFloat(b));// NaN 非字符串会先转为字符串，开头非数值的字符串会返回NaNalert(typeof parseFloat(b));// number 在对浮点数进行计算时，可能会得到一个不精确的结果，所以在处理浮点数的运算时，需要使用特殊的方式保证得到的结果尽量精确，这里以后再说。 3.2.3 Boolean在JavaScript中使用Boolean类型表示布尔型的数据，其取值只有true和false两种。 使用Boolean()方法可以用来将变量转换为布尔值： js123456789101112var i = NaN;alert(Boolean(i));// false 非NaN且非0的数值会返回false，正数和负数会返回true，Infinity和-Infinity也会返回truealert(typeof Boolean(i));// booleanvar x = &#x27;&#x27;;alert(Boolean(x));// false 空字符串会返回false，非空字符串会返回truealert(typeof Boolean(x));// booleanvar m = null;alert(Boolean(m));// false null会返回falsealert(typeof Boolean(m));// booleanvar n = undefined;alert(Boolean(n));// false undefined会返回falsealert(typeof Boolean(n));// boolean 3.2.4 Null使用Null表示空对象。 可以显示的将对象赋值为null来强制将对象设置为Null类型： js123var person = null;alert(person);// nullalert(typeof person);// object 3.2.5 Undefined使用Undefined表示声明但未赋值的变量。 js123var person;alert(person);// undefinedalert(typeof person);// undefined 3.3 变量变量的作用是给某一个值或对象标注名称。 使用var关键字声明变量： js1var i; 对声明的变量进行赋值： js1i = 1; 在声明变量时赋值： js1var i = 1; 支持对多个变量同时声明和赋值： js12var x, y, z = &#x27;z&#x27;;var m = 1, n = 2, l = 3; 3.3.1 重复声明JavaScript允许对变量进行重复声明和赋值，也允许声明为不同的数据类型： js12var i = 1;var i = &#x27;i&#x27;; 在ES6以后，还可以使用let声明变量： js1let i = 1; 通过var声明的变量称为全局变量，支持修改值和类型，支持重复声明。通过let声明的变量称为局部变量，局部变量支持修改值和类型，但不支持重复声明，建议在代码块中使用。 3.3.2 常量在ES6以后，使用const声明常量： js1const i = 1; 和var与let声明的变量相比，常量一经声明和赋值，就不再支持修改值和类型，也不支持重复声明。 3.4 运算符通过运算符可以对一个或多个值进行运算，并获取运算结果。 优先级： . [] new () ++ -- ! ~ * / % + - < >> >>>>>= &= ^= |= , 3.4.1 算数运算符在JavaScript中提供了以下几种算数运算符： 使用+进行加法或拼接运算，如果拼接的是一个字符串，会将计算结果转为字符串 使用-进行减法运算，如果涉及数值，会将结果转为数值 使用*进行乘法运算，如果涉及数值，会将结果转为数值 使用/进行除法运算，如果涉及数值，会将结果转为数值 使用%进行取模运算 自增和自减运算符： 使用++进行自增运算，根据运算符位置分为前置++i和后置i++：js1234var i = 0;alert(++i);// 1 前置获取的是自增后的值alert(i++);// 1 后置获取的是自增前的值alert(i);// 2 使用--进行自增运算，根据运算符位置分为前置--i和后置i--：js1234var i = 2;alert(--i);// 1 前置获取的是自减后的值alert(i--);// 1 后置获取的是自减前的值alert(i);// 0 3.4.2 逻辑运算符在JavaScript中提供了以下三种逻辑运算符： 使用!表示逻辑非，用于对布尔值进行取反，对于非布尔值的变量会先将其转换为布尔值再取反。 使用&amp;&amp;表示逻辑与，只有两个值都为true时，整个运算为true，返回第二个值。该运算符属于短路与，当第一个值为false时，整个运算为false，返回第一个值，不会判断第二个值。 使用||表示逻辑或，只有两个值都为false时，整个运算为false，返回第二个值。该运算符属于短路或，当第一个值为true时，整个运算为true，返回第一个值，不会判断第二个值。 3.4.3 赋值运算符在JavaScript中使用=进行赋值运算，可以使用简写： 使用+=先计算后赋值，i += 5等同i = i + 5 使用-=先计算后赋值，i -= 5等同i = i - 5 使用*=先计算后赋值，i *= 5等同i = i * 5 使用/=先计算后赋值，i /= 5等同i = i / 5 使用%=先计算后赋值，i %= 5等同i = i % 5 3.4.4 比较运算符通过比较运算符可以比较两个变量的大小关系： 使用&gt;大于号判断左侧的变量是否大于右侧的变量，成立返回true，否则返回false。 使用&lt;小于号判断左侧的变量是否小于右侧的变量，成立返回true，否则返回false。 使用==等号判断两侧的变量是否相等，如果类型不一样，会先进行自动类型转换再比较，相等返回true，否则返回false。 使用===全等号判断两侧的变量是否相等，相等返回true，否则返回false。不会进行自动类型转换。 使用!=不等号判断两侧的变量是否不等，如果类型不一样，会先进行自动类型转换再比较，不等返回true，否则返回false。 使用!==不全等号判断两侧的变量是否不等，不等返回true，否则返回false。不会进行自动类型转换。 对于非数值的变量进行比较判断时，会将变量转换为数值再比较，但当两侧的变量都是字符串时，会根据字符串的Unicode编码进行比较。 3.4.5 条件运算符条件运算符也称为三元运算符，语法： js1条件表达式?语句1:语句2; 运算逻辑： 条件运算符在执行时，首先对条件表达式进行求值。 如果该值为true，则执行语句1，并返回执行结果。如果该值为false，则执行语句2，并返回执行结果。 如果条件表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。 3.4.6 移位运算符移位运算符一般用于数值类型的变量，作用在数值补码的所有位，按位运算： 使用&amp;进行按位与运算，两个数值的相对位都为1，结果的对应位为1，否则结果的对应位为0 使用|进行按位或运算，两个数值的相对位都为0，结果的对应位为0，否则结果的对应位为1 使用^进行按位异或运算，两个数值的相对位不相同，结果的对应位为1，否则结果的对应位为0 使用~进行按位非运算，对数值的每位都进行反转 使用&lt;&lt;进行带符号左移运算，每位左移，右边补0。 使用&gt;&gt;进行带符号右移运算，每位右移，左边补0，符号位使用原来的。 使用&gt;&gt;&gt;进行无符号右移运算，每位右移，左边补0，符号位补0。 移位运算改变的是数值的补码。对于正数来说，数值的原码是其补码。对于负数来说，数值的反码+1是其补码。 3.5 语句和代码块表达式和运算符类似于单词和短语，语句是一条完整的命令，通常使用;结尾。 可以使用&#123;&#125;将多条语句包裹起来，称为代码块，只具有分组和排版的作用，没有其他意义。 3.6 条件语句3.6.1 if…else语句如果if中的条件成立，返回布尔值为true，则执行if后面代码块里的操作语句，否则执行else后面代码块里的操作语句： js12345if (条件表达式) &#123; 条件成立的操作&#125; else &#123; 条件不成立的操作&#125; 在if和else后面的代码块中，支持嵌套其他语句，如果嵌套的还是if…else语句，可以简写： js1234567if (条件表达式1) &#123; 条件1成立的操作语句&#125; else if (条件表达式2) &#123; 条件1不成立但条件2成立的操作语句&#125; else &#123; 条件1和条件2都不成立的操作语句&#125; 3.6.2 switch…case语句也称为条件分支语句，会将switch后面的值同每个case后面的值相比较，相等就执行case后面的操作语句： js1234567891011121314switch (值) &#123; case 值1: 操作语句1 break; case 值2: 操作语句2 break; case 值3: 操作语句3 break; default: 操作语句 break;&#125; 其中的break用于终止判断，如果没有break会在执行完当前case的操作语句后，继续判断后面case的值，直到遇到break或者判断结束。 如果所有switch的值和case后面的值都不相等，则执行default后面的操作语句。 3.7 循环语句不管使用那种循环语句，都需要在适当位置跳过循环和终止循环： 跳过循环：跳过本次循环，不执行后面的操作语句，直接进行条件判断，进行下一次循环，使用continue实现，一般在条件语句中使用：js1234567循环操作语句代码块 &#123; 操作语句1 if (条件表达式) &#123; continue; &#125; 操作语句2&#125; 终止循环：跳出循环，终止整个循环的执行，执行循环后面的代码，使用break实现，一般在条件语句中使用：js1234567循环操作语句代码块 &#123; 操作语句1 if (条件表达式) &#123; break; &#125; 操作语句2&#125; 3.7.1 while语句如果while后面的条件成立，则执行代码块中的操作语句，执行后重复判断是否成立，如果成立，则重复执行操作语句，只有当不成立时才终止循环： js123while (条件表达式) &#123; 条件成立的操作语句&#125; 还可以使用do…while语句，这种方式会先执行操作语句，然后再循环判断条件是否成立，以及循环执行操作语句，最终终止循环： js123do &#123; 条件成立的操作语句&#125; while (条件表达式) 相比较而言，while语句会先判断再执行，do…while语句会先执行再判断，能够保证至少执行一次操作语句。 但不管使用那种循环语句，都需要做好终止循环的判断逻辑，否则会导致死循环，严重情况会导致系统没有足够的资源而崩溃。 3.7.2 for语句使用for语句可以更加明显的设置循环终止条件，但因此也显得比较繁琐： js123for(初始化语句; 条件表达式; 更新语句) &#123; 条件成立的操作语句&#125; 先执行初始化语句，可以省略，将初始化语句放在for循环前面执行。然后判断条件是否成立，可以省略，但需要在操作语句中控制终止循环的条件，类似while语句，否则会导致死循环。如果条件成立，会执行操作语句，否则终止循环。在操作语句执行结束后，执行更新语句，对循环条件更新，并循环判断条件是否成立，如果成立则循环执行操作语句，否则终止循环。 除了for语句代码块中的操作语句外，其他三个部分都是可以省略的，省略后就类似while语句了，需要手动控制循环。 3.8 嵌套循环循环语句支持嵌套，在一个循环语句中支持嵌套另一个循环语句。 使用continue和break可以处理当前循环语句的循环逻辑，如果想处理上层循环语句的循环逻辑，需要配合label标签使用： js123456789101112label1:for(初始化语句; 条件表达式; 更新语句) &#123; 循环1的操作语句 label2: for(初始化语句; 条件表达式; 更新语句) &#123; 循环2的操作语句 for(初始化语句; 条件表达式; 更新语句) &#123; 循环3的操作语句 break label1; &#125; &#125;&#125; 使用label给循环打标签，在continue和break后面使用标签控制要操作的循环。示例： js123456789101112131415161718192021222324252627282930313233343536373839404142// 大学数组var universities = [&#x27;Peking University&#x27;, &#x27;Tsinghua University&#x27;];// 学院数组var colleges = [&#x27;College of Foreign Languages&#x27;, &#x27;College of Mathematics&#x27;, &#x27;College of Software&#x27;];// 专业数组var departments = [];departments[0] = [&#x27;English&#x27;, &#x27;French&#x27;, &#x27;Russian&#x27;];departments[1] = [&#x27;Statistics&#x27;];departments[2] = [&#x27;Software Engineering&#x27;];// 循环大学的标签，命名规范同标识符university:// 循环遍历大学for(let l = 0; l &lt; universities.length; l++) &#123; // 循环学院的标签 college: // 循环遍历学院 for(let m = 0; m &lt; colleges.length; m++) &#123; // 循环专业的标签，因为默认continue和break处理的是当前循环，所以这个标签可以省略 department: // 循环遍历专业 for(let n = 0; n &lt; departments[m].length; n++) &#123; // 如果是英语专业则进行提示 if (departments[m][n] == &#x27;Russian&#x27;) &#123; alert(universities[l] + &#x27;-&#x27; + colleges[m] + &#x27;-&#x27; + departments[m][n]); // 跳过遍历专业，等同于不使用标签 // continue department; // 跳过遍历学院 // continue college; // 跳过遍历大学 continue university; // 终止遍历专业，等同于不使用标签 // break department; // 终止遍历学院 // break college; // 终止遍历大学 // break university; &#125; // 记录已遍历的专业 console.log(universities[l] + &#x27;-&#x27; + colleges[m] + &#x27;-&#x27; + departments[m][n]); &#125; &#125;&#125; 说明：console.log()是一个函数，可以将传入的参数打印到页面的控制台上。 4 对象4.1 定义JavaScript中的数据类型有六种，包括五种基本数据类型和一种引用数据类型。 五种基本数据类型： String字符串 Number数值 Boolean布尔值 Null空值 Undefined未定义 使用Object对象来表示引用类型的数据，这是一种复合的数据类型，可以保存多个不同数据类型的属性。 4.2 使用创建对象有两种方式： 先创建，然后对属性赋值：js1234567var student = new Object();student.name = &#x27;张三&#x27;;student.sex = &#x27;男&#x27;;// 不能赋值特殊的属性名// student.&#x27;1 2 3&#x27; = 123;// 可以赋值特殊的属性名student[&#x27;1 2 3&#x27;] = 123; 在创建时对属性赋值：js12345var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;; 访问对象的属性： js12345678910var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;;console.log(student.name);// 张三// 不能访问特殊的属性名// console.log(student.&#x27;1 2 3&#x27;);// 可以访问特殊的属性名console.log(student[&#x27;1 2 3&#x27;]);// 123 删除对象属性： js123456789var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#x27;1 2 3&#x27;:123&#125;;console.log(student);// &#123; &quot;name&quot;: &quot;张三&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;1 2 3&quot;: 123 &#125;delete student[&#x27;name&#x27;];delete student[&#x27;1 2 3&#x27;];console.log(student);// &#123; &quot;sex&quot;: &quot;男&quot; &#125; 在JavaScript中，对象的属性可以是任意类型的数据，包括对象的属性时另一个对象： js123456789var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;student.friend = &#123; name:&#x27;李四&#x27;, sex:&#x27;男&#x27;&#125;;console.log(student);// &#123; &quot;name&quot;: &quot;张三&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;friend&quot;: &#123; &quot;name&quot;: &quot;李四&quot;, &quot;sex&quot;: &quot;男&quot; &#125; &#125; 可以通过in关键字判断对象是否存在指定属性： js123456var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;console.log(student.age);// undefinedconsole.log(&#x27;age&#x27; in student);// false 可以使用for…in语句循环遍历对象的属性： js12345678var student = &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;&#125;;for(var attr in student) &#123; console.log(&#x27;属性名 &#x27; + attr); console.log(&#x27;属性值 &#x27; + student[attr]);&#125; 4.3 堆栈JavaScript在运行时数据是保存到栈内存和堆内存当中的。简单来说栈内存保存堆内存中对象的引用和基本类型数据，堆内存保存引用类型数据，也就是对象。 基本数据类型和引用数据类型的区别： 对于基本数据类型的变量来说，在栈上创建栈内存用于存储数据，每个变量都是独立的栈内存，变量的修改互不影响：js1234var m = 100;var n = 100;m = 200;console.log(n);// 100 对于引用数据类型的变量来说，在堆上创建堆内存用于存储对象，在栈上创建栈内存用于存储堆内存中对象的引用，对具有相同引用的对象的修改会互相影响：js1234567var zs = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;var student = zs;student.age = 20;console.log(zs.age);// 20 在进行比较运算时的区别： 在比较基本类型数据的时候，比较的是栈内存中的值。 在比较引用类型数据的时候，比较的是栈内存中的引用地址。即使两个对象有完全相同的属性，但因为在堆内存是两个对象，就导致引用地址不同，两个对象也不同：js123456789var m = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;var n = &#123; name:&#x27;张三&#x27;, age:&#x27;18&#x27;&#125;;console.log(m == n);// false 4.4 垃圾回收垃圾回收（GC，Garbage Collection），是一种回收不再使用的对象内存的机制。 当一个对象没有任何的变量或属性对它进行引用，会导致无法操作该对象，这种对象就是一个垃圾，垃圾对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。 JavaScript拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，开发人员不需要也不能进行垃圾回收的操作，只需要将不再使用的对象设置为null即可： js12var obj = new Object();obj = null; 4.5 分类在JavaScript中可以将对象分为内部对象、宿主对象和自定义对象三种。 4.5.1 内部对象内部对象包括String、Number、Boolean、Object、Function、Array、Date、Math、RegExp、Global，以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError。 其中Global和Math这两个对象又被称为内置对象，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 4.5.2 宿主对象宿主对象就是执行JavaScript的环境提供的对象。 对于嵌入到网页中的JavaScript来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭，这会带来浏览器兼容问题，增加开发难度。 浏览器对象有很多，如Window和Document等等。 4.5.3 自定义对象顾名思义，就是开发人员自己定义的对象。JavaScript允许使用自定义对象，使应用及功能得到扩充。 5 内部对象5.1 函数5.1.1 定义函数是封装了多条语句的代码块，这段代码块会让函数具有某种功能。 函数中的语句不会自动执行，需要在有需要的地方显示调用函数，在被调用时才会执行函数中的语句。 函数是一种Function类型的对象，使用typeof检查： js12var fun = new Function();console.log(typeof fun);// function 当将函数赋值给对象的某个属性时，将这个属性称为方法，即对象的方法对应的类型是函数。 5.1.2 使用创建函数的方式： 使用普通函数，支持多个参数：js1234function func(name) &#123; console.log(&#x27;test &#x27; + name);&#125;func(&#x27;hello&#x27;); 使用函数表达式，创建匿名函数，并将函数赋值给变量：js1234var func = function(name) &#123; console.log(&#x27;test &#x27; + name);&#125;;func(&#x27;hello&#x27;); 使用函数的构造方法，支持多个参数：js12var func = new Function(&#x27;name&#x27;,&quot;console.log(&#x27;test &#x27; + name);&quot;);func(&#x27;hello&#x27;); 使用构造函数，支持多个参数：js1234function Func(name) &#123; console.log(&#x27;test &#x27; + name);&#125;new Func(&#x27;hello&#x27;); 函数的组成部分： 函数名：用于显示调用函数，可以省略函数名使用变量名调用，也可以同时省略函数名和变量名使用函数自调用：js123(function(name) &#123; console.log(name);&#125;)(&#x27;hello&#x27;); 入参：用于将数据传入到函数中进行处理，支持无参和有参，多个参数用,分隔，参数类型支持任意类型。在执行函数时会从左到右自动匹配参数，缺少的参数按照未定义处理：js1234var fun = function(name) &#123; console.log(name);&#125;;fun();// undefined 返回值：用于获取函数处理的结果。使用return关键字返回结果，返回结果支持任意类型，无返回结果按照未定义处理：js1234var fun = function(name) &#123; console.log(name);&#125;;console.log(fun(&#x27;hello&#x27;));// undefined 使用匿名函数自调用（IIFE，Immediately Invoked Function Expression）的好处是隐藏了内部实现，不污染外部命名空间。 5.1.3 作用域作用域通常用于形容变量，指的是变量的有效范围。 在JavaScript中一共有两种作用域： 全局作用域，在script元素内部声明的变量，而不是在某个方法内部声明的变量，都在全局作用域，这种变量称为全局变量。 局部作用域，在方法内部创建的变量，只在方法内部有效，这种变量称为局部变量。 全局变量的特点： 在页面打开时创建，在页面关闭时销毁。 可以直接使用由浏览器创建的window全局对象，代表浏览器的窗口，可以直接使用其属性和方法。 全局变量在页面的任意地方都可以访问。 局部变量的特点： 在方法调用时创建，在方法执行结束后销毁。 只能在方法内部使用。 只有在方法内部使用关键字声明变量，该变量才是局部变量，否则就是全局变量： js1234567891011var name = &#x27;张三&#x27;;var sex = &#x27;男&#x27;;function fun() &#123; console.log(name);// undefined 使用局部变量，声明提升但未初始化 var name = &#x27;李四&#x27;; console.log(sex);// 男 未声明变量，使用全部变量 sex = &#x27;女&#x27;;&#125;fun();console.log(name);// 张三 全局变量未被修改console.log(sex);// 女 全局变量被修改 当全局变量和局部变量名称相同时，在方法中使用的是局部变量： js1234567var name = &#x27;张三&#x27;;function fun() &#123; console.log(name);// undefined 使用局部变量，声明提升但未初始化 var name = &#x27;李四&#x27;;&#125;fun();console.log(name);// 张三 全局变量未被修改 常用的全局函数： js1234// 对URI进行编码console.log(encodeURIComponent(&#x27;localhost:8080/test?name=test&#x27;));// localhost%3A8080%2Ftest%3Fname%3Dtest// 对URI进行解码console.log(decodeURIComponent(&#x27;localhost%3A8080%2Ftest%3Fname%3Dtest&#x27;));// localhost:8080/test?name=test 5.1.4 声明提升在JavaScript中，函数及变量的声明都将被提升到函数的最顶部，变量可以先使用再声明。 在ES6引入let和const的声明方式后，只有var声明的变量才支持声明提升，并且使用函数表达式声明的函数变量也不支持声明提升。 声明提升只是将声明提前了，并没有将初始化的操作提前： js12console.log(name);// undefinedvar name = &#x27;张三&#x27;; 5.1.5 内部属性在函数内部，有两个特殊的对象： arguments：该对象实际上是一个类数组对象，有数组的特性，但本质上是Object对象，用于保存函数的参数，同时该对象还有一个属性callee来表示当前函数。 this：引用的是一个对象，用来表示函数执行的上下文，一般是函数的调用者。根据函数调用方式的不同，引用对象也会有所不同。 通过arguments对象可以获取传入的参数，即使函数没有定义入参： js1234567891011function test() &#123; console.log(arguments);// Arguments [] console.log(arguments instanceof Array);// false console.log(arguments instanceof Object);// true console.log(arguments[0]);// 1 console.log(arguments[1]);// 2 console.log(arguments.length);// 5 console.log(arguments.callee);// function test() &#123;&#125; console.log(arguments.callee == test);// true&#125;test(1, 2, 3, 4, 5); 说明：instanceof关键字可以用来判断左侧的变量是否属于右侧的类型。 5.1.6 构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是，构造函数习惯上首字母大写： js12function Student() &#123;&#125; 在调用函数时，普通函数可以直接调用，构造函数需要使用new关键字调用： js12345678function Student(name, sex) &#123; this.name = name; this.sex = sex;&#125;var student = new Student(&#x27;张三&#x27;, &#x27;男&#x27;);console.log(student);// &#123; &quot;name&quot;: &quot;张三&quot;, &quot;sex&quot;: &quot;男&quot; &#125; 构造函数调用var student = Student(&#x27;张三&#x27;, &#x27;男&#x27;);console.log(student);// undefined 普通函数调用，this表示window对象，没有name属性 也可以通过instanceof关键字判断是不是构造函数调用： js1234567891011function Student(name, sex) &#123; if (this instanceof Student) &#123; console.log(&#x27;构造函数调用&#x27;); this.name = name; this.sex = sex; &#125; else &#123; console.log(&#x27;普通函数调用&#x27;); &#125;&#125;new Student(&#x27;张三&#x27;, &#x27;男&#x27;);// 构造函数调用Student(&#x27;张三&#x27;, &#x27;男&#x27;);// 普通函数调用 使用同一个构造函数创建的对象，称为一类对象。所以也将构造函数称为类，同时将通过构造函数创建的对象，称为该类的实例。 5.1.7 原型对象JavaScript是一门面向对象的语言，而且它还是一个基于原型的面向对象的语言。 原型： 所有函数都有prototype属性的对象，称为原型。 所有对象（包括原型和函数，函数也是对象）都有__proto__属性的对象，可以通过这个对象访问其构造方法的原型。 通过函数prototype属性获取原型的方式称为显示调用，通过对象__proto__属性获取原型的方式称为隐式调用。 默认情况下，原型是一个Object对象，该对象只包含constructor属性和__proto__属性： 说明： 原型的constructor属性指向函数：js12function func() &#123;&#125;console.log(func.prototype.constructor === func);// true 原型的__proto__属性在浏览器里显示为[[Prototype]]属性，对应Object的prototype属性：js12function func() &#123;&#125;console.log(func.prototype.__proto__ === Object.prototype);// true 原型链： 原型链又称为隐式原型链，隐式调用的原型会形成原型链，顶端是Object显示调用的原型，该原型如果继续通过隐式调用获取原型会返回null：js1console.log(Object.prototype.__proto__);// null 所有对象（包括原型和函数，函数也是对象）都是Object的实例，任何对象的原型链都能追溯到Object显示调用的原型：js123function func() &#123;&#125;console.log(func.__proto__ === Function.prototype);// trueconsole.log(func.__proto__.__proto__ === Object.prototype);// true 所有方法（包括Object和Function）都是Function的实例，任何方法隐式调用的原型都是Function显示调用的原型：js123function func() &#123;&#125;console.log(func.__proto__ === Function.prototype);// trueconsole.log(Object.__proto__ === Function.prototype);// true 当访问对象的属性和方法时，首先在对象自身空间中寻找，如果没有，会在原型链上寻找，如果找不到会返回undefined： js123456789function Student() &#123;&#125;Student.prototype.name = &#x27;学生类&#x27;;Student.prototype.age = 18;var student = new Student();student.name = &#x27;学生实例&#x27;;console.log(student.name);// 学生实例console.log(student.age);// 18console.log(student.test);// undefined 在调用toString()方法时，在没有重写的情况下，调用的实际上是Object的原型对象的方法： js12345function Student() &#123;&#125;var student = new Student();console.log(student.toString());// [object Object]console.log(student.hasOwnProperty(&#x27;toString&#x27;));// false 在使用in关键字和for…in语句循环遍历对象的属性时，也会访问原型对象中的属性。 可以使用hasOwnProperty()方法判断对象自身是否包含指定属性： js12345678function Student() &#123;&#125;Student.prototype.name = &#x27;学生类&#x27;;Student.prototype.age = 18;var student = new Student();student.name = &#x27;学生实例&#x27;;console.log(student.hasOwnProperty(&#x27;name&#x27;));// trueconsole.log(student.hasOwnProperty(&#x27;age&#x27;));// false 5.1.8 函数对象方法当将函数作为对象赋值给变量时，这个对象即使函数对象，函数对象可以通过自身调用函数，也可以通过call()方法和apply()方法调用。 通过方法调用时，传入的第一个参数会被作为函数的调用者，即作为函数里的this对象： js12345678var test = function() &#123; console.log(this);&#125;test();// Window &#123;&#125;test.call();// Window &#123;&#125;test.apply();// Window &#123;&#125;test.call(123);// Number &#123;123&#125;test.apply(123);// Number &#123;123&#125; 两个方法的区别在于对入参上的处理，第二个参数会作为入参： js12345var test = function(first, last) &#123; console.log(first + &#x27; &#x27; + last);&#125;test.call(test, &#x27;John&#x27;, &#x27;Smith&#x27;);// John Smith 入参是可变参数test.apply(test, [&#x27;John&#x27;, &#x27;Smith&#x27;]);// John Smith 人参是数组 5.1.9 箭头函数箭头函数是在ES6中添加的一种规范： 省略了function关键字，箭头左侧表示入参，只有当入参只有一个时，才可以省略小括号 省略了return关键字，箭头右侧是返回语句，只有当函数直接返回表达式时，才可以省略大括号 使用： js123456// 使用箭头函数var func = (x) =&gt; x * x;// 使用普通函数var func = function(x) &#123; return x * x;&#125; 如果返回值是对象，需要使用括号包裹： js12var func = (x) =&gt; (&#123;result: x * x&#125;);console.log(func(5));// &#123;result: 25&#125; 5.2 数组5.2.1 定义数组也是对象的一种，数组是一种用于表达有顺序关系的数据的集合的语言结构。 数组和普通对象功能类似，也用来存储多个值。不同的是普通对象使用字符串作为属性名，而数组使用数字来作为索引操作元素。 索引是从0开始的整数，用于获取数组对应位置的数据。 数组可以存放任意类型的数据，可以在一个数组中存放不同类型的数据。 5.2.2 使用创建数组有两种方式： 先创建，然后插入数据：js123456var arr = new Array();arr[0] = 1;arr[1] = 2;arr[2] = 3;console.log(arr);// [1, 2, 3]console.log(typeof arr);// object 在创建时插入数据：js12345var arr = new Array(1, 2, 3);// 也可以使用这种方式// var arr = [1, 2, 3];console.log(arr);// [1, 2, 3]console.log(typeof arr);// object 删除数组数据： js1234var arr = [1, 2, 3];console.log(arr);// [1, 2, 3]delete arr[1];console.log(arr);// [1, 空, 3] 访问数组数据： js123var arr = [1, 2, 3];console.log(arr[0]);// 1console.log(arr[3]);// undefined 遍历数组数据： 使用for…in循环遍历：js1234var arr = [1, 2, 3];for (var i in arr) &#123; console.log(arr[i]);&#125; 使用forEach循环遍历：js1234var arr = [1, 2, 3];arr.forEach(function(i, e) &#123; console.log(i + &#x27; &gt; &#x27; + e);&#125;); 数组的属性： js1234var arr = [1, 2, 3];console.log(arr.constructor);// Array() &#123;[native code]&#125;console.log(arr.length);// 3console.log(arr.__proto__);// [] 数组的方法： js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var arr = [1, 2, 3];// 删除数组的最后一个元素，并返回删除的元素var del = arr.pop();console.log(del);// 3console.log(arr);// [1, 2]// 向数组的末尾添加元素，并返回数组的新的长度var len = arr.push(4, 5);console.log(len);// 4console.log(arr);// [1, 2, 4, 5]// 删除数组的第一个元素，并返回删除的元素var del = arr.shift();console.log(del);// 1console.log(arr);// [2, 4, 5]// 向数组开头添加元素，并返回新的数组长度var len = arr.unshift(-2, -1);console.log(len);// 5console.log(arr);// [-2, -1, 2, 4, 5]// 颠倒数组顺序arr.reverse();console.log(arr);// [5, 4, 2, -1, -2]// 对数组元素进行排序，默认按照字母顺序arr.sort();console.log(arr);// [-1, -2, 2, 4, 5]// 对数组元素进行排序，指定排序方式arr.sort(function(m, n) &#123; return m - n;&#125;);console.log(arr);// [-2, -1, 2, 4, 5]// 选择指定范围的字符串，前闭后开，不改变原数组，第一个参数是起始位置，第二个参数是结束位置console.log(arr);// [-2, -1, 2, 4, 5]// 空参选择全部var sli = arr.slice();console.log(sli);// [-2, -1, 2, 4, 5]// 一个参数，选择起始位置及其之后的元素var sli = arr.slice(1);console.log(sli);// [-1, 2, 4, 5]// 参数是负数则加上长度计算var sli = arr.slice(-1);console.log(sli);// [5]// 两个参数，选择定位之间的元素var sli = arr.slice(1, 3);console.log(sli);// [-1, 2]// 删除数组中的指定元素，并返回删除的元素，第一个参数是起始位置，第二个参数是删除数量，第三个及以后的参数是插入到起始位置之前的元素console.log(arr);// [-2, -1, 2, 4, 5]// 空参不删除任何元素var spli = arr.splice();console.log(spli);// []// 一个参数，删除起始位置的元素// var spli = arr.splice(1);// console.log(spli);// [-1, 2, 4, 5]// 参数是负数则加上长度计算// var spli = arr.splice(-1);// console.log(spli);// [5]// 两个参数，删除起始位置之后数量的元素// var spli = arr.splice(1, 3);// console.log(spli);// [-1, 2, 4]// 两个参数，删除起始位置之后数量的元素，插入元素到起始位置之前// var spli = arr.splice(1, 3, 0, 1);// console.log(spli);// [-1, 2, 4] 5.3 日期在JavaScript中使用Date对象表示日期： js1234567var now = new Date();console.log(typeof now);// objectconsole.log(now);// Wed Jul 03 2024 10:30:10 GMT+0800 (中国标准时间)now = new Date(&#x27;1/31/2008&#x27;);// 入参支持MM/dd/yyyy日期格式console.log(now);// Thu Jan 31 2008 00:00:00 GMT+0800 (中国标准时间)now = new Date(&#x27;1/31/2008 10:00:00&#x27;);// 入参支持MM/dd/yyyy HH:mm:ss日期时间格式console.log(now);// Thu Jan 31 2008 10:00:00 GMT+0800 (中国标准时间) 日期的属性： js123var now = new Date();console.log(now.constructor);// ƒ Date() &#123;[native code]&#125;console.log(now.__proto__);// &#123;&#125; 日期的方法： js12345678910var now = new Date();console.log(Date.now());// 时间戳，获取从1970年1月1日至今所过的毫秒数console.log(now.getFullYear());// 2024 获取Date对象的年份console.log(now.getDay());// 3 获取Date对象的星期，0表示周日console.log(now.getMonth());// 6 获取Date对象的月份，0表示1月console.log(now.getDate());// 3 获取Date对象在月份的第几日console.log(now.getHours());// 10 获取Date对象的小时，0表示0点和24点console.log(now.getMinutes());// 30 获取Date对象的分钟，0表示0分和60分console.log(now.getSeconds());// 10 获取Date对象的秒数，0表示0秒和60秒console.log(now.getMilliseconds());// 100 获取Date对象的毫秒 5.4 数学相关JavaScript为数学计算封装了一个Math对象，和其他的对象不同，Math不是一个构造函数，属于一个工具类，不用创建对象，里边封装了数学运算相关的属性和方法。 Math的属性： js123456789console.log(typeof Math);// objectconsole.log(Math.E);// 2.718... 获取算术常量e，即自然对数的底数console.log(Math.LN2);// 0.693... 获取2的自然对数console.log(Math.LN10);// 2.302... 获取10的自然对数console.log(Math.LOG2E);// 1.442... 获取以2为底的e的对数console.log(Math.LOG10E);// 0.434... 获取以10为底的e的对数console.log(Math.PI);// 3.141... 获取圆周率console.log(Math.SQRT1_2);// 0.707... 获取2的平方根的倒数console.log(Math.SQRT2);// 1.414... 获取2的平方根 Math的方法： js1234567console.log(Math.abs(-1));// 1 获取绝对值console.log(Math.ceil(-1.2));// -1 向上取整console.log(Math.floor(-1.2));// -2 向下取整console.log(Math.round(-1.2));// -1 四舍五入console.log(Math.random());// 0.5 生成0到1的随机数，不包括0和1console.log(Math.max(0, 1, 2));// 2 获取最大值console.log(Math.min(0, 1, 2));// 0 获取最小值 5.5 包装类JavaScript提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象： String：可以将基本数据类型字符串转换为String对象。 Number：可以将基本数据类型的数字转换为Number对象。 Boolean：可以将基本数据类型的布尔值转换为Boolean对象。 在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，因为对象在栈中存储的是对象的引用，所以在进行比较时会导致与预期不一致的结果： js123console.log(1 == 1);// true 基本数据类型之间的比较使用栈上的值console.log(1 == new Number(1));// true 基本数据类型与包装类之间的比较会发生自动拆箱，比较栈上的值console.log(new Number(1) == new Number(1));// false 包装类之间的比较使用栈上的引用。 5.5.1 布尔值布尔值的属性： js123var boo = new Boolean(true);console.log(boo.constructor);// ƒ Boolean() &#123;[native code]&#125;console.log(boo.__proto__);// Boolean &#123;&#125; 布尔值的方法： js12var boo = new Boolean(true);console.log(boo.valueOf());// true 获取原始值 5.5.2 数字数字的属性： js12345var num = new Number(0);console.log(num.constructor);// ƒ Number() &#123;[native code]&#125;console.log(num.__proto__);// Number &#123;&#125;console.log(Number.MIN_VALUE);// 5e-324console.log(Number.MAX_VALUE);// 1.7976931348623157e+308 数字的方法： js1234567891011console.log(Number.isNaN(&#x27;1&#x27;));// false 判断指定参数是否为NaN，只有当参数是数字且为NaN才会返回true，参数非数字和非NaN的数字会返回falseconsole.log(Number.isFinite(1));// false 判断指定参数是否为无穷大console.log(Number.isInteger(1));// true 判断指定参数是否为整数console.log(new Number(1.159).toFixed(2));// 1.16 获取指定小数位数的字符串，采用四舍五入（银行家舍入）策略，无参会返回整数字符串，参数范围是1到100console.log(new Number(1.615).toFixed(2));// 1.61 不是严格的四舍五入，严格四舍五入可以使用Math.round()方法实现，或者缩放某个倍数console.log(new Number(10).toFixed(4));// 10.0000 精度不足时会进行补位，常用于需要统一精度的场景console.log(new Number(1.159).toPrecision(3));// 1.16 获取指定位数的字符串，采用四舍五入（银行家舍入）策略，无参会返回原数字字符串，参数范围是1到100console.log(new Number(1.615).toPrecision(3));// 1.61 不是严格的四舍五入，严格四舍五入可以使用Math.round()方法实现，或者缩放某个倍数console.log(new Number(0.159).toPrecision(2));// 0.16 整数部分为0时，指定位数不包括整数部分console.log(new Number(10).toPrecision(6));// 10.0000 精度不足时会进行补位，常用于需要统一精度的场景console.log(new Number(10).valueOf());// 10 获取原始值 5.5.3 字符串字符串的属性： js1234var str = new String(&#x27;hello&#x27;);console.log(str.constructor);// ƒ String() &#123;[native code]&#125;console.log(str.length);// 5console.log(str.__proto__);// String &#123;&#125; 字符串的方法： js123456789101112131415161718192021var str = new String(&#x27;hello&#x27;);console.log(str.indexOf(&#x27;l&#x27;));// 2 获取首次出现的位置，找不到返回-1console.log(str.indexOf(&#x27;l&#x27;, 3));// 3 获取首次出现的位置，从指定位置开始，包含指定位置console.log(str.lastIndexOf(&#x27;l&#x27;));// 3 获取最后出现的位置，从右往左查找，找不到返回-1console.log(str.lastIndexOf(&#x27;l&#x27;, 2));// 2 获取最后出现的位置，从右往左查找console.log(str.charAt(1));// e 获取指定位置的字符，指定位置超出长度返回空串console.log(str.charCodeAt(1));// 101 获取指定位置的字符编码，即Unicode编码console.log(str.match(&#x27;l&#x27;));// [&#x27;l&#x27;, ...] 查找匹配的字符串，返回匹配的数组，支持正则表达式，找不到返回nullconsole.log(str.search(&#x27;l&#x27;));// 2 获取首次出现的位置，支持正则表达式，找不到返回-1console.log(str.replace(&#x27;l&#x27;, &#x27;&#x27;));// helo 查找首个匹配第一个参数的字符串，并替换为第二个参数指定的字符串，不改变原字符串console.log(str.replaceAll(&#x27;l&#x27;, &#x27;&#x27;));// heo 查找全部匹配第一个参数的字符串，并替换为第二个参数指定的字符串，不改变原字符串console.log(str.concat(&#x27; &#x27;, &#x27;world&#x27;));// hello world 获取拼接字符串，支持可变参数，不改变原字符串console.log(str.slice(1, 3));// el 获取指定范围的字符串，不改变原字符串，第一个参数是起始位置，第二个参数是结束位置，前闭后开console.log(str.slice(1));// ello 获取指定范围的字符串，不改变原字符串，只有一个参数会获取到末尾console.log(str.slice(-1));// o 获取指定范围的字符串，不改变原字符串，负数参数会从后往前查找console.log(str.substring(1, 3));// el 和slice类似，区别是不支持负数参数，负数参数会替换为0，并且参数会自动排序，保证前小后大console.log(str.split());// [&#x27;hello&#x27;] 根据字符将字符串拆分为数组，无参或字符不存在会将整个字符串作为数组的一个元素，支持正则表达式console.log(str.split(&#x27;&#x27;));// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] 空串将每个字符串作为数组的一个元素console.log(str.split(&#x27;ell&#x27;));// [&#x27;h&#x27;, &#x27;o&#x27;] 拆分后指定的字符被删除console.log(str.toLowerCase());// hello 获取小写字符串，不改变原字符串console.log(str.toUpperCase());// HELLO 获取大写字符串，不改变原字符串 5.6 正则表达式5.6.1 定义在JavaScript中使用RegExp对象表示正则表达式，正则表达式是用于从字符串中选择特定字符串的文本。 5.6.2 创建创建正则表达式有两种方式： 使用构造方法创建，第一个参数是表达式，第二个参数是可选的修饰符，如果表达式有特殊字符，需要使用\\进行转义：js123// var patt = new RegExp(pattern, modifiers);var reg = new RegExp(&#x27;123&#x27;);console.log(typeof reg);// object 直接创建，同样需要两个参数，但是使用/分隔：js123// var reg = /pattern/modifiers;var reg = /123/;console.log(typeof reg);// object 如果需要动态创建正则表达式，需要使用构造方法创建。 在创建正则表达式以后，其内部维护了一个lastIndex索引，记录下一次匹配从哪个位置开始。 5.6.3 方法使用test()方法判断是否匹配内容： js123var reg = /123/;var result = reg.test(&#x27;123a4a123a5a&#x27;);// 判断参数是否包含正则表达式匹配的字符串，返回true表示包含，返回false表示不包含console.log(result);// true 使用exec()方法获取匹配内容： js1234567var reg = /123/;var result = reg.exec(&#x27;123a4a123a5a&#x27;);// 返回从参数中匹配到的字符串，返回值是数组对象，对象内容和全局匹配修饰符有关console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(result.length);// 1 返回对象的数组长度console.log(result.index);// 0 返回匹配到的起始位置console.log(result.groups);// undefined 返回匹配到的捕获分组console.log(reg.lastIndex);// 0 未使用全局匹配修饰符时，匹配到就结束了，不会匹配下一个 使用字符串的match()方法获取匹配内容，和正则表达式的exec()方法相同： js123var reg = /123/;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 5.6.4 修饰符修饰符用于对匹配方式进行说明，修饰符可以省略，但修饰符之前的/不能省略： i：执行对大小写不敏感的匹配，默认大小写敏感 g：执行全局匹配，默认匹配到第一个停止 m：执行多行匹配，默认匹配第一行 如果没有使用g全局修饰，会在匹配到第一个停止，返回包含匹配信息的数组对象，并且exec()方法和match()方法获取的结果相同。 如果使用了g全局修饰，会匹配所有满足的内容，但是exec()方法和match()方法获取的结果不同。 使用exec()方法执行有全局修饰的正则表达式，返回从lastIndex开始匹配到的内容数组，匹配一次后返回匹配的内容并暂停： js12345678910var reg = /123/g;var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 3 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 9 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// null 匹配结束console.log(reg.lastIndex);// 0 匹配结束 使用test()方法也会更新lastIndex的值，如果不注意这一点，可能会出问题： js1234567var reg = /123/g;var result = reg.test(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 3 第一次匹配var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 9 第二次匹配var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(reg.lastIndex);// 0 匹配结束 虽然执行了一次exec()方法，但实际上已经匹配两次了 使用字符串的match()方法执行有全局修饰的正则表达式，返回匹配到的内容数组，匹配全部后结束： js1234var reg = /123/g;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123&#x27;, &#x27;123&#x27;]console.log(reg.lastIndex);// 0 匹配结束 5.6.5 字符串方法字符串中可以使用正则表达式的方法： js1234567var str = new String(&#x27;hello&#x27;);console.log(str.match(/l/));// [&#x27;l&#x27;, index: 2, input: &#x27;hello&#x27;, groups: undefined]console.log(str.match(/l/g));// [&#x27;l&#x27;, &#x27;l&#x27;] 全局匹配会获取全部匹配的内容console.log(str.search(/l/));// 2console.log(str.replace(/l/, &#x27;&#x27;));// heloconsole.log(str.replaceAll(/l/g, &#x27;&#x27;));// heo 替换全部时，修饰符必须有全局匹配console.log(str.split(/ll/));// [&#x27;he&#x27;, &#x27;o&#x27;] 5.6.6 量词表达式中可以使用量词，使用n表示任意字符： js12345678910111213var str = &#x27;hello&#x27;;console.log(str.match(/el+/g));// [&#x27;ell&#x27;] 使用n+匹配包含至少一个n的字符串console.log(str.match(/hl+/g));// null 至少包含一个nconsole.log(str.match(/el*/g));// [&#x27;ell&#x27;] 使用n*匹配包含零个或多个n的字符串console.log(str.match(/hl*/g));// [&#x27;h&#x27;] 可以不包含nconsole.log(str.match(/el?/g));// [&#x27;el&#x27;] 使用n?匹配包含零个或一个n的字符串console.log(str.match(/hl?/g));// [&#x27;h&#x27;] 可以不包含nconsole.log(str.match(/l&#123;2&#125;/g));// [&#x27;ll&#x27;] 使用n&#123;X&#125;匹配包含X个n的字符串console.log(str.match(/l&#123;1,2&#125;/g));// [&#x27;ll&#x27;] 使用n&#123;X,Y&#125;匹配至少包含X个至多包含Y个n的字符串，Y可以省略console.log(str.match(/lo$/g));// [&#x27;lo&#x27;] 使用n$匹配任何结尾为n的字符串console.log(str.match(/^he/g));// [&#x27;he&#x27;] 使用^n匹配任何开头为n的字符串console.log(str.match(/e(?=l)/g));// [&#x27;e&#x27;] 使用?=n匹配任何后面紧跟n的字符串console.log(str.match(/h(?!l)/g));// [&#x27;h&#x27;] 使用?=n匹配任何后面紧跟n的字符串 在具有量词匹配的表达式中，使用贪婪模式和非贪婪模式： js123var str = &#x27;123123&#x27;;console.log(str.match(/1.*3/g));// [&#x27;123123&#x27;] 默认开启贪婪模式，获取能匹配到的最多的内容console.log(str.match(/1.*?3/g));// [&#x27;123&#x27;, &#x27;123&#x27;] 使用?开启非贪婪模式，获取能匹配到的最少的内容 5.6.7 范围表达式中可以使用方括号限制查找某个范围的字符串，实际上比较的是ASCII码： js1234567var str = &#x27;ab12CD&#x27;;console.log(str.match(/[abCD]/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] 查找方括号之间的任何字符console.log(str.match(/[^abCD]/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找不在方括号之间的任何字符console.log(str.match(/[0-9]/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找0-9之间的数字console.log(str.match(/[a-z]/g));// [&#x27;a&#x27;, &#x27;b&#x27;] 查找a-z之间的字符，即小写英文字母console.log(str.match(/[A-Z]/g));// [&#x27;C&#x27;, &#x27;D&#x27;] 查找A-Z之间的字符，即大写英文字母console.log(str.match(/[A-z]/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] 查找A-z之间的字符，即所有英文字母，因为在ASCII码中，大写字母在小写字母前面 5.6.8 特殊字符表达式中可以使用元字符替代特殊字符进行查找： js123456789101112131415console.log(&#x27;ab12_!+&#x27;.match(/./g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找单个字符，除了换行和行结束符console.log(&#x27;ab12_!+&#x27;.match(/\\w/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;] 查找单词字符，包括数字、字母、下划线console.log(&#x27;ab12_!+&#x27;.match(/\\W/g));// [&#x27;!&#x27;, &#x27;+&#x27;] 查找非单词字符console.log(&#x27;ab12_!+&#x27;.match(/\\d/g));// [&#x27;1&#x27;, &#x27;2&#x27;] 查找数字字符console.log(&#x27;ab12_!+&#x27;.match(/\\D/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找非数字字符console.log(&#x27;ab12_!+&#x27;.match(/\\s/g));// null 查找空白字符，包括空格符、回车符、换行符、换页符、制表符、垂直制表符console.log(&#x27;ab12_!+&#x27;.match(/\\S/g));// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;_&#x27;, &#x27;!&#x27;, &#x27;+&#x27;] 查找非空白字符console.log(&#x27;hello world&#x27;.match(/\\bwo/g));// [&#x27;wo&#x27;] 查找单词边界字符，即位于单词开头和结尾的字符console.log(&#x27;hello world&#x27;.match(/\\Blo/g));// [&#x27;lo&#x27;] 查找非单词边界字符console.log(&#x27;&#x27;.match(/\\0/g));// null 查找NULL字符console.log(&#x27;&#x27;.match(/\\n/g));// null 查找换行符console.log(&#x27;&#x27;.match(/\\r/g));// null 查找回车符console.log(&#x27;&#x27;.match(/\\f/g));// null 查找换页符console.log(&#x27;&#x27;.match(/\\t/g));// null 查找制表符console.log(&#x27;&#x27;.match(/\\v/g));// null 查找垂直制表符 5.6.9 捕获分组在正则表达式中使用()有两个作用： 将被包裹的内容进行单独匹配，用于形成捕获分组 括号后的量词会将括号视为整体 在未使用全局修饰的情况下，使用exec()方法获取匹配内容： js123var reg = /(123)(a.a)/;var result = reg.exec(&#x27;123a4a123a5a&#x27;);// 在使用捕获分组时，数组第一个元素是完整的匹配内容，后面的元素是捕获的元素console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 在未使用全局修饰的情况下，使用字符串的match()方法获取匹配内容，和正则表达式的exec()方法相同： js123var reg = /(123)(a.a)/;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined] 在使用全局修饰的情况下，使用exec()方法获取匹配内容： js12345678910var reg = /(123)(a.a)/g;var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123&#x27;, &#x27;a4a&#x27;, index: 0, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 6 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// [&#x27;123a5a&#x27;, &#x27;123&#x27;, &#x27;a5a&#x27;, index: 6, input: &#x27;123a4a123a5a&#x27;, groups: undefined]console.log(reg.lastIndex);// 12 记录本次匹配结束时的索引，下次匹配从这个位置开始var result = reg.exec(&#x27;123a4a123a5a&#x27;);console.log(result);// null 匹配结束console.log(reg.lastIndex);// 0 匹配结束 在使用全局修饰的情况下，使用字符串的match()方法获取匹配内容： js1234var reg = /(123)(a.a)/g;var result = &#x27;123a4a123a5a&#x27;.match(reg);console.log(result);// [&#x27;123a4a&#x27;, &#x27;123a5a&#x27;]console.log(reg.lastIndex);// 0 匹配结束 6 文档对象模型6.1 定义文档对象模型（DOM，Document Object Model），在JavaScript中通过DOM操作HTML页面。 DOM将HTML页面映射为一个多节点模型，每个元素和属性都是节点： 文档本身就是文档节点，使用document对象表示，作为window对象的属性存在的，不用获取可以直接使用。 注释是注释节点。 元素是元素节点。 元素内的属性是属性节点。 元素内的文本是文本节点。元素之间的空白也是文本节点。 当网页被加载时，浏览器会创建页面的DOM树： 节点的通用属性： nodeName：代表当前节点的名字，只读属性。元素节点返回大写的标签名，属性节点返回属性名，文本节点返回#text字符串。 nodeType：返回一个整数，这个数值代表着给定节点的类型，只读属性。元素节点返回1，属性节点返回2，文本节点返回3。 nodeValue：返回给定节点的当前值，可读写的属性。元素节点返回null，属性节点返回属性值，文本节点返回文本节点的内容。 6.2 节点6.2.1 文档节点查询元素节点的方法，需要使用文档节点document对象调用： js1234var home = document.getElementById(&#x27;home&#x27;);// 通过元素的id属性查找元素节点home = document.getElementsByName(&#x27;home&#x27;);// 通过元素的name属性查找元素节点，返回多个匹配的节点home = document.getElementsByClassName(&#x27;home&#x27;);// 通过元素的calss属性查找元素节点，返回多个匹配的节点，支持元素节点调用home = document.getElementsByTagName(&#x27;div&#x27;);// 通过元素的标签名查找元素节点，返回多个匹配的节点，支持元素节点调用 除了通过id属性查找返回的是对象外，其余三个返回的均为伪数组： js1234567891011var home = document.getElementById(&#x27;home&#x27;);console.log(home);// &lt;span id=&quot;home&quot;&gt;home-id&lt;/span&gt;home = document.getElementsByName(&#x27;home&#x27;);console.log(home);// NodeList [span]console.log(Array.prototype.slice.call(home));// [span]home = document.getElementsByClassName(&#x27;home&#x27;);console.log(home);// HTMLCollection [span.home]console.log(Array.prototype.slice.call(home));// [span.home]home = document.getElementsByTagName(&#x27;div&#x27;);console.log(home);// HTMLCollection [div]console.log(Array.prototype.slice.call(home));// [div] 文档节点的属性： js1234console.log(document.title);// 获取文档标题console.log(document.URL);// 获取文档URLconsole.log(document.referrer);// 获取文档referrer，即前文档的URLconsole.log(document.domain);// 获取文档域名 使用文档节点操作节点： js12345console.log(document.querySelector(&#x27;#home&#x27;));// 使用CSS选择器查找元素节点，返回第一个元素节点console.log(document.querySelectorAll(&#x27;#home&#x27;));// 使用CSS选择器查找元素节点，返回全部元素节点var newDiv = document.createElement(&#x27;div&#x27;);// 创建元素节点，入参是标签名var newName = document.createAttribute(&#x27;name&#x27;);// 创建属性节点，入参是属性名var newText = document.createTextNode(&#x27;text&#x27;);// 创建文本节点，入参是文本内容 6.2.2 元素节点元素节点的属性： js12345678var home = document.getElementById(&#x27;home&#x27;);console.log(home.children);// 获取当前节点的所有子节点，只获取元素节点console.log(home.childNodes);// 获取当前节点的所有子节点，包括元素节点和非元素节点console.log(home.firstChild);// 获取当前节点的第一个子节点，包括元素节点和非元素节点console.log(home.lastChild);// 获取当前节点的最后一个子节点，包括元素节点和非元素节点console.log(home.parentNode);// 获取当前节点的父节点console.log(home.previousSibling);// 获取当前节点的前一个兄弟节点，包括元素节点和非元素节点console.log(home.nextSibling);// 获取当前节点的后一个兄弟节点，包括元素节点和非元素节点 通过元素节点获取其他节点： 通过firstChild属性获取的第一个节点通常是文本节点 通过getAttributeNode(属性名)方法获取指定属性节点，通常不使用属性节点 获取和修改元素节点的属性： js12345var home = document.getElementById(&#x27;home&#x27;);console.log(home.id);// 获取id属性console.log(home.class);// 获取class属性home.id = &#x27;home-id&#x27;;// 修改id属性home.id = &#x27;home-class&#x27;;// 修改class属性 操作元素节点： js123456789101112131415var home = document.getElementById(&#x27;home&#x27;);// 操作属性console.log(home.getAttribute(&#x27;id&#x27;));// 通过属性名获取属性console.log(home.getAttributeNode(&#x27;id&#x27;));// 通过属性名获取属性节点home.setAttribute(&#x27;name&#x27;, &#x27;home&#x27;);// 通过属性名设置属性home.setAttributeNode(document.createAttribute(&#x27;name&#x27;));// 设置属性节点home.removeAttribute(&#x27;name&#x27;);// 通过属性名删除属性home.removeAttributeNode(home.getAttributeNode(&#x27;name&#x27;));// 删除属性节点// 操作子节点var newDiv = document.createElement(&#x27;div&#x27;);// 创建元素节点var newText = document.createTextNode(&#x27;text&#x27;);// 创建文本节点home.appendChild(newDiv);// 添加子节点，新的字节点会添加到末尾子节点的后面home.insertBefore(newText, home.childNodes[0]);// 添加子节点，新的字节点会添加到首位子节点的前面home.removeChild(home.childNodes[0]);// 删除子节点home.replaceChild(newText, home.childNodes[0]);// 替换子节点 操作元素样式： js12345678910111213var home = document.getElementById(&#x27;home&#x27;);home.style[&#x27;fontSize&#x27;] = &quot;16px&quot;;// 修改行内样式console.log(home.style.fontSize);// 获取行内样式，需要将分隔命名转为驼峰命名// 获取元素样式，包括内部样式和外部样式，兼容写法，不支持修改if (window.getComputedStyle) &#123; // 大部分浏览器兼容的方式，第二个参数是伪元素 var fontSize = getComputedStyle(home, null)[&#x27;fontSize&#x27;]; console.log(fontSize);&#125; else &#123; // IE8及以下 var fontSize = home.currentStyle[&#x27;fontSize&#x27;]; console.log(fontSize);&#125; 6.2.3 属性节点属性节点的属性： js12345var home = document.getElementById(&#x27;home&#x27;);var homeName = home.getAttributeNode(&#x27;name&#x27;);console.log(homeName.name);// 获取属性名console.log(homeName.value);// 获取属性值homeName.value = &#x27;name&#x27;;// 设置属性值 6.3 事件6.3.1 使用事件就是用户和浏览器之间的交互行为，比如点击、移动。 事件可以写在HTML的元素内，也可以写在JavaScript里： 写在HTML的元素里，不建议使用这种方式：html1&lt;span id=&quot;home&quot; onclick=&quot;alert(&#x27;span&#x27;);&quot;&gt; 写在JavaScript里，建议使用这种方式：js1234var home = document.getElementById(&#x27;home&#x27;);home.onclick = function() &#123; alert(&#x27;span&#x27;);&#125; 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数，在事件对象中封装了当前事件相关的一切信息。 在使用IE浏览器时，如果版本小于IE8，响应函数被触发时，浏览器不会传递事件对象，而是将事件对象作为window对象的属性保存。 兼容IE和其他浏览器的方式： js1234567// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);// 传入事件对象，可以省略home.onclick = function(event) &#123; alert(&#x27;span&#x27;);&#125; 常用事件： js1234567891011121314151617var home = document.getElementById(&#x27;home&#x27;);// 鼠标点击时执行home.onclick = function() &#123; alert(&#x27;span&#x27;);&#125;// 元素获取焦点时执行home.onfocus = function() &#123; alert(&#x27;span&#x27;);&#125;// 元素失去焦点时执行home.onblur = function() &#123; alert(&#x27;span&#x27;);&#125;// 页面加载完后执行window.onload = function() &#123; alert(&#x27;span&#x27;);&#125; 使用target属性获取触发事件的元素： js1234567// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; var obj = event.target; alert(obj.tagName);&#125; 6.3.2 事件的传播关于事件的传播网景公司和微软公司有不同的理解： 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素。 W3C综合了两个公司的方案，将事件传播分成了三个阶段： 捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件。 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件。 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件。 IE8及以下的浏览器中没有捕获阶段，其他浏览器在调用方法时处理。 6.3.3 事件的冒泡事件的冒泡，指的是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。 如果不希望发生事件冒泡可以取消冒泡： js12345678910// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;span&#x27;); // 已弃用，不建议 event.cancelBubble = true; // 建议 event.stopPropagation();&#125; 取消冒泡并不会取消元素的默认动作，比如超链接的默认跳转，可以使用preventDefault()方法取消默认动作： js12345678// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;a&#x27;); // 取消跳转，但不能阻止冒泡 event.preventDefault();&#125; 既可以取消冒泡，又可以取消默认动作： js12345678// 获取事件对象，兼容写法event = event || window.event;var home = document.getElementById(&#x27;home&#x27;);home.onclick = function(event) &#123; alert(&#x27;a&#x27;); // 取消跳转，阻止冒泡 return false;&#125; 6.3.4 事件的绑定给元素绑定事件有两种方式： 通过元素.事件 = 函数的方式绑定，一个事件只支持绑定一个函数，后面的会覆盖前面的：js1234var home = document.getElementById(&#x27;home&#x27;);home.onclick = function() &#123; alert(&#x27;span&#x27;);&#125; 通过方法绑定，一个事件可以绑定多个函数，但是需要兼容不同的浏览器：js1234567891011121314151617181920212223242526var home = document.getElementById(&#x27;home&#x27;);// 在页面加载后绑定window.onload = function() &#123; bindClick(home, &#x27;click&#x27;, &#x27;first&#x27;); bindClick(home, &#x27;click&#x27;, &#x27;last&#x27;);&#125;;// 通用的绑定方法，将handle()方法绑定到传入的对象上function bindClick(obj, eventStr, name) &#123; if (obj.addEventListener) &#123; // 大部分浏览器兼容的方式，需要使用没有on前缀的事件 obj.addEventListener(eventStr, function() &#123; console.log(this);// 在addEventListener()方法中，this对象是绑定的事件对象 handle(name); &#125;, false);// 如果希望在捕获阶段就触发事件，可以设置为true，一般为false &#125; else &#123; // IE8及以下，需要使用有on前缀的事件 obj.attachEvent(&quot;on&quot; + eventStr, function() &#123; console.log(this);// 在attachEvent()方法中，this对象是window对象 handle.call(obj, name);// 调用回调函数，强制将this对象设为绑定的事件对象 &#125;); &#125;&#125;// 通用的执行方法function handle(name) &#123; console.log(name);&#125; 7 浏览器对象模型7.1 定义浏览器对象模型（BOM，Browser Object Model），允许JavaScript与浏览器交互。 BOM提供了一组对象用于对浏览器进行操作： Window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象。 Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器。 Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面。 History：代表浏览器历史记录，可以通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在当次访问时有效。 Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息。 这些BOM对象（全局对象）在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用。 7.2 使用7.2.1 Window对象Window对象的属性和方法可以省略直接使用。 Window对象属性： js12345console.log(window.document);// 返回Document对象的只读引用console.log(window.navigator);// 返回Navigator对象的只读引用console.log(window.location);// 返回Location对象的只读引用console.log(window.history);// 返回History对象的只读引用console.log(window.screen);// 返回Screen对象的只读引用 Window对象方法： js1234567891011121314151617181920212223// 关闭浏览器窗口close();// 打开新的浏览器窗口open(&#x27;&#x27;,&#x27;_blank&#x27;,&#x27;width=200,height=100&#x27;);// 显示带有消息和确认按钮的警告框alert(&#x27;警告框&#x27;);// 显示带有消息以及确认按钮和取消按钮的对话框confirm(&#x27;确认框&#x27;);// 按照指定的时间执行定时函数var obj = setTimeout(function(name) &#123; console.log(&#x27;3秒后打印 &#x27; + name);&#125;, 3000, &#x27;test&#x27;);// 取消设置的定时函数，在执行前有效clearTimeout(obj);// 按照指定的时间（以毫秒计）重复调用函数var id = 1;var obj = setInterval(function(name) &#123; console.log(id++ + &#x27; &#x27; + name); if (id &gt; 5) &#123; // 取消设置的重复调用函数 clearInterval(obj); &#125;&#125;, 100, &#x27;test&#x27;); 7.2.2 Navigator对象Navigator对象属性： js1234567console.log(navigator.appName);// 返回浏览器的名称console.log(navigator.appCodeName);// 返回浏览器的代码名console.log(navigator.lappVersioncation);// 返回浏览器的平台和版本信息console.log(navigator.platform);// 返回运行浏览器的操作系统平台console.log(navigator.userAgent);// 返回由客户机发送服务器的代理信息console.log(navigator.language);// 返回浏览器使用的语言console.log(navigator.product);// 返回浏览器使用的引擎（产品） 由于历史原因，Navigator对象中的大部分属性都已经不能识别浏览器了，一般只使用userAgent来判断浏览器的信息。 7.2.3 Location对象Location对象属性： js12345678console.log(location.hash);// 返回URL的锚部分console.log(location.host);// 返回URL的主机名和端口console.log(location.hostname);// 返回URL的主机名console.log(location.href);// 返回完整的URLconsole.log(location.pathname);// 返回的URL路径名console.log(location.port);// 返回URL服务器使用的端口号console.log(location.protocol);// 返回URL协议console.log(location.search);// 返回URL的查询部分 Location对象方法： js123location.assign();// 载入新的文档，相当于给location对象赋值location.reload(true);// 重新加载当前页面，相当于刷新，参数为true表示清空缓存location.replace();// 用新的文档替换当前文档，不能使用历史记录，不能使用后退 7.2.4 History对象History对象属性： js1console.log(location.length);// 返回历史列表中的网址数 History对象方法： js123location.back();// 加载历史列表中的前一个URLlocation.forward();// 加载历史列表中的下一个URLlocation.go(1);// 加载历史列表中的某个具体页面，参数大于0时前进，参数小于0时后退 7.2.5 Screen对象Screen对象属性： js12console.log(screen.height);// 返回屏幕的总高度console.log(screen.width);// 返回屏幕的总宽度","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"}]},{"title":"CSS3新特性","slug":"100-大前端/102-CSS/001-基础/004-移动端","date":"2024-05-19T03:17:44.000Z","updated":"2024-05-23T03:34:01.044Z","comments":true,"path":"posts/20240519/111744/","permalink":"https://momashanhe.com/posts/20240519/111744/","excerpt":"摘要：本文主要介绍了在移动端开发需要注意的一些问题。","text":"摘要：本文主要介绍了在移动端开发需要注意的一些问题。 1 背景一般来说，移动端需要在屏幕远小于电脑端时，支持显示几乎相同分辨率的图像，所以移动端的逻辑像素要比电脑端的逻辑像素小。 默认情况下，如果未对网页适配移动端，移动端的浏览器会将视口设置为980px，以确保网页可以在移动端正常访问，此时将980px作为物理像素。 当网页宽度不超过980px时，将980px作为逻辑像素，像素比为980px&#x2F;980px&#x3D;1，网页能正常显示。当网页宽度超过了980px时，将网页宽度作为逻辑像素，像素比为980px&#x2F;网页宽度&lt;1，网页会被缩小。 为了能让移动端正常显示网页，大部分网站都会专门为移动端设计网页。 2 完美视口为了让网页能在移动端合理显示，避免网页被缩小，需要根据网页的逻辑像素和移动端屏幕的最佳像素比调整视口的物理像素，可以在meta元素设置： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=200px&quot;&gt; 设置最佳视口，可以让浏览器根据网页的逻辑像素，自动计算视口最佳的物理像素，实现完美视口： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 设置了视口的物理像素后，当网页的逻辑像素超出后，会使用滚动条加载页面，不会缩放页面，保证文字和内容显示正常。 3 适配不同屏幕虽然设置完美视口能够解决缩放的问题，但不同设备的完美视口是不同的，在某个设备上使用200px能够撑满宽度，但是在其他设备上可能就只显示半屏，所以还需要适配不同的屏幕。 3.1 使用百分比使用百分比代替像素值，依据父元素的内容大小使用百分比。 这种方式可以避免使用像素带来的问题，但是如果父元素设置了边框或者边距，使用起来就比较麻烦。 只能在某些场景下使用，并不是完全取代像素的解决方案。 3.2 使用视口百分比使用视口的百分比代替像素值，单位是vw和vh，分别是水平方向和垂直方向。 在使用时，需要按照视口设置的物理像素，将设计图里的逻辑像素转化为视口百分比。 示例： 第一步：假设网页宽度为750px，计算1px对应的vw：100÷750≈0.1333vw 第二步：假设容器宽度为200px，计算对应的vw：200×0.1333&#x3D;26.6666vw 第三步：使用26.6666vw作为容器宽度，替换200px 这种方式不依赖父元素，能够按照比例适配不同屏幕，但是在计算的时候比较麻烦。 3.3 使用字体倍数使用字体倍数rem代替像素值，rem对应的是根元素的字体大小，这种方式是使用视口百分比的补充。 实例： 第一步：假设网页宽度为750px，计算1px对应的vw：100÷750≈0.1333vw 第二步：为了防止字体过小被浏览器改为默认的12px，建议设置网页根元素的字体大小为40px，计算对应的vw：40×0.1333&#x3D;5.3333vw 第三步：使用5.3333vw作为网页根元素的字体大小，替换40px 第四步：假设容器宽度为200px，使用字体大小将px转为rem：200÷40&#x3D;5rem 第五步：使用5rem作为容器宽度，替换200px 这种方式本质上使用的还是视口百分比，但是在计算的时候使用字体大小计算，更简单一些。 在实际开发中，并不是完全禁止使用px作为单位，如果需要根据屏幕进行缩放，才需要考虑避免使用px带来的问题。 4 响应式布局4.1 匹配媒体查询浏览器可以通过媒体查询得到当前访问浏览器的设备类型，使用@media指定对不同媒体的样式处理，在不同设备访问时得到不同样式。 匹配媒体类型： css123456@media 媒体类型 &#123; div &#123; width: 10px; height: 10px; &#125;&#125; 媒体查询也遵循样式的覆盖原则，所以需要将媒体查询写在正常样式下面，避免被覆盖失效。 常用媒体类型： all：匹配所有设备。 screen：匹配屏幕，包括电脑屏幕、平板屏幕、手机屏幕、等等。 print：匹配打印机，在打印时使用的样式。 示例： css12345@media print &#123; .title &#123; color: #000; &#125;&#125; 完整的媒体类型可以参考文档：MDN媒体类型 4.2 匹配媒体特性除了通过媒体类型设置不同的样式，也可以通过媒体特征匹配不同的样式。 匹配媒体特征： css123456@media (属性名: 属性值) &#123; div &#123; width: 10px; height: 10px; &#125;&#125; 当匹配到指定的特征时，应用指定的样式。 常用媒体特征： 属性名 作用 取值 width 匹配视口宽度，视口宽度匹配时应用样式 长度值 max-width 匹配视口最大宽度，视口宽度小于等于匹配时应用样式 长度值 min-width 匹配视口最小宽度，视口宽度大于等于匹配时应用样式 长度值 height 匹配视口高度，视口高度匹配时应用样式 长度值 max-height 匹配视口最大高度，视口高度小于等于匹配时应用样式 长度值 min-height 匹配视口最小高度，视口高度大于等于匹配时应用样式 长度值 device-width 匹配设备屏幕的宽度，设备屏幕宽度匹配时应用样式 长度值 max-device-width 匹配设备屏幕的最大宽度，设备屏幕宽度小于等于匹配时应用样式 长度值 min-device-width 匹配设备屏幕的最小宽度，设备屏幕宽度大于等于匹配时应用样式 长度值 orientation 检测视口的旋转方向，即屏幕是否横屏 portrait：视口处于纵向，即高度大于等于宽度 landscape：视口处于横向，即宽度大于高度 示例： css12345@media (width: 10px) &#123; .title &#123; color: #000; &#125;&#125; 常见用于区分不同等级屏幕的阈值： 小屏幕：宽度在768px以下。 中屏幕：宽度在769px到992px之间。 大屏幕：宽度在992px到1200px之间。 超大屏幕：宽度在1200px以上。 4.3 匹配复杂条件支持复杂匹配，如果需要同时满足，可以使用运算符连接，如果需要满足任意一个，可以使用逗号分隔。 可以混合使用媒体查询和媒体特征进行匹配。 支持的运算符： and：并且，匹配全部条件。 or：或者，匹配任意条件，支持使用逗号,分隔。 not：否定，匹配相反条件。 only：肯定，用于让IE浏览器忽略设置的条件和样式，避免部分匹配，对现代浏览器无影响。 示例： css12345@media screen and (max-width:768px) &#123; .title &#123; color: #000; &#125;&#125; 在使用时也可以通过指定条件使用不同的样式文件。示例： html1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width:768px)&quot; href=&quot;./index-small.css&quot;&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"Less","slug":"100-大前端/102-CSS/003-预处理/001-Less","date":"2024-05-19T01:44:23.000Z","updated":"2024-08-12T09:09:26.841Z","comments":true,"path":"posts/20240519/094423/","permalink":"https://momashanhe.com/posts/20240519/094423/","excerpt":"摘要：本文主要介绍了Less的使用。","text":"摘要：本文主要介绍了Less的使用。 1 简介1.1 预处理器在了解Less之前，要先认识什么是CSS预处理器以及其有什么作用。 增强传统CSS（层叠样式表）功能的脚本语言被称为CSS预处理器，它允许开发人员使用变量、嵌套、混合等功能，以更高效和可维护的方式编写CSS代码。CSS预处理器的另一个术语是动态样式表语言。 1.2 常见的预处理器1.2.1 LessLess是一种动态样式语言，它扩展了CSS的功能，提供了变量、嵌套、混合、运算等功能。 Less使用类似于CSS的语法，但具有更简洁的书写方式。 Less可以通过Less编译器将Less文件编译为普通的CSS文件。 Less具有较小的学习曲线，易于上手。 官网：https://less.bootcss.com/ 1.2.2 SassSass是一种成熟且广泛使用的CSS预处理器，它提供了许多强大的功能，如变量、嵌套规则、混合、继承等。 Sass有两种语法：Sass（使用缩进）和 SCSS（使用类似于CSS的语法）。 Sass可以通过命令行工具或构建工具编译为普通的CSS文件。 Sass具有强大的功能和灵活性，适用于大型项目。 官网：https://sass.bootcss.com/index.html 1.2.3 SCSSSCSS是Sass的一种语法格式，它使用类似于CSS的语法，但具有Sass的功能和特性。 SCSS可以看作是Sass的一种扩展，使用大括号和分号来表示代码块和语句。SCSS与Sass兼容，可以在一个项目中同时使用。 官网：https://sass.bootcss.com/index.html 1.2.4 StylusStylus是一种简洁灵活的CSS预处理器，提供了类似于Sass和Less的功能，如变量、嵌套规则、混合、继承等。 Stylus使用类似于Python的缩进语法。 Stylus也可以通过命令行工具或构建工具编译为普通的CSS文件。 Stylus的语法非常简洁，可以减少样式表的代码量。 官网：https://www.stylus-lang.cn/ 1.3 选用LessLess没有去掉任何CSS的功能，而是在现有的语法上增添了许多额外的功能特性，可以看做是CSS的一种增强版，通过Less可以用更少的代码实现更强大的样式。 Sass与Stylus相比于Less功能更为丰富，但对于学习成本以及适应时间，Less稍胜一筹。 2 引入2.1 在页面中引入如果是在浏览器环境中开发，可以通过引入Less的核心JS库使用Less的功能。 在官网上下载Less的JS文件，也可以通过GitHub下载：https://github.com/less/less.js/archive/master.zip 因为Less需要在CSS之后生效，所以需要在CSS后引入JS文件，或者在导入Less文件后引入JS文件： js123&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot;&gt;&lt;script src=&quot;less/less.min.js&quot;&gt;&lt;/script&gt; 2.2 通过命令引入如果是在Node.js环境中开发，可以使用NPM安装Less： bash1npm install -g less 使用命令将Less文件转为CSS文件： bash1lessc styles.less styles.css 3 使用在VS code中安装Easy Less插件","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"Less","slug":"Less","permalink":"https://momashanhe.com/tags/Less/"}]},{"title":"CSS3新特性","slug":"100-大前端/102-CSS/001-基础/003-CSS3新特性","date":"2024-04-16T07:55:28.000Z","updated":"2024-08-12T09:24:36.003Z","comments":true,"path":"posts/20240416/155528/","permalink":"https://momashanhe.com/posts/20240416/155528/","excerpt":"摘要：本文主要介绍了CSS3的一些新特性。","text":"摘要：本文主要介绍了CSS3的一些新特性。 1 简介1.1 概述CSS3是CSS2的升级版本，它在CSS2的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题。 CSS3在未来会按照模块化的方式去发展，官方说明：说明文档 CSS3的新特性如下： 新增了更加实用的选择器，例如伪类选择器和伪元素选择器等。 新增了更好的视觉效果，例如圆角、阴影、渐变等。 新增了丰富的背景效果，例如支持多个背景图片，同时新增了若干个背景相关的属性。 新增了全新的布局方案，即弹性盒子。 新增了Web字体，可以显示用户电脑上没有安装的字体。 增强了颜色，例如HSL、HSLA、RGBA几种新的颜色模式，新增控制元素透明度的属性。 增加了2D变形和3D变形，例如旋转、扭曲、缩放、位移等。 增加动画与过渡效果，让变形更平滑。 1.2 私有前缀W3C标准所提出的某个CSS特性，在被浏览器正式支持之前，需要根据浏览器的内核，通过私有前缀来使用该CSS特性，在浏览器正式支持该CSS特性后，就不需要私有前缀了。 如下代码中的-webkit-就是私有前缀： css12345div &#123; width: 400px; height: 400px; -webkit-border-radius: 20px;&#125; 常见浏览器私有前缀： Chrome浏览器：-webkit- Safari浏览器：-webkit- Firefox浏览器：-moz- Edge浏览器：-webkit- Opera浏览器：-o- IE浏览器：-ms- 查询CSS3兼容性的网站：caniuse 注意： 在编码时，不用过于关注浏览器私有前缀，因为主流浏览器都支持常用的CSS3新特性。 即便是为了老浏览器而加前缀，也可以借助现代的构建工具，比如webpack工具，自动添加私有前缀。 2 增强2.1 新增长度单位新增长度单位： rem：根元素字体大小的倍数，只与根元素字体大小有关，根元素就是html元素 vw：视口宽度的百分之多少，10vw就是视口宽度的10% vh：视口高度的百分之多少，10vh就是视口高度的10% vmax：视口宽高中大的那个的百分之多少 vmin：视口宽高中小的那个的百分之多少 2.2 新增颜色表示CSS3新增了三种颜色设置方式，分别是RGBA、HSL、HSLA，参考：CSS2入门-5-2-颜色 2.3 新增选择器CSS3新增的选择器有伪类选择器和伪元素选择器，参考：CSS2入门-3-4-高级选择器 2.4 新增盒子属性2.4.1 盒子宽高常用属性： 属性名 作用 取值 resize 是否允许用户设置盒子宽高，需要和overflow属性配合使用 none：不允许（默认值） both：允许用户设置盒子宽高 horizontal：只允许用户设置盒子宽度 vertical：只允许用户设置盒子高度 2.4.2 怪异盒子常用属性： 属性名 作用 取值 box-sizing 设置盒模型的类型 content-box：width和height设置的是盒子内容区的大小（默认值） border-box：width和height设置的是盒子总大小（怪异盒子） 2.4.3 盒子阴影常用属性： 属性名 作用 取值 box-shadow 添加阴影 h-shadow：水平阴影的位置，必填，填写数值，可以为负值 v-shadow：垂直阴影的位置，必填，填写数值，可以为负值 blur：可选，模糊距离，填写数值 spread：可选，阴影的外延值，填写数值 color：可选，阴影的颜色，填写颜色代码 inset：可选，将外部阴影改为内部阴影，填写inset固定字符串 none：没有阴影（默认值） 语法： css1box-shadow: 水平位置 垂直位置 模糊距离 外延值 颜色 inset; 注意： 只有先设置blur属性，才能再设置spread属性，只存在spread属性会被当做blur属性。 2.4.4 不透明度常用属性： 属性名 作用 取值 opacity 添加透明效果 0到1之间的小数，0是完全透明，1表示完全不透明 2.5 新增背景属性2.5.1 背景尺寸常用属性： 属性名 作用 取值 background-size 设置背景的尺寸 用长度值指定背景图片宽高，不允许负值 用百分比指定背景图片宽高，不允许负值 auto：背景图片的真实大小（默认值） contain：将背景图片等比缩放，包含在容器内，保证背景在容器内完整显示 cover：将背景图片等比缩放，覆盖到容器内，保证容器内全都有背景显示 2.5.2 背景原点常用属性： 属性名 作用 取值 background-origin 设置背景的原点 padding-box：从padding区域开始显示背景图像（默认值） border-box：从border区域开始显示背景图像 content-box：从content区域开始显示背景图像 2.5.3 背景裁剪常用属性： 属性名 作用 取值 background-clip 设置背景的向外裁剪的区域 border-box：从border区域开始向外裁剪背景（默认值） padding-box：从padding区域开始向外裁剪背景 content-box：从content区域开始向外裁剪背景 text：只在文字上显示背景，前提是color属性值为transparent透明色 2.5.4 背景附着常用属性： 属性名 作用 取值 background-attachment 设置背景在视口内的附着方式，是否跟随页面的滚动条滚动，是否跟随元素的滚动条滚动 scroll：背景相对于元素固定，不跟随元素的滚动条滚动，会跟随页面的滚动条滚动（默认值） fixed：背景相对于视口固定，不跟随元素的滚动条滚动，不跟随页面的滚动条滚动 local：背景相对于元素内容固定，会跟随元素的滚动条滚动，会跟随页面的滚动条滚动 2.5.5 颜色渐变常用属性： 属性名 作用 取值 background-image 设置背景的渐变颜色 linear-gradient：线性渐变，沿直线渐变 radial-gradient：径向渐变，沿弧线渐变 repeating-linear-gradient：循环线性渐变，在没有发生渐变的位置，继续进行线性渐变 repeating-radial-gradient：循环径向渐变，在没有发生渐变的位置，继续进行径向渐变 示例： css12345678910111213141516171819202122/* 线性渐变，默认从上到下渐变 */background-image: linear-gradient(red,yellow,green);/* 线性渐变，使用关键词调整渐变方向 */background-image: linear-gradient(to right top,red,yellow,green);/* 线性渐变，使用角度调整渐变方向 */background-image: linear-gradient(30deg,red,yellow,green);/* 线性渐变，使用像素值调整渐变位置 */background-image: linear-gradient(red 50px,yellow 100px,green 150px);/* 径向渐变，默认从圆心四散 */background-image: radial-gradient(red,yellow,green);/* 径向渐变，使用关键词调整渐变圆心位置 */background-image: radial-gradient(at right top,red,yellow,green);/* 径向渐变，使用像素值调整渐变圆心位置 */background-image: radial-gradient(at 100px 50px,red,yellow,green);/* 径向渐变，使用关键字调整渐变形状为正圆 */background-image: radial-gradient(circle,red,yellow,green);/* 径向渐变，使用像素值调整渐变半径 */background-image: radial-gradient(50px 100px,red,yellow,green);/* 径向渐变，使用像素值调整渐变半径和渐变圆心位置 */background-image: radial-gradient(50px 100px at 100px 50px,red,yellow,green);/* 径向渐变，使用像素值调整渐变位置 */background-image: radial-gradient(red 50px,yellow 100px,green 150px); 2.5.6 复合属性常用属性： 属性名 作用 取值 background 设置背景复合属性 包含全部背景属性，空格分隔 语法： css1background: 颜色 图片地址 重复方式 定位 / 尺寸 原点 裁剪方式; 注意： 原点和裁剪方式的取值相同，如果只写一个值，则表示都设置，如果写了两个值，前面的是原点，后面的是裁剪方式。 尺寸必须写在定位的后面，并且用/分开。 2.5.7 多背景图CSS3允许元素设置多个背景图片。 示例： css1234background: url(images/bg-lt.png) no-repeat left top, url(images/bg-rt.png) no-repeat right top, url(images/bg-lb.png) no-repeat left bottom, url(images/bg-rb.png) no-repeat right bottom; 2.6 新增边框属性2.6.1 边框圆角常用属性： 属性名 作用 取值 border-radius 复合属性，将盒子边框的四个角变为圆角，通过设置半径控制圆角范围 长度值，支持分别设置四个角的不同半径 border-top-left-radius 设置左上角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-top-right-radius 设置右上角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-bottom-left-radius 设置左下角圆角半径 长度值，支持分别设置水平半径和垂直半径 border-bottom-right-radius 设置右下角圆角半径 长度值，支持分别设置水平半径和垂直半径 2.6.2 边框外轮廓常用属性： 属性名 作用 取值 outline-width 外轮廓的宽度 长度值 outline-color 外轮廓的宽度 颜色代码 outline-style 外轮廓的风格 none：无轮廓（默认值） dotted：点状轮廓 dashed：虚线轮廓 solid：实线轮廓 double：双线轮廓 outline-offset 设置外轮廓与边框的距离，正负值都可以设置 长度值 outline 复合属性 可以包含除outline-offset之外的其他样式，空格分隔 2.7 新增文本属性2.7.1 文本阴影常用属性： 属性名 作用 取值 text-shadow 给文本添加阴影 h-shadow：水平阴影的位置，必填，填写数值，可以为负值 v-shadow：垂直阴影的位置，必填，填写数值，可以为负值 blur：可选，模糊距离，填写数值 color：可选，阴影的颜色，填写颜色代码 none：没有阴影（默认值） 语法： css1box-shadow: 水平位置 垂直位置 模糊距离 颜色; 2.7.2 文本换行常用属性： 属性名 作用 取值 white-space 设置文本换行方式 normal：文本超出边界自动换行，文本中的换行被浏览器识别为一个空格（默认值） pre：原样输出，与pre元素的效果相同，超出元素边界不换行 pre-wrap：原样输出，超出元素边界自动换行 pre-line：原样输出，超出元素边界自动换行，只识别文本中的空格，首尾的空格会忽略 nowrap：强制不换行 2.7.3 文本溢出常用属性： 属性名 作用 取值 text-overflow 设置文本内容溢出时的呈现模式 clip：当内联内容溢出时，将溢出部分裁切掉（默认值） ellipsis：当内联内容溢出块容器时，将溢出部分替换为... 注意： 要使得text-overflow属性生效，块容器必须显式定义overflow属性值为非visible的其他值，同时设置white-space属性值为nowrap。 2.7.4 文本修饰常用属性： 属性名 作用 取值 text-decoration 复合属性，升级了文本修饰 包含其他样式，空格分隔 text-decoration-line 设置文本装饰线的位置 none：指定文字无装饰（默认值） underline：指定文字的装饰是下划线 overline：指定文字的装饰是上划线 line-through：指定文字的装饰是贯穿线 text-decoration-style 设置文本装饰线条的形状 solid：实线（默认） double：双线 dotted：点状线条 dashed：虚线 wavy：波浪线 text-decoration-color 设置文本装饰线条的颜色 颜色代码 2.7.5 文本描边常用属性： 属性名 作用 取值 -webkit-text-stroke-width 设置文字描边的宽度 长度值 -webkit-text-stroke-color 设置文字描边的颜色 颜色代码 -webkit-text-stroke 复合属性，设置文字描边宽度和颜色 包含其他样式，空格分隔 注意： 文字描边功能仅webkit内核浏览器支持。 2.8 新增字体属性2.8.1 基本用法可以通过@font-face指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了。 基础语法： css1234@font-face &#123; font-family: &quot;定制字体&quot;; src: url(&#x27;webfont.ttf&#x27;);&#125; 兼容语法： css12345678910@font-face &#123; font-family: &quot;定制字体&quot;; font-display: swap; src: url(&#x27;webfont.eot&#x27;); /* IE9 */ src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;webfont.woff2&#x27;) format(&#x27;woff2&#x27;), url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* Chrome, Firefox */ url(&#x27;webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* Chrome, Firefox, Opera, Safari, Android*/ url(&#x27;webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* IOS 4.1- */&#125; 2.8.2 定制字体中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制。 可使用阿里Web字体定制工具：阿里Web字体定制 2.8.3 字体图标好处： 相比图片更加清晰，因为字体图标是矢量图，不会在放大后失真。 灵活性高，更方便改变大小、颜色、风格等。 兼容性好，IE也能支持。 常用字体图标库： Font Awesome，优点是版权清晰，缺点是数量比较少，官网地址：Font Awesome 阿里图标，优点是数量多，种类多，缺点是版权不清晰，并且需要登录，官网地址：阿里图标官网 Font Awesome阿里图标Font Awesome字体图标使用步骤： 下载并解压。 将css和webfonts移动到项目中，css用于声明字体图标名称使用的字体，webfonts中包含了实现图标样式的字体文件。 将all.css引入到网页中：html1&lt;link rel=&quot;stylesheet&quot; href=&quot;./fa/css/all.css&quot;&gt; 使用图标字体。 Font Awesome字体图标使用方式： 方式一：在元素（通常是i元素）中使用class属性，通过样式和名称使用，样式支持简写：html12&lt;i class=&quot;fa-solid fa-car&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-car&quot;&gt;&lt;/i&gt; 方式二：通过CSS样式选择器选中元素后，通过伪元素设置编码和字体使用，支持颜色和外边距等其他样式：css1234567li::before&#123; content: &#x27;\\f1b9&#x27;; font-family: &#x27;Font Awesome 5 Free&#x27;; font-weight: 900; color: blue; margin-right: 10px;&#125; 方式三：还可以通过实体的方式使用，不过不太常用：html1&lt;div class=&quot;fas&quot;&gt;&amp;#xf1b9&lt;/div&gt; Font Awesome字体图标说明： 免费版的样式有solid和brands，分别代表实心图标和品牌图标，solid样式同类的高级样式还有regular等样式，不过这些高级样式是收费的。 solid样式对应Font Awesome 5 Free字体，brands对应Font Awesome 5 Brands字体。 名称和编码可以在官网查到，每个图标的名称和编码一般是不同的。 阿里图标使用方式： 方式一：下载到本地，参考下载后的说明文档使用即可，方法和Font Awesome类似，也有三种方式。 方式二：在线使用，引入阿里服务器上的文件，其他和下载到本地类似。 2.9 新增对象属性2.9.1 元素位置常用属性： 属性名 作用 取值 object-position 设置对象元素的原点 使用两个维度定位，空格分隔，有多种方式： 1. 使用关键字(水平 垂直)设置位置： 水平：left、center、right 垂直：top、center、bottom 如果只写一个值，另一个方向的值取center 2. 使用坐标(x y)设置图片左上角的位置，以元素左上角为坐标原点： 如果只写一个值，会被当做x坐标，y坐标取center 3. 使用边缘距离设置图片位置，必须有四个值，分为前后两组： 一组代表上下，另一组代表左右，顺序没有要求 每组第一个值代表方向，第二个值代表边距 2.5.3 元素裁剪常用属性： 属性名 作用 取值 object-fit 设置对象元素的向外裁剪的区域 fill：对象被填充，对象将被拉伸以适应内容框（默认值） contain：对象被包含，对象将被保持比例缩放以适应内容框，宽高比不匹配时被添加黑边 cover：对象被覆盖，对象将被保持比例缩放以适应内容框，宽高比不匹配时被裁剪 none：被替换的内容将保持其原有的尺寸 3 变形3.1 2D变形3.1.1 坐标系在学习2D变形和3D变形之前，需要先了解CSS中的坐标系。 原点： 默认在盒子的左上角，包括边框但不包括外边距。 中心： 默认在盒子的几何中心，即两条对角线的交点。 维度： 坐标原点的横向被看作X轴，正值在坐标原点往右，负值在坐标原点往左。 坐标原点的纵向被看作Y轴，正值在坐标原点往下，负值在坐标原点往上。 坐标原点垂直于屏幕的方向被看作Z轴，正值是从坐标原点向屏幕外的方向，负值是从坐标原点向屏幕里的方向。 注意： 因为行内元素不存在宽度和高度，所以2D和3D对行内元素无效。 在3D场景下，因为无法观察Z轴，元素也不存在厚度，所以看到的是元素从3D到2D的投影。 3.1.2 位移常用属性： 属性名 作用 取值 transform 改变元素的位置，参考坐标原点 translateX：设置X轴位移，支持指定长度值和百分比，百分比参考的是自身宽度 translateY：设置Y轴位移，支持指定长度值和百分比，百分比参考的是自身宽度 translate：一个值代表X轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css12transform: translateX(30px) translateY(40px);transform: translate(50%,50%); 和相对定位的比较： 位移与相对定位的相同：都不脱离文档流，不会影响到其它元素。 位移与相对定位的区别：位移的百分比值参考的是其自身，相对定位的百分比值参考的是其父元素。 浏览器针对位移有优化，处理位移的效率比相对定位更高。 位移配合定位，可实现子元素在父元素中同时水平居中和垂直居中。示例： css123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125; 3.1.3 缩放常用属性： 属性名 作用 取值 transform 改变元素的大小，参照中心默认是元素的中心 scaleX：设置X轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scaleY：设置Y轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scale：一个值代表X轴和Y轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css12transform: scaleX(50%) scaleY(50%);transform: scale(50%,50%); 注意： 支持负数，如果设为-1会将原来的元素镜像显示，但几乎不用，因为容易产生误解。 借助缩放，可实现小于12px的文字。 3.1.4 旋转常用属性： 属性名 作用 取值 transform 让元素发生旋转，参照中心默认是元素的中心 rotateZ：设置2D旋转的角度值，绕Z轴旋转，正值顺时针，负值逆时针 rotate：一个值代表2D旋转，正值顺时针，负值逆时针 示例： css12transform: rotateZ(30deg);transform: rotate(30deg); 3.1.5 扭曲常用属性： 属性名 作用 取值 transform 让元素发生拉扯变形 skewX：设置元素在X轴扭曲的角度值，不改变宽度，正值左上角向左同时右下角向右，负值左上角向右同时右下角向左 skewY：设置元素在Y轴扭曲的角度值，不改变高度，正值左上角向上同时右下角向下，负值左上角向下同时右下角向上 skew：一个值代表X轴和Y轴，两个值分别代表X轴和Y轴，逗号分隔 示例： css123transform: skewX(30deg);transform: skewY(30deg);transform: skew(30deg,30deg); 3.1.6 多重变形常用属性： 属性名 作用 取值 transform 复合属性，支持多种变形 包含其他样式，空格分隔 示例： css1transform: translate(50%,50%) scale(50%,50%) rotate(30deg) skew(30deg,30deg); 注意： 如果位移前有缩放，位移的距离需要乘以缩放的倍数，尽量将位移写在前面。 如果位移前有旋转，旋转的参照中心不会受位移影响，尽量将旋转写在后面。 3.1.7 变形原点常用属性： 属性名 作用 取值 transform-origin 设置变形的原点，对于缩放和旋转来说，改变的是参照中心 支持长度值、百分比、关键字，一个值跟类型有关，另一个取中间点，两个值分别代表X轴和Y轴，空格分隔 示例： css1transform-origin: left top; 注意： 变形原点对位移的影响是看不出来效果的，对缩放和旋转的影响是能看出来的，将设置的原点作为参照中心。 如果只设置了长度值或百分比，则表示X轴，Y轴取中间点，如果只设置了关键字，则根据关键字表示X轴或Y轴，另一个取中间点。 3.2 3D变形3.2.1 开启3D空间常用属性： 属性名 作用 取值 transform-style 开启3D空间，元素进行3D变形的前提是父元素开启3D空间 flat：让子元素位于此元素的二维平面内，即2D空间（默认值） preserve-3d：让子元素位于此元素的三维空间内，即3D空间 示例： css123.parent &#123; transform-style: preserve-3d;&#125; 3.2.2 设置景深景深指的是观察者与z=0平面的距离，能让发生3D变形的元素产生透视效果，让元素的投影看起来更加立体。 常用属性： 属性名 作用 取值 perspective 设置景深，需要给父元素设置 none：不指定透视（默认值） 长度值：指定观察者距离z=0平面的距离，负数会被认为是默认值none，最小值是0，趋近于0表示观察者贴近平面 示例： css123.parent &#123; perspective: 200px;&#125; 注意： 如果设置了X轴或Y轴的旋转，可以看到子元素投影受父元素景深的影响。 如果未设置X轴或Y轴的旋转，并且Z轴的位移等于0，相当于2D平面的子元素，不受父元素景深的影响。 如果未设置X轴或Y轴的旋转，并且Z轴的位移大于0，此时子元素在投影前面，随着景深的减少：3.1 当景深大于位移时，观察者贴近子元素，子元素投影变大。3.2 当景深等于或者小于位移时，观察者贴合子元素，子元素投影消失。3.3 当景深小于0时，取值无效，不指定景深，子元素投影相当于2D平面的子元素。 如果未设置X轴或Y轴的旋转，并且Z轴的位移小于0，此时子元素在投影后面，随着景深的减少：4.1 当景深大于0时，观察者贴近子元素，子元素投影变小。4.2 当景深等于0时，观察者贴合2D平面，子元素投影相当于2D平面的一个点。4.3 当景深小于0时，取值无效，不指定景深，子元素投影相当于2D平面的子元素。 3.2.3 设置透视点位置透视点位置就是观察者位置，默认的透视点在元素的中心。 常用属性： 属性名 作用 取值 perspective-origin 设置透视点位置，需要给父元素设置 支持长度值、百分比、关键字，一个值跟类型有关，另一个取中间点，两个值分别代表X轴和Y轴 示例： css123.parent &#123; perspective-origin: left top;&#125; 3.2.4 位移常用属性： 属性名 作用 取值 transform 在2D位移的基础上让元素沿Z轴位移，参考坐标原点 translateZ：设置Z轴位移，只支持长度值，正值向屏幕外，负值向屏幕里 translate3d：三个值分别代表X轴、Y轴、Z轴，逗号分隔，三个值必须同时设置，否则无效 示例： css12transform: translateZ(30px);transform: translate3d(50%,50%,30px); 注意： 在X轴和Y轴的设置支持长度值和百分比，在Z轴的设置只支持长度值，因为元素没有厚度的概念，无法通过百分比确定具体长度值。 只有在父元素的perspective属性值存在且大于0的情况下，才能设置Z轴的位移。 当Z轴的位移大于perspective属性值的时候，元素位移到了观察者后面，即观察者看不到元素。 3.2.5 缩放常用属性： 属性名 作用 取值 transform 在2D缩放的基础上让元素沿Z轴缩放，参考坐标原点 scaleZ：设置Z轴的缩放比例，1表示不缩放，大于1表示放大，小于1表示缩小 scale3d：三个值分别代表X轴、Y轴、Z轴，逗号分隔，三个值必须同时设置，否则无效 示例： css12transform: scaleZ(0.5);transform: scale3d(0.5,0.5,0.5); 注意： 在Z轴进行缩放，理论上是对元素的厚度进行缩放，但是元素没有厚度的概念，所以其实是让元素更贴近观察者，效果上类似调整景深。 在Z轴放大的效果，类似景深缩小相同倍数的效果，在Z轴缩小的效果，类似景深放大相同倍数的效果。 3.2.6 旋转常用属性： 属性名 作用 取值 transform 在2D旋转的基础上让元素沿X轴和Y轴旋转，参照中心默认是元素的中心 rotateX：设置X轴旋转的角度值，正值顺时针，负值逆时针 rotateY：设置Y轴旋转的角度值，正值顺时针，负值逆时针 rotate3d：前三个值分别代表X轴、Y轴、Z轴，第四个值代表旋转的角度，四个值必须同时设置，否则无效 示例： css12transform: rotateX(30deg) rotateY(30deg);transform: rotate3d(1,1,1,30deg); 注意： 通过rotate3d设置的前三个值描述的是坐标轴的矢量定义，取值是从0到1的矢量值。 即使rotate3d的前三个值超过1的数值，也会进行内部隐式标准化：比如rotate3d(9,9,9,30deg)相当于rotate3d(1,1,1,30deg)的效果。比如rotate3d(10,1,0.5,30deg)相当于rotate3d(1,0.1,0.05,30deg)的效果。 3.2.7 多重变形同2D多重变形类似，支持3D参数，建议将位移写前面同时将旋转写后面。 3.2.8 背部可见性将元素在X轴旋转或者Y轴旋转前显示的一面称为正面，将元素在X轴旋转或者Y轴旋转后显示的一面称为背面。 常用属性： 属性名 作用 取值 backface-visibility 设置元素背面在面向用户时是否可见 visible：设置元素背面可见，允许显示正面的镜像（默认值） hidden：设置元素背面不可见 示例： html123456&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;前面的图片在下层&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;后面的图片在上层&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; css1234567891011121314151617181920212223242526272829303132body &#123; perspective: 500px;&#125;.box &#123; position: relative; width: 300px; height: 300px; margin: 100px auto; transform-style: preserve-3d;&#125;.box:hover &#123; transform: rotate3d(0,1,0,180deg);&#125;.box&gt;div &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; text-align: center; line-height: 300px;&#125;.front &#123; background-color: pink;&#125;.back &#123; background-color: coral; /* 预先旋转显示下层元素 */ transform: rotateY(180deg); /* 给上层元素设置背面不可见 */ backface-visibility: hidden;&#125; 注意： 父元素作为盒子，两个子元素分别表示前面和后面，开启定位让两个子元素在同一位置，后面元素在前面元素上层，并且不会随父元素旋转而改变。 上层元素预先旋转：上层元素在父元素旋转前显示正面，上层元素在父元素旋转后显示背面。所以先将上层元素进行旋转显示背面，这样在父元素旋转后就能显示正面。 上层元素背面不可见：将上层元素进行旋转，并且上层元素的背面不可见后，显示下层元素的正面，父元素旋转后，上层元素显示正面，挡住了下层元素，所以下层元素背面是否可见是不影响的。 4 过渡过渡可以在不使用Flash动画，不使用JavaScript的情况下，让元素从一种样式平滑过渡为另一种样式。 常用属性： 属性名 作用 取值 transition-property 定义过渡的属性，只有定义的属性才会有过渡效果 none：不过渡任何属性 all：过渡所有能过渡的属性 属性名：逗号分隔的多个属性名 transition-duration 定义过渡的时间，完成过渡需要的时间，时间越长过渡越平滑 0：没有过渡时间，即不过渡（默认值） 单个时间：所有属性设置相同时间，单位是s或者ms，表示秒或者毫秒 多个时间：给不同的属性设置不同的时间，逗号分隔，过渡时间和过渡属性对应 transition-delay 定义过渡的延迟，触发过渡后多久开始过渡 单位是s或者ms，表示秒或者毫秒 transition-timing-function 定义过渡的类型 ease：平滑过渡（默认值） linear：线性过渡 ease-in：过渡由慢到快 ease-out：过渡由快到慢 ease-in-out：过渡由慢到快再到慢 steps(integer,?)：接受两个参数的步进函数 step-start：等同于steps(1,start) step-end：等同于steps(1,end) cubic-bezie(number,number,number,number)：特定的贝塞尔曲线类型 transition 复合属性，支持多种过渡 包含其他样式，空格分隔，如果时间只有一个，则表示过渡时间，如果时间有两个，则最后一个表示过渡延迟 注意： 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。 常见的支持过渡的属性有：颜色长度值百分比z-indexopacity2D变形属性3D变形属性阴影 步进函数： 第一个参数是正整数，指定函数的步数。 第二个参数是start或end，指定每一步的值发生变化的时间点，默认值为end。 贝塞尔曲线： 英文名是Bezier Curve，又称贝兹曲线或贝济埃曲线，可以通过二维坐标系描述曲线。 在线制作贝赛尔曲线：cubic-bezier 5 动画5.1 帧和关键帧一段动画，就是一段时间内连续播放多个画面，每一张画面称为一帧。同样时间内，播放的帧数越多，画面看起来越流畅。 关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的2-3帧，可以理解为和前后有明显差别的帧。 早期要求1秒内最低24帧，现在主流使用的是60帧，对延迟要求高的应用要求120帧或者更高。 5.2 基本使用5.2.1 定义动画定义动画实际上指的是定义一组关键帧，使用@keyframes设置动画名，可以定义多个动画名，但动画名不可以重复。 有两种方式： 简单方式定义：css12345678910@keyframes 动画名 &#123; from &#123; /*property1:value1*/ /*property2:value2*/ &#125; to &#123; /*property1:value1*/ /*property2:value2*/ &#125;&#125; 完整方式定义：css1234567891011121314151617181920@keyframes 动画名 &#123; 0% &#123; /*property1:value1*/ &#125; 20% &#123; /*property1:value1*/ &#125; 40% &#123; /*property1:value1*/ &#125; 60% &#123; /*property1:value1*/ &#125; 80% &#123; /*property1:value1*/ &#125; 100% &#123; /*property1:value1*/ &#125;&#125; 5.2.2 给元素应用动画常用属性： 属性名 作用 取值 animation-name 给元素指定具体的动画 动画名 animation-duration 设置动画所需时间 单位是s或者ms animation-delay 设置动画延迟 单位是s或者ms 示例： css12345678.box &#123; /* 指定动画 */ animation-name: testKey; /* 设置动画所需时间 */ animation-duration: 5s; /* 设置动画延迟 */ animation-delay: 0.5s;&#125; 5.3 动画的其他属性常用属性： 属性名 作用 取值 animation-timing-function 设置动画的类型 ease：平滑过渡（默认值） linear：线性过渡 ease-in：过渡由慢到快 ease-out：过渡由快到慢 ease-in-out：过渡由慢到快再到慢 steps(integer,?)：接受两个参数的步进函数 step-start：等同于steps(1,start) step-end：等同于steps(1,end) cubic-bezie(number,number,number,number)：特定的贝塞尔曲线类型 animation-iteration-count 设置动画的播放次数 数值：动画循环次数 infinite：无限循环 animation-direction 设置动画方向 normal：正常方向（默认） reverse：反方向运行 alternate：动画先正常运行再反方向运行，并持续交替运行，要求动画播放至少两次 alternate-reverse：动画先反运行再正方向运行，并持续交替运行，要求动画播放至少两次 animation-fill-mode 设置动画之外的状态 forwards：设置对象状态为动画结束时的状态，要求动画播放有限次数 backwards：设置对象状态为动画开始时的状态，要求动画播放有限次数 animation-play-state 设置动画的播放状态 running：运动（默认） paused：暂停 5.4 复合属性常用属性： 属性名 作用 取值 animation 设置动画复合属性 包含其他样式，空格分隔，如果时间只有一个，则表示动画时间，如果时间有两个，则最后一个表示动画延迟 注意： 设置动画的播放状态的animation-play-state属性一般单独使用，复合使用会导致动画重新播放。 和过渡的区别： 动画不需要事件触发，过渡需要触发。 过渡只有开始和结束两个关键帧，动画可以设置多个关键帧，可以进行更细力度的控制。 6 多列布局专门用于实现类似于报纸的布局。 分列数量相关属性： 属性名 作用 取值 column-count 指定列数 数值 column-width 指定列宽，自动计算列数 长度值 columns 同时指定列宽和列数，复合属性，取列数少的效果（不推荐使用） 包含列宽和列数，空格分隔 分列边框相关属性： 属性名 作用 取值 column-rule-style 设置列与列之间边框的风格 none：无（默认值） solid：实线 dashed：虚线 dotted：点线 double：双实线 column-rule-width 设置列与列之间边框的宽度 长度值 column-rule-color 设置列与列之间边框的颜色 颜色代码，默认黑色 column-rule 设置列与列之间边框，复合属性 包含边框样式，空格分隔 分列其他属性： 属性名 作用 取值 column-gap 设置列边距 长度值 column-span 设置是否跨列 none：不跨列（默认值） all：跨列 注意： 除了column-span属性要在跨列的元素上设置，其他属性都是在父元素上设置的。 7 弹性盒子7.1 简介2009年，W3C提出了一种新的盒子模型，即弹性盒子（Flexible Box），也称为伸缩盒模型，它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序、等等。 截止目前，除了在部分IE浏览器不支持，其他浏览器均已全部支持。 弹性盒子的出现，逐渐演变出了一套新的布局方案，即弹性布局，也称为Flex布局。 布局方式： 传统布局弹性布局传统模型布局分三种模型，并且这三种模型紧密联系： 流动模型（Flow）：默认的网页布局模式，块级元素宽度总是100%，并且自上而下垂直分布，行内元素在包含元素内从左到右水平分布。 浮动模型（Float）：当元素设置了float属性，就会依照浮动的位置进行特定的定位。 层模型（Layer）：当元素设置了position属性，就会依照定位类型进行特定的定位。 因此，传统模型布局主要基于传统盒子模型、display属性、float属性、position属性。弹性布局可以为盒状模型提供最大的灵活性，目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上。 7.2 弹性容器和弹性项目将元素的display属性设为flex或者设为inline-flex就可以将该元素变为弹性容器，其子元素（不包括后代元素）会变为弹性项目。 无论原来是哪种元素（块、行内块、行内），一旦成为了弹性项目，全都会块状化，如果没有设置宽度和高度，默认由内容撑开。 7.3 主轴与侧轴概念： 主轴：项目沿主轴排列，默认方向是水平从左到右。 侧轴：与主轴垂直的就是侧轴，默认方向是垂直从上到下。 主轴换行相关属性： 属性名 作用 取值 flex-direction 设置主轴方向，同时也会影响侧轴方向 row：主轴方向水平从左到右（默认值） row-reverse：主轴方向水平从右到左 column：主轴方向垂直从上到下 column-reverse：主轴方向垂直从下到上 flex-wrap 设置主轴换行方式 nowrap：主轴不换行，允许项目的高度超出容器，不允许项目的宽度超出容器，宽度超出时会压缩容器（默认值） wrap：主轴自动换行，允许项目的高度超出容器，不允许项目的宽度超出容器，宽度超出时会换行 wrap-reverse：主轴自动反转换行，每一行的项目还是从左到右，但是每行的项目是从下到上排列，向上超出容器 flex-flow 复合属性 包含方向和换行，空格分隔 水平对齐相关属性： 属性名 作用 取值 justify-content 设置主轴对齐方式，控制项目水平位置 flex-start：主轴起点对齐（默认值） flex-end：主轴终点对齐 center：水平居中对齐 space-between：主轴水平分散对齐，中间均匀分布，项目紧贴两端（最常用） space-around：中间均匀分布，项目到两端距离与项目之间距离的一半相同 space-evenly：中间均匀分布，项目到两端距离与项目之间距离相同 垂直对齐相关属性： 属性名 作用 取值 align-items 设置侧轴对齐方式，以单个项目作为控制目标，控制项目在单行的垂直位置 flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：垂直居中对齐 baseline：每行项目的第一行文字的基线对齐，后面的大字体项目会向上超出容器高度 stretch：如果项目设置了高度，按照起点对齐，如果项目没有设置高度，将占满整个容器的高度（默认值） align-content 设置侧轴对齐方式，以一行项目作为控制目标，控制一行项目在容器的垂直位置，设置换行后有效 flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：垂直居中对齐 space-between：侧轴垂直分散对齐，中间均匀分布，项目紧贴两端 space-around：中间均匀分布，项目到两端距离与项目之间距离的一半相同 space-evenly：中间均匀分布，项目到两端距离与项目之间距离相同 stretch：如果项目设置了高度，按照起点对齐，如果项目没有设置高度，将占满整个容器的高度（默认值） 垂直对齐显示逻辑： 对于设置换行但是没有超出容器的项目，将容器高度减去每行项目的最大高度，得到的剩余高度按照行数平均分开，和每行项目的最大高度一起作为行高。 使用align-items属性将每行最大高度和剩余平均高度作为行高，可以控制项目在行高里的垂直对齐，不能控制每行在容器里的垂直对齐。 使用align-content属性将每行最大高度作为行高，可以控制每行在容器里的垂直对齐，不能控制项目在行高里的垂直对齐。并且只有设置换行，该属性才会生效，即单行无效。 同时水平居中和垂直居中： 在父元素开启弹性布局后，在父元素中设置水平居中和垂直居中。示例：css123456.outer &#123; display: flex; justify-content: center; align-items: center; align-content: center;&#125; 在父元素开启弹性布局后，在子元素中设置外边距自动。示例：css123456789.outer &#123; display: flex; justify-content: center; align-items: center; align-content: center;&#125;.inner &#123; margin: auto;&#125; 7.4 基准长度常用属性： 属性名 作用 取值 flex-basis 设置项目主轴方向的基准长度，主轴横向会让宽度失效，主轴纵向会让高度失效 0：无（默认值） solid：实线 dashed：虚线 dotted：点线 其他长度值：指定长度 flex-grow 设置项目的放大权重，默认为0，即使主轴存在剩余空间，该项目也不放大，前提是主轴存在剩余空间，否则无效 放大权重 flex-shrink 设置项目的缩小权重，默认为1，如果空间不足，该项目将会缩小 缩小权重 flex 复合属性 包含上述属性按照顺序设置，空格分隔： 1. 不放大，缩小，默认基准（默认值）： flex: 0 1 auto; 简写：flex: 0 auto; 2. 不放大，不缩小，默认基准 flex: 0 0 auto; 简写：flex: none; 3. 放大，缩小，默认基准 flex: 1 1 auto; 简写：flex: auto; 4. 放大，缩小，最小长度： flex: 1 1 0px; 简写：flex: 1; 基准长度显示规则： 默认情况下，以内容作为宽度显示。 如果设置项目宽度，以项目宽度显示。 如果设置项目宽度，又设置基准长度，如果内容长度小于基准长度，以基准长度显示，如果内容长度大于基准长度，比较项目宽度和内容长度，以最小值显示。 按权重放大规则： 默认为0，表示不放大。 如果所有项目设置为1，计算公式：css1项目放大的长度=剩余长度×(1÷项目数量) 如果项目设置的不同，计算公式：css1项目放大的长度=剩余长度×(当前权重÷&#123;(每个项目权重)求和&#125;) 按权重缩小规则： 默认为1，表示如果项目长度超出，就按权重缩小项目长度，计算公式：css1项目缩小的长度=超出长度×[(1×项目长度)÷&#123;(1×每个项目长度)求和&#125;] 如果项目设置的不同，计算公式：css1项目缩小的长度=超出长度×[(当前权重×项目长度)÷&#123;(每个项目权重×每个项目长度)求和&#125;] 7.5 单独对齐常用属性： 属性名 作用 取值 align-self 设置单独项目的对齐方式 参考align-items属性，默认值为auto，表示继承父元素的align-items属性 7.6 项目排序常用属性： 属性名 作用 取值 order 设置项目的排列顺序，数值越小，排列越靠前，默认为0，支持负值 数值 8 BFCBFC，即块级格式化上下文（Block Formatting Context），可以理解为一种功能，当某些情况下元素满足条件时开启。 开启BFC的元素所具有的特点： 元素开启BFC后，其子元素不会再产生外边距塌陷问题。 元素开启BFC后，元素自身不会被其他浮动元素所覆盖。 元素开启BFC后，就算其子元素浮动，元素自身高度也不会塌陷。 开启BFC的方式： 根元素默认开启。 表格相关的元素默认开启。 行内块元素默认开启。 给块元素的overflow属性设置不为visible的值后自动开启。 将元素改为浮动元素后自动开启。 给元素设置绝对定位或固定定位，称为定位元素后自动开启。 弹性布局中的弹性项目自动开启。 多列布局中的多列容器自动开启。 多列布局中的多列项目，将元素的column-span属性的值设置为all后自动开启。 将元素的display属性的值设置为flow-root后自动开启。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"HTML5新特性","slug":"100-大前端/101-HTML/001-基础/003-HTML5新特性","date":"2024-04-14T14:19:20.000Z","updated":"2024-07-18T08:00:02.815Z","comments":true,"path":"posts/20240414/221920/","permalink":"https://momashanhe.com/posts/20240414/221920/","excerpt":"摘要：本文主要介绍了HTML5的一些新特性。","text":"摘要：本文主要介绍了HTML5的一些新特性。 1 简介HTML5是新一代的HTML标准，2014年10月由万维网联盟（W3C）完成标准制定。 HTML5在狭义上是指新一代的HTML标准，在广义上是指整个前端。 官网地址： W3C官网：https://www.w3.org/TR/html/index.html WHATWG官网：https://whatwg-cn.github.io/html/multipage 优势： 针对JavaScript新增了很多可操作的接口。 新增了一些布局元素和全局属性。 新增了多媒体元素，可以很好的替代Flash。 更加侧重语义化，对于SEO更友好。 可移植性好，可以大量应用在移动设备上。 2 新增元素2.1 新增布局元素新增的元素： 标签名 说明 单双 header 整个页面，或部分区域的头部 双标签 footer 整个页面，或部分区域的底部 双标签 nav 导航 双标签 article 文章 双标签 section 章节 双标签 aside 侧边栏 双标签 2.2 新增标量测量元素新增的元素： 标签名 说明 单双 meter 定义已知范围内的标量测量，也被称为尺度 双标签 常用属性： 属性名 作用 取值 high 规定高值 数值 low 规定低值 数值 max 规定最大值 数值 min 规定最小值 数值 optimum 规定最优值 数值 value 规定当前值 数值 2.3 新增进度显示元素新增的元素： 标签名 说明 单双 progress 显示某个任务完成的进度的指示器，一般用于表示进度条 双标签 常用属性： 属性名 作用 取值 max 规定目标值 数值 value 规定当前值 数值 2.4 新增列表元素新增的元素： 标签名 说明 单双 details 用于展示问题和答案，或对专有名词进行解释 双标签 summary 写在details元素的里面，用于指定问题或专有名词 双标签 2.5 新增文本元素新增的元素： 标签名 说明 单双 ruby 包裹需要注音的文字 双标签 rt 注音， 写在ruby元素里面 双标签 mark 标记文字，建议用于标记搜索结果中的关键字 双标签 3 表单功能增强3.1 新增通用属性新增属性： 属性名 作用 取值 placeholder 提示文字，适用于文字输入类的表单控件 文字 required 是否必填，适用于除按钮外其他表单控件，表单提交时会验证 无 autofocus 自动获取焦点，适用于所有表单控件，对焦点时首个有效 无 autocomplete 自动完成，适用于文字输入类的表单控件，密码输入框和多行输入框不可用 on：默认值，自动完成 off：不自动完成 pattern 填写正则表达式校验输入内容是否符合表达式，适用于文本输入类表单控件，往往与required属性配合 正则表达式 3.2 输入框类型增强input元素新增类型，对type属性新增的可选值： email：邮箱类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 url：URL类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 number：数字类型的输入框，表单提交时会验证格式，输入为空则不验证格式。 search：搜索类型的输入框，表单提交时不会验证格式。 tel：电话类型的输入框，表单提交时不会验证格式，在移动端使用时，会唤起数字键盘。 range：范围选择框，默认值为50，表单提交时不会验证格式。 color：颜色选择框，默认值为黑色，表单提交时不会验证格式。 date：日期选择框，默认值为空，表单提交时不会验证格式。 month：月份选择框，默认值为空，表单提交时不会验证格式。 week：周选择框，默认值为空，表单提交时不会验证格式。 time：时间选择框，默认值为空，表单提交时不会验证格式。 datetime-local：日期时间选择框，默认值为空，表单提交时不会验证格式。 3.3 新增表单属性form元素新增属性： 属性名 作用 取值 novalidate 表单提交的时候不再进行验证 无 3.4 新增下拉框元素下拉框增强，可以在输入框选择下拉选项。 新增的元素： 标签名 说明 单双 datalist 用于搜索框的关键字提示，类似select元素 双标签 需要配合input元素的list属性使用。示例： html123456789&lt;form action=&quot;#&quot;&gt; 请选择省份：&lt;input type=&quot;text&quot; list=&quot;province&quot;&gt; &lt;datalist id=&quot;province&quot;&gt; &lt;option value=&quot;黑&quot;&gt;黑龙江&lt;/option&gt; &lt;option value=&quot;辽&quot;&gt;辽宁&lt;/option&gt; &lt;option value=&quot;吉&quot;&gt;吉林&lt;/option&gt; &lt;option value=&quot;粤&quot;&gt;广东&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; 4 支持多媒体功能新增的元素： 标签名 说明 单双 audio 表示音频 双标签 video 表示视频 双标签 audio元素常用属性： 属性名 作用 取值 src 音频URL地址 URL地址 controls 向用户显示音频控件，比如播放和暂停按钮 无 muted 音频静音播放 无 autoplay 音频自动播放，媒体参与度超过阈值时才会有效 无 loop 音频循环播放 无 preload 音频预加载，如果使用了autoplay属性，则忽略该属性 none：不预加载音频 metadata：仅预先获取音频的元数据，例如长度 auto：可以下载整个音频文件，即使用户不希望使用它 video元素常用属性： 属性名 作用 取值 src 视频URL地址 URL地址 width 设置视频播放器的宽度 长度值 height 设置视频播放器的高度 长度值 controls 向用户显示视频控件，比如播放和暂停按钮 无 muted 视频静音播放 无 autoplay 视频自动播放，媒体参与度超过阈值时才会有效 无 loop 视频循环播放 无 poster 视频封面 URL地址 preload 视频预加载，如果使用了autoplay属性，则忽略该属性 none：不预加载视频 metadata：仅预先获取视频的元数据，例如长度 auto：可以下载整个视频文件，即使用户不希望使用它 媒体参与度： 启动autoplay属性并不能自动播放，还需要判断媒体参与度。 媒体参与度指的是用户和网页媒体的交互程度，媒体参与度超过阈值以后，才会在启动autoplay属性的前提下激活自动播放。 媒体参与度查询网址： 媒体参与度查询 5 新增全局属性新增属性： 属性名 作用 取值 contenteditable 表示元素是否可被用户编辑 true：可编辑 false：不可编辑 draggable 表示元素可以被拖动 true：可拖动 false：不可拖动 hidden 隐藏元素 无 spellcheck 规定是否对元素进行拼写和语法检查 true：检查 false：不检查 contextmenu 规定元素的上下文菜单，在用户鼠标右键点击元素时显示 无 data-* 用于存储页面的私有定制数据 定制数据 6 兼容性处理添加元信息，让浏览器处于最优渲染模式： html1234&lt;!-- 设置IE总是使用最新的文档模式进行渲染 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;&lt;!-- 优先使用webkit内核（Chromium）进行渲染，针对360等壳浏览器 --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 使用html5shiv.js让低版本浏览器认识H5元素，但某些元素仍然不能被低版本浏览器识别： html123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;../sources/js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 扩展： lt：小于 lte：小于等于 gt：大于 gte：大于等于 !：逻辑非 示例： html123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]--&gt;&lt;!--[if lt IE 8]&gt;仅IE8以下可见&lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]--&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"}]},{"title":"缩放导致元素尺寸错乱","slug":"100-大前端/102-CSS/002-技巧/002-缩放导致元素尺寸错乱","date":"2024-04-07T03:47:39.000Z","updated":"2024-04-07T03:47:51.044Z","comments":true,"path":"posts/20240407/114739/","permalink":"https://momashanhe.com/posts/20240407/114739/","excerpt":"摘要：","text":"摘要： https://blog.csdn.net/O3O_O3O_/article/details/121255024","categories":[],"tags":[]},{"title":"Emmet语法规则","slug":"100-大前端/102-CSS/002-技巧/001-Emmet语法规则","date":"2024-04-07T02:47:45.000Z","updated":"2024-04-07T02:47:45.459Z","comments":true,"path":"posts/20240407/104745/","permalink":"https://momashanhe.com/posts/20240407/104745/","excerpt":"摘要：","text":"摘要：","categories":[],"tags":[]},{"title":"CSS2进阶","slug":"100-大前端/102-CSS/001-基础/002-CSS2进阶","date":"2024-04-05T06:24:36.000Z","updated":"2024-05-21T07:03:08.337Z","comments":true,"path":"posts/20240405/142436/","permalink":"https://momashanhe.com/posts/20240405/142436/","excerpt":"摘要：本文主要介绍了CSS的盒子模型。","text":"摘要：本文主要介绍了CSS的盒子模型。 1 长度单位CSS中主要有以下几种长度单位： px：像素 em：元素字体大小的倍数 %：父元素对应属性的百分比 CSS中设置长度，必须加单位，否则样式无效。 2 显示模式2.1 分类2.1.1 块级元素又称为块元素（block）。 特点： 在页面中独占一行，不会与任何元素共用一行，从上到下排列。 默认宽度：撑满父元素。 默认高度：由内容撑开。 可以通过CSS设置宽高。 相关元素： 主体结构元素：html、body 排版相关元素：h1~h6、div、hr、p、pre、div 列表相关元素：ul、ol、li、dl、dt、dd 表格相关元素：table、tbody、thead、tfoot、caption、tr 表单相关元素：form、option 2.1.2 行内元素又称为内联元素（inline）。 特点: 在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 默认宽度：由内容撑开。 默认高度：由内容撑开。 无法通过CSS设置宽高。 相关元素： 文本：br、span、em、strong、sup、sub、del、ins 标记：label 超链接：a 2.1.3 行内块元素又称为内联块元素（inline-block）。 特点： 在页面中不独占一行，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。 默认宽度：由内容撑开。 默认高度：由内容撑开。 可以通过CSS设置宽高。 相关元素： 图片：img 表格：th、td 表单：input、textarea、select、button 框架：iframe 如果按照“是否独占一行”进行分类，行内块元素应该算作行内元素。 2.2 设置显示模式常用属性： 属性名 作用 取值 display 控制元素的显示模式 none：元素会被隐藏 block：元素将作为块级元素显示 inline：元素将作为内联元素显示 inline-block：元素将作为行内块元素显示 示例： css1display: none; 3 盒子模型3.1 概念CSS会把所有的HTML元素都看成一个盒子，所有的样式也都是基于这个盒子。 相关概念： content（内容）：盒子内容，也就是元素内容。 padding（内边距）：盒子内部边距，盒子内容与盒子边框的补白区域。 border（边框）：盒子边框，分隔盒子的内外区域。 margin（外边距）：盒子外部边距，盒子边框与其他盒子的间隔区域。 说明： 盒子的大小&#x3D;内容的大小+内边距的大小+边框的大小。 盒子的外边距不受盒子样式的影响，不会影响盒子的大小，只会影响盒子的位置。 图示如下： 3.2 相关属性3.2.1 盒子内容相关常用属性： 属性名 作用 取值 width 设置内容区域宽度 长度值 max-width 设置内容区域的最大宽度，一般不与width一起使用 长度值 min-width 设置内容区域的最小宽度，一般不与width一起使用 长度值 height 设置内容区域高度 长度值 max-height 设置内容区域的最大高度，一般不与height一起使用 长度值 min-height 设置内容区域的最小高度，一般不与height一起使用 长度值 如果没有设置宽度和高度： 总宽度&#x3D;父盒子content-自身左右margin 内容宽度&#x3D;父盒子content-自身左右margin-自身左右border-自身左右padding 总高度&#x3D;父盒子content-自身上下margin 内容高度&#x3D;父盒子content-自身上下margin-自身上下border-自身上下padding 示例： css12width: 100px;height: 500px; 3.2.2 盒子内边距相关常用属性： 属性名 作用 取值 padding-top 设置上内边距 长度值 padding-right 设置右内边距 长度值 padding-bottom 设置下内边距 长度值 padding-left 设置左内边距 长度值 padding 复合属性 顺时针设置内边距，空格分隔： 1. 四个方向内边距相同： padding: 长度; 2. 上下内边距相同，左右内边距相同： padding: 上下长度 左右长度; 3. 上内边距，左右内边距相同，下内边距： padding: 上长度 左右长度 下长度; 4. 上内边距，右内边距，下内边距，左内边距： padding: 上长度 右长度 下长度 左长度; 说明： 值不能为负数。 行内元素的左右内边距是没问题的，上下内边距不能完美的设置。 示例： css1padding: 10px; 3.2.3 盒子边框相关常用属性： 属性名 作用 取值 border-style 设置边框风格，复合四个方向 none：无（默认值） solid：实线 dashed：虚线 dotted：点线 double：双实线 border-width 设置边框宽度，复合四个方向 长度值，默认3px border-color 设置边框颜色，复合四个方向 颜色代码，默认黑色 border 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 上述的每个属性都能在四个方向上的边框单独设置。 3.2.4 盒子外边距相关常用属性： 属性名 作用 取值 margin-top 设置上外边距 长度值 margin-right 设置右外边距 长度值 margin-bottom 设置下外边距 长度值 margin-left 设置左外边距 长度值 margin 复合属性 顺时针设置外边距，空格分隔： 1. 四个方向外边距相同： margin: 长度; 2. 上下外边距相同，左右外边距相同： margin: 上下长度 左右长度; 3. 上外边距，左右外边距相同，下外边距： margin: 上长度 左右长度 下长度; 4. 上外边距，右外边距，下外边距，左外边距： margin: 上长度 右长度 下长度 左长度; 说明： 行内元素的左右外边距是没问题的，上下外边距不能设置。 上左影响自己的位置，下右影响后面兄弟元素的位置。 值可以为负数，负值允许其他元素进入到元素内部。 值可以设为auto，给块级元素的左右设为auto会让元素水平居中。 示例： css1margin: 10px; 3.3 技巧3.3.1 外边距问题3.3.1.1 外边距塌陷在设置外边距时，第一个子元素的上外边距会作用在父元素上，最后一个子元素的下外边距会作用在父元素上。 问题原因： 历史遗留问题，可以看作早期CSS故意这么处理的。 解决办法： 方案一：给父元素的padding属性设为非0的数字。 方案二：给父元素的border属性设为非0的数字。 方案三（推荐）：把父元素的overflow属性设为hidden。 3.3.1.2 外边距合并上面兄弟元素的下外边距和下面兄弟元素的上外边距会合并，取一个最大的值，而不是相加。 这种是正常的，可以把元素外边距设为期望的总和。 3.3.2 内容溢出文本内容过长超出父元素设置的高度会产生纵向内容溢出，子元素宽度过长超出父元素设置的宽度会产生横线内容溢出。 常用属性： 属性名 作用 取值 overflow 设置内容溢出的处理方式 visible：显示（默认值） hidden：隐藏（常用） scroll：显示滚动条，不论内容是否溢出 auto：自动显示滚动条，内容不溢出不显示（常用） 示例： css1overflow: auto; 3.3.3 隐藏元素常用属性： 属性名 作用 取值 visibility 设置元素的可见性 show：元素会被显示（默认值） hidden：元素会被隐藏，会保留占位 display 控制元素的显示模式 none：元素会被隐藏，不保留占位 block：元素将作为块级元素显示 inline：元素将作为内联元素显示 inline-block：元素将作为行内块元素显示 示例： css1display: none; 3.3.4 继承样式元素会自动拥有祖先元素设置的某些样式，并且关系近的优先级高。 可以继承的属性，都是不影响布局的，即都是和盒子模型没关系的。 3.3.5 居中布局让子元素在父元素中水平居中： 子元素为块级元素。给子元素设置：css1margin: auto; 子元素为行内元素和行内块元素。给父元素设置：css1text-align: center; 让子元素在父元素中垂直居中： 子元素为块级元素。给子元素设置：css1margin-top: (父元素盒子内容高度-子元素盒子高度)/2; 子元素为行内元素和行内块元素2.1 给父元素设置：css1line-height: 父元素盒子内容高度; 2.2 当子元素字体大小不同时，字体小的子元素会靠下，需要让子元素使用中线对齐，给子元素设置：css1vertical-align: middle; 2.3 父元素字体越大子元素越靠下，需要清除父元素字体的影响，给父元素设置：css1font-size: 0px; 3.3.6 消除空白3.3.6.1 消除换行空白行内元素和行内块元素之间的换行会被浏览器解析为一个空白字符。 解决办法： 方案一：去掉换行和空格。 方案二（推荐）：把父元素字体大小设为0，再给子元素单独设置字体大小。 3.3.6.2 消除基线空白子元素与基线对齐，而基线与盒子底部之间是有一定距离的。 解决办法： 方案一（推荐）：把子元素的vertical-align属性设为除了baseline以外的其他值，比如top、middel、bottom均可。 方案二：若子元素只有一个，设置子元素的display属性为block，将子元素转为块级元素。 方案三：把父元素字体大小设为0，清除父元素字体的影响，再给子元素单独设置字体大小。 4 浮动4.1 介绍浮动最初是用来实现文字环绕图片效果的，现在是主流的页面布局方式之一。 元素浮动的特点： 会脱离文档流。 不管浮动前是什么元素，浮动后默认宽高都是尽可能小的被内容撑开，而且可以设置宽高。 不会独占一行，可以与其他元素共用一行。 不会产生外边距问题，能够完美的设置四个方向的外边距和内边距。 不会有空白问题。 4.2 影响浮动产生的影响： 对父元素的影响：不能撑起父元素的高度，导致父元素高度塌陷，但是父元素的宽度依然束缚浮动元素。 对兄弟元素的影响：不浮动的兄弟元素会占据浮动元素之前的位置，而且是在浮动元素的下层。 解决浮动的影响： 方案一：给父元素指定高度，不能解决对兄弟元素的影响。 方案二：给父元素也设置浮动，不能解决对兄弟元素的影响。 方案三：给父元素的overflow属性设置为hidden，不能解决对兄弟元素的影响。 方案四（推荐）：如果不是全都浮动，给不浮动的兄弟元素的clear属性设为both，清除浮动效果，解决浮动产生的全部影响。 方案五：如果全都浮动，在最后添加不浮动的块级元素，给不浮动的块级元素的clear属性设为both，原理与方案四相同。 方案六（推荐）：如果全都浮动，给父元素设置伪元素，通过伪元素清除浮动，原理与方案四相同：css12345父元素::after &#123; content: &quot;&quot;; display: block; clear: both;&#125; 4.3 属性常用属性： 属性名 作用 取值 float 设置元素的浮动方式 left：设置左浮动 right：设置右浮动 none：不浮动（默认值） clear 控制元素的显示模式 left：清除前面左浮动的影响 right：清除前面右浮动的影响 both：清除前面左右浮动的影响 5 定位5.1 属性设置定位方式。常用属性： 属性名 作用 取值 position 设置元素的定位方式 static：不开启定位（默认值） relative：开启相对定位 absolute：开启绝对定位 fixed：开启固定定位 sticky：开启粘性定位 开启定位后可以调整元素位置。常用属性： 属性名 作用 取值 left 调整到左侧边缘的距离 长度值 right 调整到右侧边缘的距离，不能和left同时使用 长度值 top 调整到顶部边缘的距离 长度值 bottom 调整到底部边缘的距离，不能和top同时使用 长度值 5.2 分类5.2.1 相对定位参考元素： 基于原来的位置，即基于正常定位的位置进行调整的。 效果： 只设为相对定位，不设置位置，无变化。 设置位置后，根据层级进行元素覆盖。 特点： 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。 不建议和float属性同时使用。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为相对定位之后，不会变成定位元素（宽度和高度由内容决定，可以自由设置）。 5.2.2 绝对定位参考元素： 基于包含块。如果没有脱离文档流，包含块就是父元素，如果脱离文档流，包含块就是最近开启任何定位的祖先元素。 效果： 只设为绝对定位，不设置位置，元素在绝对定位前的位置浮动，后面的元素占用绝对定位前的位置并且被元素覆盖。 设置位置后，根据包含块进行元素覆盖。 特点： 会脱离文档流，会对后面的兄弟元素有影响，会对父元素有影响。 不建议和float属性同时使用，浮动会失效，以绝对定位为主。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为绝对定位之后，都会变成定位元素（宽度和高度由内容决定，可以自由设置）。 使用规则： 在父元素上开启相对定位，在对其他元素没有影响的情况下，支持作为子元素的包含块。 在子元素上开启绝对定位，在包含块为父元素的前提下修改位置。 和浮动的区别： 绝对定位的元素内容会被覆盖，不能环绕元素。 绝对定位的元素会变成定位元素。 绝对定位的元素一般会配合相对定位的包含块一起使用。 5.2.3 固定定位参考元素： 基于视口。对于PC浏览器来说，视口就是浏览器展示内容的界面。 效果： 只设为固定定位，不设置位置，元素在固定定位前的位置浮动，后面的元素占用固定定位前的位置并且被元素覆盖。 设置位置后，根据视口进行元素覆盖，并且页面内容滚动时，固定定位固定在视口相对位置，不随页面内容滚动。 特点： 会脱离文档流，会对后面的兄弟元素有影响，会对父元素有影响。 不建议和float属性同时使用，浮动会失效，以固定定位为主。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为固定定位之后，都会变成定位元素（宽度和高度由内容决定，可以自由设置）。 和绝对定位的区别： 固定定位不使用包含块，不需要父元素配合，不需要和相对定位配合。 固定定位保持在视口显示，不会跟随内容移动而消失。 5.2.4 粘性定位参考元素： 基于滚动元素。根据关系最近的具有滚动机制的祖先元素，即祖先元素必须有滚动条，最远的是body元素。 效果： 只设为粘性定位，不设置位置，无变化。 设置位置后，根据滚动元素进行元素覆盖，并且页面内容滚动时，粘性定位固定在滚动元素相对位置，不随页面内容滚动。 当滚动元素和父元素同时在页面显示时，粘性定位显示，否则粘性定位消失，多个粘性定位会进行元素覆盖。 特点： 不会脱离文档流，是一种专门用于窗口滚动时的新的定位方式。 不建议和float属性同时使用。 不建议和margin属性同时使用。 元素（行内元素、行内块元素、块级元素）在设置为粘性定位之后，不会变成定位元素（宽度和高度由内容决定，可以自由设置）。 滚动机制： 设置元素的高度小于元素内容的高度，继续将元素的overflow属性设为scroll或者auto，就能在元素上显示滚动条。 5.3 层级元素的显示层级： 开启定位的元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况下，后面的元素会覆盖前面的元素。 如果元素被显示层级低的元素覆盖了，可能是因为包含块的显示层级低被其他元素覆盖，导致元素和包含块一起被覆盖。 常用属性： 属性名 作用 取值 z-index 调整元素的显示层级，开启定位的元素有效 无单位的数字，值越大显示层级越高 5.4 定位元素的特殊应用定位元素的宽度和高度由内容决定，不再充满包含块，由此会带来一些问题。 成为定位元素的两种方式： 方式一：元素使用固定定位成为定位元素。 方式二：父元素使用相对定位，元素使用绝对定位成为定位元素。 5.4.1 让定位元素充满包含块在定位元素没有设置宽度和高度的前提下，让定位元素在包含块居中，有以下两种方案： 方案一：计算充满所需要的宽度和高度。 方案二（推荐）：给定位元素的用于调整定位的属性设置为0：css1234top: 0;right: 0;bottom: 0;left: 0; 5.4.2 让定位元素在包含块居中在定位元素设置宽度和高度的前提下，让定位元素在包含块居中，有以下两种方案： 方案一：设置左右外边距为auto，计算上外边距长度。 方案二：使用折半的方式设置：css1234left: 50%;top: 50%;margin-left: 元素宽度一半的负数;margin-top: 元素高度一半的负数; 方案三（推荐）：将用于调整定位的属性设置为0，同时设置外边距为auto：css12345top: 0;right: 0;bottom: 0;left: 0;margin: auto; 6 布局6.1 版心在PC端网页中，一般都会有一个固定宽度且水平居中的盒子，来显示网页的主要内容，这是网页的版心。 版心的宽度一般是960像素到1200像素之间。 版心可以是一个，也可以是多个。 6.2 布局名词常用布局名词： 版心：container 顶部导航条：topbar 页头：header、page-header 导航：nav、navigator、navbar 搜索框：search、search-box 横幅：banner 主要内容：content、main 侧边栏：aside、sidebar 页脚：footer、page-footer 6.3 重置默认样式在早期元素默认样式能够快速的绘制网页，但如今网页的设计越来越复杂，这些默认样式会在绘制页面时带来麻烦，而且这些默认样式在不同的浏览器上呈现出来的效果也不一样，所以需要重置这些默认样式。 6.3.1 全局选择器示例： css1234* &#123; margin: 0; padding: 0;&#125; 此种方法在测试时可以用，但实际开发中不会使用，因为在重置样式时，需要对特定元素进行重做，并不是清除所有样式。 6.3.2 重置样式文件将对默认样式的修改写入单独的reset.css文件，在页面中引入默认的CSS文件。 6.3.3 Normalize.cssNormalize.css也是CSS文件，它对默认样式提供了跨浏览器的高度一致性，相比传统的重置样式文件，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 使用方式和重置样式文件一样，需要先在官网下载最新的CSS文件，在页面中引入即可。 官网：http://necolas.github.io/normalize.css/ 相对于重置样式文件来说，重置样式文件侧重于清除样式，Normalize.css侧重于统一样式，有如下优点： 保护了有价值的默认样式，而不是完全去掉它们。 为大部分HTML元素提供高度一致的样式。 新增对HTML5元素的设置。 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"CSS2入门","slug":"100-大前端/102-CSS/001-基础/001-CSS2入门","date":"2024-04-02T06:49:27.000Z","updated":"2024-08-12T09:25:38.889Z","comments":true,"path":"posts/20240402/144927/","permalink":"https://momashanhe.com/posts/20240402/144927/","excerpt":"摘要：本文主要介绍了CSS的语法规则和选择器，以及CSS常用的一些属性。","text":"摘要：本文主要介绍了CSS的语法规则和选择器，以及CSS常用的一些属性。 1 简介CSS全称：Cascading Style Sheets（层叠样式表）。 CSS也是一种标记语言，用于给网页设置样式，比如文字大小、颜色、元素宽高等等。 官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn 2 语法规范2.1 基本语法CSS的语法为： css1234选择器 &#123; 属性名: 属性值; 属性名: 属性值;&#125; 主要由两部分组成： 选择器：匹配要添加样式的元素。 声明块：给匹配到的元素设置具体的样式，声明块由多个声明组成，并使用&#123;&#125;包裹，声明由属性名和属性值组成。 说明： 选择器和声明块之间，声明的属性名和属性值之间，均有一个可以省略的空格，建议不要省略，提高可读性。 声明使用;分号结尾，最后一个声明可以省略，建议不要省略，提高可读性。 2.2 注释CSS中注释的语法为： css1/* 注释内容 */ 2.3 代码风格展开风格，开发时使用，可读性高： css123span &#123; color: red;&#125; 紧凑风格，上线时使用，文件体积小： css1span&#123;color:red;&#125; 在上线时可以使用工具将展开风格转为紧凑风格。 2.4 编写位置2.4.1 行内样式行内样式又称为内联样式，写在元素的style属性中。 示例： hello.html1&lt;p&gt;欢迎学习&lt;span style=&quot;color: red;&quot;&gt;前端&lt;/span&gt;知识&lt;/p&gt; 这种方式编写的CSS没有和HTML分离，不能体现出结构和样式分离的思想，而且样式不能复用，不建议使用这种方式。 2.4.2 内部样式将CSS提取出来，写在页面内部的style元素中。 示例： hello.html12345&lt;style&gt;span &#123; color: red;&#125;&lt;/style&gt; 理论上可以将style元素放在页面的任何位置，建议放到head元素中。 和行内样式相比，这种方式编写的结构和样式分离，样式也能复用，但也没有做到完全分离，并且样式不能在多个页面复用。 2.4.3 外部样式将CSS进一步提取，写在单独的CSS文件中，在HTML页面中使用元素引用外部的CSS文件。 相关的元素： 标签名 说明 单双 link 表示引用文件 单标签 常用属性： 属性名 作用 取值 rel 引用文件和当前文件的关系 目前用到的关系： stylesheet：引用的是样式表 href 引用文件位置 位置 创建CSS文件，后缀为.css格式。示例： hello.css123span &#123; color: red;&#125; 在HTML页面引用CSS文件。示例： hello.html1&lt;link rel=&quot;stylesheet&quot; href=&quot;./hello.css&quot;&gt; 这种方式可维护高，并且做到了结构和样式分离，也能被其他页面复用，建议使用这种方式。 2.5 优先级三种方式的优先级：行内样式 &gt; 内部样式 &#x3D; 外部样式 行内样式的优先级最高，内部样式和外部样式的优先级和位置有关，后面的样式会覆盖前面的样式。 三种方式比较： 方式 优点 缺点 使用频率 作用范围 行内样式 优先级高 结构和样式未分离样式不能复用 低 当前元素 内部样式 结构和样式分离样式可以在当前页面复用 结构和样式未彻底分离样式不能在多个页面复用 中 当前页面 外部样式 结构和样式彻底分离样式可以在多个页面复用能够触发浏览器缓存机制 需要引入才能使用 低 多个页面 2.6 书写顺序为了便于阅读和维护，提升浏览器的渲染性能，建议遵从以下顺序书写： 优先级第一的是定位属性：display visibility box-sizing position top&#x2F;left&#x2F;bottom&#x2F;right transform float clear z-index flex-xxx order 优先级第二的是自身属性：width&#x2F;height&#x2F;line-height overflow padding margin background border 优先级第三的是文字样式：font-family font-size font-style font-weight color 优先级第四的是文本属性：text-align vertical-align text-wrap text-indent text-decoration letter-spacing word-spacing white-space text-overflow 优先级第五的是CSS3中新增属性：content box-shadow border-radius transition 3 选择器3.1 基本选择器基本选择器： 通配选择器 元素选择器 属性选择器 类选择器 ID选择器 其他选择器可以参考文档：MDN官方CSS文档 3.1.1 通配选择器匹配所有元素。 语法： css123* &#123; 声明块&#125; 3.1.2 元素选择器匹配元素的标签名和选择器的标签名相同的所有元素。 语法： css123标签名 &#123; 声明块&#125; 3.1.3 类选择器匹配元素的class属性值和选择器的类名相同的所有元素。 语法： css123.类名 &#123; 声明块&#125; 说明： 在类名前增加.符号，表示这是类选择器，用来和其他选择器区分。 一个元素中的class属性最多只有一个，属性值可以有多个，空格分隔。 class属性值不是唯一的，不同的元素可以有相同的属性值。 class属性值按照标准，建议使用英文和数字的组合，并且使用英文开头，多个单词之间使用-短横线和_下划线连接，注意区分大小写。 3.1.4 ID选择器匹配元素的id属性值和选择器的id属性值相同的所有元素。 语法： css123#id值 &#123; 声明块&#125; 说明： 在id值前增加.符号，表示这是ID选择器，用来和其他选择器区分。 一个元素中的id属性最多只有一个，属性值只能有一个。 id属性值是唯一的，不同的元素不能有相同的属性值。 id属性值按照标准，建议使用英文和数字的组合，并且使用英文开头，多个单词之间使用-短横线和_下划线连接，注意区分大小写。 3.1.5 属性选择器匹配元素的属性及属性值和选择器指定的属性及属性值相同的所有元素。 属性选择器可以对元素的所有属性进行匹配，可以实现类选择器和ID选择器的效果。 属性选择器的语法较为复杂，使用[]包裹来区分其他选择器： css12345678910111213141516171819202122232425262728/* 选择具有指定属性名的元素，对属性值没有要求 */[属性名] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是指定属性值的元素 */[属性名=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是以指定属性值开头的元素 */[属性名^=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是以指定属性值结尾的元素 */[属性名$=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值包含指定属性值的元素 */[属性名*=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是用空格分隔的列表，存在指定属性值的列表项的元素 */[属性名~=属性值] &#123; 声明块&#125;/* 选择具有指定属性名的元素，并且属性值是指定属性值的元素或者属性值是以指定属性值拼接&quot;-&quot;开头的元素 */[属性名|=属性值] &#123; 声明块&#125; 说明： 选择器中的属性名不需要&quot;双引号包裹，但是属性值需要&quot;双引号包裹。 3.2 复合选择器复合选择器建立在基本选择器之上，由多个基础选择器，通过不同的方式组合而成。 主要有： 并集选择器 交集选择器 后代选择器 子代选择器 兄弟选择器 伪类选择器 伪元素选择器 3.2.1 并集选择器选择满足任何一个选择器的元素。 语法： css1234基础选择器1,基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用,逗号分隔，建议多个选择器换行编写，提高可读性。 3.2.2 交集选择器选择满足所有选择器的元素。 语法： css123基础选择器1基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器相邻，中间不能有任何符号，也不能有空格和换行。 因为没有任何符号分隔，所以如果有元素选择器的话，需要将其放在首位，否则会被识别为其他选择器的一部分。 3.3 关系选择器3.3.1 后代选择器选择满足后一个选择器是前一个选择器的后代的元素。 语法： css123基础选择器1 基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用空格分隔，子代也属于后代。 3.3.2 子代选择器选择满足后一个选择器是前一个选择器的子代的元素。 语法： css123基础选择器1&gt;基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用&gt;大于号分隔。 3.3.3 兄弟选择器3.3.3.1 相邻兄弟选择器选择满足后一个选择器是前一个选择器下方的相邻兄弟的元素。 语法： css123基础选择器1+基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用+加号分隔。 选择器匹配的元素之间必须是兄弟关系，必须相邻，除了空格和换行，没有其他代码。 可以匹配到多个元素，每个选择器匹配的元素的相邻兄弟元素只有一个。 3.3.3.2 通用兄弟选择器选择满足后一个选择器是前一个选择器下方的所有兄弟的元素。 语法： css123基础选择器1~基础选择器2 &#123; 声明块&#125; 说明： 不同的选择器使用~加号分隔。 选择器匹配的元素之间必须是兄弟关系，可以有其他代码。 可以匹配到多个元素，每个选择器匹配的元素的兄弟元素可以有多个。 3.4 高级选择器3.4.1 伪类选择器说明：CSS3新增功能。 3.4.1.1 伪类普通的元素，如果处于某种特殊状态下，把这种处于特殊状态下的元素称为伪类。 伪类选择器固定以:冒号开头。 3.4.1.2 动态伪类匹配需要用户手动操作才会出现的元素： 使用:link选择未被访问的元素，多用于超链接。 使用:visited选择被访问后的元素，多用于超链接。 使用:hover选择被鼠标悬停的元素。 使用:focus选择获取焦点时的元素，多用于表单元素。 使用:active选择被鼠标按住的元素。 说明： 在使用:link和:visited匹配超链接时，匹配到的是具有href属性的超链接，因为这种超链接才具有访问的功能。 在使用:focus匹配元素时，需要元素拥有获取焦点的功能，否则无效。 如果元素同时存在多个伪类选择器那么后面的样式会替换前面的样式，所以需要按照l-v-h-f-a的顺序，将规则宽松的放前面，将规则严格的放后面。 3.4.1.3 结构伪类匹配在页面结构上处于特殊顺序的元素： 使用:first-child选择元素的父元素的所有子元素中的第一个，即元素的第一个兄弟元素，并且兄弟元素要和元素相同。 使用:last-child选择元素的父元素的所有子元素中的最后一个，即元素的最后一个兄弟元素，并且兄弟元素要和元素相同。 使用:nth-child(n)选择元素的父元素的所有子元素中的第n个，即元素的第n个兄弟元素，并且兄弟元素要和元素相同。 使用:first-of-type选择元素的父元素的和元素相同的子元素中的第一个，即元素的第一个相同的兄弟元素。 使用:last-of-type选择元素的父元素的和元素相同的子元素中的最后一个，即元素的最后一个相同的兄弟元素。 使用:nth-of-type(n)选择元素的父元素的和元素相同的子元素中的第n个，即元素的第n个相同的兄弟元素。 使用:root选择根元素，即html元素。 使用:empty选择内容为空元素，即双标签中开始标签紧跟结束标签的元素或者单标签的元素，双标签的空格和换行也算内容。 说明： 伪类选择器中的n实际上是an+b性质的表达式，a和b都是数字。 0或者小于0都表示不选择任何元素。 n表示选择全部元素。 2n表示选择偶数元素。 2n+1表示选择奇数元素。 -n+5表示选择前5个元素。 n+5表示选择从第5个元素往后的元素，包括第5个元素。 3.4.1.4 否定伪类匹配不满足指定选择器的元素： 使用:not(选择器)选择不满足指定选择器的元素。 说明： 伪类选择器中指定的选择器可以使用伪类选择器。 3.4.1.5 界面伪类匹配在界面上有特殊效果的元素： 使用:checked选择被勾选的元素，多用于单选框和复选框。 使用:enable选择可用的元素，即没有disabled属性的元素，多用于表单元素。 使用:disabled选择不可用的元素，即有disabled属性的元素，多用于表单元素。 3.4.1.6 锚点伪类匹配被作为锚点跳转的元素： 使用:target选择锚点指向的元素。 3.4.1.7 语言伪类匹配被作为锚点跳转的元素： 使用:lang(语言)选择特定语言的元素，即有lang属性并且属性值和伪类选择器中语言相同的元素。 说明： 如果在html元素中使用lang属性，那么html的后代元素也默认使用相同的lang属性。 3.4.2 伪元素选择器说明：CSS3新增功能。 伪元素指的是元素中的一些特殊位置。 伪元素选择器固定以::双冒号开头，但为了兼容之前的版本，使用:冒号开头也能被识别。 常用伪元素选择器： 使用::first-letter选择元素内容中的第一个文字。 使用::first-line选择元素内容中的第一行文字。 使用::selection选择元素内容中被鼠标选中的内容。 使用::placeholder选择输入框的提示文字，多用于输入框和文本域。 使用::before在元素的起始位置，创建一个子元素，需要使用content属性指定内容。 使用::after在元素的结束位置，创建一个子元素，需要使用content属性指定内容。 3.5 优先级使用相同的选择器，选择相同的元素，优先级和位置有关，后面的选择器优先级高。 使用不同的选择器，选择相同的元素，优先级和权重有关，权重高的选择器优先级高比。 3.5.1 简单描述优先级： 行内样式 &gt; ID选择器 &gt; 类选择器 &#x3D; 伪类选择器 &#x3D; 属性选择器 &gt; 元素选择器 &#x3D; 伪元素选择器 &gt; 通配选择器 3.5.2 详细描述优先级： !important &gt; 行内样式 &gt; 按权重计算选择器 &gt; 通配选择器 &gt; 继承的样式 权重计算规则： 每个选择器，都可计算出一组格式为(a,b,c)的权重，说明：a：ID选择器的个数。b：类选择器、伪类选择器、属性选择器的个数。c：元素选择器、伪元素选择器的个数。 比较规则：按照从左到右的顺序，依次比较大小，当前位胜出后，后面的不再对比。 特殊规则：并集选择器需要被看作多个选择器，只能计算涉及当前元素的选择器的权重，不能计算整个并集选择器的权重。 4 三大特性4.1 层叠性如果发生了样式冲突，会根据选择器优先级进行样式层叠，优先级低的会被优先级高的覆盖。 4.2 继承性元素会自动拥有祖先元素设置的某些样式，继承性也遵循样式优先级，关系近的优先级高。 常见的可继承样式： color font-前缀 text-前缀 line-前缀 可以在MDN网站查询属性是否可被继承。 4.3 优先级选择器相同： !important &gt; 行内样式 &gt; 后面的选择器 &gt; 前面的选择器 &gt; 通配选择器 &gt; 默认的样式 &gt; 继承的样式 选择器不同： !important &gt; 行内样式 &gt; 按权重计算选择器优先级 &gt; 通配选择器 &gt; 默认的样式 &gt; 继承的样式 5 常用属性5.1 像素5.1.1 概念在涉及电子设备的屏幕时，为了更精确的描述图像的清晰度，创建了像素这个新的长度计量单位，使用px表示。 像素是图像最小的单位，图像是由多个像素组成的，每个像素内的颜色是相同的，像素越高的图像看起来画质越清晰，占用空间也越大。 像素是一个相对单位，其与绝对单位的换算和屏幕有关。 5.1.2 尺寸一般情况下，屏幕的尺寸指的是屏幕对角线的长度，通常用英寸（in）作为单位，英寸和厘米的换算： 1英寸 &#x3D; 2.54厘米 在某些情况下，也使用长度和宽度表示尺寸。 5.1.3 分辨率屏幕的分辨率指的是屏幕在横向和纵向上的像素数量。 在同一个设备上，分辨率是固定的，这是厂商在出厂时就设置好了的。 常用的分辨率： 720P：1280×720 1080P：1920×1080 2K：2560×1440 4K：3840*2160 虽然分辨率在出厂时就确定了，但是对于某些操作系统，比如Windows系统，支持修改分辨率，不过上限是屏幕的分辨率。系统在渲染图像的时候会自动计算，将图像里的单个逻辑像素用屏幕上的几个物理像素显示。 5.1.4 像素密度像素密度使用PPI（Pixels Per Inch）作为单位，描述图像的每英寸上的像素数量，也称为图像的采样率。 在尺寸、分辨率、像素密度这三个条件中，已知任何两个条件都可以计算剩余的条件，通过分辨率可以计算得到屏幕对角线上的像素数量，其结果与屏幕对角线的尺寸的比值就是像素密度。 像素并没有固定的大小，所以在尺寸固定的情况下，像素密度越高，分辨率越高，像素越小，画质越清晰。 此外，在将图像输出时，使用DPI（Dots Per Inch）作为单位，描述输出到载体的图像的每英寸上的像素数量。 虽然DPI和PPI类似，都用于描述每英寸上的像素数量，但是PPI用于屏幕上的图像，而DPI常用于输出的图像。 在输出图像时，如果设置的DPI大于PPI，输出的尺寸会小于图像在屏幕上的尺寸，并且不会失真，如果设置的DPI小于PPI，输出的尺寸会大于图像在屏幕上的尺寸，同时会产生失真效果。 另外，对于鼠标来说，高DPI鼠标使用起来更灵活，低DPI鼠标使用起来更沉重。当鼠标从电脑屏幕移动相同距离时，高DPI鼠标在桌子上实际移动的距离要比低DPI鼠标要短。 5.1.5 像素比像素分为物理像素和逻辑像素： 物理像素：设备能控制显示的最小单位，由厂家决定的，常说的1920×1080像素分辨率指的就是物理像素。 逻辑像素：也称为设备独立像素（Device Independent Pixel，DIP），CSS里定义的像素，比如1px指的就是逻辑像素。 设备像素比（Device Pixel Ratio，DPR），指的是屏幕的物理像素与逻辑像素之比，厂商在设备出厂时就已经进行设置，并且禁止用户进行更改。 一般情况下，普通电脑显示屏的DPR默认为1，即一个物理像素相当于一个逻辑像素。 对于手机等设备来说，需要在比电脑小的屏幕上显示相同分辨率的图像，因此手机屏幕的DPR一般会大于1。比如苹果6手机的DPR为2，物理像素分辨率是1334×750，逻辑像素分辨率是667×375，那么一个逻辑像素实际上会占用2×2&#x3D;4个物理像素。 5.2 颜色5.2.1 使用颜色名使用颜色名表示颜色。 语法： css1颜色名; 使用颜色名设置颜色为红色： css1color: red; 这种方式比较简单，但是颜色名有限，不常见的颜色没有颜色名。 可用颜色名参考文档：MDN具名颜色 5.2.2 使用RGB或RGBARGB指的是光的红（Red）绿（Green）蓝（Blue）三原色，RGBA多了一个透明度（Alpha）。 三原色的可选范围是0到255，透明度的可选范围是0到1，0表示全透明，1表示不透明。 语法： css1rgb(红色,绿色,蓝色); 使用RGB设置颜色为红色： css1color: rgb(255,0,0); 使用RGBA设置颜色为半透明红色： css1color: rgba(255,0,0,0.5); 5.2.3 使用HEX或HEXAHEX或HEXA是一种使用RGB或RGBA的十六进制表示的一种方式。 三原色和透明度都使用两位十六进制表示，范围是00到FF，对应数字0到255。 说明： 如果HEX或HEXA表示的颜色，每组两位十六进制都相同，可以简写为一位十六进制。 颜色字母大小写不敏感。 IE浏览器不支持HEXA，只支持HEX。 语法： css1#红色绿色蓝色; 使用HEX设置颜色为红色： css1color: #ff0000; 使用HEXA设置颜色为半透明红色： css1color: #ff000088; 5.2.4 使用HSL或HSLA说明：CSS3新增功能。 HSL指的是色相（Hue）、饱和度（Saturation）、亮度（Lightness），HSLA多了一个透明度（Alpha）。 概念： 色相：取值范围是0度到360度，表示颜色的角度。 饱和度：取值范围是0%到100%，表示向色相中对应颜色中添加灰色，0%表示黑白，100%表示彩色。 亮度：取值范围是0%到100%，表色颜色的明亮程度，0%表示没有亮度的黑色，100%表示最高亮度的白色。 色相的度数对应的颜色如下图： 语法： css1hsl(色相,饱和度,亮度); 使用HSL设置颜色为红色： css1color: hsl(0,100%,50%); 使用HSLA设置颜色为半透明红色： css1color: hsl(0,100%,50%,50%); 5.3 字体5.3.1 字体大小常用属性： 属性名 作用 取值 font-size 控制文本字体的大小 长度值 说明： 设置为0会让文本消失。 浏览器有默认字体，不同浏览器默认字体可能不一样大，为了显示统一，建议设置明确大小。 因为CSS的继承性，只需要给body元素设置字体大小，后代元素默认继承祖先元素的字体大小。不建议使用通配选择器，否则会导致在给某个元素的父元素的字体设置大小后，因为通配选择器优先级高于继承，元素优先使用通配选择器设置的大小，并没有使用继承父元素设置的大小。 示例： css1font-size: 16px; 5.3.2 字体族常用属性： 属性名 作用 取值 font-family 控制文本字体的字型 字体名称，多个使用,分隔分隔 分类： 衬线字体：字体线条粗细不一，类似毛笔和钢笔的字体。使用serif表示选择系统可用的衬线字体。 非衬线字体：字体线条宽度一致。使用sans-serif表示选择系统可用的非衬线字体。 说明： 支持使用中文，但有的字体没有提供中文名称，建议使用英文，如果存在空格，需要使用&quot;双引号包裹。 多个字体使用时按照从左到右的顺序查找，系统存在就使用，系统不存在就查找下一个。 如果都不能匹配，会使用操作系统默认字体，不同的操作系统能够使用的字体不同。在Windows系统下使用微软雅黑作为默认字体。 为了保证显示效果统一，通常多个字体都是衬线字体或者非衬线字体，并且可以使用serif或者sans-serif兜底，当前面的字体在系统中不存在时，强制使用系统可用的衬线字体或者非衬线字体进行渲染。 示例： css1font-family: &quot;Microsoft YaHei&quot;,sans-serif; 5.3.3 字体风格常用属性： 属性名 作用 取值 font-style 控制文本字体的风格（是否斜体） normal：正常（默认字体） italic：斜体（先使用斜体字体，如果不存在，才会强制字体倾斜，推荐） oblique：斜体（不使用斜体字体，直接强制字体倾斜） 示例： css1font-style: italic; 5.3.4 字体粗细常用属性： 属性名 作用 取值 font-weight 控制文本字体的粗细 有两种方式： 1. 使用名称设置粗细： lighter：细 normal：正常 bold：粗 bolder：很粗（多数字体不支持，效果同bold） 2. 使用数值设置粗细： 数值的范围是从100到1000，一般来说数值越大字体越粗，具体要看字体设计 100~300等同于lighter 400~500等同于normal 600及以上等同于bold 示例： css1font-weight: 200; 5.3.5 复合写法常用属性： 属性名 作用 取值 font 控制文本字体的多个属性的复合写法 设置多个属性，空格分隔： 1. 字体族必须存在并且是最后一位 2. 字体大小必须存在并且是倒数第二位 3. 其他属性在前即可 语法： css1font: 字体粗细 字体风格 字体大小/行高 字体族; 示例： css1font: normal 200 40px/1.5 &quot;Microsoft YaHei&quot;, sans-serif; 5.4 文本5.4.1 文本颜色常用属性： 属性名 作用 取值 color 控制文本的颜色 颜色名 RGB或RGBA（常用） HEX或HEXA（常用） HSL或HSLA 示例： css1color: #ff0000; 5.4.2 文本划线常用属性： 属性名 作用 取值 text-decoration 控制文本的各种装饰线 支持三种维度设置，空格分隔： 1. 装饰线类型： none：无装饰线（常用） line-through：删除线（常用） underline：下划线（常用） overline：上划线 2. 装饰线样式： dotted：虚线 wavy：波浪线 3. 装饰线颜色： 颜色代码 示例： css1text-decoration: line-through dotted #ff0000; 5.4.3 文本缩进常用属性： 属性名 作用 取值 text-indent 控制文本的缩进 长度值 说明： 正值让文本右移，负值让文本左移。 示例： css1text-indent: 5px; 5.4.4 文本间距常用属性： 属性名 作用 取值 letter-spacing 控制字符之间的距离，包括汉字和标点符号，也包括空格 长度值 word-spacing 控制空格分隔的词语之间的距离，实际控制的是空格占用的距离 长度值 说明： 正值让间距增大，负值让间距缩小。 示例： css12letter-spacing: 5px;word-spacing: 5px; 5.4.5 文本水平对齐常用属性： 属性名 作用 取值 text-align 控制块级元素内容或者单元格元素内容的水平对齐 left：左对齐（默认值） right：右对齐 center：居中对齐 示例： css1text-align: center; 5.4.6 文本字体字体设计用到的参考线： 概念： baseline：基线，以英文字符x下边缘为参考的横线，字符默认是以基线对齐的。 middle：中线，以英文字符x上边缘为参考的横线。 top：顶线，字符的上边缘，所有字符均不会超过上边缘，包括中文。 bottom：底线，字符的下边缘，所有字符均不会超过下边缘，包括中文。 line-height：行高，文字的高度，实际是上下两行基线之间的高度。 说明： 即使可以通过font-size给不同的字体设置统一的大小，不同的字体在页面上显示的大小还是有细微的区别。 不同的字体对相同的字符在垂直方向上的处理也是不同的，有的可能贴近底线，有的可能贴近顶线。 5.4.7 行高常用属性： 属性名 作用 取值 line-height 控制元素内容一行内容的高度 normal：由浏览器根据文字大小决定的默认值 像素：使用像素`px`作为单位设置行高 数字倍数：使用`font-size`的数字倍数设置行高（很常用） 百分比倍数：使用`font-size`的百分比倍数设置行高 说明： 如果设置行高为负数，效果等同设置行高为normal的效果。 如果设置行高为最小值0，效果和字体设计以及元素区块有关。 如果设置行高为字体大小，会因为字体设计的问题，导致相邻两行发生重叠。 建议设置行高为字体的1.5倍，不会发生重叠，也不会间隔太长。 示例： css1line-height: normal; 5.4.8 文本垂直对齐常用属性： 属性名 作用 取值 vertical-align 控制行内元素内容或者单元格元素内容的垂直对齐 baseline：使元素的基线与父元素的基线对齐（默认值） middle：使元素的中线与父元素的中线对齐 top：使元素的顶线与其所在行的顶线对齐 bottom：使元素的底线与其所在行的底线对齐 说明： 只能用于控制行内元素在父元素一行中的垂直对齐，不能控制行内元素在父元素整个元素中的垂直对齐。 示例： css1vertical-align: middle; 5.5 列表控制列表的属性，可以作用在ul、ol、li元素上。 常用属性： 属性名 作用 取值 list-style-type 设置列表符号 none：不显示前面的标识（很常用） square：实心方块 disc：圆形 decimal：数字 lower-roman：小写罗马字 upper-roman：大写罗马字 lower-alpha：小写字母 upper-alpha：大写字母 list-style-position 设置列表符号的位置 inside：在`li`的里面 outside：在`li`的外边 list-style-image 自定义列表符号 url(图片地址) list-style 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1list-style: decimal; 5.6 表格5.6.1 边框可以作用在其他元素上，不仅仅是表格相关的元素。 常用属性： 属性名 作用 取值 border-style 设置边框风格 none：默认值 solid：实线 dashed：虚线 dotted：点线 double：双实线 border-width 设置边框宽度 长度值 border-color 设置边框颜色 颜色代码 border 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1border: none; 5.6.2 表格独有只能作用在table元素上。 常用属性： 属性名 作用 取值 table-layout 设置列宽度 auto：自动，列宽根据内容计算（默认值） fixed：固定列宽，平均分 border-collapse 合并单元格边框 collapse：合并 separate：不合并（默认值） border-spacing 设置单元格间距，这个属性生效的前提是单元格边框不能合并 长度值 empty-cells 隐藏没有内容的单元格，这个属性生效的前提是单元格边框不能合并 show：显示（默认值） hide：隐藏 caption-side 设置表格标题位置 top：在表格上面（默认值） bottom：在表格下面 示例： css1border-collapse: separate; 5.7 背景常用属性： 属性名 作用 取值 background-color 设置背景颜色 默认是transparent background-image 设置背景图片 url(图片地址) background-repeat 设置背景重复方式 repeat：重复，铺满整个元素（默认值） repeat-x：只在水平方向重复 repeat-y：只在垂直方向重复 no-repeat：不重复 background-position 设置背景图位置 使用两个维度定位，空格分隔，有多种方式： 1. 使用关键字(水平 垂直)设置位置： 水平：left、center、right 垂直：top、center、bottom 如果只写一个值，另一个方向的值取center 2. 使用坐标(x y)设置图片左上角的位置，以元素左上角为坐标原点： 如果只写一个值，会被当做x坐标，y坐标取center 3. 使用边缘距离设置图片位置，必须有四个值，分为前后两组： 一组代表上下，另一组代表左右，顺序没有要求 每组第一个值代表方向，第二个值代表边距 background 设置复合属性 没有数量和顺序要求，同属性后面的会覆盖前面的 示例： css1background: transparent; 5.8 鼠标常用属性： 属性名 作用 取值 cursor 设置鼠标光标的样式，也可以自定义鼠标图标 pointer：小手 move：移动图标 text：文字选择器 crosshair：十字架 wait：等待 help：帮助 url(图片地址)：自定义图标 示例： css1cursor: pointer;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"HTML4进阶","slug":"100-大前端/101-HTML/001-基础/002-HTML4进阶","date":"2024-03-14T08:31:25.000Z","updated":"2024-05-28T08:09:13.230Z","comments":true,"path":"posts/20240314/163125/","permalink":"https://momashanhe.com/posts/20240314/163125/","excerpt":"摘要：本文主要介绍了HTML常见的元素及其特点。","text":"摘要：本文主要介绍了HTML常见的元素及其特点。 1 文本元素和排版元素相比，文本元素侧重词汇和短语并且一般是行内元素，排版元素侧重文章和段落并且一般是块级元素，而且文本元素通常写在排版元素中。 常用的元素： 标签名 说明 单双 em 表示需要注意的内容 双标签 strong 表示十分重要的内容，语气比em元素更重 双标签 不太常用的元素： 标签名 说明 单双 cite 表示作品标题 双标签 dfn 表示特殊术语或者专属名词 双标签 del 表示想要删除的文本 双标签 ins 表示想要插入的文本 双标签 sub 表示下标 双标签 sup 表示上标 双标签 code 表示代码 双标签 i 表示具有特定含义的文本，多用于呈现字体图标 双标签 省略了一些语义不强、较少使用、能被替代的元素，可以在官方网站上查看全部元素。 2 图片元素2.1 基本结构图片元素用于定义图片资源的位置，以及图片的一些属性，属于行内元素。 常用的元素： 标签名 说明 单双 img 表示图片 单标签 常用属性： 属性名 作用 取值 src 图片路径 路径 alt 图片描述 描述 width 图片宽度，默认使用图片本身的宽度 长度值 height 图片高度，默认使用图片本身的高度 长度值 2.2 路径图片路径也称为图片地址，分为相对路径和绝对路径，以及网络地址： 相对路径：从当前页面文件所在的位置开始，能够访问图片资源的路径。 绝对路径：从当前页面文件所在的磁盘的根目录开始，能够访问图片资源的路径。 网络地址：相对路径和绝对路径都是本地图片，如果是网络图片则需要使用图片的网络地址进行访问。 如果是本地图片，需要注意图片被移动会导致路径失效，如果是网络图片，需要注意在开启防盗链后会导致图片不可访问。 2.3 图片格式2.3.1 jpg说明：扩展名为jpg和jpeg，有损压缩，丢弃了肉眼观察不到的细节。 特点：占用空间较小，不支持透明背景，不支持动态图片。 场景：对图片质量没有极高的要求，适合绝大多数场景。 2.3.2 png说明：扩展名为png，无损压缩，支持图片高质量的保存。 特点：占用空间较大，支持透明背景，不支持动态图片。 场景：对图片质量有一定的要求，或者需要使用有透明背景的图片。 2.3.3 bmp说明：扩展名为bmp，不进行压缩，最大程度保留了图片细节。 特点：占用空间极大，不支持透明背景，不支持动态图片。 场景：对图片细节要求极高的场景，页面中很少使用。 2.3.4 gif说明：扩展名为gif，有损压缩，仅支持256种颜色。 特点：占用空间较小，支持颜色较少，支持透明背景，支持动态图片。 场景：页面中的动态图片。 2.3.5 webp说明：扩展名为webp，同时支持无损压缩和有损压缩，谷歌推出的图片格式，专用于处理页面图片。 特点：占用空间较小，支持透明背景，支持动态图片，需要注意兼容性问题。 场景：页面中的图片，在和jpg在同等大小的情况下能保留更多细节。 2.3.6 base64说明：将图片转换得到的一串特殊的文本，支持通过浏览器打开，但某些看图应用无法打开。 特点：字符串会特别长，并且会占用和图片大小相同的空间。 场景：一些较小的图片，或者需要同页面一起加载的图片。 3 超链接3.1 基本结构用于从当前页面进行跳转，超链接本身属于行内元素。 常用的元素： 标签名 说明 单双 a 表示超链接 双标签 常用属性： 属性名 作用 取值 href 指定要跳转到的具体目标 目标地址 target 控制跳转时如何打开页面 _self：在当前标签页打开，即替换当前页面的地址为目标地址并访问 _blank：在新建标签页打开，当前标签页保留 注意： 虽然a元素是行内元素，但是可以包裹a元素之外的其他元素，包括块级元素和行内元素。 3.2 跳转方式3.2.1 跳转到页面使用href属性指定页面，那么点击超链接会跳转到指定的页面。 使用target属性指定打开目标页面的方式。 3.2.2 跳转到文件使用href属性指定文件，那么点击超链接会跳转到指定的文件。 如果浏览器能打开指定的文件就在浏览器展示，比如图片文件，如果浏览器不能打开指定的文件就引导用户下载，比如压缩文件。 3.2.3 跳转到锚点使用href属性指定锚点，那么点击超链接会跳转到指定的锚点。 锚点是#符号和在其他元素中id属性值拼接得到的。示例： html123&lt;a href=&quot;#test&quot;&gt;点击前往测试内容&lt;/a&gt;&lt;!-- 其他内容 --&gt;&lt;p id=&quot;test&quot;&gt;测试内容&lt;/p&gt; 也可以跳转到页面顶部。示例： html1&lt;a href=&quot;#top&quot;&gt;点击前往页面顶部&lt;/a&gt; 如果href属性空白，页面上不会有超链接样式，可以使用#符号占位，点击会跳转到当前页。示例： html1&lt;a href=&quot;#&quot;&gt;占位链接&lt;/a&gt; 如果不想在点击后触发跳转的操作，或者在开发阶段不确定要跳转到哪个页面，可以将href属性设为javascript:;实现。示例： html1&lt;a href=&quot;javascript:;&quot;&gt;占位链接&lt;/a&gt; 3.2.4 跳转到应用使用href属性指定应用，那么点击超链接会跳转到指定的应用，需要应用支持，比如邮箱等。 示例： html1&lt;a href=&quot;mailto:momashanhe@163.com&quot;&gt;点击发送邮件&lt;/a&gt; 4 列表4.1 有序列表有顺序或侧重顺序的列表，属于块级元素。 常用的元素： 标签名 说明 单双 ol 表示有序列表的范围 双标签 li 表示列表的一列 双标签 示例： html123456&lt;p&gt;要把大象放冰箱总共分几步&lt;/p&gt;&lt;ol&gt; &lt;li&gt;把冰箱门打开&lt;/li&gt; &lt;li&gt;把大象放进去&lt;/li&gt; &lt;li&gt;把冰箱门关上&lt;/li&gt;&lt;/ol&gt; 4.2 无序列表无顺序或不侧重顺序的列表，属于块级元素。 常用的元素： 标签名 说明 单双 ul 表示无序列表的范围 双标签 li 表示列表的一列 双标签 示例： html1234567&lt;p&gt;我想去的几个城市&lt;/p&gt;&lt;ul&gt; &lt;li&gt;成都&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;li&gt;武汉&lt;/li&gt;&lt;/ul&gt; 4.3 嵌套列表有序列表和无序列表支持嵌套列表。 示例： html123456789101112131415&lt;p&gt;我想去的几个城市&lt;/p&gt;&lt;ul&gt; &lt;li&gt;成都&lt;/li&gt; &lt;li&gt; &lt;span&gt;上海&lt;/span&gt; &lt;ul&gt; &lt;li&gt;外滩&lt;/li&gt; &lt;li&gt;杜莎夫人蜡像馆&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.opg.cn/&quot;&gt;东方明珠&lt;/a&gt;&lt;/li&gt; &lt;li&gt;迪士尼乐园&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;西安&lt;/li&gt; &lt;li&gt;武汉&lt;/li&gt;&lt;/ul&gt; 4.4 自定义列表包含术语名称以及术语描述的列表，属于块级元素。 常用的元素： 标签名 说明 单双 dl 表示自定义列表的范围 双标签 dt 表示术语名称 双标签 dd 表示术语描述 双标签 示例： html12345678910&lt;p&gt;如何高效的学习&lt;/p&gt;&lt;dl&gt; &lt;dt&gt;做好笔记&lt;/dt&gt; &lt;dd&gt;笔记是我们以后复习的一个抓手&lt;/dd&gt; &lt;dd&gt;笔记可以是电子版，也可以是纸质版&lt;/dd&gt; &lt;dt&gt;多加练习&lt;/dt&gt; &lt;dd&gt;只有敲出来的代码，才是自己的&lt;/dd&gt; &lt;dt&gt;别怕出错&lt;/dt&gt; &lt;dd&gt;错很正常，改正后并记住，就是经验&lt;/dd&gt;&lt;/dl&gt; 5 表格5.1 基本结构一个完整的表格由四部分组成：表格标题、表格头部、表格主体、表格脚注。 表格的某些部分可以省略，各个部分都属于块级元素。 表格结构如图： 常用的元素： 标签名 说明 单双 table 表示表格的范围 双标签 caption 表示表格的标题行 双标签 thead 表示表格头部的范围 双标签 tbody 表示表格主体的范围 双标签 tfoot 表示表格脚注的范围 双标签 tr 表示表格一行的范围，可以用在thead元素、tbody元素、tfoot元素 双标签 th 表示表格头部一格的范围，可以用在thead元素 双标签 td 表示表格主体一格的范围，可以用在tbody元素、tfoot元素 双标签 表格详细结构如图： 示例： html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;table&gt; &lt;!-- 表格标题 --&gt; &lt;caption&gt;学生信息&lt;/caption&gt; &lt;!-- 表格头部 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;民族&lt;/th&gt; &lt;th&gt;政治面貌&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表格主体 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;汉族&lt;/td&gt; &lt;td&gt;团员&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;满族&lt;/td&gt; &lt;td&gt;群众&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;回族&lt;/td&gt; &lt;td&gt;党员&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;赵六&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;壮族&lt;/td&gt; &lt;td&gt;团员&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- 表格脚注 --&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;共计：4人&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 5.2 常用属性table元素常用属性： 属性名 作用 取值 width 设置表格宽度 长度值 height 设置表格最小高度，表格最终高度可能比设置的值大 长度值 border 设置表格边框宽度 长度值 cellspacing 设置单元格之间的间距 长度值 thead元素常用属性： 属性名 作用 取值 height 设置表格头部高度 长度值 align 设置单元格的水平对齐方式 left：左边对齐 right：右边对齐 center：中间对齐 valign 设置单元格的垂直对齐方式 top：顶部对齐 middle：中间对齐 bottom：底部对齐 tbody元素常用属性：与thead元素常用的属性相同。 tfoot元素常用属性：与thead元素常用的属性相同。 tr元素常用属性：与thead元素常用的属性相同。 th元素常用属性： 属性名 作用 取值 width 设置单元格的宽度，同列所有单元格全都受影响 长度值 height 设置单元格的高度，同行所有单元格全都受影响 长度值 align 设置单元格的水平对齐方式 left：左边对齐 right：右边对齐 center：中间对齐 valign 设置单元格的垂直对齐方式 top：顶部对齐 middle：中间对齐 bottom：底部对齐 rowspan 指定要跨的行数 行数 colspan 指定要跨的列数 列数 td元素常用属性：与th元素常用的属性相同。 5.3 跨行跨列常用属性： 属性名 作用 取值 rowspan 指定要跨的行数 行数 colspan 指定要跨的列数 列数 使用属性实现跨行跨列： 原始表格使用colspan跨行使用rowspan跨列示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1-1&lt;/td&gt; &lt;td&gt;2-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1-2&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;1-1&lt;/td&gt; &lt;!-- &lt;td&gt;2-1&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1-2&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;示例： html123456789101112&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot; valign=&quot;middle&quot;&gt;1-1&lt;/td&gt; &lt;td&gt;2-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;1-2&lt;/td&gt; --&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 6 表单6.1 基本元素表单是一个包含交互的区域，用于收集用户提供的数据，整个表单属于块级元素，表单中的控件一般属于行内元素。 常用的元素： 标签名 说明 单双 form 表示表单的范围 双标签 input 表示表单中的控件，存在多种控件类型 单标签 button 表示表单中的按钮，点击可以触发处理表单数据的操作 双标签 textarea 表示文本域，可以存储多行文本 双标签 select 表示下拉框的范围，点击展示下拉框选项 双标签 option 表示下拉框的选项，用在select元素 双标签 label 和表单控件关联，点击元素可使表单控件获得焦点 双标签 fieldset 表示表单元素分组的范围 双标签 legend 表示表单元素分组的标题，用在fieldset元素 双标签 form元素常用属性： 属性名 作用 取值 action 表单提交的地址，需要和后端沟通确定 地址 target 表单提交后，页面的打开方式 _self：在当前标签页打开，即替换当前页面的地址为目标地址并访问 _blank：在新建标签页打开，当前标签页保留 method 表单提交的请求方式 get：默认值，表单数据会附加在URL中发送，一般用于不敏感信息，如分页等 post：表单数据会包含在表单体内发送，用于提交敏感数据，如用户名与密码等 input元素常用属性： 属性名 作用 取值 type 设置控件的类型 text：默认值，普通文本 input：文本输入框 password：密码输入框 radio：单选框 checkbox：多选框 hidden：隐藏域 submit：提交按钮 reset：重置按钮 button：普通按钮 name 设置控件的数据名称，需要和后端沟通确定 名称 value 设置控件的数据，不同的表单控件有不同的获取方式 数据 disabled 设置控件不可用 无 button元素常用属性： 属性名 作用 取值 disabled 设置按钮不可用 无 type 设置按钮的类型，不同的类型对表单数据的处理方式不同 submit：默认值，提交表单 reset：重置表单 button：普通按钮 textarea元素常用属性： 属性名 作用 取值 name 设置文本域的数据名称 名称 rows 设置文本域默认显示的行数，影响文本域的高度 行数 cols 设置文本域默认显示的列数，影响文本域的宽度 列数 disabled 设置文本域不可用 无 select元素常用属性： 属性名 作用 取值 name 设置下拉框的数据名称 名称 disabled 设置下拉框不可用 无 option元素常用属性： 属性名 作用 取值 value 设置下拉选项的数据，在省略的情况下，会使用下拉选项的元素内容作为数据 数据 selected 设置下拉选项在加载后默认选中 无 disabled 设置下拉选项不可用 无 label元素常用属性： 属性名 作用 取值 for 用于指定要匹配的表单控件 表单控件的id属性值 6.2 常用控件6.2.1 文本输入框最常用的表单控件，支持输入一行文本。 示例： html1请输入文本：&lt;input type=&quot;text&quot;&gt; 常用属性： 属性名 作用 取值 name 设置输入框的数据名称 名称 value 设置输入框的默认值 默认值 maxlength 设置输入框可输入的最大长度 最大长度 6.2.2 密码输入框和文本输入框类似，但是输入的内容会显示为*号，避免密码泄露。 示例： html1请输入密码：&lt;input type=&quot;password&quot;&gt; 常用属性： 属性名 作用 取值 name 设置输入框的数据名称 名称 value 设置输入框的默认值，作为密码时无意义，可以省略 默认值 maxlength 设置输入框可输入的最大长度 最大长度 6.2.3 单选框支持单选的控件。 示例： html123请选择性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男 常用属性： 属性名 作用 取值 name 设置单选框的数据名称，同组控件要保持一致 名称 value 设置单选框提交的数据值，会提交被选中的控件的value属性 数据值 checked 设置单选框在加载后默认选中 无 6.2.4 多选框多选框也称为复选框，支持多选的控件。 示例： html1234请选择爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;抽烟&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;喝酒&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;烫头 常用属性： 属性名 作用 取值 name 设置多选框的数据名称，同组控件要保持一致 名称 value 设置多选框提交的数据值，会提交被选中的控件的value属性，多个值会组成数组 数据值 checked 设置多选框在加载后默认选中 无 6.2.5 隐藏域不会让用户看到的特殊控件，可以在检查后看到，通常用于提交特殊数据。 示例： html1&lt;input type=&quot;hidden&quot; name=&quot;tag&quot; value=&quot;100&quot;&gt; 常用属性： 属性名 作用 取值 name 设置隐藏域的数据名称 名称 value 设置隐藏域提交的数据值，通常由操作自动存储，不需要用户处理 数据值 6.2.6 提交按钮用于将表单数据提交到指定地址。 使用input元素。示例： html1&lt;input type=&quot;submit&quot; value=&quot;提交表单&quot;&gt; 也可以使用button元素。示例： html1&lt;button type=&quot;submit&quot;&gt;提交表单&lt;/button&gt; 6.2.7 重置按钮用于将表单数据清空，恢复到页面加载后的状态。 使用input元素。示例： html1&lt;input type=&quot;reset&quot; value=&quot;重置表单&quot;&gt; 也可以使用button元素。示例： html1&lt;button type=&quot;reset&quot;&gt;重置表单&lt;/button&gt; 6.2.8 普通按钮用于触发特定操作。 使用input元素。示例： html1&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; 也可以使用button元素。示例： html1&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt; 6.2.9 文本域用于存储多行文本。 示例： html1请输入多行文本：&lt;textarea name=&quot;msg&quot; rows=&quot;3&quot; cols=&quot;3&quot;&gt;我是文本域&lt;/textarea&gt; 使用textarea元素时不需要使用type属性，其他和input元素的文本输入框一致。 6.2.10 下拉框用于选择下拉选项。 示例： html1234567请选择省份：&lt;select name=&quot;from&quot;&gt; &lt;option value=&quot;黑&quot;&gt;黑龙江&lt;/option&gt; &lt;option value=&quot;辽&quot;&gt;辽宁&lt;/option&gt; &lt;option value=&quot;吉&quot;&gt;吉林&lt;/option&gt; &lt;option value=&quot;粤&quot; selected&gt;广东&lt;/option&gt;&lt;/select&gt; 使用option元素时如果没有设置value属性，会将元素内容作为数据提交。 6.2.11 标记和表单控件关联，点击元素可使表单控件获得焦点，需要配合表单控件使用。 示例： html1&lt;label for=&quot;password&quot;&gt;请输入密码：&lt;/label&gt;&lt;input id=&quot;password&quot; type=&quot;password&quot;&gt; 6.2.12 分组用于对表单元素进行分组，和其他控件不同，分组元素属于块级元素。 示例： html123456789101112&lt;fieldset&gt; &lt;legend&gt;主要信息&lt;/legend&gt; &lt;label for=&quot;username&quot;&gt;账户：&lt;/label&gt; &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; maxlength=&quot;10&quot;&gt; &lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; maxlength=&quot;6&quot;&gt; &lt;br&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; id=&quot;male&quot;&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; id=&quot;female&quot;&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;&lt;/fieldset&gt; 7 框架用于在当前页面加载其他内容，属于行内元素。 在HTML中，将和框架类似的元素称为可替换元素，即这种元素展示的内容是由外部的文件决定的，典型的元素有： 表示框架的iframe元素 表示视频的video元素 表示音频的audio元素 表示图片的img元素 表示外部资源的embed元素，该元素现在已经不建议使用了，可以用上面的元素代替 常用的元素： 标签名 说明 单双 iframe 框架，允许在框架里展示其他内容 双标签 常用属性： 属性名 作用 取值 name 框架名字，可以与其他元素的target属性配合，实现在框架中展示页面的效果 框架名字 src 框架内容，可以是网址，也可以是资源文件地址 框架内容 width 框架宽度 长度值 height 框架高度 长度值 frameborder 是否显示边框 0：默认值，否，不显示边框 1：是，显示边框 示例： html1&lt;iframe src=&quot;https://momashanhe.com&quot;&gt;查看博客&lt;/iframe&gt; 8 全局属性常用属性： 属性名 含义 id 元素唯一标识，一个页面中的id属性值不能重复。可以配合CSS和JS使用，也可以在其他元素中使用 class 元素类名，可以配合CSS和JS使用 style 元素样式，给元素设置CSS样式 title 元素提示，一般超链接和图片用得比较多 lang 元素语言，给元素指定语言，很少使用 一般来说，在html元素中设置lang属性设置语言即可，很少会在其他元素中使用lang属性，除非想要使用其他语言显示某个元素。 虽然这些属性是全局属性，但是在一些特殊元素上使用是没有意义的，不建议使用，也没有必要使用，比如html元素，以及head元素及其内部元素，等一些其他特殊元素。 完整的全局属性可以参考文档：MDN全局属性 9 元数据9.1 基本结构元数据就是描述数据的数据，对于HTML而言，元数据就是描述HTML页面的数据。 常用的元素： 标签名 说明 单双 meta 表示元数据，用在head元素 单标签 9.2 使用示例配置字符编码： html1&lt;meta charset=&quot;UTF-8&quot;&gt; 配置网页自动刷新： html1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10;url=https://momashanhe.com&quot;&gt; 刷新说明： 数字表示秒数，非负整数有效。 url表示地址，省略或地址无效会刷新当前页面。 针对IE浏览器的兼容性配置： html1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 针对移动端的兼容性配置： html1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 配置网页关键字： html1&lt;meta name=&quot;keywords&quot; content=&quot;英文逗号隔开的一组词语&quot;&gt; 配置网页描述信息： html1&lt;meta name=&quot;description&quot; content=&quot;80字以内的一段话，与网站内容相关&quot;&gt; 针对搜索引擎爬虫配置： html1&lt;meta name=&quot;robots&quot; content=&quot;可选值&quot;&gt; 可选值如下： 值 描述 index 要求搜索爬虫索引此页面 noindex 要求搜索爬虫不索引此页面 follow 要求搜索爬虫跟随此页面上的链接 nofollow 要求搜索爬虫不跟随此页面上的链接 all 和设置index, follow相同 none 和设置noindex, nofollow相同 noarchive 要求搜索引擎不缓存页面内容 nocache 是noarchive的代名词 配置网页作者： html1&lt;meta name=&quot;author&quot; content=&quot;momashanhe&quot;&gt; 配置网页生成工具： html1&lt;meta name=&quot;generator&quot; content=&quot;Visual Studio Code&quot;&gt; 配置网页版权信息： html1&lt;meta name=&quot;copyright&quot; content=&quot;2020-2050©版权所有&quot;&gt; 完整的网页元数据可以参考文档：MDN元数据","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"HTML4入门","slug":"100-大前端/101-HTML/001-基础/001-HTML4入门","date":"2024-03-14T06:35:53.000Z","updated":"2024-05-08T08:42:38.308Z","comments":true,"path":"posts/20240314/143553/","permalink":"https://momashanhe.com/posts/20240314/143553/","excerpt":"摘要：本文主要介绍了HTML相关的一些概念。","text":"摘要：本文主要介绍了HTML相关的一些概念。 1 简介1.1 软件软件分类： 系统软件：Windows、Linux、MacOS 应用软件：Office、QQ 游戏软件：绝地求生、王者荣耀 其他分类 通常情况下，现在的软件一般由客户端与服务端两个部分组成： 客户端：用户通过客户端来使用软件。 服务端：服务端负责在远程处理业务逻辑。 服务端开发的语言： Java PHP C# Python Node.js 客户端的形式： 命令行界面：占老的方式，通过命令行来使用软件。 图形化界面：通过点击拖动等来使用软件。比较典型的时Windows中的大部分应用，属于C&#x2F;S架构，即Client&#x2F;Server架构。 网页：通过访问网页来使用软件。所有的网站都属于这个范畴，属于B&#x2F;S架构，即Brower&#x2F;Server架构。 相较于传统的命令行界面和图形化界面，网页具有如下一些优点： 不需要安装 无需更新 跨平台 网页中使用的语言： HTML CSS JS 1.2 网页网站是指在因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的网页集合。 网页是网站中的一“页”，通常是HTML格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以.htm或.html后缀结尾的文件，因此将其俗称为HTML文件。 HTML全称：HyperText Markup Language（超文本标记语言），含义如下： HyperText（超文本）：指可以加入图片、声音、动画、多媒体等内容，超越了文本限制，也指可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。 Markup（标记）：文本要变成超文本，就需要用到各种标记符号，包括各种元素。 Language（语言）：每一个标记的写法、读音、使用规则，组成了一个标记语言。 HTML不是一种编程语言，而是一种标记语言（Markup Language），标记语言是一套标记标签（Markup Tag）。 1.3 浏览器浏览器是网页显示、运行的平台。常用的浏览器有IE、Firefox、Chrome、Safari和Opera等，称为五大浏览器。 浏览器内核是将文件展示成网页的渲染引擎，负责读取网页内容、整理讯息、计算网页的显示方式并显示页面。 1.4 国际组织1.4.1 IETF全称：Internet Engineering Task Force（国际互联网工程任务组），成立于1985年底，是一个权威的互联网技术标准化组织，主要负责互联网相关技术规范的研发和制定，当前绝大多数国际互联网技术标准均出自IETF。 官网：https://www.ietf.org 1.4.2 W3C全称：World Wide Web Consortium（万维网联盟），创建于1994年，是目前Web技术领域，最具影响力的技术标准机构。共计发布了200多项技术标准和实施指南，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。 官网：https://www.w3.org 1.4.3 WHATWF全称：Web Hypertext Application Technology Working Group（网页超文本应用技术工作小组），成立于2004年，是一个以推动网络HTML5标准为目的而成立的组织。由Opera、Mozilla基金会、苹果，等这些浏览器厂商组成。 官网：https://whatwg.org 1.5 发展历史从HTML1.0开始发展，期间经历了很多版本，目前HTML的最新标准是HMTL5，具体发展史如图： 1.6 Web标准Web标准是由W3C组织和其他标准化组织制定的一系列标准的集合。 遵循Web标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 让Web的发展前景更广阔。 内容能被更广泛的设备访问。 更容易被搜寻引擎搜索。 降低网站流量费用。 使网站更易于维护。 提高页面浏览速度。 Web标准主要包括三个方面： 结构（Structure）：用于对网页元素进行整理和分类，主要指的是HTML。 表现（Presentation）：用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为（Behavior）：用于定义网页模型及编写网页交互，主要指的是JS。 Web标准提出的最佳体验方案是结构、样式、行为互相分离，即结构写到HTML文件中、表现写到CSS文件中、行为写到JS文件中。 1.7 官方文档官方文档地址： W3C官网：https://www.w3.org/ W3School：https://www.w3school.com.cn MDN：https://developer.mozilla.org 推荐使用MDN官方文档。 2 概念2.1 标签2.1.1 定义标签又称元素，是HTML的基本组成单位。 标签名不区分大小写，但推荐小写，因为小写更规范。 元素分为双标签和单标签，绝大多数都是双标签： 双标签单标签前面的是开始标签，两个标签中间的是元素内容，后面的是结束标签，结束标签多了一个/符号且不可省略： html1&lt;span&gt;&lt;/span&gt;只有一个标签，不存在元素内容： html1&lt;input /&gt; 标签后面的空格和/符号可以省略： html1&lt;input&gt; 2.1.2 尝试使用鼠标右键新建文本文档，输入以下内容： hello.html1&lt;h1&gt;Hello HTML&lt;/h1&gt; 将文本文档重命名为hello.html后，双击打开，即可看到创建的页面。 2.1.3 基本结构一般情况下，在网页中右键，在菜单的底部可以看到查看页面源代码和检查这两个选项： 查看页面源代码：可以看到程序员编写的页面源码。 检查：浏览器对页面源码经过格式化等处理后的代码。 选择检查后，可以看到页面的基本结构： html123456&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 常用的元素： 标签名 说明 单双 html 页面中最大的元素，称为根元素 双标签 head 用于定义页面的特性，不会展示在页面上，通常是给浏览器或者搜索引擎使用的 双标签 title 用于定义页面的标题，嵌套在head元素中 双标签 body 用于定义页面的内容，会展示在页面上 双标签 使用VSCode工具快速生成页面结构： 第一步：双击打开软件。 第二步：新建文件并保存为.html文件。 第三步：输入!符号并根据提示按下Tab键，会自动生成基本结构。 生成的页面结构如下： html12345678&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;我是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 此外，如果想配置网站图标，可以在存放页面的根目录中，使用favicon.ico图片作为网站图标。 2.1.4 关系元素的关系可以分为两类：嵌套和并列。 嵌套指的是不同层次的元素之间的关系，将被嵌套的元素置于嵌套元素之中，要求嵌套元素必须有双标签。示例： html12345&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 嵌套的元素之间存在父子关系： 父亲元素：对于title元素来说，head元素是其父亲元素。对于head元素来说，html元素是其父亲元素。 儿子元素：对于head元素来说，title元素是其儿子元素。对于html元素来说，head元素是其儿子元素。 祖先元素：对于title元素来说，head元素和html元素都是其祖先元素。父亲元素也是祖先元素的一种。 后代元素：对于html元素来说，head元素和title元素都是其后代元素。儿子元素也是后代元素的一种。 并列指的是相同层次的元素之间的关系，对元素的标签无要求。示例： html12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 并列的元素之间存在兄弟关系： 兄弟元素：对于body元素来说，head元素是其兄弟元素。对于head元素来说，body元素是其兄弟元素。 2.2 声明2.2.1 说明用于告知浏览器当前页面的版本。 页面的声明必须写在第一行，并且要写在html元素外面，即和html元素同级且在html元素上面。 格式： html1&lt;!DOCTYPE&gt; DOCTYPE是Document Type Declaration（文档类型声明）的缩写。 声明不是HTML标签，既不是单标签也不是双标签。 声明不区分大小写，可以按照个人习惯选择。 2.2.2 HTML4在HTML4中，确切的说是在HTML4.01及之前版本中，因为基于SGML（Standard Generalized Markup Language，标准通用标记语言），声明可能会指向DTD（Document Type Definition，文档类型定义）文件，这个文件定义了文档的结构和元素规则。 HTML4.01规定了三种不同的声明： Strict：最严格，包含所有元素和属性，不包括表象或过时的元素，框架集frameset是不允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; Transitional：较严格，包含所有元素和属性，包括表象或过时的元素，框架集frameset是不允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; Frameset：最宽松，包含所有元素和属性，包括表象或过时的元素，框架集frameset是允许使用的。示例：html1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; 2.2.3 HTML5在HTML5中不再基于SGML，因此不再依赖DTD文件，而是使用更简单的声明。示例： html1&lt;!DOCTYPE html&gt; 因为声明是向下兼容的，因此可以在HTML5的声明中编写HTML4的代码，但是不能在HTML4的声明中编写HTML5的代码。 2.3 属性属性用于给元素提供附加信息，在双标签中可以将属性写在开始标签中，在单标签中可以将属性写在/符号前。 属性一般由属性名和属性值组成，某些特殊属性也可以只有属性名，其属性值可以省略： 指定属性值省略属性值html1&lt;input type=&quot;password&quot;&gt;html1&lt;input disable&gt; 注意： 不同的元素有不同的属性，存在适用所有元素的通用属性，比如id属性用于在页面上作为元素的唯一标识。 属性名和属性值都是W3C规定好的，不能乱写。 属性名和属性值不区分大小写，推荐使用小写。 属性值的双引号也可以写成单引号，如果没有空格等特殊字符也可以不写，推荐使用双引号。 元素中如果出现同名属性，后面的属性会失效。 2.4 语言设置页面语言可以让浏览器显示对应的翻译提示，也可以方便搜索引擎的优化。 语言可以在html元素中使用lang属性设置，写法如下： html1&lt;html lang=&quot;zh-CN&quot;&gt; 其他语言的设置： zh-CN：中文-中国大陆（简体中文） zh-TW：中文-中国台湾（繁体中文） zh：中文 en-US：英语-美国 en-GB：英语-英国 2.5 字符集计算机本身是二进制的，为了方便使用，在写入时会对输入的数据进行编码，在读取时会对输出的数据进行解码。 在编码和解码时，需要使用字符集进行规范，解码需要使用和编码相同的字符集，否则会导致最终读取出来的内容产生乱码。 常见的字符集如下： ASCII：大写字母、小写字母、数字、一些符号，共计128个。 ISO 8859-1：在ASCII基础上，扩充了一些欧洲字符，比如希腊字符等，共计是256个。 GB2312：继续扩充，收录了6763个常用汉字和682个字符。 GBK：收录了的汉字和符号达到20000多个，支持繁体中文。 UTF-8：包含世界上所有的文字与符号。建议使用。 可以在head元素中通过meta元素配合charset属性指定页面的字符集，让浏览器使用这种字符集对页面内容进行解析： html123&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt; 2.6 注释使用注释可以对页面源码进行解释和说明，并且注释在展示的时候会被过滤掉，但是查看源码是可以看到的。 格式： html1&lt;!-- 注释内容，在页面上不可见 --&gt; 注意： 注释不支持嵌套，不要在注释里嵌套其他注释。 3 基础3.1 排版元素排版元素用于规范页面内容的显示。 常用的元素： 标签名 说明 单双 h1~h6 用于标识页面内容的6个标题级别，从h1到h6级别越来越低，元素里不能嵌套其他排版元素 双标签 p 用于表示页面内容的段落，元素里不能嵌套其他排版元素 双标签 div 无特殊含义，用于整体布局，元素里可以嵌套其他元素，包括排版元素 双标签 span 无特殊含义，用于局部修饰，元素里不能嵌套其他排版元素 双标签 3.2 语义化语义指的是元素的含义，某些元素是有特定含义的，比如p元素的含义是表示段落，某些元素是没有特定含义的，比如span元素。 语义化元素指的是具有特定含义的元素，这种元素有一定的优势： 代码结构清晰，方便阅读，有利于团队合作开发。 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。 有利于搜索引擎优化（SEO）。 在使用语义化元素时，应该关注元素特定含义，不应该关注元素样式，因为样式可以通过CSS进行调整。 常用的元素： 标签名 说明 单双 br 换行，如果只想增加段落间隔，建议使用CSS实现 单标签 hr 分隔，如果只想使用水平线，建议使用CSS实现 单标签 pre 按原文显示，一般用于在页面中嵌入大段代码 双标签 3.3 元素区块在页面上只能独占一行的元素被称为块级元素，比如div元素，在页面上不需要独占一行的元素被称为行内元素，比如span元素。 排版元素属于块级元素，是独占一行的。 一般情况下，在块级元素中可以嵌套块级元素和行内元素，在行内元素中只能嵌套行内元素，但某些特殊的块级元素不能嵌套： 标题元素h1~h6中不支持互相嵌套，也不建议在标题中嵌套其他块级元素。 段落元素p中不支持其他块级元素，建议分段并在段落中使用其他块级元素。 3.4 实体3.4.1 介绍在HTML中存在一些预留字符，比如标签的&lt;字符和&gt;字符。 浏览器默认会将预留字符识别为标签，如果想要在页面内容里使用预留字符，就需要用特殊形式的内容来表示这些预留字符，这种特殊形式的内容称为实体。 比如想要在页面中显示这句话： html1我记得&lt;div&gt;是块级元素 如果在代码中直接写的话，会导致页面将&lt;div&gt;解析为标签，而不是文本内容，解决办法就是使用实体替换预留字符。 再比如想要在页面中显示多个空格： html1这里有 三个空格 但是页面实际上会将多个空格合并为一个空格，想要强制显示多个空格，就需要使用实体。 3.4.2 规则实体的规则： 以&amp;符号开始。 以;符号结束。 如果使用实体名称，格式为&amp;实体名称;，如果使用实体编号，格式为&amp;#实体编号;。 实体名称更方便记忆，能使用实体名称就尽量使用实体名称，但是需要注意： 实体名称对大小写敏感。 并不是所有的预留字符都有实体名称。 部分浏览器可能不支持某些实体名称。 3.4.3 常见常见的预留字符对应的实体名称和实体编号如下： 预留字符 描述 实体名称 实体编号 &#38; 和 amp 38 &#60; 小于号 lt 60 &#62; 大于号 gt 62 &#160; 空格 nbsp 160 &#165; 元 yen 165 &#169; 版权 copy 169 &#174; 商标 reg 174 &#215; 乘号 times 215 &#247; 除号 divide 247 &#34; 双引号 quot 34 &#39; 单引号 无 39 &#96; 反引号 无 96 更多的对应关系可以参考文档：WHATWG实体 3.4.4 解决回到之前的问题，可以使用下面的代码实现： html12我记得&amp;lt;div&amp;gt;是块级元素这里有&amp;nbsp;&amp;nbsp;&amp;nbsp;三个空格","categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"}]},{"title":"使用GitHub图床存放博客静态资源","slug":"000-建站技术/001-Hexo/002-折腾/007-使用GitHub图床存放博客静态资源","date":"2024-03-10T06:15:20.000Z","updated":"2024-08-13T02:35:29.172Z","comments":true,"path":"posts/20240310/141520/","permalink":"https://momashanhe.com/posts/20240310/141520/","excerpt":"摘要：本文主要介绍了如何使用GitHub图床存放静态资源，并对静态资源的获取进行加速。","text":"摘要：本文主要介绍了如何使用GitHub图床存放静态资源，并对静态资源的获取进行加速。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 简介博客暂时还没有服务器进行备案，也不想使用别人的图床，就只能自己打一个比较简陋的了。 使用GitHub作为图床，但是需要注意不要超过1G容量，超过1G的时候需要想办法进行拆分。 使用NPM加速访问，实现CDN的效果。 2 GitHubGitHub官网：https://github.com/ 如果没有注册过GitHub的话，需要注册一个账号。 创建一个用于存储静态资源的仓库。 点击右上角个人头像，在下拉列表中点击Settings进入设置界面。 点击左侧菜单栏底部的Developer Settings进入开发者界面。 点击Personal access tokens选项，然后点击Tokens (classic)菜单，并在右侧点击Generate new token下拉列表中的Generate new token (classic)按钮： 在Note中输入对Token使用的描述，把Expiration设置为No expiration永不过期，然后给下面的Select scopes勾选repo选框： 最后点击底部的Generate token创建Token，并将页面上展示的Token进行复制保存，这个Token只会出现这一次，忘记只能重新生成。 将静态资源文件上传到仓库里。 3 NPM3.1 注册NPM官网：https://www.npmjs.com/ 注册NPM账号： 新账号注册后需要配置2FA认证： txt1You don’t have two-factor authentication (2FA) enabled on your account. Configure 2FA or visit our docs to learn more. 点击2FA认证链接，选择使用Authenticator app的方式认证： 在手机上下载Authenticator并安装，打开后选择扫描QR码然后扫描网页上的二维码，将生成的一次性密码代码输入底部的密码框中。 保存好生成的恢复代码，这里只出现一次，忘记需要重新生成。 3.2 本地仓库进入静态资源的本地仓库，执行以下命名切换回原生源： bash1npm config set registry https://registry.npmjs.org 如果是第一次使用，需要执行命令添加本地NPM用户配置，输入账户和密码以及邮箱即可： bash1npm adduser 如果不是第一次使用，执行登录命令，输入账户和密码以及邮箱即可： bash1npm login 如果命令行提示需要登录，在下面的网址里完成登录即可： bash1Create your account at: 在打包前准备好包名，需要事先确认包名没有重复，可以在NPM官网搜索相应包名，搜不到就说明还没被占用。 执行初始化命令，将仓库打包，按照指示进行配置： bash1npm init 根据实际情况填写，红框内的使用默认就好： 注意名称不要使用带有年月日的数字，不然会被认为垃圾名称发布失败，尽量是用-短横线分隔。 最后输入yes即可。 打包以后就可以发布了，执行命令： bash1npm publish --otp=123456 命令说明： –otp：需要输入Authenticator生成的一次性密码。 发布成功提示： 发布成功后，可以寻找NPM的节点使用，比如可以按照下面的方式使用： url1https://unpkg.com/:package@:version/:file 3.3 升级仓库以后使用静态资源的时候，先在本地试用，然后将静态资源同步到GitHub上，再发布NPM升级包。 使用命令增加NPM版本，版本由3位组成，从左到右分别是： major：主要版本，左边首位，不会向后兼容的重大改动。 minor：次要版本，中间位，向后兼容的新增功能。 patch：补丁版本，右边首位，向后兼容的缺陷修复。 如果需要更新补丁版本，执行如下命令即可，会自动给版本的patch部分加一： bash1npm version patch 然后执行发布命令： bash1npm publish --otp=123456 发布成功后修改使用的版本就可以了。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://momashanhe.com/tags/NPM/"}]},{"title":"博客图床对比","slug":"000-建站技术/001-Hexo/002-折腾/006-博客图床对比","date":"2024-03-10T03:31:45.000Z","updated":"2024-04-24T01:43:33.725Z","comments":true,"path":"posts/20240310/113145/","permalink":"https://momashanhe.com/posts/20240310/113145/","excerpt":"摘要：本文主要介绍了不同图床之间的区别。","text":"摘要：本文主要介绍了不同图床之间的区别。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 对比图床一般用来加速对博客图片的访问，实际上是一种专门存储图片的服务器，大致分为：个人图床，平台图床。 1.1 个人图床由个人搭建的图床，搭建之后将其公开，允许公众使用的图床。 代表： SM.MS图床：土豪兽兽建的图床，2015年开始正式运营，烧风自建的CDN，支持HTTPS地址。 路过图床：老牌图床，2011年开放，提供全球CDN，支持HTTPS地址。 去不图床：杜老师创建的图床，部署在腾讯云上，需要搭配CDN。 1.2 平台图床由大型服务商搭建的图床，安全性要比个人图床好，但也更贵一些，可能会有一些限制。 代表： GitHub：支持存储1G以内图片，稳定可靠，需要额外配置CDN。 腾讯云：稳定可靠，就是贵。 阿里云：稳定可靠，就是贵。 又拍云：需要在网站底部添加LOGO和官网链接，每月10G免费空间，每月10G免费CDN。 七牛云：免费流量不支持HTTPS地址，每月10G免费空间，每月15G免费CDN。 多吉云：域名需要在服务器进行ICP备案，每月10G免费空间，每月20G免费CDN。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"给博客加装Waline评论","slug":"000-建站技术/001-Hexo/002-折腾/005-给博客加装Waline评论","date":"2024-03-09T02:08:21.000Z","updated":"2024-04-24T01:48:11.467Z","comments":true,"path":"posts/20240309/100821/","permalink":"https://momashanhe.com/posts/20240309/100821/","excerpt":"摘要：本文主要介绍了通过使用LeanCloud数据库和Vercel服务器将Waline评论部署到Hexo博客。","text":"摘要：本文主要介绍了通过使用LeanCloud数据库和Vercel服务器将Waline评论部署到Hexo博客。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 Waline评论1.1 简介详情查看官方文档：Waline官方文档 - 快速上手 2 使用LeanCloud2.1 简介LeanCloud是针对移动应用的一站式云端服务，专注于为应用开发者提供工具和平台。提供包括LeanStorage数据存储、LeanMessage通信服务、LeanAnalytics统计分析、LeanModules拓展模块等四大类型的后端云服务，加速应用开发。 加装Waline评论主要使用LeanCloud的LeanStorage数据存储功能。 LeanCloud中文官网：https://www.leancloud.cn/ 2.2 注册账号并创建应用注册LeanCloud账号，分为中国大陆版和国际版，区别是中国大陆版需要绑定手机、实名认证、备案域名，国际版不需要，这里注册国际版就能满足要求。 国际版注册链接：https://console.leancloud.app/register 输入注册信息，然后在邮箱中验证邮件完成注册。 点击创建应用并选择免费的开发版，创建用于Waline的应用： 进入应用，在左侧的导航栏内进入设置下的应用凭证界面，记录认证信息以便后续使用： 3 使用Vercel3.1 创建项目创建账户并登录到Vercel，在Waline提供的文档里找到快速创建Vercel项目的链接。 快速链接：部署Waline到Vercel 输入GitHub项目名称后会自动在GitHub上创建项目，然后会在Vercel上自动部署，首次部署后需要设置环境变量。 3.2 配置项目进入刚刚创建的项目界面，切换到Settings标签。 在左侧导航栏点击Environment Variables设置，配置LEAN_ID、LEAN_KEY、LEAN_MASTER_KEY三个环境变量，值为上面LeanCloud里的应用凭证里的认证信息： 如果使用LeanCloud国内版，需要额外配置LEAN_SERVER环境变量，值为绑定的域名。 切换到Deployments标签，点击任意一项后面的...并在下拉选项中选择Redeploy，点击弹出界面下方的Redeploy重新部署。 在Domains中的https://xxx.vercel.app地址即为环境ID。 4 前端部署4.1 选择评论系统在主题的配置文件中选择Waline作为评论系统。 特殊配置参考官方文档即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://momashanhe.com/tags/LeanCloud/"},{"name":"Waline","slug":"Waline","permalink":"https://momashanhe.com/tags/Waline/"}]},{"title":"给博客加装Twikoo评论","slug":"000-建站技术/001-Hexo/002-折腾/004-给博客加装Twikoo评论","date":"2024-03-03T07:21:02.000Z","updated":"2024-04-24T01:48:13.664Z","comments":true,"path":"posts/20240303/152102/","permalink":"https://momashanhe.com/posts/20240303/152102/","excerpt":"摘要：本文主要介绍了通过使用MongoDB数据库和Vercel服务器将Twikoo评论部署到Hexo博客。","text":"摘要：本文主要介绍了通过使用MongoDB数据库和Vercel服务器将Twikoo评论部署到Hexo博客。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 Twikoo评论1.1 简介详情查看官方文档：Twikoo官方文档 - 快速上手 2 使用MongoDB2.1 简介MongoDB是一款流行的开源文档型数据库，用于存储文档类型的数据，比如博客产生的评论。 MongoDB中文官网：https://www.mongodb.com/zh-cn/ 如果有云服务器，可以在服务器上使用MongoDB本地数据库，如果没有云服务器，可以使用MongoDB Atlas云数据库。 2.2 注册账号并创建集群注册MongoDB账号，然后在邮箱中验证邮件完成注册。 在Overview界面中可以设置组织名和项目名，然后创建一个集群： 在区域选择界面，选择免费的，提供商Provider选择AWS亚马逊即可，区域Region选择N. Virginia (us-east-1)弗吉尼亚州，也可以选择其他的。 继续设置Name集群名称，默认使用Cluster0作为集群名称，可以自定义，一旦设定不可修改。 继续设置Tag标签，这是可选的。 点击页面下方的Create创建免费集群。 2.3 创建用户进入Database Access界面，创建用户。 选择Password作为认证方式，输入用户和密码，这个用户是用来登录云数据库的，因此密码尽量设置的难一些： 继续设置用户权限，点击Add Built In Role并选择Atlas Admin选项： 点击页面下方的Add User创建用户。 2.4 设置IP地址进入Network Access界面，添加能访问云数据库的IP地址。 点击Allow Access from Anywhere或者在Access List Entry输入0.0.0.0/0表示允许所有IP地址的连接，点击Confirm保存设置： 2.5 查看如何连接进入Database界面，点击集群后面的Connect建立连接，连接方式选择Drivers使用驱动连接： 使用Driver默认的Node.js作为驱动，使用Version默认的5.5 or later作为版本： 复制下方mongodb+srv开头的字符串，并将&lt;password&gt;修改为创建用户时设置的密码，将这个数据库连接字符串复制并保存，后面需要用到。 点击页面下方的Close关闭退出即可。 3 使用Vercel3.1 创建项目创建账户并登录到Vercel，在Twikoo提供的文档里找到快速创建Vercel项目的链接。 快速链接：部署Twikoo到Vercel 输入GitHub项目名称后会自动在GitHub上创建项目，然后会在Vercel上自动部署，首次部署后会提示需要设置MONGODB_URI环境变量。 3.2 配置项目进入刚刚创建的项目界面，切换到Settings标签。 在左侧导航栏点击Environment Variables设置，在Key中输入MONGODB_URI，在Value中输入前面设置MongoDB保存的数据库连接字符串，点击Save保存： 在左侧导航栏点击Environment Variables设置，将Vercel Authentication设置为Disable，点击Save保存，这是关闭对项目的登录保护，支持任何人访问项目： 切换到Deployments标签，点击任意一项后面的...并在下拉选项中选择Redeploy，点击弹出界面下方的Redeploy重新部署，如果环境配置正确，可以看到提示： 在Domains中的https://xxx.vercel.app地址即为环境ID。 4 前端部署4.1 选择评论系统在主题的配置文件中选择Twikoo作为评论系统。 特殊配置参考官方文档即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://momashanhe.com/tags/Twikoo/"}]},{"title":"博客评论系统对比","slug":"000-建站技术/001-Hexo/002-折腾/003-博客评论系统对比","date":"2024-03-03T05:12:51.000Z","updated":"2024-04-24T01:43:01.414Z","comments":true,"path":"posts/20240303/131251/","permalink":"https://momashanhe.com/posts/20240303/131251/","excerpt":"摘要：本文主要介绍了不同评论系统之间的区别。","text":"摘要：本文主要介绍了不同评论系统之间的区别。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 对比Hexo支持的评论系统有很多，大致分为：GitHub系列，Vercel系列，云服务器系列。 1.1 GitHub系列这种方式基于GitHub，使用Discussions功能或者Issue功能实现评论。 代表： Giscus：基于GitHub的Discussions功能。 Gitalk：基于GitHub的Issue功能。 Beaudar：基于GitHub的Issue功能。 Utterances：基于GitHub的Issue功能。 优点是使用简单，不用注册额外数据库和服务器。 缺点是数据管理不方便，不能通过数据库维护评论。 出于数据管理方面的考虑，不太推荐这种方式。 1.2 Vercel系列这种方式基于Vercel服务器，借助免费版的Vercel服务器，以及免费版的云数据库，将评论系统部署到Vercel服务器，将评论存储到数据库中。 代表： Twikoo：支持多种部署方式，支持自动填写浏览数，支持获取评论数。 Waline：支持多种部署方式，支持自动填写浏览数和评论数。 优点是免费，免费版的资源足够个人使用了，而且有一些额外功能，比如统计浏览数和评论数。 缺点是需要注册相关账户，使用额外功能需要进行额外配置。 在不考虑购买服务器的情况下，推荐这种方式。 1.3 云服务器系列这种方式基于云服务器，需要购买云服务器资源，然后在云服务器上安装数据库，将评论系统部署到云服务器，将评论存储到数据库中。 代表： Artalk：部署在服务器上，功能强大的评论系统。 优点是安全，评论系统提供的功能更为强大。 缺点是需要购买云服务器资源，有一定的开销，并且需要对数据库和服务器有一定的了解。 不差钱的情况下，推荐这种方式。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"使用Vercel托管博客","slug":"000-建站技术/001-Hexo/002-折腾/002-使用Vercel托管博客","date":"2024-03-03T03:23:21.000Z","updated":"2024-04-24T01:48:18.470Z","comments":true,"path":"posts/20240303/112321/","permalink":"https://momashanhe.com/posts/20240303/112321/","excerpt":"摘要：本文主要介绍了如何将博客托管到Vercel云平台。","text":"摘要：本文主要介绍了如何将博客托管到Vercel云平台。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 使用Vercel1.1 简介Vercel是一个云服务平台，可以用于部署静态网站，也用于部署一些没有接口数据交互的动态网站。 对于个人博客，在Vercel上部署类似于在GitHub Pages上进行部署，但是Vercel的访问速度要比GitHub Pages好太多，因此许多博主都将博客部署在Vercel上。 Vercel官网：https://vercel.com/ 1.2 注册在注册时选择私人目的，不要选择商业目的： 选择邮箱注册，在邮箱收到链接后验证完成注册。 1.3 部署1. 通过本地手动部署2. 通过GitHub Pages博客项目自动部署3. 通过GitHub博客源码项目自动部署这种方式不需要访问GitHub，是通过本地命令的方式进行部署的。 类似于将本地博客部署到GitHub Pages需要安装插件，将本地博客部署到Vercel也需要安装插件。 在博客目录打开bash命令行，安装Vercel插件，需要进行全局安装： bash1npm install vercel -g 执行命令将博客部署到平台，首次执行会登录Vercel平台，然后进行一些设置，可以直接回车使用默认设置： bash1vercel 部署完成后会提示生成的链接，通过链接可以访问博客。 还有一些常用命令，可以在官网学习。 推荐方式之一，从本地可以直接部署到Vercel平台，简单快速。进入Vercel项目管理界面，打开Overview并在右侧点击Add New...下拉列表中的Project选项： 在导入项目管理界面点击Continue with GitHub并在弹出的界面上完成GitHub授权： 在导入项目管理界面可以看到刚刚导入的项目，点击项目后面的Install并在弹出的界面上选择Only select repositories选项，在Select repositories下拉列表中选择GitHub Pages博客项目，点击Install执行安装，输入GitHub密码将项目从GitHub复制到Vercel上。 在导入项目管理界面点击项目右侧的Import，进入设置和部署界面： 设置和部署： 设置Vercel中的项目名，可以使用默认的。 设置框架，自动识别为Other框架，可以使用默认的，因为项目中只有静态文件，不需要使用框架部署。 检查并设置部署命令，可以使用默认配置，点击Deploy在Vercel上进行部署。 等到部署结束，会跳转到祝贺页面，能够看到博客的缩略图，点击即可通过Vercel提供的链接访问博客。 当对GitHub Pages博客项目进行推送时，会触发Vercel的自动部署。 推荐方式之一，不需要对现有流程进行更改，不需要考虑在Vercel上部署带来的一系列问题。进入Vercel项目管理界面，打开Overview并在右侧点击Add New...下拉列表中的Project选项： 在导入项目管理界面点击Continue with GitHub并在弹出的界面上完成GitHub授权： 在导入项目管理界面可以看到刚刚导入的项目，点击项目后面的Install并在弹出的界面上选择Only select repositories选项，在Select repositories下拉列表中选择GitHub博客源码项目，点击Install执行安装，输入GitHub密码将项目从GitHub复制到Vercel上。 在导入项目管理界面点击项目右侧的Import，进入设置和部署界面： 设置和部署： 设置Vercel中的项目名，可以使用默认的。 设置框架，支持自动识别比如Hexo框架，如果不对可以修改。 检查并设置部署命令，可以使用默认配置，点击Deploy在Vercel上进行部署。 等到部署结束，会跳转到祝贺页面，能够看到博客的缩略图，点击即可通过Vercel提供的链接访问博客。 当对GitHub博客源码项目进行推送时，会触发Vercel的自动部署。 不推荐这种方式，在某些情况下会出现问题，将主题项目作为子模块或者子项目，会导致部署后进入博客白屏。 1.4 设置域名进入Vercel项目管理界面，点击创建的博客项目进入项目界面，切换到Settings标签，在左侧导航栏点击Domains设置： 在输入框中输入购买的域名，点击Add添加。 根据提示去域名服务商配置域名解析，将指向GitHub Pages改为指向Vercel。 之后等待域名生效即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"}]},{"title":"给博客添加徽标","slug":"000-建站技术/001-Hexo/002-折腾/001-给博客添加徽标","date":"2024-03-03T02:25:43.000Z","updated":"2024-04-24T01:45:36.831Z","comments":true,"path":"posts/20240303/102543/","permalink":"https://momashanhe.com/posts/20240303/102543/","excerpt":"摘要：本文主要介绍了如何给博客添加自定义徽标。","text":"摘要：本文主要介绍了如何给博客添加自定义徽标。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 静态徽标1.1 语法徽标生成网站：https://shields.io/ 通过访问特定链接就能生成自定义徽标，特定链接的语法： url1https://img.shields.io/badge/前缀-后缀-颜色?参数 特定链接使用-短横线分隔，如果用到了特殊字符需要转义： 需要 空格，则使用_下划线或者%20表示。 需要_下划线，则使用__双下划线表示。 需要-短横线，则使用--双短横线表示。 颜色支持十六进制、RGB、RGBA、HSL、HSLA和CSS进行表达。 样式： 可以使用img标签引用，也可以使用object标签引用： 1. img2. object不支持点击徽标跳转链接，需要包装跳转链接。 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue&quot;&gt;&lt;/a&gt;支持点击徽标跳转链接。 写法： html1&lt;object data=&quot;https://img.shields.io/badge/left-right-blue&quot;&gt;&lt;/object&gt; 1.2 参数1.2.1 类型类型参数名为style，类型参数值支持多种。 1. flat2. flat-square3. plastic4. for-the-badge5. social扁平，默认，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue?style=flat&quot;&gt;&lt;/a&gt;方角扁平，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue?style=flat-square&quot;&gt;&lt;/a&gt;塑料质感，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue?style=plastic&quot;&gt;&lt;/a&gt;放大版，同时字母大写，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue?style=for-the-badge&quot;&gt;&lt;/a&gt;后缀改为聊天气泡，样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-blue?style=social&quot;&gt;&lt;/a&gt; 1.2.2 标签左侧标签参数名为label，左侧标签颜色参数名为labelColor，右侧标签颜色参数名为color，支持重写左侧标签和自定义两侧标签颜色。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-90EE90?label=edit&amp;labelColor=A9A9A9&amp;color=FF0000&quot;&gt;&lt;/a&gt; 1.2.3 链接链接参数名为link，链接参数值支持自定义链接，用于点击徽标进行跳转。 只有使用object标签才支持跳转，使用img标签需要包装跳转链接。 样式： 写法： html1&lt;a href=&quot;https://shields.io/&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-90EE90&quot;&gt;&lt;/a&gt; 1.2.4 LOGOLOGO参数名为logo，LOGO颜色参数名为logoColor，参数值支持从网站获取。 获取参数值：https://simpleicons.org/ 在上述网站中可以找到支持的LOGO名称和颜色，也可以复制下载SVG格式的图标。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/left-right-90EE90?logo=hexo&amp;logoColor=0E83CD&quot;&gt;&lt;/a&gt; 2 动态徽标2.1 通过URL获取的文件内容语法： url1https://img.shields.io/badge/dynamic/类型?参数 支持的文件类型有： json toml xml yaml 参数沿用静态徽标的参数，并且新增了url参数和query参数，用于指定文件地址和属性名，属性名前使用$.作为前缀。 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/dynamic/json?url=https://github.com/badges/shields/raw/master/package.json&amp;query=$.name&quot;&gt;&lt;/a&gt; 2.2 通过URL获取的响应内容语法： url1https://img.shields.io/endpoint?参数 参数沿用静态徽标的参数，并且新增了url参数，用于请求地址。 请求地址需要响应的内容： schemaVersion：版本，必填，总是设置为1。 style：类型，非必填，默认是flat。 label：左侧标签内容，可以设置为空字符串，必填。 message：右侧标签内容，不能设置为空字符串，必填。 labelColor：左侧标签颜色，非必填，默认是grey。 color：右侧标签颜色，非必填，默认是lightgrey。 namedLogo：LOGO对应名字，非必填，默认不传。 logoSvg：LOGO对应的SVG字符串，非必填，默认不传。 logoColor：LOGO颜色，非必填，默认不传。 isError：非必填，默认否。 请求url得到的响应内容： json1&#123; &quot;schemaVersion&quot;: 1, &quot;label&quot;: &quot;is it monday&quot;, &quot;message&quot;: &quot;no&quot;, &quot;color&quot;: &quot;orange&quot; &#125; 样式： 写法： html1&lt;a href=&quot;javascript:void(0);&quot; title=&quot;shields&quot;&gt;&lt;img src=&quot;https://img.shields.io/endpoint?url=https://shields.redsparr0w.com/2473/monday&quot;&gt;&lt;/a&gt;","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"设置博客主题","slug":"000-建站技术/001-Hexo/001-搭建/006-设置博客主题","date":"2024-02-26T14:39:23.000Z","updated":"2024-03-17T03:22:43.215Z","comments":true,"path":"posts/20240226/223923/","permalink":"https://momashanhe.com/posts/20240226/223923/","excerpt":"摘要：本文主要介绍如何设置博客主题。","text":"摘要：本文主要介绍如何设置博客主题。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 设置主题对于在GitHub上的主题，有四种方式进行设置，四种方式各有优缺点。 1. 下载并解压2. 安装3. 克隆主题作为子模块4. 克隆主题作为子项目下载并解压主题到博客目录的themes目录中。 最简单的方式，特点如下：是否支持通过命令更新主题：否，需要重新下载。本地是否存储主题代码：是，可以修改主题。远程是否存储主题代码：是，保留主题代码。 适用场景：是否需要使用新版主题：否。是否会对主题进行更改：是。安装主题到博客： bash1npm install hexo-theme-themename 最节省空间的方式，特点如下：是否支持通过命令更新主题：是，支持通过npm install命令更新主题，更新前需要在package.json中将版本号改为*。本地是否存储主题代码：否，不可以修改主题。远程是否存储主题代码：否，不保留主题代码。 适用场景：是否需要使用新版主题：是。是否会对主题进行更改：否。通过git submodule add命令将GitHub上的主题项目克隆到本地，作为博客项目的子模块： bash1git submodule add git@github.com:username/hexo-theme-themename.git themes/themename 较为兼容的方式，特点如下：是否支持通过命令更新主题：是，支持通过git pull命令更新主题。本地是否存储主题代码：是，可以修改主题。远程是否存储主题代码：否，不保留主题代码，但是会保留主题子模块链接。 适用场景：是否需要使用新版主题：是。是否会对主题进行更改：是。通过git clone命令将GitHub上的主题项目克隆到本地，作为博客项目的子项目： bash1git clone git@github.com:username/hexo-theme-themename.git themes/themename 建议使用这种方式，特点如下：是否支持通过命令更新主题：是，支持通过git pull命令更新主题。本地是否存储主题代码：是，可以修改主题。远程是否存储主题代码：否，不保留主题代码。 适用场景：是否需要使用新版主题：是。是否会对主题进行更改：是。 打开_config.yml配置文件，设置theme的值为主题中指定的名字。 根据主题说明文件，创建_config.themename.yml主题专用配置文件，按照主题说明文档修改配置即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"在文章中插入本地图片","slug":"000-建站技术/001-Hexo/001-搭建/005-在文章中插入本地图片","date":"2024-02-26T13:15:23.000Z","updated":"2024-03-17T03:22:43.784Z","comments":true,"path":"posts/20240226/211523/","permalink":"https://momashanhe.com/posts/20240226/211523/","excerpt":"摘要：本文主要介绍如何在文章中插入本地图片。","text":"摘要：本文主要介绍如何在文章中插入本地图片。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 插入图片进入博客目录，修改_config.yml配置文件，启动资源目录： _config.yml1post_asset_folder: true 在博客目录打开bash命令行，安装插件： bash1npm install hexo-image-link --save 每次创建博客时，都会创建同名目录，通过相对路径引用同名目录里的图片即可。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"给文章设置模板和永久链接","slug":"000-建站技术/001-Hexo/001-搭建/004-给文章设置模板和永久链接","date":"2024-02-26T12:13:52.000Z","updated":"2024-04-24T01:07:07.249Z","comments":true,"path":"posts/20240226/201352/","permalink":"https://momashanhe.com/posts/20240226/201352/","excerpt":"摘要：本文主要介绍如何给文章设置模板和永久链接。","text":"摘要：本文主要介绍如何给文章设置模板和永久链接。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 模板进入博客目录，打开scaffolds目录，修改post.md模板，这是默认模板： post.md12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:---摘要：&lt;!-- more --&gt; 进入博客目录，打开scaffolds目录，修改draft.md模板： draft.md123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 2 永久链接修改博客目录下的_config.yml配置文件： _config.yml12url: https://username.com/permalink: posts/:year:month:day/:hour:minute:second/ 把url改为自己的域名即可，这种永久链接的好处是采用文章创建时间里的元素作为永久链接，即使文章路径或者文章标题发生改动，也不会对已生成的链接产生影响。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]},{"title":"将博客源码上传到GitHub","slug":"000-建站技术/001-Hexo/001-搭建/003-将博客源码上传到GitHub","date":"2024-02-26T09:26:37.000Z","updated":"2024-08-13T02:51:50.270Z","comments":true,"path":"posts/20240226/172637/","permalink":"https://momashanhe.com/posts/20240226/172637/","excerpt":"摘要：本文主要介绍如何将博客源码上传到GitHub。","text":"摘要：本文主要介绍如何将博客源码上传到GitHub。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 创建私有源码仓库登录GitHub，创建一个名称为username.source的私有仓库，把username改为GitHub的用户名。 2 创建说明文档和许可证明进入博客目录，创建README.md说明文档，输入对项目的简单介绍，创建LICENSE许可证明，并设置许可类型。 3 同步源码进入博客目录，右键进入bash命令行，执行命令初始化为Git仓库： bash1git init 结果如下： 因为GitHub新的仓库默认分支已经改成了main，但本地还是master，所以执行命令将本地分支改为main： bash1git branch -M main 结果如下： 修改.gitignore配置文件： .gitignore12345678910.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.deploy_git*/_multiconfig.yml.github*/ 右键进入bash命令行，设置当前目录用户名和邮箱： bash12git config --local user.name usernamegit config --local user.email username@163.com 添加至暂存： bash1git add . 提交更改并注释： bash1git commit -m &quot;init(博客): 初始化博客&quot; 添加远程仓库： bash1git remote add origin git@github.com:username/username.source.git 推送到远程仓库： bash1git push -u origin main","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"}]},{"title":"将博客部署到GitHub","slug":"000-建站技术/001-Hexo/001-搭建/002-将博客部署到GitHub","date":"2024-02-26T07:34:29.000Z","updated":"2024-08-13T02:52:04.320Z","comments":true,"path":"posts/20240226/153429/","permalink":"https://momashanhe.com/posts/20240226/153429/","excerpt":"摘要：本文主要介绍如何将博客部署到GitHub。","text":"摘要：本文主要介绍如何将博客部署到GitHub。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 配置GitHub1.1 登录注册并登录GitHub。 1.2 生成SSH公钥打开资源管理器，在地址栏输入C:\\Users\\登录用户\\.ssh并回车进入，查看登录用户目录里有没有.ssh目录： 根据目录是否存在： 目录存在目录不存在如果目录存在，说明以前设置过.ssh目录，如果没用了就删掉，如果还有用就需要参考SSH配置多用户，在此先不做介绍了。如果目录不存在，进入上级C:\\Users\\登录用户目录，右键进入bash命令行，执行命令生成SSH秘钥和公钥： bash1ssh-keygen -t rsa -C 个人邮箱 命令说明： -t：指定密钥类型，默认是rsa，可以省略。 -C：设置注释文字，一般会设置为个人邮箱。 执行命令后，会提示置生成的秘钥和公钥名称，默认是id_rsa作为名称，回车使用默认名称。 继续执行，还会提示设置密码和确认密码，回车设置为空。 命令最终执行如下： 此时会在登录用户目录里生成.ssh目录，打开id_rsa.pub公钥文件并复制内容。 1.3 配置SSH公钥进入GitHub点击个人头像，选择Settings进入设置页面，在左侧找到SSH and GPG keys设置，在顶部的SSH keys模块中，点击右侧的New SSH key按钮新增配置： 在添加配置的页面中，设置Title的配置名称，然后设置Key中的公钥，粘贴刚刚复制的公钥文件内容，然后点击底部的Add SSH key按钮保存配置。 使用ssh -T git@github.com命令测试通过SSH能否连接到GitHub： 如果提示确认输入，就按照提示输入yes然后回车即可连接成功，下次在测试就没有这个提示了，同时在.ssh目录中会增加known_hosts的配置文件。 2 部署GitHub2.1 创建仓库登录GitHub，创建一个名称为username.github.io的公共仓库，把username改为GitHub的用户名。 这种仓库是GitHub Pages仓库，一个用户只能创建一个这种仓库，创建后允许用户将仓库发布为一个静态网站，网址就是username.github.io仓库名称。 2.2 安装插件进入博客目录，右键进入bash命令行，安装部署到GitHub上的插件： bash1npm install hexo-deployer-git --save 修改博客目录下的_config.yml配置文件，修改底部的deploy配置项，如果没有找到则自己添加： _config.yml12345678# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: github: url: git@github.com:username/username.github.io.git branch: main 2.3 发布进入博客目录，右键进入bash命令行，执行命令清理博客、生成博客、发布博客： bash123hexo cleanhexo generatehexo deploy 发布后如果提示未知身份： 说明需要设置用户名和邮箱，有两种方式： 方式一：全局设置，按照提示设置全局用户名和邮箱：bash12git config --global user.name usernamegit config --global user.email username@163.com 方式二：本地设置，进入博客目录下的.deploy_git发布目录，右键进入bash命令行，设置发布目录的用户名和邮箱：bash12git config --local user.name usernamegit config --local user.email username@163.com 然后重新发布，通过GitHub访问博客：https://username.github.io 3 域名解析3.1 域名通过阿里云或者腾讯云，或者其他服务商，都可以购买域名。 3.2 解析打开cmd命令行，输入命令查询IP地址： cmd1ping username.github.io 进入域名解析页面，配置域名解析： 新增记录，主机记录为@，记录类型为A，记录值为上面查到的IP地址，TTL使用默认的600即可。 新增记录，主机记录为www，记录类型为CNAME，记录值为GitHub访问博客的地址，TTL使用默认的600即可。 3.3 配置进入博客目录下的source目录，新建CNAME文件，注意不要有后缀名，打开后添加域名并保存。 进入仓库页面，点击仓库页面右上角的Settings标签，在左侧菜单栏中找到Pages配置页，找到Custom domain填入域名并保存。 将博客重新发布后就可以通过域名访问了。","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"}]},{"title":"本地安装Hexo博客","slug":"000-建站技术/001-Hexo/001-搭建/001-本地安装Hexo博客","date":"2024-02-26T03:13:54.000Z","updated":"2024-06-27T08:02:03.360Z","comments":true,"path":"posts/20240226/111354/","permalink":"https://momashanhe.com/posts/20240226/111354/","excerpt":"摘要：本文主要介绍如何下载和安装Hexo。","text":"摘要：本文主要介绍如何下载和安装Hexo。 环境 Windows 10 企业版 LTSC 21H2Node 18.14.0NPM 9.3.1Git 2.37.3Hexo 4.3.1 1 简介Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官网：https://hexo.io/zh-cn 2 环境2.1 安装Git由于初始化博客目录需要Git支持，并且Hexo的某些命令需要在bash命令行中执行，因此需要安装Git工具。 下载方式： 方式一：官网下载最新版：https://git-scm.com 方式二：通过GitHub选择2.37.3版本下载，历史版本下载地址：v2.37.3.windows.1&#x2F; 方式三：通过淘宝镜像下载，比GitHub访问速度快：v2.37.3.windows.1&#x2F; 如果不太了解Git工具，可以使用默认设置安装。 安装结束后，右键选择Git Bash Here进入bash命令行： 输入git --version命令查看Git的安装版本： 需要注意的是，默认安装的2.37.3版本在初始化本地Git项目的时候，默认创建的分支还是master分支，可以在安装的时候自定义： 2.2 安装NodeHexo基于Node，搭建过程中还需要使用NPM（Node包管理工具，安装Node时默认安装）。 下载方式： 方式一：官网下载最新版：https://nodejs.org/en 方式二：本文使用的版本不是最新版，是18.14.0版本。下载地址：v18.14.0&#x2F; 使用默认配置安装结束后，打开cmd命令行，输入npm -v命令和node -v命令查询NPM版本和Node版本： NPM是包管理工具，通过命令将安装包使用的源设置为淘宝镜像，速度会快一些： bash1npm config set registry https://registry.npmmirror.com 使用命令查看安装使用的源： bash1npm config get registry 2.3 安装Hexo在cmd命令行中使用NPM安装Hexo： bash1npm install hexo-cli -g 安装结束后，使用hexo -v命令查看Hexo版本： 3 使用3.1 初始化博客目录在电脑中新建博客目录，右键进入bash命令行，使用命令初始化博客目录： bash1hexo init 结果如下： 3.2 博客预览使用hexo generate命令生成博客内容，也可以简写为hexo g命令。 结果如下： 使用hexo server命令启动本地预览，也可以简写为hexo s命令。 结果如下： 根据提示，在浏览器输入地址访问博客：http://localhost:4000/ 可以看到博客的默认界面： 可以使用Ctrl+C命令停止博客。 3.3 新建文章使用命令创建文章： bash1hexo new test 执行后创建标题为test的文章，在博客名录下的source目录中的_posts目录中会自动新增对应的Markdown文件： 也可以指定文字标题和文章路径： bash1hexo new post test -p demo/test 可以通过文本编辑器修改文章，保存后在本地预览： bash1hexo clean &amp;&amp; hexo s 3.4 站点设置修改博客目录下的_config.yml配置文件，修改的Site配置项，修改站点属性。 4 分类和标签4.1 分类进入博客目录，打开bash命令行，添加分类页： bash1hexo new page categories 打开sources/categories/index.md文件，增加分类配置： index.md12345---title: 所有分类date: 2024-02-25 21:45:11type: &quot;categories&quot;--- 使用分类： index.md123---categories: --- 4.2 标签进入博客目录，打开bash命令行，添加标签页： bash1hexo new page tags 打开sources/tags/index.md文件，增加标签配置： index.md12345---title: 所有标签date: 2024-02-25 21:53:29type: &quot;tags&quot;--- 使用标签： index.md123---tags: []---","categories":[{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"}]}],"categories":[{"name":"大前端","slug":"大前端","permalink":"https://momashanhe.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"建站技术","slug":"建站技术","permalink":"https://momashanhe.com/categories/%E5%BB%BA%E7%AB%99%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://momashanhe.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"https://momashanhe.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://momashanhe.com/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"https://momashanhe.com/tags/Less/"},{"name":"Hexo","slug":"Hexo","permalink":"https://momashanhe.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://momashanhe.com/tags/GitHub/"},{"name":"NPM","slug":"NPM","permalink":"https://momashanhe.com/tags/NPM/"},{"name":"Vercel","slug":"Vercel","permalink":"https://momashanhe.com/tags/Vercel/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://momashanhe.com/tags/LeanCloud/"},{"name":"Waline","slug":"Waline","permalink":"https://momashanhe.com/tags/Waline/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://momashanhe.com/tags/MongoDB/"},{"name":"Twikoo","slug":"Twikoo","permalink":"https://momashanhe.com/tags/Twikoo/"}]}
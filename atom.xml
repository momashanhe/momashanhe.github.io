<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>墨码山河</title>
  
  <subtitle>代码改变世界</subtitle>
  <link href="https://momashanhe.com/atom.xml" rel="self"/>
  
  <link href="https://momashanhe.com/"/>
  <updated>2025-08-06T03:49:14.873Z</updated>
  <id>https://momashanhe.com/</id>
  
  <author>
    <name>墨码山河</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾回收</title>
    <link href="https://momashanhe.com/posts/20250803/194843/"/>
    <id>https://momashanhe.com/posts/20250803/194843/</id>
    <published>2025-08-03T11:48:43.000Z</published>
    <updated>2025-08-06T03:49:14.873Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了虚拟机的垃圾回收机制。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1 垃圾回收"></a>1 垃圾回收</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>垃圾回收机制是由垃圾收集器GC（Garbage Collection）实现的，GC是后台的守护进程。</p><p>GC的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况调整优先级，在内存低到一定限度时会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。</p><h3 id="1-2-发生位置"><a href="#1-2-发生位置" class="headerlink" title="1.2 发生位置"></a>1.2 发生位置</h3><p>JVM的内存结构包括五大区域：程序计数器、本地方法栈、虚拟机栈、堆区、方法区。</p><p>程序计数器、本地方法栈、虚拟机栈三个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p><p>堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p><h3 id="1-3-内存泄漏"><a href="#1-3-内存泄漏" class="headerlink" title="1.3 内存泄漏"></a>1.3 内存泄漏</h3><p>内存泄漏指的是无法回收不再使用的对象，导致内存中没有空闲空间。</p><p>内存泄漏的八种情况：</p><ol><li>单例模式，单例模式中的对象生命周期和应用程序是一样长的，如果单例程序中持有外部对象的引用，这个外部引用就不能被回收。</li><li>资源未被关闭，数据库连接和网络连接以及输入输出流都需要手动关闭，否则不能被回收。</li><li>静态集合类，如果这些容器为静态的，那么它们的生命周期与应用程序一致，容器中的对象在程序结束之前将不能被释放，不能被回收。</li><li>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用也不能被回收。</li><li>改变哈希值，当对象被存入HashSet中后，就不能再修改这个对象的哈希值了，否则就会导致无法从HashSet中检索到该对象，这个对象就不能被回收。</li><li>不合理的作用域，变量定义的作用范围大于其使用范围，可能会导致内存泄漏，另外，如果没有及时将对象置空，这个对象就不能被回收。</li><li>缓存泄漏，一旦将对象放入到缓存中，就会很容易遗忘缓存对象，缓存对象就不能被回收。</li><li>监听器和回调，如果客户端在接口中注册回调，但没有显示取消，相关对象就不能被回收。</li></ol><h3 id="1-4-内存溢出"><a href="#1-4-内存溢出" class="headerlink" title="1.4 内存溢出"></a>1.4 内存溢出</h3><p>内存溢出指的是定义的对象占用的内存过大，需要的内存溢出了内存空间。</p><h3 id="1-5-STW"><a href="#1-5-STW" class="headerlink" title="1.5 STW"></a>1.5 STW</h3><p>STW（Stop The World）指的是GC事件发生过程中，会产生应用程序的停顿，整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉。</p><h3 id="1-6-安全点和安全区域"><a href="#1-6-安全点和安全区域" class="headerlink" title="1.6 安全点和安全区域"></a>1.6 安全点和安全区域</h3><h4 id="1-6-1-安全点"><a href="#1-6-1-安全点" class="headerlink" title="1.6.1 安全点"></a>1.6.1 安全点</h4><p>从线程角度看，安全点（Safe Point）可以理解成是在代码执行过程中的一些特殊位置，在线程执行到这些位置时，说明虚拟机当前的状态是安全的。</p><p>安全点的选择很重要，太少会导致等待进入安全点的时间过长，太多会导致性能问题，可以将执行时间较长的程序作为安全点，比如方法调用、循环跳转、异常跳转等。</p><p>对于一些需要暂停的操作，比如STW，需要等线程进入安全点才能执行，线程进入安全点的方式有两种：</p><ul><li>抢先式中断：首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点。过时，目前没有虚拟机采用。</li><li>主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul><h4 id="1-6-2-安全区域"><a href="#1-6-2-安全区域" class="headerlink" title="1.6.2 安全区域"></a>1.6.2 安全区域</h4><p>当需要暂停线程时，如果线程正在执行可以等待进入安全点，但如果线程处于休眠状态或者阻塞状态，等待时间就会变得很长。</p><p>为了解决这个问题，引入了安全区域的概念。</p><p>安全区域是指在一段代码片中，引用关系不会发生改变，在这个区域中的任何位置开始GC都是安全的，可以看做是安全点的扩展。</p><p>当线程进入安全区域时，会标识已经进入安全区域，此时发生GC会忽略进入安全区域的线程。</p><p>当线程离开安全区域时，会检查是否完成GC，只有完成GC线程才可以离开，否则需要等待GC完成才可以离开。</p><h2 id="2-对象存活判断"><a href="#2-对象存活判断" class="headerlink" title="2 对象存活判断"></a>2 对象存活判断</h2><h3 id="2-1-堆的存活判断"><a href="#2-1-堆的存活判断" class="headerlink" title="2.1 堆的存活判断"></a>2.1 堆的存活判断</h3><h4 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h4><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。</p><p>此方法简单，但无法解决对象相互循环引用的问题：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoGC</span> <span class="variable">demoA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoGC</span>();<span class="comment">// step 1</span></span><br><span class="line">        <span class="type">DemoGC</span> <span class="variable">demoB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoGC</span>();<span class="comment">// step 2</span></span><br><span class="line">        <span class="comment">// 相互引用</span></span><br><span class="line">        demoA.instance = demoB;<span class="comment">// step 3</span></span><br><span class="line">        demoB.instance = demoA;<span class="comment">// step 4</span></span><br><span class="line">        <span class="comment">// 释放对象</span></span><br><span class="line">        demoA = <span class="literal">null</span>;<span class="comment">// step 5</span></span><br><span class="line">        demoB = <span class="literal">null</span>;<span class="comment">// step 6</span></span><br><span class="line">        <span class="comment">// 发生CG</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一步和第二步执行后，在堆中创建了两个实例对象：</p><ul><li>demoA引用实例对象A，引用数量变为1。</li><li>demoB引用实例对象B，引用数量变为1。</li></ul><p>在第三步和第四步执行后：</p><ul><li>demoB的instance属性引用实例对象A，引用数量变为2。</li><li>demoA的instance属性引用实例对象B，引用数量变为2。</li></ul><p>在第五步和第六步执行后：</p><ul><li>demoA不再引用实例对象A，引用数量变为1。</li><li>demoB不再引用实例对象B，引用数量变为1。</li></ul><p>此时如果发生GC，虽然demoA和demoB均已经不再引用实例对象了，但是其内部的instance属性还在引用实例对象，所以此时实例对象的引用不为0，不能被GC回收。</p><h4 id="2-1-2-可达性算法"><a href="#2-1-2-可达性算法" class="headerlink" title="2.1.2 可达性算法"></a>2.1.2 可达性算法</h4><p>从GCRoots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的，可以回收，但不一定会被回收，原因在于虚拟机的二次标记机制。</p><p>可以作为GCRoots的对象：</p><ul><li>虚拟机栈的栈帧中的局部变量表引用的对象，比如各个线程中被调用的参数和局部变量等。</li><li>本地方法栈中JNI（Native方法）引用的对象，比如线程中的<code>start()</code>方法中使用的对象。</li><li>静态属性引用的对象，比如引用类型的静态变量。</li><li>方法区中常量引用的对象，比如在方法区中使用字符串常量池中的对象。</li><li>被synchronized所持有的对象。</li><li>虚拟机内部的引用，比如基本类型对应的Class对象，常驻异常对象，系统类加载器等。</li><li>本地代码缓存。</li><li>除了固定的对象外，根据用户选用的垃圾回收器和当前回收的内存区域，还可以有临时对象加入，比如分代收集和局部收集。</li></ul><p>再回到相互循环引用的问题上，demoA和demoB是方法中的局部变量，其存储位置是虚拟机栈的栈帧中的局部变量表，可以作为GCRoots对象。instance属性是类中的成员属性，其存储位置是堆，不可以作为GCRoots对象。当demoA和demoB不再引用实例对象后，从GCRoots向下搜索，会发现实例对象没有引用链相连，可以被GC回收。</p><h4 id="2-1-3-二次标记"><a href="#2-1-3-二次标记" class="headerlink" title="2.1.3 二次标记"></a>2.1.3 二次标记</h4><p>Object类有一个<code>finalize()</code>方法，该方法会在该对象被回收之前调用，并且任何一个对象的<code>fianlize()</code>方法都只会被系统自动调用一次。</p><p>在被标记后，如果重写了<code>finalize()</code>方法，并且在方法里将该对象重新加入到了引用链中。此时虽然已经被标记了，但并不会被回收，原因在于虚拟机的二次标记机制：</p><ul><li>第一次标记，标记不在引用链的对象，判断是否需要执行<code>finalize()</code>方法。如果已经被执行或者没有被重写，就表示不需要执行，否则表示需要执行。</li><li>将需要执行<code>finalize()</code>方法的对象放在F-Queue的队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程去执行。</li><li>第二次标记，遍历F-Queue队列中的对象，判断是否存在引用链。如果存在引用链，表示该对象不需要被回收，否则标记不存在引用链的对象，等待回收。</li></ul><p>该机制在JDK1.9已被弃用。</p><h3 id="2-2-方法区的存活判断"><a href="#2-2-方法区的存活判断" class="headerlink" title="2.2 方法区的存活判断"></a>2.2 方法区的存活判断</h3><p>方法区主要回收废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="3-对象的引用"><a href="#3-对象的引用" class="headerlink" title="3 对象的引用"></a>3 对象的引用</h2><p>在JDK1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可达状态，程序才能使用它。</p><p>从JDK1.2版本开始，对象的引用被划分为四种级别：</p><ul><li>强引用（StrongReference）：不会被垃圾回收器回收，即使以后也不会用到。</li><li>软引用（SoftReference）：比强引用弱，当系统内存不足时才会被回收。通常用在对内存敏感的程序中，比如高速缓存。</li><li>弱引用（WeakReference）：比软引用弱，生命周期更短，只要发生了垃圾回收，不管内存空间是否足够都会被回收。</li><li>虚引用（PhantomReference）：最弱，在任何时候都有可能被垃圾回收器回收。通常配和引用队列联合使用，在被回收前能够收到系统通知。</li></ul><p>无论引用计数算法还是可达性分析算法都是基于强引用而言的。</p><p>如果对象是不可达的，不管是哪种引用都会被垃圾回收器回收。</p><h3 id="3-1-强引用"><a href="#3-1-强引用" class="headerlink" title="3.1 强引用"></a>3.1 强引用</h3><p>强引用是使用最普遍的引用。</p><p>如果强引用的对象可达，虚拟机宁愿抛出OutOfMemoryError错误使程序异常终止，也不会回收对象来解决内存不足的问题。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明原引用</span></span><br><span class="line">        test = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明强引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> test;</span><br><span class="line">        <span class="comment">// 打印强引用</span></span><br><span class="line">        System.out.println(strongReference);</span><br><span class="line">        <span class="comment">// 去除原引用</span></span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 发生CG</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 强制睡眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印强引用</span></span><br><span class="line">        System.out.println(strongReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">// 等待1s</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h3 id="3-2-软引用"><a href="#3-2-软引用" class="headerlink" title="3.2 软引用"></a>3.2 软引用</h3><p>如果软引用的对象可达，只有当内存空间不足时才会被回收，当内存充足时不被回收。</p><p>软引用通常用来实现内存敏感的缓存。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明原引用</span></span><br><span class="line">        test = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明软引用</span></span><br><span class="line">        SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(test);</span><br><span class="line">        <span class="comment">// 打印软引用</span></span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        <span class="comment">// 去除原引用</span></span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 发生CG</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 强制睡眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印软引用，内存充足不被回收</span></span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分配大内存，强制抛出OOM</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">7</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 内存不足抛出OOM</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 打印软引用，内存不足会被回收</span></span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">// 等待1s</span><br><span class="line">test</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">  at Demo.main(Demo.java:30)</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h3 id="3-3-弱引用"><a href="#3-3-弱引用" class="headerlink" title="3.3 弱引用"></a>3.3 弱引用</h3><p>无论弱引用的对象是否可达，无论内存是否充足，在下一次垃圾回收时都会被回收。</p><p>弱引用通常用来保存可有可无的缓存数据。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明原引用</span></span><br><span class="line">        test = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明弱引用</span></span><br><span class="line">        WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(test);</span><br><span class="line">        <span class="comment">// 打印弱引用</span></span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 去除原引用</span></span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 发生CG</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 强制睡眠</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印弱引用</span></span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">// 等待1s</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h3 id="3-4-虚引用"><a href="#3-4-虚引用" class="headerlink" title="3.4 虚引用"></a>3.4 虚引用</h3><p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么随时都可能被垃圾回收器回收。</p><p>虚引用必须和引用队列联合使用，当垃圾回收器在回收有虚引用的对象之前，会加入到引用队列，以通知应用程序对象的回收情况。</p><p>虚引用通常用来跟踪对象被垃圾回收器回收的活动，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> String test;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 声明原引用</span></span><br><span class="line">        test = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 声明引用队列</span></span><br><span class="line">        referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 声明虚引用</span></span><br><span class="line">        PhantomReference&lt;String&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(test, referenceQueue);</span><br><span class="line">        <span class="comment">// 打印虚引用</span></span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">        <span class="comment">// 去除原引用</span></span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 发生CG</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (referenceQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;String&gt; str = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        str = (PhantomReference&lt;String&gt;) referenceQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;发生GC&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">发生GC</span><br></pre></td></tr></table></figure><h2 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4 垃圾回收算法"></a>4 垃圾回收算法</h2><h3 id="4-1-标记-清除算法"><a href="#4-1-标记-清除算法" class="headerlink" title="4.1 标记-清除算法"></a>4.1 标记-清除算法</h3><p>标记-清除（Mark-Sweep）算法分为两个阶段：</p><ul><li>标记阶段的任务是标记出所有需要被回收的对象.</li><li>清除阶段的任务是回收被标记的对象所占用的空间。</li></ul><p>说明：<br><img src="/@image/D01004/004-20250804111135.jpg" alt="20250804111135-标记-清除算法"></p><p>这种方法的标记和清除过程的效率都不高，并且在标记清除之后会产生大量不连续的内存碎片，当程序需要分配较大对象时，无法找到足够的连续内存，不得不提前触发另一次垃圾收集动作。</p><h3 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h3><p>为了解决标记-清除算法的缺陷，复制（Copying）算法就被提了出来。</p><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</p><p>很显然，复制算法的效率跟存活对象的多少有很大的关系，如果存活对象很多，那么复制算法的效率将大大降低。</p><p>说明：<br><img src="/@image/D01004/004-20250804112127.jpg" alt="20250804112127-复制算法"></p><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p><h3 id="4-3-标记-压缩算法"><a href="#4-3-标记-压缩算法" class="headerlink" title="4.3 标记-压缩算法"></a>4.3 标记-压缩算法</h3><p>为了解决复制算法的缺陷，充分利用内存空间，提出了标记-压缩（Mark-Compact）算法。</p><p>该算法标记阶段和标记-清除算法的标记阶段一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</p><p>说明：<br><img src="/@image/D01004/004-20250804112609.jpg" alt="20250804112609-标记-压缩算法"></p><p>这种方法的效率比较低，并且在移动过程中，需要全面暂停应用程序，即会触发STW。</p><h3 id="4-4-分代收集算法"><a href="#4-4-分代收集算法" class="headerlink" title="4.4 分代收集算法"></a>4.4 分代收集算法</h3><p>分代收集（Generational Collection）算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域，根据不同区域的特点采取最适合的收集算法。</p><p>一般情况下将堆区划分为年轻代和老年代两个区域。</p><h4 id="4-4-1-年轻代"><a href="#4-4-1-年轻代" class="headerlink" title="4.4.1 年轻代"></a>4.4.1 年轻代</h4><p>在年轻代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，所以选用复制算法。</p><p>分配：</p><ul><li>因为大部分新生成的对象的生命周期都很短，所以将年轻代分为一块较大的Eden区和两块较小的Survivor区。</li><li>一块较大的Eden区用来存放新生成的对象，两块较小的Survivor区用来存放在多次GC存活下来的对象，一块称为S0区，另一块称为S1区。</li></ul><p>年轻代发生的GC叫做MinorGC，也称为YoungGC，MinorGC发生频率比较高。</p><p>过程：</p><ul><li>当第一次发生GC时，先将垃圾对象清除，然后将Eden区还存活的对象一次性复制到任意一个Survivor区，最后清空Eden区。为了区分方便，将使用的Survivor区称为From区，将空闲的Survivor区称为To区。</li><li>当再次发生GC时，先将垃圾对象清除，然后将Eden区和From区还存活的对象一次性复制到To区，最后清空Eden区和From区。每次GC完成之后，将正在使用的To区称为From区，将空闲的From区称为To区。</li><li>对象在放到Survivor区时都会设置一个年龄，并且每经过一次GC后都会将年龄加一，当对象的年龄超过虚拟机设置的阈值之后，会将对象放到老年代。</li></ul><h4 id="4-4-2-老年代"><a href="#4-4-2-老年代" class="headerlink" title="4.4.2 老年代"></a>4.4.2 老年代</h4><p>因为老年代中对象存活率高、没有额外空间对它进行分配担保，所以使用标记清除算法或标记压缩算法来进行回收。</p><p>分配：</p><ul><li>大对象直接进入老年代。</li><li>多次不被回收的对象，经过多次MinorGC后仍在Survivor区的对象进入老年代。</li><li>动态年龄判断，计算某个年龄的对象数量超过了Survivor区总数量的一半，大于或等于这个年龄的对象进入老年代。</li><li>空间分配担保，经过MinorGC后Survivor区不足以存放对象进入老年代。</li></ul><p>老年代发生的GC也叫做MajorGC，也称为OldGC，MajorGC发生频率比较低。</p><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5 垃圾收集器"></a>5 垃圾收集器</h2><h3 id="5-1-Serial系列"><a href="#5-1-Serial系列" class="headerlink" title="5.1 Serial系列"></a>5.1 Serial系列</h3><p>Serial是年轻代垃圾收集器，串行运行，采用复制算法，响应速度优先，使用STW机制，停顿时间长。</p><p>SerialOld是老年代垃圾收集器，串行运行，采用标记-压缩算法，响应速度优先，使用STW机制，停顿时间长。</p><p>对于单个CPU环境而言，Serial系列的收集器由于没有线程交互开销，可以获取最高的单线程收集效率。</p><p>配置：</p><ul><li>Serial系列的收集器是Client模式下默认的垃圾收集器。</li><li>可以通过<code>-XX:+UseSerialGC</code>来指定年轻代和老年代都使用Serial系列的收集器。</li></ul><h3 id="5-2-ParNew"><a href="#5-2-ParNew" class="headerlink" title="5.2 ParNew"></a>5.2 ParNew</h3><p>年轻代垃圾收集器，并行运行，采用复制算法，响应速度优先，使用STW机制，停顿时间长。</p><p>ParNew是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。</p><p>配置：</p><ul><li>ParNew收集器是Server模式下默认的垃圾收集器。</li><li>可以通过<code>-XX:+UseParNewGC</code>来指定年轻代使用ParNew收集器。</li><li>可以通过<code>-XX:ParallelGCThreads</code>来限制垃圾收集的线程数，默认开启和CPU数据相同的线程数。</li></ul><h3 id="5-3-Parallel系列"><a href="#5-3-Parallel系列" class="headerlink" title="5.3 Parallel系列"></a>5.3 Parallel系列</h3><p>Parallel是年轻代垃圾收集器，并行运行，采用复制算法，吞吐量优先，使用STW机制，停顿时间长。</p><p>ParallelOld是老年代垃圾收集器，并行运行，采用标记-压缩算法，吞吐量优先，使用STW机制，停顿时间长。</p><p>追求高吞吐量，高效利用CPU，主要是为了达到可控的吞吐量，适合在后台运算而不需要太多交互的任务</p><p>配置：</p><ul><li>Parallel系列的收集器是JDK1.8默认的垃圾收集器。</li><li>可以通过<code>-XX:+UseParallelGC</code>来指定年轻代使用Parallel收集器。</li><li>可以通过<code>-XX:+UseParallelOldGC</code>来指定老年代使用ParallelOld收集器。</li><li>可以通过<code>-XX:ParallelGCThreads</code>来限制年轻代垃圾收集器的线程数。一般最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li><li>可以通过<code>-XX:MaxGCPauseMillis</code>来指定垃圾收集器的STW的时间，单位是毫秒。</li></ul><h3 id="5-4-CMS"><a href="#5-4-CMS" class="headerlink" title="5.4 CMS"></a>5.4 CMS</h3><p>JDK1.5推出，JDK1.9废弃，JDK1.14移除。</p><p>CMS（Current Mark Sweep）是老年代垃圾收集器，并发运行，采用标记-清除算法，响应速度优先，使用STW机制，停顿时间长。</p><p>过程：</p><ol><li>初始标记，标记GCRoots能直接关联到的对象，有STW现象，暂停时间非常短。</li><li>并发标记，进行可达性分析过程，时间很长，不需要暂停用户线程，可与其他垃圾收集线程并发运行。在这个阶段使用了三色标记。</li><li>重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长，不需要暂停用户线程。</li><li>并发清除，回收内存空间，时间很长，不需要暂停用户线程。</li></ol><p>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。</p><p>优缺点：</p><ul><li>优点是并发收集和低延迟。</li><li>缺点是会产生内存碎片，对CPU资源非常敏感，并且无法处理浮动垃圾。</li></ul><h3 id="5-5-G1"><a href="#5-5-G1" class="headerlink" title="5.5 G1"></a>5.5 G1</h3><p>JDK1.7推出，JDK1.9默认。</p><p>G1（Garbage First）是年轻代和老年代垃圾收集器，支持并发运行和并行运行，采用复制算法和标记-压缩算法，响应速度优先，同时注重吞吐量。</p><p>G1的目标是在延迟可控的情况下获得尽可能高的吞吐量。</p><p>使用G1收集器时，将整个堆划分为多个大小相等的独立区域（Region），分区如图：<br><img src="/@image/D01004/004-20250804125541.jpg" alt="20250804125541-G1分区"></p><p>说明：</p><ul><li>每个独立区域都按照分代收集算法代表一种分区，分区有Eden区，S0区，S1区等分类。</li><li>所有的独立区域大小相同，且在JVM生命周期内不会被改变。</li><li>增加Humongous内存区域，主要用于存储大对象，如果超过0.5个独立区域就会放到H区域，如果一个H区装不下就会寻找连续的H区来存储。</li></ul><p>过程：</p><ul><li>当Eden空间耗尽时，启动年轻代GC，只回收Eden区和Survivor区：<ul><li>首先停止应用程序的执行触发STW机制，创建回收集，包含Eden区和Survivor区所有的内存分段。</li><li>回收剩余存活的对象会被复制到新的S区，S区达到一定的阈值会被放到O区，或者S区空间不足也会被放到O区。</li></ul></li><li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程：<ul><li>初始标记，标记GCRoots直接可达的对象，会触发年轻代GC，也会触发STW机制。</li><li>根区域标记，标记Survivor区引用老年代的对象，必须在下一次年轻代GC前完成，否则会阻塞年轻代GC。</li><li>并发标记，在整个堆中进行并发标记，支持与用户线程并发。</li><li>最终标记，由于应用程序持续进行，需要修正上一次的标记结果，使用SATB处理并发期间的引用变化，会触发STW机制。</li><li>清理，计算各个区域的存活对象和GC回收比例，并进行排序，识别并清理完全空闲的区域，会触发STW机制。</li></ul></li><li>当老年代中的对象进一步增加时，会触发MixedGC混合回收，回收整个年轻代和部分老年代：<ul><li>并发标记结束以后，老年代中完全空闲的区域被回收了，部分空闲的区域被计算了出来。默认情况下，每个区域都会分8次回收。</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。</li></ul></li><li>如果上述方式不能正常工作，G1会执行兜底的FullGC回收，G1收集器退化为SerialOld收集器，性能会非常差，会触发STW机制，触发条件：</li><li>回收阶段没有足够的空间存放对象，解决办法是增加堆空间。</li><li>并发标记过程完成之前空间耗尽，解决办法是调小触发老年代并发标记的阈值，默认是45%。</li><li>最大GC停顿时间太短导致在规定的时间间隔内无法完成垃圾回收，解决办法是增加STW时间。</li></ul><p>特点：</p><ul><li>并行性：在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。</li><li>并发性：拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，不会在整个回收阶段发生完全阻塞应用程序的情况。</li><li>无需连续：从堆的结构上看，不要求整个年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>分代收集：独立管理整个堆，但是能够采用不同的方式处理新对象和旧对象。</li><li>空间整合：独立区域之间是复制算法，整体上可以看作是标记-压缩算法，这两种算法都能避免产生内存碎片。</li><li>可预测的停顿：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul><p>配置：</p><ul><li>G1收集器是JDK1.9默认的垃圾收集器。</li><li>可以通过<code>-XX:+UseG1GC</code>来指定使用G1收集器。</li><li>可以通过<code>-XX:G1HeapRegionSize</code>来指定每个独立区域的大小。值是2的幂，范围是1MB到32MB之间。默认为堆内存的1&#x2F;2000大小。</li><li>可以通过<code>-XX:ParallelGCThread</code>来指定工作线程数的值，最多设置为8。</li><li>可以通过<code>-XX:ConcGCThreads</code>来指定并发标记的线程数。默认为工作线程数（ParallelGcThreads）的1&#x2F;4左右。</li><li>可以通过<code>-XX:InitiatingHeapOccupancyPercent</code>来指定触发老年代并发标记的阈值，默认为45%。</li><li>可以通过<code>-XX:G1MixedGCLiveThresholdPercent</code>来指定是否要回收区域垃圾占用的比例，当垃圾占用的比例达到比例时才会被混合回收，默认为65%。</li><li>可以通过<code>-XX:G1HeapWastePercent</code>来指定允许垃圾占用的比例，当垃圾占用的比例低于比例时就不再进行混合回收，默认为10%。</li><li>可以通过<code>-XX:MaxGCPauseMillis</code>来指定垃圾收集器的STW的时间，单位是毫秒。</li></ul><h2 id="6-调优配置"><a href="#6-调优配置" class="headerlink" title="6 调优配置"></a>6 调优配置</h2><p>配置日志的打印信息：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 输出日志</span><br><span class="line">-XX:+PrintGC</span><br><span class="line"># 输出详细日志</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"># 输出时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line"># 输出时间戳（以日期的形式）</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"># 输出GC发生前后的堆信息</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"># 输出STW时间</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"># 输出强软弱虚信息</span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"># 输出安全点信息</span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line"># 输出打印安全点信息的次数</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br></pre></td></tr></table></figure><p>配置日志文件：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置日志文件的输出路径</span><br><span class="line">-Xloggc:../logs/gc-%t.log</span><br><span class="line"># 开启日志文件分割</span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line"># 设置日志文件个数，超过就从头开始写</span><br><span class="line">-XX:NumberOfGCLogFiles=10</span><br><span class="line"># 设置日志文件上限大小，超过就触发分割</span><br><span class="line">-XX:GCLogFileSize=10M</span><br></pre></td></tr></table></figure><p>配置内存大小：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 设置线程栈的大小，不建议修改</span><br><span class="line">-Xss128k</span><br><span class="line"># 设置堆内存的初始内存，默认为物理内存的1/64</span><br><span class="line">-Xms4096m</span><br><span class="line"># 设置堆内存的最大内存，默认为物理内存的1/4</span><br><span class="line">-Xmx4096m</span><br><span class="line"># 设置年轻代中Eden:S1:S0的比率，默认值为8，表示Eden:S1:S0=8:1:1</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line"># 设置年轻代:老年代的比率，默认值为2，表示年轻代:老年代=2:8</span><br><span class="line">-XX:NewRatio=2</span><br><span class="line"># 设置年轻代对象在经过多少次回收后能进入老年代，默认是15</span><br><span class="line">-XX:MaxTenuringThreshold=15</span><br><span class="line"># 设置元空间的初始内存，默认为21m</span><br><span class="line">-XX:MetaspaceSize=21m</span><br><span class="line"># 设置元空间的最大内存，默认没有限制</span><br><span class="line">-XX:MaxMetaspaceSize=-1</span><br></pre></td></tr></table></figure><h2 id="7-执行分析"><a href="#7-执行分析" class="headerlink" title="7 执行分析"></a>7 执行分析</h2><h3 id="7-1-查看内存"><a href="#7-1-查看内存" class="headerlink" title="7.1 查看内存"></a>7.1 查看内存</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max memory: 7260MB</span><br><span class="line">total memory: 491MB</span><br></pre></td></tr></table></figure><p>本机电脑是32G，去掉一些自身的占用后，堆内存的最大值约为物理内存的1&#x2F;4，堆内存的初始值为物理内存的1&#x2F;64。</p><h3 id="7-2-修改内存"><a href="#7-2-修改内存" class="headerlink" title="7.2 修改内存"></a>7.2 修改内存</h3><p>配置VM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m</span><br><span class="line">-Xmx20m</span><br><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  1012K-&gt;648K(5632K), 0.0005734 secs]</span><br><span class="line">max memory: 18MB</span><br><span class="line">total memory: 5MB</span><br></pre></td></tr></table></figure><p>说明堆内存已经被修改了。</p><h3 id="7-3-占用内存"><a href="#7-3-占用内存" class="headerlink" title="7.3 占用内存"></a>7.3 占用内存</h3><p>配置VM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m</span><br><span class="line">-Xmx20m</span><br><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始内存&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] b1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;分配内存&quot;</span> + b1.length / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] b2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;分配内存&quot;</span> + b2.length / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  1012K-&gt;632K(5632K), 0.0009215 secs]</span><br><span class="line">初始内存</span><br><span class="line">max memory: 18MB</span><br><span class="line">free memory: 4MB</span><br><span class="line">total memory: 5MB</span><br><span class="line">分配内存1M</span><br><span class="line">max memory: 18MB</span><br><span class="line">free memory: 3MB</span><br><span class="line">total memory: 5MB</span><br><span class="line">分配内存10M</span><br><span class="line">max memory: 18MB</span><br><span class="line">free memory: 2MB</span><br><span class="line">total memory: 15MB</span><br></pre></td></tr></table></figure><p>初始，最大内存约为20M，空闲内存约为4M，总内存约为5M。</p><p>分配1M的内存，空闲内存足够，空闲内存约为3M，总内存约为5M。</p><p>继续分配10M的内存，空闲内存不足，自动增加内存，空闲内存约为2M，总内存约为15M。</p><h3 id="7-4-内存溢出"><a href="#7-4-内存溢出" class="headerlink" title="7.4 内存溢出"></a>7.4 内存溢出</h3><p>配置VM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m</span><br><span class="line">-Xmx20m</span><br><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;初始内存&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] b1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;分配内存&quot;</span> + b1.length / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] b2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;分配内存&quot;</span> + b2.length / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;max memory: &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;free memory: &quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;total memory: &quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  1012K-&gt;652K(5632K), 0.0005981 secs]</span><br><span class="line">初始内存</span><br><span class="line">max memory: 18MB</span><br><span class="line">free memory: 4MB</span><br><span class="line">total memory: 5MB</span><br><span class="line">分配内存1M</span><br><span class="line">max memory: 18MB</span><br><span class="line">free memory: 3MB</span><br><span class="line">total memory: 5MB</span><br><span class="line">[GC (Allocation Failure)  2357K-&gt;1817K(15360K), 0.0006138 secs]</span><br><span class="line">[GC (Allocation Failure)  1817K-&gt;1873K(15360K), 0.0004490 secs]</span><br><span class="line">[Full GC (Allocation Failure)  1873K-&gt;1678K(5632K), 0.0042680 secs]</span><br><span class="line">[GC (Allocation Failure)  1678K-&gt;1678K(16384K), 0.0002214 secs]</span><br><span class="line">[Full GC (Allocation Failure)  1678K-&gt;1660K(7680K), 0.0044765 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">  at Demo.main(Demo.java:14)</span><br></pre></td></tr></table></figure><p>当年轻代内存不足时，触发MinorGC，当老年代内存不足时，触发MajorGC，当内存仍不足时，触发FullGC，如果内存还不足则触发OOM异常。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了虚拟机的垃圾回收机制。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据存储</title>
    <link href="https://momashanhe.com/posts/20250731/163910/"/>
    <id>https://momashanhe.com/posts/20250731/163910/</id>
    <published>2025-07-31T08:39:10.000Z</published>
    <updated>2025-08-06T02:39:56.939Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了虚拟机如何管理对象。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-内存区域模型"><a href="#1-内存区域模型" class="headerlink" title="1 内存区域模型"></a>1 内存区域模型</h2><p>虚拟机定义的内存区域模型：<br><img src="/@image/D01004/003-20250731170055.jpg" alt="20250731170055-模型"></p><p>图中绿色部分就是所有线程之间共享的内存区域，包括方法区和堆。而绿色部分则是线程运行时独享的数据区域，包括程序计数器、本地方法栈、虚拟机栈。</p><p>之所以要划分这么多区域出来是因为这些区域都有自己的用途，以及创建和销毁的时间。</p><p>有些区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而销毁和建立。</p><h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2 运行时数据区"></a>2 运行时数据区</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><h4 id="2-1-1-作用"><a href="#2-1-1-作用" class="headerlink" title="2.1.1 作用"></a>2.1.1 作用</h4><p>存储指向下一条指令的地址，以便由执行引擎读取下一条指令。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><h4 id="2-1-2-独享"><a href="#2-1-2-独享" class="headerlink" title="2.1.2 独享"></a>2.1.2 独享</h4><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。</p><h4 id="2-1-3-异常"><a href="#2-1-3-异常" class="headerlink" title="2.1.3 异常"></a>2.1.3 异常</h4><p>此内存区域是唯一不会出现OutOfMemoryError情况的区域。</p><h3 id="2-2-本地方法栈"><a href="#2-2-本地方法栈" class="headerlink" title="2.2 本地方法栈"></a>2.2 本地方法栈</h3><h4 id="2-2-1-作用"><a href="#2-2-1-作用" class="headerlink" title="2.2.1 作用"></a>2.2.1 作用</h4><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p><h4 id="2-2-2-独享"><a href="#2-2-2-独享" class="headerlink" title="2.2.2 独享"></a>2.2.2 独享</h4><p>与程序计数器一样，本地方法栈也是线程私有的。</p><h4 id="2-2-3-异常"><a href="#2-2-3-异常" class="headerlink" title="2.2.3 异常"></a>2.2.3 异常</h4><p>在虚拟机规范中，对这个区域规定了两种异常状况：</p><ul><li>StackOverflowError<ul><li>递归太深。如果线程请求的栈深度大于虚拟机所允许的深度，即递归调用次数太多，将抛出StackOverflowError异常。</li><li>数据过大。局部数组过大，当函数内部定义的数组过大时，有可能导致内存溢出，抛出StackOverflowError异常。</li></ul></li><li>OutOfMemoryError<ul><li>内存不足。如果虚拟机栈无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那虚拟机将会抛出OutOfMemoryError异常。</li></ul></li></ul><h4 id="2-2-4-本地方法"><a href="#2-2-4-本地方法" class="headerlink" title="2.2.4 本地方法"></a>2.2.4 本地方法</h4><p>Java诞生的时候是C&#x2F;C++横行的时候，要想立足，必须有调用C&#x2F;C++程序，于是使用native关键字标识调用了C&#x2F;C++程序的方法，把这种方法称为Native方法。</p><p>为了和用于处理Java方法的虚拟机栈区分开来，又在内存中专门开辟了一块区域用于处理Native方法，这块区域就被称为本地方法栈。</p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机。</p><p>Object类中的hashCode()方法就是本地方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-虚拟机栈"><a href="#2-3-虚拟机栈" class="headerlink" title="2.3 虚拟机栈"></a>2.3 虚拟机栈</h3><h4 id="2-3-1-作用"><a href="#2-3-1-作用" class="headerlink" title="2.3.1 作用"></a>2.3.1 作用</h4><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。</p><p>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，这个过程遵循先进后出的规则。</p><p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。</p><p>结构图：<br><img src="/@image/D01004/003-20250731170338.jpg" alt="20250731170338-虚拟机栈"></p><h4 id="2-3-2-独享"><a href="#2-3-2-独享" class="headerlink" title="2.3.2 独享"></a>2.3.2 独享</h4><p>与本地方法栈一样，虚拟机栈也是线程私有的，它的生命周期与线程相同，每创建一个线程时就会对应创建一个虚拟机栈，所以虚拟机栈也是线程私有的内存区域。</p><h4 id="2-3-3-异常"><a href="#2-3-3-异常" class="headerlink" title="2.3.3 异常"></a>2.3.3 异常</h4><p>与本地方法栈一样，虚拟机栈也会抛出StackOverflowError异常和OutOfMemoryError异常。</p><h4 id="2-3-4-栈帧"><a href="#2-3-4-栈帧" class="headerlink" title="2.3.4 栈帧"></a>2.3.4 栈帧</h4><p>一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><h5 id="2-3-4-1-局部变量表"><a href="#2-3-4-1-局部变量表" class="headerlink" title="2.3.4.1 局部变量表"></a>2.3.4.1 局部变量表</h5><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，包括各种基本类型、引用类型和返回地址类型。</p><p>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小，具体大小可在编译后的class文件中看到。</p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位，每个变量槽都可以存储32位长度的内存空间。</p><p>64位长度的long类型和double类型的数据会占用2个变量槽，其余的数据类型只占用1个变量槽。</p><h5 id="2-3-4-2-操作数栈"><a href="#2-3-4-2-操作数栈" class="headerlink" title="2.3.4.2 操作数栈"></a>2.3.4.2 操作数栈</h5><p>操作数栈（Operand Stack）同样也可以在编译期确定大小。</p><p>栈帧被创建时，操作栈是空的。方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。例如在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的。</p><h5 id="2-3-4-3-动态链接"><a href="#2-3-4-3-动态链接" class="headerlink" title="2.3.4.3 动态链接"></a>2.3.4.3 动态链接</h5><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。</p><p>比较：</p><ul><li>静态链接：当字节码文件被装载进JVM内部时，在类加载阶段中的解析阶段就将符号引用转为直接引用，这种过程被称为静态链接。</li><li>动态链接：如果在程序运行期才能将符号引用转为直接引用，这种过程被称为动态链接。</li></ul><h5 id="2-3-4-4-方法返回地址"><a href="#2-3-4-4-方法返回地址" class="headerlink" title="2.3.4.4 方法返回地址"></a>2.3.4.4 方法返回地址</h5><p>方法返回地址（Return Address）用于存放调用该方法的程序计数器的值，用于在退出方法后执行下一条命令。</p><p>方法有两种方式可以退出：</p><ul><li>正常执行退出。</li><li>执行异常退出。</li></ul><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><h4 id="2-4-1-作用"><a href="#2-4-1-作用" class="headerlink" title="2.4.1 作用"></a>2.4.1 作用</h4><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><h4 id="2-4-2-共享"><a href="#2-4-2-共享" class="headerlink" title="2.4.2 共享"></a>2.4.2 共享</h4><p>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存储的数据不是线程安全的。</p><h4 id="2-4-3-异常"><a href="#2-4-3-异常" class="headerlink" title="2.4.3 异常"></a>2.4.3 异常</h4><p>在虚拟机规范中，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。</p><p>如果在养老区中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p>一般出现异常的原因是：</p><ul><li>堆内存设置不够。</li><li>代码中创建了大量对象，并且长时间不能被垃圾回收器收集。</li></ul><h4 id="2-4-4-分代"><a href="#2-4-4-分代" class="headerlink" title="2.4.4 分代"></a>2.4.4 分代</h4><p>堆是垃圾回收器管理的主要区域，因此很多时候也被称做GC堆（Garbage Collected Heap）。</p><p>为了优化垃圾回收的性能，虚拟机会将堆空间进行分代。</p><p>在JDK1.8以后，将堆空间分为年轻代和老年代。</p><h5 id="2-4-4-1-年轻代"><a href="#2-4-4-1-年轻代" class="headerlink" title="2.4.4.1 年轻代"></a>2.4.4.1 年轻代</h5><p>年轻代（Young Generation Space）存放新生成的对象，年轻代对象朝生夕死，存活率很低。</p><p>在年轻代中进行垃圾回收一般可以回收70%到95%的空间，回收效率很高。</p><p>年轻代又可细分为Eden空间、From Survivor空间、To Survivor空间，默认比例为8:1:1。</p><h5 id="2-4-4-2-老年代"><a href="#2-4-4-2-老年代" class="headerlink" title="2.4.4.2 老年代"></a>2.4.4.2 老年代</h5><p>老年代（Old Generation Space）存放在年轻代多次回收长期存活的对象，也会将大对象直接存放到老年代中，老年代中的对象生命周期较长，存活率比较高。</p><p>在老年代中进行垃圾回收的频率较低，而且回收的速度也比较慢。</p><p>当老年代内存满了之后会触发垃圾回收，如果垃圾回收后内存空间仍不满足，则会触发OOM异常。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><h4 id="2-5-1-作用"><a href="#2-5-1-作用" class="headerlink" title="2.5.1 作用"></a>2.5.1 作用</h4><p>在JDK1.8之前，方法区存储类元数据、运行时常量池、静态变量等数据，并在逻辑上将方法区划分为堆中的永久代，作为堆的逻辑部分。</p><p>在JDK1.8之后，方法区中的数据被拆分到了堆和元空间：</p><ul><li>静态变量：存储在堆中。</li><li>字符串常量池：将字符串常量池从运行时常量池拆分，存储在堆中。</li><li>运行时常量池：存储在元空间中，但运行时常量池的符号引用解析后可能指向堆中的对象。</li><li>类元数据：存储在元空间中。</li></ul><h4 id="2-5-2-共享"><a href="#2-5-2-共享" class="headerlink" title="2.5.2 共享"></a>2.5.2 共享</h4><p>方法区与堆一样，是各个线程共享的内存区域。</p><h4 id="2-5-3-异常"><a href="#2-5-3-异常" class="headerlink" title="2.5.3 异常"></a>2.5.3 异常</h4><p>在虚拟机规范中，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>一般出现异常的原因是：</p><ul><li>内存设置不够。</li><li>加载大量第三方Jar包。</li><li>存在大量调用反射的代码。</li></ul><h4 id="2-5-4-永久代"><a href="#2-5-4-永久代" class="headerlink" title="2.5.4 永久代"></a>2.5.4 永久代</h4><p>在JDK1.8之前，永久代参数设置不合理会产生问题，参数过小容易产生OOM，参数过大会导致空间浪费，因此在JDK1.8中使用元空间取代了永久代。</p><p>此外，移除永久代是为融合HotSpot与JRockit而做出的努力，JRockit没有永久代，不需要配置永久代。</p><h4 id="2-5-5-垃圾回收"><a href="#2-5-5-垃圾回收" class="headerlink" title="2.5.5 垃圾回收"></a>2.5.5 垃圾回收</h4><p>这个区域垃圾回收的任务：</p><ul><li>对废弃常量的回收。</li><li>对类型的卸载。</li></ul><h2 id="3-对象内存结构"><a href="#3-对象内存结构" class="headerlink" title="3 对象内存结构"></a>3 对象内存结构</h2><p>对象的内存结构：<br><img src="/@image/D01004/003-20250731170500.jpg" alt="20250731170500-内存结构"></p><p>对象内存结构分为对象头、实例数据、对齐填充。</p><h3 id="3-1-对象头"><a href="#3-1-对象头" class="headerlink" title="3.1 对象头"></a>3.1 对象头</h3><p>对象头分为对象标记和类型指针，如果是数组对象还有数组长度。</p><h4 id="3-1-1-对象标记"><a href="#3-1-1-对象标记" class="headerlink" title="3.1.1 对象标记"></a>3.1.1 对象标记</h4><p>对象标记存储的数据会根据对象的锁状态进行复用，在运行期间，对象标记中的数据会随着锁标志位的变化而变化。</p><p>对象标记结构图：<br><img src="/@image/D01004/003-20250731170550.jpg" alt="20250731170550-对象标记"></p><p>在64位的HotSpot虚拟机下，对象标记占用8个字节。</p><h4 id="3-1-2-类型指针"><a href="#3-1-2-类型指针" class="headerlink" title="3.1.2 类型指针"></a>3.1.2 类型指针</h4><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>在开启压缩的情况下占用4个字节，否则占用8个字节，JDK1.8默认开启压缩。</p><h4 id="3-1-3-数组长度"><a href="#3-1-3-数组长度" class="headerlink" title="3.1.3 数组长度"></a>3.1.3 数组长度</h4><p>如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据。</p><p>因为虚拟机可以通过普通对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><p>数组长度占用4个字节。</p><h3 id="3-2-实例数据"><a href="#3-2-实例数据" class="headerlink" title="3.2 实例数据"></a>3.2 实例数据</h3><p>用于存储对象的有效信息，包括程序代码中定义的各种类型的字段（包括继承自父类的和自身声明的），规则如下：</p><ul><li>相同宽度的字段总被分配在一起。</li><li>父类中定义的变量会出现在子类之前。</li><li>如果虚拟机CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙。</li></ul><h3 id="3-3-对齐填充"><a href="#3-3-对齐填充" class="headerlink" title="3.3 对齐填充"></a>3.3 对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p><h2 id="4-对象生命周期"><a href="#4-对象生命周期" class="headerlink" title="4 对象生命周期"></a>4 对象生命周期</h2><p>创建对象的几种方式：</p><ul><li>使用new关键字，这是最常见的方式。</li><li>使用Class对象的<code>newInstance()</code>方法，通过反射的方式，只能调用空参的构造器，必须是public权限。</li><li>使用Constructor对象的<code>newInstance()</code>方法，通过反射的方式，可以调用任何定义的构造器，没有权限要求。</li><li>使用<code>clone()</code>方法，不调用任何构造器，当前类需要实现Cloneable接口，重写<code>clone()</code>方法。</li><li>使用反序列化，从文件和网络中获取对象的二进制流，然后反序列化为对象。</li><li>使用第三方库，例如通过Objenesis创建。</li></ul><h3 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1 创建"></a>4.1 创建</h3><h4 id="4-1-1-加载"><a href="#4-1-1-加载" class="headerlink" title="4.1.1 加载"></a>4.1.1 加载</h4><p>检查能否在常量池中定位到类的符号引用，并且检查这个符号引用代表的类是否已经被加载、链接和初始化。如果没有，那么必须先执行类的初始化过程。</p><h4 id="4-1-2-分配内存"><a href="#4-1-2-分配内存" class="headerlink" title="4.1.2 分配内存"></a>4.1.2 分配内存</h4><p>类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，在堆中为对象分配内存。</p><p>分配方式：</p><ul><li>指针碰撞法：内存是规整的，用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，在空闲的内存将指针挪动一段与对象大小相等的距离。</li><li>空闲列表法：内存不是规整的，已使用的内存和未使用的内存相互交错，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul><p>如果是在多线程环境下的为对象分配内存，需要使用TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）保证创建对象时的线程安全：</p><ul><li>在堆中为每个线程创建创建一小块TLAB私有区域，线程分配对象时优先考虑分配在TLAB区域。</li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，直接在Eden空间中分配内存。</li></ul><h4 id="4-1-3-设置初始值"><a href="#4-1-3-设置初始值" class="headerlink" title="4.1.3 设置初始值"></a>4.1.3 设置初始值</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。</p><p>这一步保证了对象的实例字段在代码中可以不用赋初始值就可以直接使用。</p><h4 id="4-1-4-设置对象头"><a href="#4-1-4-设置对象头" class="headerlink" title="4.1.4 设置对象头"></a>4.1.4 设置对象头</h4><p>设置对象的对象头信息。</p><p>这个过程的具体设置方式取决于JVM实现。</p><h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2 初始化"></a>4.2 初始化</h3><p>初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><h3 id="4-3-使用"><a href="#4-3-使用" class="headerlink" title="4.3 使用"></a>4.3 使用</h3><p>不同虚拟机实现的对象访问方式有所不同，主流的访问方式是句柄访问和直接指针。</p><h4 id="4-3-1-句柄访问"><a href="#4-3-1-句柄访问" class="headerlink" title="4.3.1 句柄访问"></a>4.3.1 句柄访问</h4><p>在堆中划分出一块内存作为句柄池，栈帧中的reference存储的是对象的句柄地址，句柄中包含：</p><ul><li>存储在堆中的对象实例数据的地址。</li><li>存储在方法区中的对象类型数据的地址。</li></ul><p>句柄访问：<br><img src="/@image/D01004/003-20250803190642.jpg" alt="20250803190642-句柄访问"></p><h4 id="4-3-2-直接指针访问"><a href="#4-3-2-直接指针访问" class="headerlink" title="4.3.2 直接指针访问"></a>4.3.2 直接指针访问</h4><p>栈帧中的reference存储的是对象实例数据的地址，对象实例数据中的类型指针存储指向方法区的对象类型数据的地址。</p><p>直接指针访问：<br><img src="/@image/D01004/003-20250803190711.jpg" alt="20250803190711-直接指针访问"></p><h3 id="4-4-不可达"><a href="#4-4-不可达" class="headerlink" title="4.4 不可达"></a>4.4 不可达</h3><p>当对象经过存活判断为不可达后，进入不可达阶段。</p><h3 id="4-5-回收"><a href="#4-5-回收" class="headerlink" title="4.5 回收"></a>4.5 回收</h3><p>不可达对象会被垃圾回收器回收，释放其占用的堆内存。</p><h3 id="4-6-销毁"><a href="#4-6-销毁" class="headerlink" title="4.6 销毁"></a>4.6 销毁</h3><p>当对象的内存被完全释放，且无法再被任何方式访问，则对象彻底销毁，生命周期结束。</p><h2 id="5-逃逸分析"><a href="#5-逃逸分析" class="headerlink" title="5 逃逸分析"></a>5 逃逸分析</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>逃逸分析（Escape Analysis）是虚拟机可以分析新创建对象的使用范围，并决定是否在堆上分配内存的一项技术。</p><p>一个在方法中创建的对象，可能在方法结束后返回被外部方法所引用，也可能在方法中调用其他方法时作为参数传入，以上两种情况都称之为对象逃逸。</p><p>根据作用域可分为下面三种情况：</p><ul><li>GlobalEscape（全局逃逸）：对象的引用逃出了方法或者线程。例如：<ul><li>将对象的引用赋值给类变量或者静态变量。</li><li>对象跟随方法返回。</li></ul></li><li>ArgEscape（参数级逃逸）：在方法中调用其他方法时，对象的引用作为参数传递至其他方法。</li><li>NoEscape（没有逃逸）：对象的作用域范围就只在本方法中，随着方法栈帧的进栈而生、出栈而亡。这种情况下，对象可以分配在栈中，但不是一定分配在栈中。</li></ul><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>逃逸分析的JVM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启逃逸分析</span><br><span class="line">-XX:+DoEscapeAnalysis</span><br><span class="line"># 关闭逃逸分析</span><br><span class="line">-XX:-DoEscapeAnalysis</span><br><span class="line"># 显示分析结果</span><br><span class="line">-XX:+PrintEscapeAnalysis</span><br></pre></td></tr></table></figure><p>逃逸分析技术在JDK1.7以后开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p><h3 id="5-3-优化"><a href="#5-3-优化" class="headerlink" title="5.3 优化"></a>5.3 优化</h3><p>如果使用逃逸分析判断一个对象没有逃逸，编译器可以对代码进行优化。</p><h4 id="5-3-1-同步消除"><a href="#5-3-1-同步消除" class="headerlink" title="5.3.1 同步消除"></a>5.3.1 同步消除</h4><p>如果一个对象只能被一个线程访问到，那么将此对象作为锁，或者对于此对象的同步操作，在虚拟机优化后都可以忽略，这也就是多线程中的锁消除技术。</p><p>同步消除的JVM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启锁消除</span><br><span class="line">-XX:+EliminateLocks</span><br><span class="line"># 关闭锁消除</span><br><span class="line">-XX:-EliminateLocks</span><br></pre></td></tr></table></figure><p>同步消除在JDK1.8中是默认开启的，并且要建立在逃逸分析的基础上。</p><h4 id="5-3-2-标量替换"><a href="#5-3-2-标量替换" class="headerlink" title="5.3.2 标量替换"></a>5.3.2 标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate）。Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在编译阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT编译器优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程就是标量替换。</p><p>标量替换的JVM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启标量替换</span><br><span class="line">-XX:+EliminateAllocations</span><br><span class="line"># 关闭标量替换</span><br><span class="line">-XX:-EliminateAllocations</span><br><span class="line"># 显示标量替换详情</span><br><span class="line">-XX:+PrintEliminateAllocations</span><br></pre></td></tr></table></figure><p>标量替换在JDK1.8中是默认开启的，并且要建立在逃逸分析的基础上。</p><h4 id="5-3-3-栈上分配"><a href="#5-3-3-栈上分配" class="headerlink" title="5.3.3 栈上分配"></a>5.3.3 栈上分配</h4><p>如果一个对象没有发生逃逸，那么这个对象可能会被优化存储在栈中，但也并不是绝对存储在栈中，也有可能还是存储在堆中。</p><p>需要说明的是，在现有的虚拟机中，并没有真正的实现栈上分配，其实是通过标量替换实现的。</p><p>当对象没有发生逃逸时，该对象就可以通过标量替换分解为成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了GC压力，提高了应用程序性能。</p><h2 id="6-分析案例"><a href="#6-分析案例" class="headerlink" title="6 分析案例"></a>6 分析案例</h2><h3 id="6-1-导包"><a href="#6-1-导包" class="headerlink" title="6.1 导包"></a>6.1 导包</h3><p>在pom.xml文件中引入依赖：</p><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JOL依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以直接导入<code>jol-core-0.9.jar</code>Jar包。</p><p>在读取对象信息时，虚拟机是按照8位一组，从高位向低位读取的。</p><h3 id="6-2-压缩"><a href="#6-2-压缩" class="headerlink" title="6.2 压缩"></a>6.2 压缩</h3><p>在64位的HotSpot虚拟机下，类型指针需要占8个字节。</p><p>从JDK1.6开始，64位的虚拟机可对OOP（Ordinary Object Pointer，普通对象指针）进行压缩，使其只占用4个字节，以达到节约内存的目的。</p><p>在JDK1.8下，该选项默认启用。</p><p>可以显式配置JVM参数：</p><figure class="highlight plaintext"><figcaption><span>conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启指针压缩</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line"># 关闭指针压缩</span><br><span class="line">-XX:-UseCompressedOops</span><br></pre></td></tr></table></figure><h3 id="6-3-查看"><a href="#6-3-查看" class="headerlink" title="6.3 查看"></a>6.3 查看</h3><h4 id="6-3-1-查看Object对象"><a href="#6-3-1-查看Object对象" class="headerlink" title="6.3.1 查看Object对象"></a>6.3.1 查看Object对象</h4><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Object</span>()).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           00 1c 53 1c (00000000 00011100 01010011 00011100) (475208704)</span><br><span class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>OFFSET：偏移量，表示从第几个字节开始。</li><li>SIZE：占用的字节大小。</li><li>TYPE：Class中定义的类型。</li><li>DESCRIPTION：对类型的描述。</li><li>VALUE：在内存中的值。</li></ul><p>一个空的Object对象占用16字节，对象标记占用8个字节，类型指针在关闭压缩后占用8个字节。</p><h4 id="6-3-2-查看Integer对象"><a href="#6-3-2-查看Integer对象" class="headerlink" title="6.3.2 查看Integer对象"></a>6.3.2 查看Integer对象</h4><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>)).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Integer object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           e0 71 5e 1c (11100000 01110001 01011110 00011100) (475951584)</span><br><span class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">     16     4    int Integer.value                             1</span><br><span class="line">     20     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><p>对比空的Object对象，总大小占用24个字节。其中，对象标记仍为8个字节并且内容相同，指针类型仍为8个字节但是内容有变化，增加了占用4个字节的实例数据，增加了占用4个字节的对齐填充。</p><p>因为int类型长度为32位，也就是4个字节，所以实例数据的大小也就是4个字节，为了保证总大小为8的倍数，额外增加了4个字节的对齐填充。</p><h4 id="6-3-3-查看Long对象"><a href="#6-3-3-查看Long对象" class="headerlink" title="6.3.3 查看Long对象"></a>6.3.3 查看Long对象</h4><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>)).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Long object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           f0 ac ba 1c (11110000 10101100 10111010 00011100) (481996016)</span><br><span class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">     16     8   long Long.value                                1</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure><p>对比Integer对象，总大小仍为24个字节。其中，对象标记和指针类型变化不大，但是实例数据占用的大小变为8个字节，并且没有对齐填充。</p><p>因为long类型长度为64位，也就是8个字节，所以实例数据就占用8个字节，并且不需要对齐填充。</p><h4 id="6-3-4-查看数组对象"><a href="#6-3-4-查看数组对象" class="headerlink" title="6.3.4 查看数组对象"></a>6.3.4 查看数组对象</h4><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.Integer; object internals:</span><br><span class="line">OFFSET  SIZE                TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                     (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4                     (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4                     (object header)                           00 42 e6 1c (00000000 01000010 11100110 00011100) (484852224)</span><br><span class="line">     12     4                     (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">     16     4                     (object header)                           03 00 00 00 (00000011 00000000 00000000 00000000) (3)</span><br><span class="line">     20     4                     (alignment/padding gap)</span><br><span class="line">     24    24   java.lang.Integer Integer;.&lt;elements&gt;                       N/A</span><br><span class="line">Instance size: 48 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure><p>数组对象在对象头中会增加数组长度，占用4个字节并且值为3表示长度为3，另外在对象标记中还需要4个字节的对齐填充。</p><p>实例数据占用了24个字节。</p><h4 id="6-3-5-查看分代信息"><a href="#6-3-5-查看分代信息" class="headerlink" title="6.3.5 查看分代信息"></a>6.3.5 查看分代信息</h4><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           00 1c a2 1c (00000000 00011100 10100010 00011100) (480386048)</span><br><span class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           09 00 00 00 (00001001 00000000 00000000 00000000) (9)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           00 1c a2 1c (00000000 00011100 10100010 00011100) (480386048)</span><br><span class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure><p>因为虚拟机在读取对象头时，是将每8位作为一组，从高往低读取的，所以在代表对象标记的8个字节中，首先打印的8位数字实际上是最后的8位数字。</p><p>对照对象头存储的信息，当没有被垃圾回收时，高8位表示如下：第1位是无效位，后4位表示分代年龄，后1位表示偏向锁，最后2位表示锁标志。</p><p>垃圾回收前，分代年龄是0，执行垃圾回收后，分代年龄变为1，4位的分代年龄表示最高年龄为15。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了虚拟机如何管理对象。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>加载过程</title>
    <link href="https://momashanhe.com/posts/20250730/165326/"/>
    <id>https://momashanhe.com/posts/20250730/165326/</id>
    <published>2025-07-30T08:53:26.000Z</published>
    <updated>2025-08-06T01:56:47.831Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了如何将类加载到虚拟机。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-类生命周期"><a href="#1-类生命周期" class="headerlink" title="1 类生命周期"></a>1 类生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括加载、连接、初始化、使用和卸载五个阶段。</p><p>如图：<br><img src="/@image/D01004/002-20250731095857.jpg" alt="20250731095857-类加载器"></p><p>其中，连接包括验证、准备、解析三个阶段。解析阶段在某些情况下可以在初始化后再开始，这是为了支持运行时绑定。</p><p>这几个阶段按顺序开始，相互交叉混合进行，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h3 id="1-1-加载阶段"><a href="#1-1-加载阶段" class="headerlink" title="1.1 加载阶段"></a>1.1 加载阶段</h3><h4 id="1-1-1-做什么"><a href="#1-1-1-做什么" class="headerlink" title="1.1.1 做什么"></a>1.1.1 做什么</h4><p>类的加载就是将class文件中的二进制数据读取到运行时内存中，将class文件中类的信息放在方法区中，然后在堆中创建一个Class对象，用于封装方法区中的数据结构。</p><p>在进行加载的时候，虚拟机需要完成三件事：</p><ul><li>通过类的全类名获取该类的二进制字节流。</li><li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。</li><li>在内存中创建一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><h4 id="1-1-2-何时做"><a href="#1-1-2-何时做" class="headerlink" title="1.1.2 何时做"></a>1.1.2 何时做</h4><p>虚拟机规范允许某个类在预料被使用的时候预先执行类的加载，不需要等到某个类首次被使用的时候才进行类的加载。</p><p>如果在进行类的加载时遇到class文件缺失，只有当使用到了该类的时候，类加载器才会报告错误，如果该类并没有被使用，那么类加载器是不会报告错误的。</p><h4 id="1-1-3-文件的来源"><a href="#1-1-3-文件的来源" class="headerlink" title="1.1.3 文件的来源"></a>1.1.3 文件的来源</h4><p>加载的class文件有种来源：</p><ul><li>从本地硬盘直接加载，最为普通的场景。</li><li>通过网络下载class文件加载，常用于Applet应用程序。</li><li>从压缩文件中提取class文件加载，常用于Jar包和War包。</li><li>运行时计算生成，常用于动态代理。</li><li>由其他文件生成，常用于JSP应用。</li><li>从数据库中提取加载，比较少见。</li><li>将源文件编译成class文件加载，常用于防止反编译的保护措施。</li></ul><h4 id="1-1-4-补充说明"><a href="#1-1-4-补充说明" class="headerlink" title="1.1.4 补充说明"></a>1.1.4 补充说明</h4><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义的类加载器来完成加载。</p><h3 id="1-2-链接阶段"><a href="#1-2-链接阶段" class="headerlink" title="1.2 链接阶段"></a>1.2 链接阶段</h3><h4 id="1-2-1-验证阶段"><a href="#1-2-1-验证阶段" class="headerlink" title="1.2.1 验证阶段"></a>1.2.1 验证阶段</h4><p>确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段大致会完成四个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合class文件格式的规范。比如是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行分析，以保证其描述的信息符合Java语言规范的要求。比如这个类是否有除了Object之外的超类。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是安全法的、符合逻辑的，不会导致虚拟机崩溃。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，可以通过参数关闭验证以缩短虚拟机类加载的时间。</p><h4 id="1-2-2-准备阶段"><a href="#1-2-2-准备阶段" class="headerlink" title="1.2.2 准备阶段"></a>1.2.2 准备阶段</h4><p>为类变量（也就是静态成员变量，不包括实例变量）分配内存并设置初始值的阶段，这些变量所使用的内存都在方法区中进行分配。</p><p>这个阶段只是为静态成员变量设置初始值，并不是赋值，赋值是在初始化阶段的<code>cinit()</code>方法中完成的。</p><p>如果静态成员变量同时是常量，常量在编译时分配初始值，如果赋值不涉及方法调用（包括构造方法调用），会在这个阶段进行赋值。</p><p>赋值：</p><ul><li>非static类型的变量，在初始化阶段的<code>init()</code>方法中赋值。</li><li>static类型的变量，在准备阶段设置初始值，在初始化阶段的<code>cinit()</code>方法中赋值。</li><li>static类型的变量，并且是final类型的变量，在编译阶段设置初始值。如果赋值不涉及方法调用，在准备阶段赋值，否则在初始化阶段的<code>cinit()</code>方法中赋值。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在准备阶段设置初始值为0，在初始化阶段的clinit方法中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在准备阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 在准备阶段设置初始值为null，在初始化阶段的clinit方法中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT=Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 在准备阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STR</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 在准备阶段设置初始值为null，在初始化阶段的clinit方法中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STR_CONSTANT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-3-解析阶段"><a href="#1-2-3-解析阶段" class="headerlink" title="1.2.3 解析阶段"></a>1.2.3 解析阶段</h4><p>虚拟机将常量池内的符号引用替换为直接引用，会把该类所引用的其他类全部加载进来，类中的引用方式包括继承、实现接口、域变量、方法定义、方法中定义的本地变量等等。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这七类符号引用进行。</p><p>引用：</p><ul><li>符号引用：在编译文件时，并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</li><li>直接引用：直接指向目标的指针（指向方法区，Class对象）、指向相对偏移量（指向堆区，Class实例对象）或指向能间接定位到目标的句柄。</li></ul><h3 id="1-3-初始化阶段"><a href="#1-3-初始化阶段" class="headerlink" title="1.3 初始化阶段"></a>1.3 初始化阶段</h3><h4 id="1-3-1-做什么"><a href="#1-3-1-做什么" class="headerlink" title="1.3.1 做什么"></a>1.3.1 做什么</h4><p>为类的静态变量赋予正确的初始值，虚拟机负责对类进行初始化，主要对类变量进行初始化。</p><p>对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量时指定初始值。</li><li>使用静态代码块为类变量指定初始值。</li></ul><p>换句话说，初始化阶段是执行<code>cinit()</code>方法的过程。</p><p>在执行子类的<code>cinit()</code>方法前，虚拟机会先执行父类的<code>cinit()</code>方法。</p><h4 id="1-3-2-线程安全"><a href="#1-3-2-线程安全" class="headerlink" title="1.3.2 线程安全"></a>1.3.2 线程安全</h4><p>在执行<code>cinit()</code>方法时，虚拟机会保证在多线程环境中正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>cinit()</code>方法。</p><p>如果一个类的<code>cinit()</code>方法中有耗时的操作，可能会造成多线程阻塞，从而导致产生死锁，并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>赋值方法：</p><ul><li><code>init()</code>方法是对象构造器方法，在new一个对象并调用该类的构造方法时才会执行，用于对非静态变量进行赋值。</li><li><code>clinit()</code>方法是类构造器方法，在初始化阶段执行，用于对静态变量进行赋值。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(); <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// &lt;init&gt;</span></span><br><span class="line">    X () &#123;</span><br><span class="line">        <span class="comment">// &lt;init&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;clinit&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-何时做"><a href="#1-3-3-何时做" class="headerlink" title="1.3.3 何时做"></a>1.3.3 何时做</h4><p>只有当主动使用时才会进行初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，包括使用new的方式，也包括使用反射、克隆、序列化的方式，会触发初始化。</li><li>调用<code>Class.forName()</code>方法，将Class文件加载到内存并返回Class对象，会触发初始化。</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值，会触发初始化。</li><li>调用类的静态方法，会触发初始化。</li><li>作为父类，初始化子类时，会触发初始化。</li><li>类中包含<code>main()</code>方法作为主类，虚拟机在启动时，会触发初始化</li><li>JDK1.7开始提供的动态语言支持，涉及解析相关方法句柄对应的类，虚拟机在启动时，会触发初始化。</li></ul><p>除此之外，其它所有引用类的方式都不会触发初始化，称为被动引用：</p><ul><li>子类引用父类静态属性，不会触发初始化。</li><li>调用<code>loadClass()</code>方法，将Class文件加载到内存，不会触发初始化。</li><li>通过数组引用类，不会触发初始化。</li><li>引用类的常量，常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发初始化。</li></ul><h4 id="1-3-4-接口说明"><a href="#1-3-4-接口说明" class="headerlink" title="1.3.4 接口说明"></a>1.3.4 接口说明</h4><p>接口中不能使用静态代码块，但是允许有静态变量初始化的赋值操作，因此接口和类一样也会生成静态构造方法。</p><p>接口在执行静态构造方法时，不需要加载父接口，也不需要在准备阶段执行父接口的静态构造方法，只有在使用了父接口的静态变量才会加载父接口，并执行父接口的静态构造方法。</p><h3 id="1-4-使用阶段"><a href="#1-4-使用阶段" class="headerlink" title="1.4 使用阶段"></a>1.4 使用阶段</h3><p>调用成员变量或者成员方法执行业务逻辑。</p><h3 id="1-5-卸载阶段"><a href="#1-5-卸载阶段" class="headerlink" title="1.5 卸载阶段"></a>1.5 卸载阶段</h3><p>虚拟机在进行垃圾收集的时候卸载类。</p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>类加载器是通过类的全类名来加载类的二进制字节流的代码模块，其主要作用是将class文件二进制数据放入方法区内，然后在堆内创建一个Class类型的对象。</p><p>使用Class对象封装类在方法区内的数据结构，向开发者提供了访问方法区内数据结构的接口。</p><h3 id="2-2-唯一"><a href="#2-2-唯一" class="headerlink" title="2.2 唯一"></a>2.2 唯一</h3><p>对于任意一个类，都需要由类的类加载器和类本身共同确立其在虚拟机中的唯一性。</p><p>即使两个类来源于同一个Class文件，并且被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相同。</p><p>这里的相同包括<code>equals()</code>方法和<code>isInstance()</code>方法的返回结果，也包括使用<code>instanceof</code>关键字做对象所属关系判定等情况。</p><h3 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h3><p>从虚拟机的角度来看，只存在两种不同的类加载器：</p><ul><li>启动类加载器：这个类加载器使用C++语言实现，是虚拟机自身的一部分。</li><li>其他类加载器：这些类加载器由Java语言实现，独立存在于虚拟机外部，继承自ClassLoader类。</li></ul><p>站在开发人员的角度来看，可以将其他类加载器划分得更细致一些。</p><h4 id="2-2-1-启动类加载器"><a href="#2-2-1-启动类加载器" class="headerlink" title="2.2.1 启动类加载器"></a>2.2.1 启动类加载器</h4><p>BootstrapClassLoader类负责加载存放在JDK安装目录中的lib目录中的类库，或被-Xbootclasspath参数指定路径中的类库（比如rt.jar和<code>java</code>开头的类）。</p><p>启动类加载器是无法被程序直接引用的，也就是说是无法直接获取的。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">    System.out.println(String.class.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h4 id="2-2-2-扩展类加载器"><a href="#2-2-2-扩展类加载器" class="headerlink" title="2.2.2 扩展类加载器"></a>2.2.2 扩展类加载器</h4><p>ExtensionClassLoader类由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK安装目录中的ext目录中的类库，或者被java.ext.dirs系统变量指定路径中的类库（比如<code>javax</code>开头的类）。</p><p>开发者可以直接使用扩展类加载器。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader@4b67cf4d</span><br></pre></td></tr></table></figure><h4 id="2-2-3-应用类加载器"><a href="#2-2-3-应用类加载器" class="headerlink" title="2.2.3 应用类加载器"></a>2.2.3 应用类加载器</h4><p>ApplicationClassLoader类由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径（ClassPath）所指定的类。</p><p>开发者可以直接使用应用类加载器，如果应用程序中没有自定义过自己的类加载器，默认使用这个类加载器。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">    System.out.println(Demo.class.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><h4 id="2-2-4-自定义类加载器"><a href="#2-2-4-自定义类加载器" class="headerlink" title="2.2.4 自定义类加载器"></a>2.2.4 自定义类加载器</h4><p>如果上述虚拟机自带的类加载器不能满足需求，就需要自定义类加载器。</p><p>比如应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样就需要自定义类加载器来实现。</p><p>自定义类加载器需要继承ClassLoader抽象类，并重写父类的<code>findClass()</code>方法，在所有父类加载器无法加载的时候调用<code>findClass()</code>方法加载类。</p><p>被加载的类：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoBusiness</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> DemoBusiness.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLoader &gt;&gt;&gt; &quot;</span> + classLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLoader.parent &gt;&gt;&gt; &quot;</span> + classLoader.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并生成class字节码文件：</p><figure class="highlight cmd"><figcaption><span>cmd</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">utf8</span> <span class="title">DemoBusiness.java</span></span></span><br></pre></td></tr></table></figure><p>使用自定义类加载器：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 指定类加载器加载调用</span></span><br><span class="line">        <span class="type">DemoClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClassLoader</span>();</span><br><span class="line">        classLoader.loadClass(<span class="string">&quot;DemoBusiness&quot;</span>).getMethod(<span class="string">&quot;business&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 加载指定类名的Class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classDir</span> <span class="operator">=</span> <span class="string">&quot;D:\\&quot;</span> + name.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(classDir);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String path) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path); <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader &gt;&gt;&gt; DemoClassLoader@7ea987ac</span><br><span class="line">ClassLoader.parent &gt;&gt;&gt; sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><h3 id="2-4-关系"><a href="#2-4-关系" class="headerlink" title="2.4 关系"></a>2.4 关系</h3><p>类加载器的关系如图：<br><img src="/@image/D01004/002-20250730170959.jpg" alt="20250730170959-类加载器"></p><p>这里类加载器之间的父子关系一般不会以继承（Inheritance）关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><h3 id="2-5-机制"><a href="#2-5-机制" class="headerlink" title="2.5 机制"></a>2.5 机制</h3><h4 id="2-5-1-全盘负责机制"><a href="#2-5-1-全盘负责机制" class="headerlink" title="2.5.1 全盘负责机制"></a>2.5.1 全盘负责机制</h4><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p>重要性：</p><ul><li>保证一致性：确保一个类及其所有依赖项都由同一个类加载器加载。</li><li>命名空间隔离：这是沙箱机制和模块化的基础。不同类加载器加载的类属于不同的命名空间，即使类名相同也被视为不同的类。</li></ul><h4 id="2-5-2-双亲委派机制"><a href="#2-5-2-双亲委派机制" class="headerlink" title="2.5.2 双亲委派机制"></a>2.5.2 双亲委派机制</h4><p>先让父类加载器加载该类，如果父类加载器之上还有加载器，则进一步向上委托，只有在父类加载器无法加载该类时才尝试自己加载该类。</p><p>重要性：</p><ul><li>避免重复加载：确保一个类在JVM中只被加载一次，防止同一个类被不同加载器加载多次导致类型混乱和资源浪费。</li><li>保证核心库安全：保证程序安全稳定运行，防止核心类被随意篡改。</li></ul><p>在某些特定场景下，类加载机制不遵循双亲委派的原则，而是由子加载器主动加载或选择特定的加载路径，破坏了双亲委派模型。</p><p>但是这种破坏并非设计缺陷，而是为满足特定需求而采取的必要手段：</p><div class="tabs" id="tab-tab-id-1"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1-1">历史原因</a></li><li class="tab"><a class="#tab-id-1-2">核心类依赖应用类</a></li><li class="tab"><a class="#tab-id-1-3">容器隔离需求</a></li><li class="tab"><a class="#tab-id-1-4">动态更新</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1-1"><p>在JDK1.2之前，尚未引入双亲委派模型，用户自定义类加载器需要重写<code>loadClass()</code>方法，可能未遵循委派模型。</p><p>在JDK1.2之后，引入了双亲委派模型，用户自定义类加载器需要重写<code>findClass()</code>方法，符合双亲委派模型。</p><p>总结：</p><ul><li>如果想破坏双亲委派模型，就重写<code>loadClass()</code>方法。</li><li>如果想保持双亲委派模型，就重写<code>findClass()</code>方法。</li></ul></div><div class="tab-pane" id="tab-id-1-2"><p>在某些特殊场景中，接口由启动类加载器加载，实现类由应用类加载器加载，此时应当由应用类加载器负责接口的加载。</p><p>比如JNDI服务，接口由启动类加载器去加载，由独立厂商实现的接口提供者（SPI，Service Provider Interface）的代码属于实现类，启动类加载器无法加载用户自定义的实现类。</p><p>解决办法是使用线程上下文类加载器（Thread Context ClassLoader），支持设置和获取：</p><ul><li>使用<code>Thread.setContextClassLoaser()</code>方法进行设置。</li><li>使用<code>Thread.currentThread().getContextClassLoader()</code>方法获取。</li></ul><p>当启动类加载器加载核心类后，需要加载实现类时，启动类加载器尝试获取线程上下文类加载器加载实现类。如果创建线程时没有设置，将使用父线程的线程上下文类加载器，如果在全局范围内都没有设置，默认使用应用程序类加载器。</p><p>所有涉及SPI的加载动作基本上都采用这种逆向委派方式加载，例如JNDI和JDBC等。</p></div><div class="tab-pane" id="tab-id-1-3"><p>Tomcat需要部署多个Web应用，每个应用可能依赖不同版本的类库。若遵循双亲委派，这些类会被父加载器加载并共享，导致版本冲突。</p><p>Tomcat使用WebAppClassLoader加载，失败后再委托SharedClassLoader加载，而非默认双亲委派。</p><p>这么做可以让每个Web应用的类由自己的WebAppClassLoader加载，实现类隔离，避免版本冲突。</p></div><div class="tab-pane" id="tab-id-1-4"><p>为了追求程序的动态性，使用热替换（Hot Swap）和热部署（Hot Deployment）等技术，在不重启JVM的情况下更新类。</p><p>OSGi框架为每个模块创建独立的BundleClassLoader类加载器，当模块动态更新时，OSGi会销毁旧的类加载器，创建新的类加载器重新加载类，此时新类与旧类虽然全限定名相同，但属于不同类加载器加载的不同类，实现热部署。</p><p>这种模型完全打破了双亲委派的层级关系，类加载器之间可以平级委托甚至双向委托，灵活性极高。</p></div></div></div><h4 id="2-5-3-缓存机制"><a href="#2-5-3-缓存机制" class="headerlink" title="2.5.3 缓存机制"></a>2.5.3 缓存机制</h4><p>加载过的Class会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</p><p>这就是为什么修改了Class后，必须重启虚拟机才会生效，这也是热部署需要解决的问题。</p><h4 id="2-5-4-沙箱机制"><a href="#2-5-4-沙箱机制" class="headerlink" title="2.5.4 沙箱机制"></a>2.5.4 沙箱机制</h4><p>沙箱机制是将代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p><p>沙箱机制是对核心源代码的保护，在一定程度上可以保护程序安全，保护原生的JDK代码。</p><h2 id="3-类加载顺序"><a href="#3-类加载顺序" class="headerlink" title="3 类加载顺序"></a>3 类加载顺序</h2><p>当加载类时：</p><ul><li>加载同时被static和final修饰的基本类型（包括String类型）的常量并赋值。在准备阶段完成。</li><li>加载父类的静态代码，包括静态代码块和静态变量，优先加载写在前面的代码。在初始化阶段完成。</li><li>加载类的静态代码，包括静态代码块和静态变量，优先加载写在前面的代码。在初始化阶段完成。</li><li>加载父类的成员属性，包括构造代码块和成员变量，优先加载写在前面的代码。在初始化阶段完成。</li><li>加载父类的构造器方法。在初始化阶段完成。</li><li>加载类的成员属性，包括构造代码块和成员变量，优先加载写在前面的代码。在初始化阶段完成。</li><li>加载类的构造器方法。在初始化阶段完成。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">PersonOtherStatic</span> <span class="variable">personOtherStatic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonOtherStatic</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person 静态代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">PersonOther</span> <span class="variable">personOther</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonOther</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person 普通代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Person 构造器 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">HumanOtherStatic</span> <span class="variable">humanOtherStatic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanOtherStatic</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Human 静态代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Human 普通代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Human</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Human 构造器 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonOther</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOther 静态代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOther 普通代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonOther</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOther 构造器 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonOtherStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOtherStatic 静态代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOtherStatic 普通代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonOtherStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;PersonOtherStatic 构造器 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanOtherStatic</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HumanOtherStatic 静态代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HumanOtherStatic 普通代码块 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanOtherStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;HumanOtherStatic 构造器 ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HumanOtherStatic 静态代码块 ...</span><br><span class="line">HumanOtherStatic 普通代码块 ...</span><br><span class="line">HumanOtherStatic 构造器 ...</span><br><span class="line">Human 静态代码块 ...</span><br><span class="line">PersonOtherStatic 静态代码块 ...</span><br><span class="line">PersonOtherStatic 普通代码块 ...</span><br><span class="line">PersonOtherStatic 构造器 ...</span><br><span class="line">Person 静态代码块 ...</span><br><span class="line">Human 普通代码块 ...</span><br><span class="line">Human 构造器 ...</span><br><span class="line">PersonOther 静态代码块 ...</span><br><span class="line">PersonOther 普通代码块 ...</span><br><span class="line">PersonOther 构造器 ...</span><br><span class="line">Person 普通代码块 ...</span><br><span class="line">Person 构造器 ...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了如何将类加载到虚拟机。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>整体架构</title>
    <link href="https://momashanhe.com/posts/20250730/153323/"/>
    <id>https://momashanhe.com/posts/20250730/153323/</id>
    <published>2025-07-30T07:33:23.000Z</published>
    <updated>2025-08-06T01:44:18.760Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了虚拟机的整体架构。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>虚拟机（Java Virtual Machine，JVM）是Java程序运行的核心环境，它负责将class文件解释或编译为本地机器指令，并管理内存、线程、垃圾回收等关键任务。</p><h3 id="1-2-体系结构"><a href="#1-2-体系结构" class="headerlink" title="1.2 体系结构"></a>1.2 体系结构</h3><p>Java编译器输入的指令流有两种：</p><ul><li>基于栈的指令集架构：特点是不需要硬件支持，可移植性更好，更好实现跨平台。</li><li>基于寄存器的指令集架构：特点是性能优秀和执行更高效。</li></ul><p>由于跨平台性的设计，Java的指令集基于栈进行设计。</p><p>JVM模型如下：<br><img src="/@image/D01004/001-20250730154203.jpg" alt="20250730154203-模型"></p><p>模型包括类加载器、运行时数据区、执行引擎、本地接口、本地类库。</p><h3 id="1-3-发展历史"><a href="#1-3-发展历史" class="headerlink" title="1.3 发展历史"></a>1.3 发展历史</h3><h4 id="1-3-1-Sun-Classic-VM"><a href="#1-3-1-Sun-Classic-VM" class="headerlink" title="1.3.1 Sun Classic VM"></a>1.3.1 Sun Classic VM</h4><p>早在1996年JDK1.0版本的时候，Sun公司发布的Java虚拟机，是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</p><p>这款虚拟机内部只提供解释器，还没有JIT编译器，效率比较低。</p><p>可以通过外挂使用JIT编译器，但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统，解释器就不再工作，解释器和编译器不能配合工作。</p><p>现在HotSpot VM内置了此虚拟机。</p><h4 id="1-3-2-Exact-VM"><a href="#1-3-2-Exact-VM" class="headerlink" title="1.3.2 Exact VM"></a>1.3.2 Exact VM</h4><p>为了解决上一个虚拟机问题，在JDK1.2时Sun公司提供了此虚拟机。</p><p>这款虚拟机具备现代高性能虚拟机的维形，不仅支持热点探测，还支持编译器与解释器混合工作模式。</p><h4 id="1-3-3-HotSpot-VM"><a href="#1-3-3-HotSpot-VM" class="headerlink" title="1.3.3 HotSpot VM"></a>1.3.3 HotSpot VM</h4><p>最初由Longview Technologies公司设计。1997年，此公司被Sun公司收购。2009年，Sun公司被甲骨文公司收购。</p><p>在JDK1.3时，成为默认的虚拟机。</p><p>名称中的HotSpot指的就是它的热点代码探测技术：</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换。</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li></ul><h4 id="1-3-4-Taobao-JVM"><a href="#1-3-4-Taobao-JVM" class="headerlink" title="1.3.4 Taobao JVM"></a>1.3.4 Taobao JVM</h4><p>由阿里JVM团队发布，基于Hotspot VM发布的国内第一个深度定制且开源的高性能服务器版Java虚拟机。</p><p>硬件严重依赖Intel的CPU，损失了兼容性，但提高了性能。</p><h4 id="1-3-5-Graal-VM"><a href="#1-3-5-Graal-VM" class="headerlink" title="1.3.5 Graal VM"></a>1.3.5 Graal VM</h4><p>2018年4月，Oracle Labs公开了Graal VM，号称“Run Programs Faster Anywhere”，野心勃勃。与1995年Java的“write once，run anywhere”遥相呼应。</p><p>是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为任何语言的运行平台使用，包括Java、Scala、Groovy、Kotlin、C、C++、Javascript、Ruby、Python、R等。</p><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p><h2 id="2-组成部分"><a href="#2-组成部分" class="headerlink" title="2 组成部分"></a>2 组成部分</h2><h3 id="2-1-类加载器"><a href="#2-1-类加载器" class="headerlink" title="2.1 类加载器"></a>2.1 类加载器</h3><p>类加载器的作用是读取编译后的class文件，寻找类并加载到JVM内存中。</p><h3 id="2-2-运行时数据区"><a href="#2-2-运行时数据区" class="headerlink" title="2.2 运行时数据区"></a>2.2 运行时数据区</h3><p>运行时数据区的作用是在程序执行期间存储数据，包括类的信息，变量和常量，代码和指令，计算结果等数据。</p><p>在JDK1.8以前，运行时数据区是由程序计数器、本地方法栈、虚拟机栈、堆、方法区组成。</p><p>在JDK1.8以后，在本地内存增加了元空间的概念，将方法区从运行时数据区移除并作为元空间的实现放到了本地内存。</p><p>其中，方法区和堆是线程共享区域，虚拟机栈和本地方法栈以及程序计数器是线程私有区域。</p><h3 id="2-3-执行引擎"><a href="#2-3-执行引擎" class="headerlink" title="2.3 执行引擎"></a>2.3 执行引擎</h3><p>执行引擎的作用是对class文件中的字节码进行编译解释，转换为机器指令码并执行。</p><p>在执行指令码时，会将计算结果存储在运行时数据区中。</p><h3 id="2-4-本地接口"><a href="#2-4-本地接口" class="headerlink" title="2.4 本地接口"></a>2.4 本地接口</h3><p>本地接口的作用是为执行引擎提供支持。</p><h3 id="2-5-本地类库"><a href="#2-5-本地类库" class="headerlink" title="2.5 本地类库"></a>2.5 本地类库</h3><p>本地类库的作用是为执行引擎和本地接口提供支持。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了虚拟机的整体架构。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>锁事</title>
    <link href="https://momashanhe.com/posts/20250730/143223/"/>
    <id>https://momashanhe.com/posts/20250730/143223/</id>
    <published>2025-07-30T06:32:23.000Z</published>
    <updated>2025-07-30T07:27:24.706Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了多线程中有关锁的一些特性。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-锁升级"><a href="#1-锁升级" class="headerlink" title="1 锁升级"></a>1 锁升级</h2><p>在JDK1.5之前，使用synchronized是操作系统级别的重量级操作。在JDK1.6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁。</p><p>在Java对象头里的MarkWord中存储了synchronized用到的锁，锁升级主要依赖占用1位的偏向锁标志位和占用2位的锁标志位。</p><h3 id="1-1-无锁"><a href="#1-1-无锁" class="headerlink" title="1.1 无锁"></a>1.1 无锁</h3><p>对象被实例化后，如果没有线程竞争锁，就是无锁状态。</p><p>偏向锁标志位为0，锁标志位为01。</p><h3 id="1-2-偏向锁"><a href="#1-2-偏向锁" class="headerlink" title="1.2 偏向锁"></a>1.2 偏向锁</h3><p>同步代码一直被同一个线程访问，在后续访问时会自动获得偏向锁。</p><p>偏向锁标志位为1，锁标志位为01。</p><h3 id="1-3-轻量锁"><a href="#1-3-轻量锁" class="headerlink" title="1.3 轻量锁"></a>1.3 轻量锁</h3><p>同步代码存在线程竞争，会升级为轻量锁，通过CAS自旋尝试获取锁。</p><p>偏向锁标志位为0，锁标志位为00。</p><h3 id="1-4-重量锁"><a href="#1-4-重量锁" class="headerlink" title="1.4 重量锁"></a>1.4 重量锁</h3><p>同步代码存在线程竞争，并且通过CAS自旋尝试超过一定次数以后，仍未能获取锁，会升级为重量锁。</p><p>偏向锁标志位为0，锁标志位为10。</p><h2 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2 锁消除"></a>2 锁消除</h2><p>如果在同步代码块中锁的是局部对象，而不是共享对象，编译器就会无视同步代码块，相当于并没有对锁住的对象加锁，消除了锁的使用。</p><h2 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3 锁粗化"></a>3 锁粗化</h2><p>如果前后同步代码块锁住的都是同一个对象，编译器就会把代码块合并成更大的代码块，加粗加大范围，一次申请锁使用即可，避免多次的申请和释放锁，提升了性能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了多线程中有关锁的一些特性。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin</title>
    <link href="https://momashanhe.com/posts/20250726/174117/"/>
    <id>https://momashanhe.com/posts/20250726/174117/</id>
    <published>2025-07-26T09:41:17.000Z</published>
    <updated>2025-07-30T06:34:04.496Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了多线程的ForkJoin框架。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>在JDK1.7之后引入了ForkJoin框架，将一个大任务分解成多个子任务，子任务可以继续往下分解，将多个子任务的结果合并成一个大结果，最终合并成大任务的结果。</p><p>ForkJoin框架要完成两件事情：</p><ul><li>Fork：把大任务拆分成子任务。</li><li>Join：把子任务的结果合并成大任务的结果。</li></ul><p>ForkJoin框架的实现非常复杂，内部大量运用了位操作和无锁算法，核心组件：</p><ul><li>ForkJoinPool：基于工作窃取算法的线程池，负责全局任务调度与负载均衡。</li><li>ForkJoinTask：可递归Fork和Join的任务单元，自带状态机驱动完成通知。</li><li>ForkJoinWorkerThread：拥有独立队列的线程，优先执行本地任务，空闲时窃取外部队列任务。</li><li>WorkQueue：无锁双端队列，支持FIFO先进先出和LIFO后进先出，实现高效任务分发与窃取。</li></ul><h2 id="2-类和接口"><a href="#2-类和接口" class="headerlink" title="2 类和接口"></a>2 类和接口</h2><h3 id="2-1-ForkJoinPool"><a href="#2-1-ForkJoinPool" class="headerlink" title="2.1 ForkJoinPool"></a>2.1 ForkJoinPool</h3><p>ForkJoinPool是分支合并池，类似于线程池ThreadPoolExecutor类，同样是ExecutorService接口的一个实现类。</p><p>在ForkJoinPool类中提供了三个构造方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, <span class="type">boolean</span> asyncMode)</span>;</span><br></pre></td></tr></table></figure><p>最终调用的是下面这个私有构造器：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, <span class="type">int</span> mode, String workerNamePrefix)</span>;</span><br></pre></td></tr></table></figure><p>参数含义：</p><ul><li>parallelism：并行级别，默认值为CPU核心数，ForkJoinPool里线程数量与该参数有关，但它不表示最大线程数。</li><li>factory：线程工厂，默认是DefaultForkJoinWorkerThreadFactory，其实就是用来创建ForkJoinWorkerThread线程对象。</li><li>handler：异常处理器。</li><li>mode：调度模式，FIFO_QUEUE表示本地队列先进先出，LIFO_QUEUE表示本地队列后进先出。</li><li>workerNamePrefix：线程的名称前缀。</li></ul><p>成员变量：</p><ul><li>config：创建ForkJoinPool的配置，int类型的变量，占32位内存：<ul><li>低16位表示parallelism。</li><li>第17位表示mode，0表示队列后进先出，1表示队列先进先出。</li><li>第32位表示是否共享模式，0表示普通模式，1表示共享模式，队列没有线程，只能被其他线程窃取任务。</li></ul></li><li>ctl：ForkJoinPool的主要控制字段，long类型的变量，占64位内存：<ul><li>第63~48位表示激活线程数量，值为激活线程数减去parallelism（补码表示），线程激活则加1，线程停用则减1。当累积增加parallelism时第63位翻转为0，则不允许再激活线程。</li><li>第47~32位表示所有线程数量，值为所有线程数减去parallelism（补码表示），创建线程则加1，终止线程则减1。当累积增加parallelism时第47位翻转为0，则不允许再创建线程。</li><li>第31～0位表示非激活线程链中top线程的本地队列的scanState属性：<ul><li>第15~0位表示非激活线程链中top线程的本地队列在workQueues数组中的索引。</li><li>第31~16位表示非激活线程链中top线程的版本计数和线程状态。</li></ul></li></ul></li><li>workQueues：WorkQueue数组，奇数索引的队列可以关联线程并接收线程提交的本地任务，偶数索引的队列只能接收外部任务。</li><li>factory：创建线程的工厂。</li></ul><h3 id="2-2-ForkJoinTask"><a href="#2-2-ForkJoinTask" class="headerlink" title="2.2 ForkJoinTask"></a>2.2 ForkJoinTask</h3><p>ForkJoinTask是Future接口的抽象实现类，提供了用于分解任务的<code>fork()</code>方法和用于合并任务的<code>join()</code>方法。</p><p>在ThreadPoolExecutor类中，线程池执行任务调用的<code>execute()</code>方法中要求传入Runnable接口的实例。但是在ForkJoinPool类中，除了可以传入Runnable接口的实例外，还可以传入ForkJoinTask抽象类的实例，并且传入Runnable接口的实例也会被适配为ForkJoinTask抽象类的实例。</p><h3 id="2-3-RecursiveTask"><a href="#2-3-RecursiveTask" class="headerlink" title="2.3 RecursiveTask"></a>2.3 RecursiveTask</h3><p>通常情况下使用ForkJoinTask抽象类的实例，并不需要直接继承ForkJoinTask类，只需要继承其子类：</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask：用于有返回结果的任务，最常用。</li></ul><h3 id="2-4-ForkJoinWorkerThread"><a href="#2-4-ForkJoinWorkerThread" class="headerlink" title="2.4 ForkJoinWorkerThread"></a>2.4 ForkJoinWorkerThread</h3><p>ForkJoinWorkerThread类是Thread的子类，作为线程池中的线程执行任务，其内部维护了一个WorkerQueue类型的双向任务队列。</p><p>线程在执行任务时，优先处理本地任务队列中的任务（支持FIFO和LIFO），当本地任务队列为空时，会窃取外部任务队列中的任务（FIFO）。</p><h3 id="2-5-WorkerQueue"><a href="#2-5-WorkerQueue" class="headerlink" title="2.5 WorkerQueue"></a>2.5 WorkerQueue</h3><p>WorkerQueue类是ForkJoinPool类的一个内部类，存储ForkJoinTask实例的双端队列。</p><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3 源码"></a>3 源码</h2><h3 id="3-1-提交任务"><a href="#3-1-提交任务" class="headerlink" title="3.1 提交任务"></a>3.1 提交任务</h3><p>调用ForkJoinPool类的<code>submit()</code>方法提交任务，将任务添加到外部队列，唤醒线程执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-分解任务"><a href="#3-2-分解任务" class="headerlink" title="3.2 分解任务"></a>3.2 分解任务</h3><p>调用ForkJoinTask类的<code>fork()</code>方法分解任务，将任务添加到队列并唤醒线程执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 判断调用线程是否为内部线程</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        <span class="comment">// 如果是内部线程，将任务添加到本地队列，唤醒线程执行任务</span></span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是内部线程，将任务添加到外部队列，唤醒线程执行任务</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-添加任务"><a href="#3-3-添加任务" class="headerlink" title="3.3 添加任务"></a>3.3 添加任务</h3><h4 id="3-3-1-添加任务到本地队列"><a href="#3-3-1-添加任务到本地队列" class="headerlink" title="3.3.1 添加任务到本地队列"></a>3.3.1 添加任务到本地队列</h4><p>调用WorkQueue类的<code>push()</code>方法，将任务添加到本地队列，唤醒线程执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        <span class="comment">// 将任务添加到本地队列</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="built_in">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 唤醒线程执行任务</span></span><br><span class="line">                p.signalWork(p.workQueues, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-添加任务到外部队列"><a href="#3-3-2-添加任务到外部队列" class="headerlink" title="3.3.2 添加任务到外部队列"></a>3.3.2 添加任务到外部队列</h4><p>调用ForkJoinPool类的<code>externalPush()</code>方法，将任务添加到外部队列，唤醒线程执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runState;</span><br><span class="line">    <span class="comment">// 计算偶数下标，尝试将任务添加到外部队列</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (q = ws[m &amp; r &amp; SQMASK]) != <span class="literal">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="type">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 唤醒线程执行任务</span></span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务失败，初始化外部队列，唤醒线程执行任务</span></span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinPool类的<code>externalSubmit()</code>方法，初始化外部队列，唤醒线程执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="type">int</span> rs, m, k;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">move</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果runState为负数，则终止线程池并跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程池未初始化，则初始化然后继续循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                  ((ws = workQueues) == <span class="literal">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="built_in">this</span>, STEALCOUNTER, <span class="literal">null</span>,</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">AtomicLong</span>());</span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则加锁尝试添加任务唤醒工作线程并跳出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> q.top;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">submitted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="literal">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                        (a = q.growArray()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        submitted = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒线程执行任务</span></span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="literal">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列为空，则创建队列并放到数组的偶数索引然后继续循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                k &lt; ws.length &amp;&amp; ws[k] == <span class="literal">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新获取下标并进行新的循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="literal">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-唤醒线程"><a href="#3-4-唤醒线程" class="headerlink" title="3.4 唤醒线程"></a>3.4 唤醒线程</h3><p>调用ForkJoinPool类的<code>signalWork()</code>方法唤醒线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> &#123;</span><br><span class="line">    <span class="type">long</span> c; <span class="type">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="comment">// 最高位为1表示可以激活线程</span></span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="comment">// 低16位为0表示没有非激活线程</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="comment">// 第47位不为0表示可以创建线程</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                <span class="comment">// 创建线程</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="literal">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="literal">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取非激活线程链的top线程然后激活，将下一个非激活线程作为top线程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vs</span> <span class="operator">=</span> (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 唤醒线程执行任务</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinPool类的<code>tryAddWorker()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAddWorker</span><span class="params">(<span class="type">long</span> c)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 设置活跃线程数和总线程数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="type">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                <span class="comment">// 创建线程</span></span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="type">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinPool类的<code>createWorker()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">createWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">fac</span> <span class="operator">=</span> factory;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThread</span> <span class="variable">wt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="literal">null</span> &amp;&amp; (wt = fac.newThread(<span class="built_in">this</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 启动线程</span></span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注销线程</span></span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-管理线程"><a href="#3-5-管理线程" class="headerlink" title="3.5 管理线程"></a>3.5 管理线程</h3><h4 id="3-5-1-创建线程"><a href="#3-5-1-创建线程" class="headerlink" title="3.5.1 创建线程"></a>3.5.1 创建线程</h4><p>调用ForkJoinPool类的<code>newThread()</code>方法创建线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title function_">newThread</span><span class="params">(ForkJoinPool pool)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinWorkerThread</span>(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinWorkerThread类的构造方法创建线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> &#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;aForkJoinWorkerThread&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = pool.registerWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinPool类的<code>registerWorker()</code>方法创建线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WorkQueue <span class="title function_">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="literal">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="literal">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, wt);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> config &amp; MODE_MASK;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="type">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 保证i是奇数</span></span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="literal">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">probes</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 保证线程的本地队列在workQueues数组中的索引是奇数</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-2-启动线程"><a href="#3-5-2-启动线程" class="headerlink" title="3.5.2 启动线程"></a>3.5.2 启动线程</h4><p>调用Thread类的<code>start()</code>方法创建线程，逐步调用ForkJoinWorkerThread类<code>run()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="literal">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">// 启动线程</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 注销线程</span></span><br><span class="line">                pool.deregisterWorker(<span class="built_in">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinPool类的<code>runWorker()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(WorkQueue w)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化任务队列</span></span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="comment">// 尝试窃取任务</span></span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="comment">// 窃取失败，加入等待队列，继续循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="comment">// 加入等待队列失败，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-3-注销线程"><a href="#3-5-3-注销线程" class="headerlink" title="3.5.3 注销线程"></a>3.5.3 注销线程</h4><p>调用ForkJoinPool类的<code>deregisterWorker()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 移除队列</span></span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="literal">null</span> &amp;&amp; (w = wt.workQueue) != <span class="literal">null</span>) &#123;</span><br><span class="line">        WorkQueue[] ws;                           <span class="comment">// remove index from array</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> w.config &amp; SMASK;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            ws[idx] = <span class="literal">null</span>;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少CTL</span></span><br><span class="line">    <span class="type">long</span> c;                                       <span class="comment">// decrement counts</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                  (<span class="built_in">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                        (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                        (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">// 处理队列相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">        w.qlock = -<span class="number">1</span>;                             <span class="comment">// ensure set</span></span><br><span class="line">        w.transferStealCount(<span class="built_in">this</span>);</span><br><span class="line">        w.cancelAll();                            <span class="comment">// cancel remaining tasks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理未终止的线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                    <span class="comment">// possibly replace</span></span><br><span class="line">        WorkQueue[] ws; <span class="type">int</span> m, sp;</span><br><span class="line">        <span class="comment">// 尝试终止线程</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>) || w == <span class="literal">null</span> || w.array == <span class="literal">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="literal">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              <span class="comment">// already terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 终止线程失败，存在空闲线程，尝试激活空闲线程</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;         <span class="comment">// wake up replacement</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止线程失败，并且不存在空闲线程，但CTL不为0，创建替换线程执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="literal">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            tryAddWorker(c);                      <span class="comment">// create replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 符合条件，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span>                                      <span class="comment">// don&#x27;t need replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="literal">null</span>)                               <span class="comment">// help clean on way out</span></span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>     </span><br><span class="line">        <span class="comment">// 抛出异常                                     // rethrow</span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-管理任务"><a href="#3-6-管理任务" class="headerlink" title="3.6 管理任务"></a>3.6 管理任务</h3><h4 id="3-6-1-窃取任务"><a href="#3-6-1-窃取任务" class="headerlink" title="3.6.1 窃取任务"></a>3.6.1 窃取任务</h4><p>调用ForkJoinPool类的<code>scan()</code>方法窃取任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="type">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="type">int</span> b, n; <span class="type">long</span> c;</span><br><span class="line">            <span class="comment">// 定位任务队列</span></span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (a = q.array) != <span class="literal">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                              U.getObjectVolatile(a, i))) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        q.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    <span class="comment">// 创建线程执行任务</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                 w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 激活栈顶线程</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="type">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已扫描全部线程，但并未找到任务</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                    oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 尝试对当前线程灭活</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((SP_MASK &amp; ns) |</span><br><span class="line">                               (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="type">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-2-执行任务"><a href="#3-6-2-执行任务" class="headerlink" title="3.6.2 执行任务"></a>3.6.2 执行任务</h4><p>调用WorkQueue类的<code>runTask()</code>方法执行任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        <span class="comment">// 执行外部任务</span></span><br><span class="line">        (currentSteal = task).doExec();</span><br><span class="line">        U.putOrderedObject(<span class="built_in">this</span>, QCURRENTSTEAL, <span class="literal">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        <span class="comment">// 执行本地任务</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        <span class="type">ForkJoinWorkerThread</span> <span class="variable">thread</span> <span class="operator">=</span> owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            <span class="comment">// 增加窃取任务数</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-3-阻塞任务"><a href="#3-6-3-阻塞任务" class="headerlink" title="3.6.3 阻塞任务"></a>3.6.3 阻塞任务</h4><p>调用ForkJoinPool类的<code>awaitWork()</code>方法阻塞任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">awaitWork</span><span class="params">(WorkQueue w, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pred</span> <span class="operator">=</span> w.stackPred, spins = SPINS, ss;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="type">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="literal">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                    (v.parker == <span class="literal">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="type">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ac</span> <span class="operator">=</span> (<span class="type">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);</span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>)) ||</span><br><span class="line">                (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="type">int</span>)c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="literal">false</span>, parkTime);</span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="literal">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-合并任务"><a href="#3-7-合并任务" class="headerlink" title="3.7 合并任务"></a>3.7 合并任务</h3><p>调用ForkJoinTask类的<code>join()</code>方法获取任务执行结果：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ForkJoinTask类的<code>doJoin()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><p>任务类定义，因为需要返回结果，所以继承RecursiveTask，并覆写compute方法。</p><p>任务的拆分通过ForkJoinTask的fork方法执行，join方法用于等待任务执行后返回。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">sumTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ForkJoinTask&lt;Integer&gt; task = pool.submit(sumTask);</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// 拆分阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 拆分开始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="comment">// 拆分结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 小于阈值，直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end; i++) &#123;</span><br><span class="line">                value += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于阈值，递归计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">beginTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(begin, middle);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">endTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            beginTask.fork();</span><br><span class="line">            endTask.fork();</span><br><span class="line">            value = beginTask.join() + endTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5050</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了多线程的ForkJoin框架。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>辅助类</title>
    <link href="https://momashanhe.com/posts/20250725/091434/"/>
    <id>https://momashanhe.com/posts/20250725/091434/</id>
    <published>2025-07-25T01:14:34.000Z</published>
    <updated>2025-07-26T09:35:05.671Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要学习了JUC提供的三个常用的辅助类。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>用于将线程阻塞某段时间，等其他线程完成后，唤醒被阻塞的线程继续执行。</p><p>CountDownLatch在内部维护了一个计数器，需要在构造方法中传入一个非负整数。</p><p>当线程调用<code>await()</code>方法后，判断计数器是否为0，如果为0则继续执行，如果不为0则阻塞线程。</p><p>当其他线程调用<code>countDown()</code>方法后，将计数器减1，并判断计数器是否为0，如果计数器不为0则无事发生，如果计数器为0则唤醒被阻塞的线程继续执行。</p><p>计数器无法被重置，只能使用一次，不能重复使用。</p><h3 id="1-2-源码"><a href="#1-2-源码" class="headerlink" title="1.2 源码"></a>1.2 源码</h3><h4 id="1-2-1-构造方法"><a href="#1-2-1-构造方法" class="headerlink" title="1.2.1 构造方法"></a>1.2.1 构造方法</h4><p>构造方法需要传入一个非负整数，否则会抛出异常：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Sync继承自AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Sync的构造方法</span></span><br><span class="line">    Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// AQS类的setState()方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-阻塞方法"><a href="#1-2-2-阻塞方法" class="headerlink" title="1.2.2 阻塞方法"></a>1.2.2 阻塞方法</h4><p>调用<code>await()</code>方法后，判断计数器是否为0，如果为0则继续执行，如果不为0则阻塞线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch的await()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// AQS的acquireSharedInterruptibly()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Sync的tryAcquireShared()方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-减少计数"><a href="#1-2-3-减少计数" class="headerlink" title="1.2.3 减少计数"></a>1.2.3 减少计数</h4><p>调用countDown()方法将计数器减1，在执行会对进行双层判断：</p><ul><li>在减少计数前，判断计数器是否为0，为0则返回false，不为0则减少计数。</li><li>在减少计数后，判断计数器是否为0，为0则返回true，不为0则返回false。</li></ul><p>只有在减少后判断等于0的时候才会唤醒等待线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch的countDown()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS的releaseShared()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sync的tryReleaseShared()方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">cdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cdl.getCount(); i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开课堂&quot;</span>);</span><br><span class="line">            cdl.countDown();</span><br><span class="line">        &#125;, i + <span class="string">&quot;号&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    cdl.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有学生都已离开课堂&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1号离开课堂</span><br><span class="line">2号离开课堂</span><br><span class="line">所有学生都已离开课堂</span><br></pre></td></tr></table></figure><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>用于将线程阻塞某段时间，等其他线程也被阻塞后，唤醒被阻塞的线程继续执行。</p><p>CyclicBarrier在内部维护了一个计数器和一个屏障操作，需要在构造方法中传入一个正整数和一个屏障方法。</p><p>当线程调用<code>await()</code>方法后，将计数器减1，并判断计数器是否为0，如果计数器不为0则阻塞线程，如果计数器为0则唤醒被阻塞的线程继续执行，并由当前线程执行屏障方法。</p><h3 id="2-2-源码"><a href="#2-2-源码" class="headerlink" title="2.2 源码"></a>2.2 源码</h3><h4 id="2-2-1-构造方法"><a href="#2-2-1-构造方法" class="headerlink" title="2.2.1 构造方法"></a>2.2.1 构造方法</h4><p>构造方法有两个，最终调用的是同一个。</p><p>要求传入一个正整数和一个屏障方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier的构造方法，指定计数器和屏障方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CyclicBarrier的构造方法，指定计数器，默认屏障方法为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-阻塞方法"><a href="#2-2-2-阻塞方法" class="headerlink" title="2.2.2 阻塞方法"></a>2.2.2 阻塞方法</h4><p>调用<code>await()</code>方法后，线程会被阻塞，直到达到指定数量后，唤醒阻塞线程，并由当前线程执行屏障操作：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;龙珠是最后一颗，龙珠集齐，召唤神龙&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;龙珠被收集&quot;</span>);</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1龙珠被收集</span><br><span class="line">4龙珠被收集</span><br><span class="line">5龙珠被收集</span><br><span class="line">7龙珠被收集</span><br><span class="line">3龙珠被收集</span><br><span class="line">2龙珠被收集</span><br><span class="line">6龙珠被收集</span><br><span class="line">4龙珠是最后一颗，龙珠集齐，召唤神龙</span><br></pre></td></tr></table></figure><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3 Semaphore"></a>3 Semaphore</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>用于控制同时访问许可证的线程数量。</p><p>Semaphore在内部维护了一个许可证数量，需要在构造方法中传入一个非负整数。</p><p>当线程调用<code>acquire()</code>方法后，尝试将许可证数量减1并判断是否大于等于0，如果为true则继续执行，如果为false则阻塞并等待，直到有许可证释放重新尝试获取许可证。</p><p>当线程调用<code>release()</code>方法后，释放许可证，唤醒被阻塞的线程抢占许可证。</p><h3 id="3-2-源码"><a href="#3-2-源码" class="headerlink" title="3.2 源码"></a>3.2 源码</h3><h4 id="3-2-1-构造方法"><a href="#3-2-1-构造方法" class="headerlink" title="3.2.1 构造方法"></a>3.2.1 构造方法</h4><p>构造方法有两个，都需要传入整型的许可证数量。</p><p>第一个使用非公平的锁：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore类的非公平锁的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个可以传入参数指定使用公平锁还是非公平锁：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore类的公平锁的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-获取许可证"><a href="#3-2-2-获取许可证" class="headerlink" title="3.2.2 获取许可证"></a>3.2.2 获取许可证</h4><p>调用<code>acquire()</code>方法后，线程尝试获取许可证，获取失败会被阻塞，当有许可证被释放时重新抢占许可证：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-释放许可证"><a href="#3-2-3-释放许可证" class="headerlink" title="3.2.3 释放许可证"></a>3.2.3 释放许可证</h4><p>调用<code>release()</code>方法后，线程释放许可证，唤醒被阻塞的线程抢占许可证：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放了&quot;</span>);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2抢到了</span><br><span class="line">1抢到了</span><br><span class="line">// 等待1s</span><br><span class="line">1释放了</span><br><span class="line">2释放了</span><br><span class="line">4抢到了</span><br><span class="line">3抢到了</span><br><span class="line">// 等待1s</span><br><span class="line">3释放了</span><br><span class="line">4释放了</span><br><span class="line">5抢到了</span><br><span class="line">// 等待1s</span><br><span class="line">5释放了</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要学习了JUC提供的三个常用的辅助类。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://momashanhe.com/posts/20250724/160737/"/>
    <id>https://momashanhe.com/posts/20250724/160737/</id>
    <published>2025-07-24T08:07:37.000Z</published>
    <updated>2025-07-26T14:22:50.204Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要了解了JUC中的AQS抽象类。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>AQS（AbstractQueuedSynchronizer，抽象的队列同步器）定义了一套多线程访问共享资源的同步器框架，是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石。</p><h3 id="1-2-抽象"><a href="#1-2-抽象" class="headerlink" title="1.2 抽象"></a>1.2 抽象</h3><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><h3 id="1-3-原理"><a href="#1-3-原理" class="headerlink" title="1.3 原理"></a>1.3 原理</h3><p>AQS最重要的组成部分是FIFO队列和state变量，通过FIFO队列来完成资源获取线程的排队工作，通过state整型变量表示持有锁的状态：<br><img src="/@image/D01003/011-20250725092231.jpg" alt="20250725092231-原理"></p><p>抢到资源的线程直接处理业务逻辑，抢不到资源的线程进入等待队列，这个队列是CLH队列的变体。队列将请求共享资源的线程封装成队列的Node结点，通过CAS自旋以及LockSupport的凭证机制，维护state变量的状态，使并发达到同步的控制效果。</p><p>CLH（Craig Landin Hagersten，三个科学家名字）队列的原版是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO，头节点在初始化后变为空节点。</p><h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h2><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 内部封装Node节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 标记线程以共享的模式等待锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 标记线程以独占的模式等待锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// waitStatus取值为1表示线程取消，即超时和中断，被取消的节点不会阻塞</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// waitStatus取值为-1表示后继节点已经准备完成，等待线程释放资源</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// waitStatus取值为-2表示线程在Condition队列中阻塞，当其他线程调用了Condition中的唤醒方法后，将节点从Condition队列转移到CLH等待队列</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// waitStatus取值为-3表示线程及后续线程无条件传播</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 线程的等待状态，初始值为0</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="comment">// 前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev</span><br><span class="line">        <span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 线程对象</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">// 资源状态，等于0表示可获取，大于等于1表示已占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="comment">// 获取资源状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置资源状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS设置资源状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS使用volatile修饰的state整型变量表示同步状态，通过CLH同步队列来完成线程的排队工作。</p><p>对state值的修改是通过CAS完成的，当前线程根据state的值判断能否获取资源。如果获取失败，AQS会将当前线程thread以及等待状态waitStatus等信息封装成Node节点，并将其加CLH入同步队列，同时阻塞当前线程。当state的值变为可获取资源后，会把Node节点中的线程唤醒，再次尝试获取资源。</p><h2 id="3-逻辑"><a href="#3-逻辑" class="headerlink" title="3 逻辑"></a>3 逻辑</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>Lock接口的实现类基本都是通过聚合队列同步器的子类完成线程访问控制。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock类的内部聚合了Sync类，Sync类继承自AQS类，并且非公平锁NonfairSync和公平锁FairSync都继承自Sync，默认创建的是非公平锁NonfairSync。</p><h3 id="3-2-阶段"><a href="#3-2-阶段" class="headerlink" title="3.2 阶段"></a>3.2 阶段</h3><p>整个ReentrantLock的加锁过程，可以分为三个阶段：</p><ul><li>尝试加锁。</li><li>加锁失败，线程入队列。</li><li>线程入队列后，进入阻赛状态。</li></ul><h3 id="3-3-举例"><a href="#3-3-举例" class="headerlink" title="3.3 举例"></a>3.3 举例</h3><p>三个客户在银行办理业务，使用默认的非公平锁：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-分析"><a href="#3-4-分析" class="headerlink" title="3.4 分析"></a>3.4 分析</h3><h4 id="3-4-1-线程A获取资源"><a href="#3-4-1-线程A获取资源" class="headerlink" title="3.4.1 线程A获取资源"></a>3.4.1 线程A获取资源</h4><p>线程A进入，调用<code>lock()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用CAS设置state为1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 表示获取资源成功，将当前线程设为占用线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 表示获取资源失败，继续抢占资源</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程A是第一个获取资源的线程，所以获取资源成功，将当前线程设为占用线程，执行业务。</p><h4 id="3-4-2-线程B获取资源"><a href="#3-4-2-线程B获取资源" class="headerlink" title="3.4.2 线程B获取资源"></a>3.4.2 线程B获取资源</h4><p>线程B进入，调用<code>lock()</code>方法。</p><p>因为线程B是第二个获取资源的线程，线程A已经将state从0改为了1，所以使用<code>compareAndSetState()</code>方法设置失败。</p><h4 id="3-4-3-线程B抢占资源"><a href="#3-4-3-线程B抢占资源" class="headerlink" title="3.4.3 线程B抢占资源"></a>3.4.3 线程B抢占资源</h4><p>线程B获取失败，调用<code>acquire()</code>方法抢占资源：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 抢占资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 加入等待队列</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 线程阻塞</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>tryAcquire()</code>方法抢占资源：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用非公平锁的尝试抢占方法</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用非公平锁的<code>nonfairTryAcquire()</code>方法，返回false表示占用失败：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 记录当前资源状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 0表示当前资源可用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用CAS设置state为请求数</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 表示获取资源成功，将当前线程设为占用线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于等于1表示当前资源被占用，判断当前线程是否为占用线程（可重入锁的情况）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程为占用线程，记录资源状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires</span><br><span class="line">        <span class="comment">// 判断是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置state为新的资源状态</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程B是第二个获取资源的线程，线程A已经将state从0改为了1，所以使用<code>nonfairTryAcquire()</code>方法占用失败。</p><h4 id="3-4-4-线程B等待"><a href="#3-4-4-线程B等待" class="headerlink" title="3.4.4 线程B等待"></a>3.4.4 线程B等待</h4><p>线程B抢占失败，调用<code>addWaiter()</code>方法将当前线程加入等待队列：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程和传入的独占模式封装为节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 尾节点不为空，表示CLH队列已经初始化，CAS操作将当前节点设为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点为空，表示CLH队列还未初始化，初始化队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程B是第一个进入等待的线程，尾节点为空，所以使用<code>enq()</code>方法初始化队列：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 尾节点为空，通过CAS设置头节点和尾节点为空节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾节点不为空，通过CAS将当前节点作为新的尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化CLH队列后，头节点为空节点，尾节点为当前节点。</p><h4 id="3-4-5-线程B阻塞"><a href="#3-4-5-线程B阻塞" class="headerlink" title="3.4.5 线程B阻塞"></a>3.4.5 线程B阻塞</h4><p>线程B得到当前节点后，作为参数传入<code>acquireQueued()</code>方法加入CLH队列：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前节点是否取消，默认为true，表示取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记当前节点是否中断，默认为false，表示当前节点没有中断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的上一节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果上一节点是头节点，表示当前节点即将被唤醒，尝试抢占资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设为新头节点，置空当前节点的上一节点，并取消当前节点同当前线程的绑定</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将原头节点的下一节点置空，方便GC回收</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 标记当前节点为false，表示没有取消</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回false，表示当前节点没有中断</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果上一节点不是头节点，或者抢占资源失败，处理上一节点并阻塞当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 标记为true，表示当前节点中断</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点如果被取消，执行取消操作</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程B是第一个进入等待的线程，上一节点为头节点，调用<code>tryAcquire()</code>方法尝试获取资源。获取成功则将当前节点作为头节点并移除上一节点，获取失败则阻塞。</p><p>获取资源失败调用<code>shouldParkAfterFailedAcquire()</code>方法处理上一节点：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录上一节点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 如果上一节点的等待状态为-1，表示当前线程可以被阻塞，返回true，继续判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果上一节点的等待状态为1，表示上一节点被取消，循环移除被取消的上一节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 上述条件不满足，表示上一节点的等待状态为0或者-3，通过CAS将等待状态设置为-1</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false，重新进入自旋</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程B是第一个进入等待的线程，上一节点为头节点，头节点为空节点，等待状态为0，所以两次进入<code>shouldParkAfterFailedAcquire()</code>方法：</p><ul><li>第一次进入将上一节点的等待状态设置为-1后返回false，条件判断为false重新进入自旋。</li><li>第二次进入检测到上一节点的等待状态为-1，返回true，调用<code>parkAndCheckInterrupt()</code>方法。</li></ul><p>调用<code>parkAndCheckInterrupt()</code>方法阻塞当前节点：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 阻塞当前节点</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 返回线程的中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-6-线程C获取资源"><a href="#3-4-6-线程C获取资源" class="headerlink" title="3.4.6 线程C获取资源"></a>3.4.6 线程C获取资源</h4><p>线程C进入，调用<code>lock()</code>方法。</p><p>因为线程C是第三个获取资源的线程，线程A已经将state从0改为了1，所以使用<code>compareAndSetState()</code>方法设置失败。</p><h4 id="3-4-7-线程C抢占资源"><a href="#3-4-7-线程C抢占资源" class="headerlink" title="3.4.7 线程C抢占资源"></a>3.4.7 线程C抢占资源</h4><p>线程C获取失败，调用<code>acquire()</code>方法抢占资源，源码同上。</p><p>调用<code>tryAcquire()</code>方法抢占资源，源码同上。</p><p>调用非公平锁的<code>nonfairTryAcquire()</code>方法，返回false表示占用失败，源码同上。</p><p>因为线程C是第三个获取资源的线程，线程A已经将state从0改为了1，所以使用<code>nonfairTryAcquire()</code>方法占用失败。</p><h4 id="3-4-8-线程C等待"><a href="#3-4-8-线程C等待" class="headerlink" title="3.4.8 线程C等待"></a>3.4.8 线程C等待</h4><p>线程C抢占失败，调用<code>addWaiter()</code>方法将当前线程加入等待队列，源码同上。</p><p>因为线程C是第二个进入等待的线程，线程B已经完成了队列初始化，尾节点不为空，使用CAS将当前节点作为新的尾节点。</p><h4 id="3-4-9-线程C阻塞"><a href="#3-4-9-线程C阻塞" class="headerlink" title="3.4.9 线程C阻塞"></a>3.4.9 线程C阻塞</h4><p>线程C得到当前节点后，作为参数传入<code>acquireQueued()</code>方法加入CLH队列，源码同上。</p><p>因为线程C是第二个进入等待的线程，上一节点为B节点，B节点不是头节点，不能获取资源。</p><p>调用<code>shouldParkAfterFailedAcquire()</code>方法处理上一节点，源码同上。</p><p>因为线程C是第二个进入等待的线程，上一节点为B节点，等待状态为-1，返回true，调用<code>parkAndCheckInterrupt()</code>方法。</p><p>调用<code>parkAndCheckInterrupt()</code>方法阻塞当前节点，源码同上。</p><h4 id="3-4-10-线程A执行完毕"><a href="#3-4-10-线程A执行完毕" class="headerlink" title="3.4.10 线程A执行完毕"></a>3.4.10 线程A执行完毕</h4><p>线程A执行完毕，调用<code>unlock()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>release()</code>方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用tryRelease()方法尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 获取头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 如果头节点不为空，并且等待状态不为0，表示需要唤醒其他线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放失败返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-11-线程A释放资源"><a href="#3-4-11-线程A释放资源" class="headerlink" title="3.4.11 线程A释放资源"></a>3.4.11 线程A释放资源</h4><p>调用<code>tryRelease()</code>方法释放资源：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录资源状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不为占用线程则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 标记资源空闲，默认为false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 资源状态为0则标记资源空闲为true，并将占用线程置空</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置资源状态</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 返回资源空闲</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-12-线程A唤醒线程"><a href="#3-4-12-线程A唤醒线程" class="headerlink" title="3.4.12 线程A唤醒线程"></a>3.4.12 线程A唤醒线程</h4><p>线程B和线程C已经进入等待队列，调用<code>unparkSuccessor()</code>方法唤醒线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录头节点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果头节点的等待状态小于0，则将头节点的等待状态设为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 记录头节点的下一节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 判断下一节点是否为空或者下一节点的等待状态是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历下一节点，找到不为空并且等待状态小于等于0的节点，将其设为下一节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果下一节点不为空，则唤醒下一节点中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头节点的下一节点为B节点，线程B被唤醒。</p><h4 id="3-4-13-线程B抢占资源"><a href="#3-4-13-线程B抢占资源" class="headerlink" title="3.4.13 线程B抢占资源"></a>3.4.13 线程B抢占资源</h4><p>线程B在<code>parkAndCheckInterrupt()</code>方法中被唤醒后，返回中断状态为false，重新进入自旋。</p><p>线程B的上一节点为头节点，进入<code>tryAcquire()</code>方法抢占资源。</p><p>抢占资源成功后，将当前线程设为占用线程，将当前节点设为头节点，同时解除同线程B的绑定，执行业务。</p><h4 id="3-4-14-线程B执行完毕"><a href="#3-4-14-线程B执行完毕" class="headerlink" title="3.4.14 线程B执行完毕"></a>3.4.14 线程B执行完毕</h4><p>线程B执行完毕，调用<code>unlock()</code>方法释放资源并唤醒线程。</p><p>头节点的下一节点为C节点，线程C被唤醒。</p><h4 id="3-4-15-线程C抢占资源"><a href="#3-4-15-线程C抢占资源" class="headerlink" title="3.4.15 线程C抢占资源"></a>3.4.15 线程C抢占资源</h4><p>线程C在<code>parkAndCheckInterrupt()</code>方法中被唤醒后，返回中断状态为false，重新进入自旋。</p><p>线程C的上一节点为头节点，进入<code>tryAcquire()</code>方法抢占资源。</p><p>抢占资源成功后，将当前线程设为占用线程，将当前节点设为头节点，同时解除同线程C的绑定，执行业务。</p><h4 id="3-4-16-线程C执行完毕"><a href="#3-4-16-线程C执行完毕" class="headerlink" title="3.4.16 线程C执行完毕"></a>3.4.16 线程C执行完毕</h4><p>线程B执行完毕，调用<code>unlock()</code>方法释放资源并唤醒线程。</p><p>头节点的下一节点为空，不会有任何线程被唤醒。</p><h2 id="4-公平锁与非公平锁"><a href="#4-公平锁与非公平锁" class="headerlink" title="4 公平锁与非公平锁"></a>4 公平锁与非公平锁</h2><h3 id="4-1-非公平锁"><a href="#4-1-非公平锁" class="headerlink" title="4.1 非公平锁"></a>4.1 非公平锁</h3><p>非公平锁在资源可用时不会判断当前队列是否有线程在等待，刚加入的线程可以与被唤醒的线程一起竞争资源。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-公平锁"><a href="#4-2-公平锁" class="headerlink" title="4.2 公平锁"></a>4.2 公平锁</h3><p>公平锁在资源可用时会判断当前队列是否有线程在等待，刚加入的线程不可以与被唤醒的线程一起竞争资源。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>tryAcquire()</code>方法中使用<code>hasQueuedPredecessors()</code>方法判断等待队列中是否存在有效节点：</p><ul><li>返回false表示没有，取反后为true表示当前节点不需要排队，需要执行占用资源的操作。</li><li>返回true表示有，取反后为false表示当前节点需要排队，需要执行加入等待队列的操作。</li></ul><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>判断头节点和尾节点是否相同，如果相同，说明队列未初始化或者当前队列只有一个空节点，返回false，取反后为true，尝试占用资源。</li><li>判断头节点和尾节点是否相同，如果不相同，说明存在两个不同节点。<ul><li>继续判断下一节点是否为空节点，如果成立，说明下一节点为空，可能上个线程刚刚将头节点初始化，尚未给尾节点赋值，返回true，取反后为false，需要排队。</li><li>继续判断下一节点是否为空节点，如果不成立，说明下一节点不为空。<ul><li>继续判断下一节点封装的线程是否不等于当前线程，如果成立，说明下一线程不为当前线程，返回true，取反后为false，需要排队。</li><li>继续判断下一节点封装的线程是否不等于当前线程，如果不成立，说明下一线程为当前线程，返回false，取反后为true，尝试占用资源。</li></ul></li></ul></li></ul><h2 id="5-自定义同步器"><a href="#5-自定义同步器" class="headerlink" title="5 自定义同步器"></a>5 自定义同步器</h2><h3 id="5-1-实现方法"><a href="#5-1-实现方法" class="headerlink" title="5.1 实现方法"></a>5.1 实现方法</h3><p>不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需要实现共享资源state的获取与释放即可，至于具体线程等待队列的维护（如获取资源失败入队和唤醒出队等），AQS已经在底层实现好了。</p><p>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease和tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h3 id="5-2-举例说明"><a href="#5-2-举例说明" class="headerlink" title="5.2 举例说明"></a>5.2 举例说明</h3><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。</p><p>线程A调用<code>lock()</code>方法获取资源，同时调用<code>tryAcquire()</code>占用资源，并将state的值加1。</p><p>其他线程再调用<code>tryAcquire()</code>方法占用资源就会失败，直到线程A调用<code>unlock()</code>方法释放资源，并将state的值减0，其它线程才有机会获取该锁。</p><p>在释放锁之前，A线程可以重复获取资源，state的值会累加，这就是可重入锁。获取多少次就要释放多少次，这样才能保证state最后的值是0。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文主要了解了JUC中的AQS抽象类。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport</title>
    <link href="https://momashanhe.com/posts/20250724/142313/"/>
    <id>https://momashanhe.com/posts/20250724/142313/</id>
    <published>2025-07-24T06:23:13.000Z</published>
    <updated>2025-07-24T08:06:07.689Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了ThreadLocal的用法和原理。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，在内部使用凭证的概念来实现阻塞和唤醒，每个线程都有一个凭证，只有1和0两个值，默认是0。</p><p>LockSupport中提供了两个方法：</p><ul><li>park()方法会在凭证可用时执行，将凭证从1变成0，用于阻塞线程。</li><li>unpark()方法会在凭证不可用时执行，将凭证从0变成1，用于唤醒线程。</li></ul><p>LockSupport中的方法调用的是Unsafe类中的native代码。</p><h2 id="2-比较"><a href="#2-比较" class="headerlink" title="2 比较"></a>2 比较</h2><p>比较三种阻塞唤醒线程的方式：</p><ul><li>使用Object的wait()方法和notify()方法：<ul><li>使用wait()方法阻塞线程，使用notify()方法唤醒线程。</li><li>必须在synchronized代码块内部执行，否则抛出IllegalMonitorStateException。</li><li>必须先执行wait()方法再执行notify()方法，否则线程会一直等待无法被唤醒。</li></ul></li><li>使用Condition的await()方法和signal()方法：<ul><li>使用await()方法阻塞线程，使用signal()方法唤醒线程。</li><li>必须和Lock组队使用，否则抛出IllegalMonitorStateException。</li><li>必须先执行await()方法再执行signal()方法，否则线程会一直等待无法被唤醒。</li></ul></li><li>使用LockSupport的park()方法和uppark()方法：<ul><li>使用park()方法阻塞线程，使用uppark()方法唤醒线程。</li><li>不需要在任何代码块内执行，可以在任何地方执行。</li><li>使用顺序无要求，即使先执行uppark()方法再执行park()方法，也能唤醒线程。</li></ul></li></ul><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h2><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入&quot;</span>);</span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b进入</span><br><span class="line">b执行</span><br><span class="line">// 等待1s</span><br><span class="line">a进入</span><br><span class="line">a执行</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>LockSuport是一个线程阻塞工具类，底层调用的Unsafe中的native代码，所有的方法都是静态方法，可以让线程在任意位置阻塞和唤醒。</p><p>两个方法：</p><ul><li>调用park()方法，将凭证从1变成0，立即返回并继续执行。如果凭证为0则会阻塞，直到unpark()方法将凭证从0变为1。</li><li>调用unpark()方法，将凭证从0变成1，立即返回并继续执行，多次调用unpark()方法不会累加凭证。如果凭证为1则会阻塞，直到park()方法将凭证从1变为0。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了ThreadLocal的用法和原理。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://momashanhe.com/posts/20250723/134333/"/>
    <id>https://momashanhe.com/posts/20250723/134333/</id>
    <published>2025-07-23T05:43:33.000Z</published>
    <updated>2025-07-24T06:20:05.085Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了ThreadLocal的用法和原理。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>ThreadLocal是一个本地线程副本变量工具类，主要用于将本地线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。</p><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h2><h3 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h3><h4 id="2-1-1-设置"><a href="#2-1-1-设置" class="headerlink" title="2.1.1 设置"></a>2.1.1 设置</h4><p>设置当前线程对应的局部变量的值。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 取出当前线程对应的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果存在，将当前ThreadLocal对象作为key，将传入的值作为value，放到map里</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不存在，通过线程创建ThreadLocalMap对象</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-获取"><a href="#2-1-2-获取" class="headerlink" title="2.1.2 获取"></a>2.1.2 获取</h4><p>返回当前线程对应的局部变量的值。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 取出当前线程对应的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在，直接从map取出ThreadLocal对应的value返回</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在，创建ThreadLocalMap对象，设置并返回初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-删除"><a href="#2-1-3-删除" class="headerlink" title="2.1.3 删除"></a>2.1.3 删除</h4><p>删除当前线程对应的局部变量的值，目的是为了减少内存的占用。</p><p>当线程结束后，线程对应的局部变量将自动被回收，所以显式调用该方法并不是必须的操作，但它可以加快内存回收的速度。</p><p>如果在调用了<code>remove()</code>方法后又调用了<code>get()</code>方法，会进行重新初始化。</p><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>返回当前线程对应的局部变量的初始值。</p><p>特点：</p><ul><li>覆盖：该方法是<code>protected</code>方法，显然是为了让子类覆盖而设计的。</li><li>延迟：在线程首次调用<code>get()</code>方法或<code>set()</code>方法时执行，并且仅执行一次。</li></ul><p>源码：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><p>在一个线程中，需要共享某个资源，希望不管是在哪个类中使用该资源，都能保证该资源都是同一个，只会被创建一次，这就需要使用TheadLocal来实现。</p><p>在项目中有时会在一个线程内调用多个方法，并且在有的方法中需要传递上下文信息，比如用户信息等。</p><p>不使用TheadLocal，那就要给每一个方法增加参数，就会存在过渡传参问题，造成代码冗余：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        test.func1(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        test.func2(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TheadLocal，那么只需要设置一次参数的绑定，在其他方法中就可以通过TheadLocal直接获取，不需要传参：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadLocalUser.set(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        test.func1();</span><br><span class="line">        test.func2();</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> threadLocalUser.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h2><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><p>在ThreadLocal类内部定义了ThreadLocalMap类，该类是一个类似HashMap的类，key存储对ThreadLocal实例的弱引用，value存储引用变量。</p><p>在Thread类内部有ThreadLocalMap类型的属性，通过Thread类内部的ThreadLocalMap对象对变量进行维护。</p><p>ThreadLocal不能解决线程之间的资源共享问题，ThreadLocal解决的是一个线程内部的资源共享问题。</p><h3 id="3-2-线性探测"><a href="#3-2-线性探测" class="headerlink" title="3.2 线性探测"></a>3.2 线性探测</h3><p>ThreadLocalMap结构非常简单，没有实现Map接口，其数据存储结构不是链表而是数组，解决哈希冲突的方式并非链表的拉链法方式，而是采用线性探测方式。</p><p>根据初始key的哈希值确定元素在table数组中的位置，如果已被占用，检查通过算法得到的下一个位置，如果检查到末尾没有空位置，则从开头继续检查，直至找到空位置。</p><p>如果在ThreadLocalMap中存储了大量的ThreadLocal会导致出现聚集，严重影响解决哈希冲突的性能，建议使用Map作为变量管理不同类型的参数。</p><h3 id="3-4-数据共享"><a href="#3-4-数据共享" class="headerlink" title="3.4 数据共享"></a>3.4 数据共享</h3><p>如果在当前线程创建了子线程，在子线程中想要获取父线程中的变量，就不能使用ThreadLocal类，需要使用InheritableThreadLocal类。</p><p>InheritableThreadLocal类继承于ThreadLocal类，会自动为子线程复制继承自父线程的本地变量。</p><p>在创建子线程时，子线程会接收所有可继承的线程本地变量的初始值，当必须将本地线程变量自动传送给所有创建的子线程时，应尽可能的使用InheritableThreadLocal，而非ThreadLocal。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-内存泄漏"><a href="#4-内存泄漏" class="headerlink" title="4 内存泄漏"></a>4 内存泄漏</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>虚拟机会在达到触发条件时，对内存中不被使用的对象和变量进行回收，以便合理利用内存空间。</p><p>当不被使用的对象或者变量占用的内存不能被回收时，就会产生内存泄漏。</p><p>由ThreadLocal引发的内存泄露分为两种情况：</p><ul><li>由ThreadLocalMap中的key引起的，也就是ThreadLocal对象内存泄露。</li><li>由ThreadLocalMap中的value引起的，也就是ThreadLocal对象绑定的对象内存泄露。</li></ul><h3 id="4-2-引用类型"><a href="#4-2-引用类型" class="headerlink" title="4.2 引用类型"></a>4.2 引用类型</h3><p>根据引用类型可以分为强软弱虚四种：<br>强引用（StrongReference）：不会被垃圾回收器回收，即使以后也不会用到。<br>软引用（SoftReference）：比强引用弱，当系统内存不足时才会被回收。通常用在对内存敏感的程序中，比如高速缓存。<br>弱引用（WeakReference）：比软引用弱，生命周期更短，只要发生了垃圾回收，不管内存空间是否足够都会被回收。<br>虚引用（PhantomReference）：最弱，在任何时候都有可能被垃圾回收器回收。通常配和引用队列联合使用，在被回收前能够收到系统通知。</p><p>当需要操作共享变量时，需要先声明ThreadLocal对象，然后通过ThreadLocal对象的方法操作共享变量，这个操作实际上是通过Thread类里的ThreadLocalMap集合实现的。</p><h3 id="4-3-解决办法"><a href="#4-3-解决办法" class="headerlink" title="4.3 解决办法"></a>4.3 解决办法</h3><h4 id="4-3-1-key引起的内存泄漏"><a href="#4-3-1-key引起的内存泄漏" class="headerlink" title="4.3.1 key引起的内存泄漏"></a>4.3.1 key引起的内存泄漏</h4><p>在ThreadLocalMap集合中，key存储了ThreadLocal对象的弱引用，这么做是为了避免强引用导致的内存泄漏：</p><ul><li>如果在ThreadLocalMap集合中使用强引用，加上声明ThreadLocal对象使用的默认是强引用，此时ThreadLocal对象就同时拥有两个强引用，即使将声明ThreadLocal的变量置空后，因为存在另一个强引用，就会导致ThreadLocal对象不能被回收，进而导致内存泄露。</li><li>如果在ThreadLocalMap集合中使用弱引用，此时ThreadLocal对象就只有一个强引用，在将声明ThreadLocal对象的变量置空后，没有强引用指向ThreadLocal对象，能够保证在ThreadLocal对象在下一次垃圾回收时被回收。</li></ul><h4 id="4-3-2-value引起的内存泄漏"><a href="#4-3-2-value引起的内存泄漏" class="headerlink" title="4.3.2 value引起的内存泄漏"></a>4.3.2 value引起的内存泄漏</h4><p>在ThreadLocalMap集合中，value存储了变量的强引用。</p><p>当声明ThreadLocal对象的变量置空后，因为弱引用导致出现了key为null但value不为null的键值对，于是value存储的变量无法被获取也不能被回收，产生内存泄漏。</p><p>解决办法是及时调用<code>remove()</code>方法将用过的value对象移除。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了ThreadLocal的用法和原理。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程创建方式</title>
    <link href="https://momashanhe.com/posts/20250716/131400/"/>
    <id>https://momashanhe.com/posts/20250716/131400/</id>
    <published>2025-07-16T05:14:00.000Z</published>
    <updated>2025-07-23T03:49:40.176Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文整理了创建线程的几种方式。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1 继承Thread类"></a>1 继承Thread类</h2><p>步骤：</p><ul><li>创建继承Thread类的子类，重写<code>run()</code>方法。</li><li>创建子类的Thread对象。</li><li>调用Thread对象的<code>start()</code>方法。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2 实现Runnable接口"></a>2 实现Runnable接口</h2><p>步骤：</p><ul><li>创建实现Runnable接口的类，实现<code>run()</code>方法。</li><li>创建实现类的Runnable对象。</li><li>将Runnable对象传入Thread类的构造方法中，创建Thread对象。</li><li>调用Thread对象的<code>start()</code>方法。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发中优先选择实现Runnable接口的方式，没有单继承的局限性，更适合处理多个线程共享数据的情况。</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3 实现Callable接口"></a>3 实现Callable接口</h2><p>步骤：</p><ul><li>创建实现Callable接口的类，实现<code>call()</code>方法。</li><li>创建实现类的Callable对象。</li><li>将Callable对象传入FutureTask类的构造方法中，创建FutureTask对象。</li><li>将FutureTask对象传入Thread类的构造方法中，创建Thread对象。</li><li>调用Thread对象的<code>start()</code>方法。</li><li>调用FutureTask对象的<code>get()</code>方法，获取执行结果。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoCallable</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Integer&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1, <span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2, <span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(f1.get() + f2.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask类间接实现了Runnable接口和Future接口，所以既可以作为Runnable被线程执行，又可以作为Future获取线程执行的结果。</p><h2 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4 使用线程池"></a>4 使用线程池</h2><p>步骤：</p><ul><li>创建实现Runnable接口的类，实现<code>run()</code>方法。</li><li>创建线程池的ThreadPoolExecutor对象。</li><li>创建实现类的Runnable对象。</li><li>将Runnable对象传入ThreadPoolExecutor对象的<code>execute()</code>方法中，提交任务。</li><li>调用ThreadPoolExecutor对象的<code>shutdown()</code>方法关闭线程池。</li></ul><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(i);</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程编号：&quot;</span> + i + <span class="string">&quot;，线程池：&quot;</span> + executor.getPoolSize() + <span class="string">&quot;，队列：&quot;</span> + executor.getQueue().size());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(<span class="type">int</span> taskNo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskNo = taskNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task &quot;</span> + taskNo);</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文整理了创建线程的几种方式。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://momashanhe.com/posts/20250716/093820/"/>
    <id>https://momashanhe.com/posts/20250716/093820/</id>
    <published>2025-07-16T01:38:20.000Z</published>
    <updated>2025-07-23T03:47:41.892Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了如何在高并发场景下使用线程池创建线程。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-类和接口"><a href="#1-类和接口" class="headerlink" title="1 类和接口"></a>1 类和接口</h2><h3 id="1-1-Executor"><a href="#1-1-Executor" class="headerlink" title="1.1 Executor"></a>1.1 Executor</h3><p>Executor是一个顶层接口，在它里面只声明了一个<code>execute()</code>方法，用来在接下来的某个时刻执行提交的任务。</p><p>常用方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-ExecutorService"><a href="#1-2-ExecutorService" class="headerlink" title="1.2 ExecutorService"></a>1.2 ExecutorService</h3><p>ExecutorService接口继承了Executor接口，并声明了一些方法。</p><p>常用方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来关闭线程池，此时线程池不能够接受新的任务，它会等待所有任务执行完毕</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 用来关闭线程池，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 当调用shutdown或shutdownNow方法后返回为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 若关闭后所有任务都已完成，则返回true。注意除非首先调用shutdown或shutdownNow，否则isTerminated永不为true</span></span><br><span class="line"><span class="comment">// 当调用shutdown方法后，如果所有提交的任务都已完成，返回为true</span></span><br><span class="line"><span class="comment">// 当调用shutdownNow方法后，成功停止，返回为true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 用来向线程池提交任务，并返回任务执行的结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"><span class="comment">// 用来向线程池提交任务，并返回任务执行的结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"><span class="comment">// 用来向线程池提交任务，并返回任务执行的结果</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><h3 id="1-3-ThreadPoolExecutor"><a href="#1-3-ThreadPoolExecutor" class="headerlink" title="1.3 ThreadPoolExecutor"></a>1.3 ThreadPoolExecutor</h3><p>ThreadPoolExecutor是线程池中最核心的一个类，通过间接的方式实现了ExecutorService接口。</p><p>构造方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>corePoolSize：核心池的大小。当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。</li><li>maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程。</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize。</li><li>unit：参数keepAliveTime的时间单位，有7种取值。在TimeUnit类中有7种静态属性：<ul><li>TimeUnit.DAYS;&#x2F;&#x2F; 天</li><li>TimeUnit.HOURS;&#x2F;&#x2F; 小时</li><li>TimeUnit.MINUTES;&#x2F;&#x2F; 分钟</li><li>TimeUnit.SECONDS;&#x2F;&#x2F; 秒</li><li>TimeUnit.MILLISECONDS;&#x2F;&#x2F; 毫秒</li><li>TimeUnit.MICROSECONDS;&#x2F;&#x2F; 微妙</li><li>TimeUnit.NANOSECONDS;&#x2F;&#x2F; 纳秒</li></ul></li><li>workQueue：一个阻塞队列，用来存储等待执行的任务。一般来说，这里的阻塞队列有以下几种选择：<ul><li>ArrayBlockingQueue：有界阻塞队列。</li><li>LinkedBlockingQueue：无界阻塞队列。</li><li>SynchronousQueue：不存储元素阻塞队列，即单个元素阻塞队列。</li><li>DelayQueue：延时阻塞队列。</li></ul></li><li>threadFactory：线程工厂，主要用来创建线程。</li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值：<ul><li>ThreadPoolExecutor.AbortPolicy：抛异常，默认策略。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用线程处理新任务。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃新任务。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久任务，将新任务加入队列。</li></ul></li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-线程池状态"><a href="#2-1-线程池状态" class="headerlink" title="2.1 线程池状态"></a>2.1 线程池状态</h3><p>常用属性：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态：RUNNING。工作线程数量：0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 使用32位的高3位表示状态，余下29位表示容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 最大容量为：^29-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 运行状态用32位整型的高3位表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 封装和解析ctl值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>状态的转换：</p><ul><li>RUNNING -&gt; SHUTDOWN：调用了shutdown()方法。</li><li>RUNNING &#x2F; SHUTDOWN -&gt; STOP：调用了shutdownNow()方法。</li><li>SHUTDOWN -&gt; TIDYING：当队列中任务都被取出执行完成，并且所有工作线程都结束了任务，再没有未被执行的任务。</li><li>STOP -&gt; TIDYING：线程池中没有正在运行的线程，任务队列中任务都被取消。</li><li>TIDYING -&gt; TERMINATED：钩子方法terminated()执行完毕后。</li></ul><p>状态说明：</p><ul><li>RUNNING：运行态，可处理新任务并执行队列中的任务。</li><li>SHUTDOW：关闭态，不接受新任务，但处理队列中的任务。</li><li>STOP：停止态，不接受新任务，不处理队列中任务，且打断运行中任务。</li><li>TIDYING：整理态，所有任务已经结束，将执行terminated()方法。</li><li>TERMINATED：结束态，terminated()方法已完成。</li></ul><p>创建线程池之后不会马上创建线程，在提交任务后才会创建线程，可以手动设置创建线程池后马上创建线程：</p><ul><li>prestartCoreThread()：初始化一个核心线程。</li><li>prestartAllCoreThreads()：初始化所有核心线程。</li></ul><p>关闭线程池：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li></ul><p>动态调整线程池容量：</p><ul><li>setCorePoolSize()：设置核心池大小。</li><li>setMaximumPoolSize()：设置线程池最大能创建的线程数目大小。</li></ul><h3 id="2-2-按需创建线程池"><a href="#2-2-按需创建线程池" class="headerlink" title="2.2 按需创建线程池"></a>2.2 按需创建线程池</h3><p>Executors类中提供了几个静态方法创建线程池：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建容量为1的缓冲池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建指定容量的缓冲池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建容量可变的缓冲池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建指定容量的定时缓冲池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;：</span><br></pre></td></tr></table></figure><p>它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了：</p><ol><li>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue。</li><li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue。</li><li>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</li><li>newScheduledThreadPool将corePoolSize设置为入参，将maximumPoolSize设置为Integer.MAX_VALUE，使用的DelayQueue。</li></ol><p>不建议直接使用这几个静态方法创建线程池：</p><ul><li>SingleThreadPool和FixedThreadPool允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</li><li>CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li></ul><p>建议通过ThreadPoolExecutor的方式创建线程池，这样的处理方式能更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p><h3 id="2-3-线程创建策略"><a href="#2-3-线程创建策略" class="headerlink" title="2.3 线程创建策略"></a>2.3 线程创建策略</h3><p>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务。</p><p>如果当前线程池中的线程数目大于等于corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中：</p><ul><li>若添加成功，则该任务会等待空闲线程将其取出去执行。</li><li>若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务。</li></ul><p>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理。</p><p>如果线程池中的线程数量大于corePoolSize时，当某线程空闲时间超过keepAliveTime时，线程将被终止，直至线程池中的线程数目不大于corePoolSize。</p><p>如果允许为核心池中的线程设置存活时间，当核心池中的线程空闲时间超过keepAliveTime时，核心线程也会被终止。</p><h3 id="2-4-缓存队列"><a href="#2-4-缓存队列" class="headerlink" title="2.4 缓存队列"></a>2.4 缓存队列</h3><p>超出一定数量的任务会转移队列中，队列与池里的线程大小的关联表现在：</p><ul><li>如果运行的线程数小于corePoolSize，会创建线程执行任务。</li><li>如果运行的线程已大于corePoolSize，会把新的任务放于队列中。如果队列已到最大时，会继续创建线程，直到超过maximumPoolSize。如果线程超过maximumPoolSize，将拒绝接收新的任务。</li></ul><p>而添加任务到队列时，有几种常规的策略：</p><ul><li>有界队列。如ArrayBlockingQueue，当定义了maximumPoolSizes时，使用有界队列可以预防资源的耗尽，但是增加了调整和控制队列的难度，队列的大小和线程池的大小是相互影响的，使用很大的队列和较小的线程池会减少CPU消耗、操作系统资源以及线程上下文开销，但却人为的降低了吞吐量。如果任务是频繁阻塞型的（I&#x2F;O），系统是可以把时间片分给多个线程的。而采用较小的队列和较大的线程池，虽会造成CPU繁忙，但却会遇到调度开销，这也会降低吞吐量。</li><li>无界队列。如LinkedBlockingQueue，当核心线程正在工作时，使用不用预先定义大小的无界队列，使新任务等待，所以如果线程数是小于corePoolSize时，将不会有入队操作。这种策略将很适合那些相互独立的任务，如Web服务器。无界队列可能会堆积大量的请求，从而导致OOM。</li><li>直接传递。如SynchronousQueue，不存储元素的阻塞队列，将任务直接交给线程。每一个入队操作必须等待另一个线程移除操作，否则入队将一直阻塞。当处理一些可能有内部依赖的任务时，这种策略避免了加锁操作。直接传递一般不能限制maximumPoolSizes以避免拒绝接收新的任务，可能会造成增加无限多的线程导致OOM。</li><li>延时队列。如DelayQueue，队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。延时队列也是一个无界队列，因此往队列中插入数据的操作永远不会被阻塞，而只有获取数据的操作才会被阻塞。延时队列的maximumPoolSizes没有限制，可能会造成增加无限多的线程导致OOM。</li></ul><h3 id="2-5-拒绝策略"><a href="#2-5-拒绝策略" class="headerlink" title="2.5 拒绝策略"></a>2.5 拒绝策略</h3><p>当线程数量达到缓存队列的最大容量时，线程池则已经饱和了，此时则不会接收新的任务。会调用RejectedExecutionHandler的<code>rejectedExecution()</code>方法执行饱和策略。</p><p>在线程池内部预定义了几种处理策略：</p><ul><li>终止执行（AbortPolicy）。默认策略，会抛出一个RejectedExecutionException运行异常到调用者线程来阻止系统运行。</li><li>调用者线程来运行任务（CallerRunsPolicy）。这种策略会由调用execute()方法的线程来执行任务，它提供了一个简单的反馈机制并能降低新任务的提交频率。</li><li>丢弃策略（DiscardPolicy）。丢弃提交的任务。</li><li>丢弃队列里最老的一个任务（DiscardOldestPolicy）。丢弃工作队列中等待最久一个任务，并将提交的任务加入队列。</li></ul><h3 id="2-6-合理配置"><a href="#2-6-合理配置" class="headerlink" title="2.6 合理配置"></a>2.6 合理配置</h3><p>一般需要根据任务的类型来配置线程池大小。</p><p>如果是CPU密集型任务，即需要执行大量运算且没有阻塞的任务，就需要设置尽量少的线程数，减少线程上下文切换，参考值可以设为<code>NCPU+1</code>。</p><p>如果是IO密集型任务，即线程存在阻塞或等待，并不是一直再执行，就需要设置尽量多的线程数，参考值可以设置为<code>2*NCPU</code>。</p><p>另外，如果是IO密集型任务，也可以根据<code>NCPU/(1-阻塞系数)</code>这个公式计算，阻塞系数是在0.8到0.9之间的一个值。</p><p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h2><h3 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h3><p>常用属性：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">// 线程池的主要状态锁，控制线程池状态和线程池大小的改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 用来存放工作集</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"><span class="comment">// 用于延时的条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br><span class="line"><span class="comment">// 线程池中曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 已经执行完毕的任务个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"><span class="comment">// 线程工厂，用来创建线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">// 任务拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">// 线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">// 是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">// 核心池的大小，即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"><span class="comment">// 线程池最大能容忍的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><h3 id="3-2-源码"><a href="#3-2-源码" class="headerlink" title="3.2 源码"></a>3.2 源码</h3><h4 id="3-2-1-内部类"><a href="#3-2-1-内部类" class="headerlink" title="3.2.1 内部类"></a>3.2.1 内部类</h4><p>内部类：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 维护了自己的一个Thread对象</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 维护了自己的一个Runnable对象</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 记录完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用传入的Runnable对象和ThreadFactory产生的Thread对象生成Worker对象</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了Runnable里的run()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-提交任务"><a href="#3-2-2-提交任务" class="headerlink" title="3.2.2 提交任务"></a>3.2.2 提交任务</h4><p>最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit()</code>方法也可以提交任务，但是实际上<code>submit()</code>方法里面最终调用的还是<code>execute()</code>方法。</p><p>提交任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在接下来的某个时刻执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是空任务则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 获取ctl的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1 如果工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 尝试添加线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 添加线程失败则重新获取ctl的值</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 如果工作线程数大于或者等于核心线程数</span></span><br><span class="line">    <span class="comment">// 2.1 如果线程池正在运行，则尝试将任务放入缓存队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新根据ctl检查状态，因为可能在这段时间进程死掉了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 2.1.1 如果线程池不处于运行状态，则尝试删除刚刚放入缓存队列的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.1.2 如果线程池在运行状态</span></span><br><span class="line">        <span class="comment">// 如果工作线程数是0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             <span class="comment">// 添加无初始任务的线程</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 如果线程池不在运行状态，或者缓存队列已满</span></span><br><span class="line">    <span class="comment">// 尝试添加线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 添加失败则拒绝任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-添加线程"><a href="#3-2-3-添加线程" class="headerlink" title="3.2.3 添加线程"></a>3.2.3 添加线程</h4><p>添加线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加线程，第一个参数是要添加的任务，第二个参数是是否核心线程，返回是否插入成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取ctl的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程还未SHUTDOWN，此时是可以添加新线程的</span></span><br><span class="line">        <span class="comment">// 如果线程是SHUTDOWN状态，而且传进来的任务为空，并且任务队列不为空的时候，此时是可以添加新线程的</span></span><br><span class="line">        <span class="comment">// 将这两个条件取反，如果满足，则返回插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 如果线程数大于最大值，或者当core为true时大于核心线程数，当core为false时大于最大线程数，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 尝试通过CAS添加线程数目，成功则跳出retry循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 添加失败则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 如果状态改变则重新进行retry循环，如果没有改变则重新尝试添加线程数</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程运行标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 线程添加标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 封装了任务的Worker对象</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用全局锁添加线程</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 如果处于运行状态，或者是SHUTDOWN状态并且添加的任务为空</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果线程已经在运行，则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 添加线程</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新线程数量的历史最大值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 更新线程添加标志位</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果添加成功，则运行线程，并更新线程运行标志位</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程运行标志位是false，则线程添加失败进行回滚</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失败回滚：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程添加失败进行回滚</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用全局锁回滚线程个数的添加</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 移除线程</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// 减少线程数</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 尝试终止线程</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-启动线程"><a href="#3-2-4-启动线程" class="headerlink" title="3.2.4 启动线程"></a>3.2.4 启动线程</h4><p>启动线程：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动线程最终调用的还是runWorker()方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取初始Runnable对象</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 置空初始Runnable对象</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 释放锁，允许被中断</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="comment">// 因为运行异常导致线程突然终止的标志</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取任务，如果没有任务可以获取，则此循环终止</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取工作线程锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池关闭，则确保线程被中断</span></span><br><span class="line">            <span class="comment">// 如果线程池没有关闭，则确保线程不会被中断。这就要求进行重新获取ctl，以便在清除中断时处理shutdownNow竞争</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回调方法，给子类具体实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用Runnable对象的run()方法</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 回调方法，给子类具体实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置空，如果进入下一个循环可以继续取任务</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 完成数累加</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 释放工作线程锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明不是用户任务异常引起的</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 程序退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-获取任务"><a href="#3-2-5-获取任务" class="headerlink" title="3.2.5 获取任务"></a>3.2.5 获取任务</h4><p>获取任务：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取任务，控制线程池线程数量</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取任务超时标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取ctl的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// 如果是STOP状态之后，或者在SHUTDOWN状态之后并且任务队列是空的</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用CAS让线程数量减一</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="comment">// 返回并使一个线程退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">        <span class="comment">// 如果允许为核心线程设置存活时间，或者线程数大于核心线程数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 如果任务数大于最大线程数，或者超时并且允许为核心线程设置存活时间，或者超时并且任务数大于核心线程数</span></span><br><span class="line">        <span class="comment">// 而且，线程数大于1，或者任务队列是空的</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用CAS让线程数量减一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 线程数量减一成功，返回并使一个线程退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 线程数量减一失败，说明线程数量已被抢先改变，继续循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 超时获取任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="comment">// 如果在生效时间内获取到任务则返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 否则将超时标志设置为true</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果有异常，则将超时标志设置为false</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-6-程序退出"><a href="#3-3-6-程序退出" class="headerlink" title="3.3.6 程序退出"></a>3.3.6 程序退出</h4><p>程序退出：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理线程退出，第一个参数是要处理的Worker，第二个参数用来判断是否异常导致退出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是异常退出，需要减少线程数。如果是正常退出，则不需要调整</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="comment">// 获取全局锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 完成任务数自增</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 移除线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结线程</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">// 获取ctl的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 如果线程池关闭了</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 如果允许超时关闭核心线程，那就是0，否则就取核心线程数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果没有核心线程，并且队列中的任务不为空，则设置最少线程为1</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果线程数量大于等于正常工作的数量则不再添加新的线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加线程</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><p>创建线程池，核心线程数为2，最大线程数为4，任务队列大小为3，启动7个线程。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>(i);</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程编号：&quot;</span> + i + <span class="string">&quot;，线程池：&quot;</span> + executor.getPoolSize() + <span class="string">&quot;，队列：&quot;</span> + executor.getQueue().size());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">taskNo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoThread</span><span class="params">(<span class="type">int</span> taskNo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskNo = taskNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task &quot;</span> + taskNo);</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程编号：1，线程池：1，队列：0</span><br><span class="line">task 1</span><br><span class="line">线程编号：2，线程池：2，队列：0</span><br><span class="line">线程编号：3，线程池：2，队列：1</span><br><span class="line">线程编号：4，线程池：2，队列：2</span><br><span class="line">task 2</span><br><span class="line">线程编号：5，线程池：2，队列：3</span><br><span class="line">线程编号：6，线程池：3，队列：3</span><br><span class="line">线程编号：7，线程池：4，队列：3</span><br><span class="line">task 6</span><br><span class="line">task 7</span><br><span class="line">// 等待1s</span><br><span class="line">task 3</span><br><span class="line">task 4</span><br><span class="line">task 5</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在前2个任务放到线程池里时，没有超过核心线程数，所以创建新的线程，执行任务。</li><li>在第3个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。</li><li>在第4个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。</li><li>在第5个任务放到线程池里时，超过了核心线程数，所以放到了任务缓存队列里，等待执行任务。</li><li>在第6个任务放到线程池里时，超过了核心线程数，超过了缓存队列长度，线程池的线程数量小于线程池的最大容量，所以创建新的线程，执行任务。</li><li>在第7个任务放到线程池里时，超过了核心线程数，超过了缓存队列长度，线程池的线程数量小于线程池的最大容量，所以创建新的线程，执行任务。</li><li>等待任务执行完毕，释放线程，获取任务缓存队列里的任务，执行任务。</li><li>如果有第8个任务放到线程池里，超过了核心线程数，超过了缓存队列长度，线程池的线程数量大于线程池的最大容量，所以产生RejectedExecutionException拒绝任务异常。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了如何在高并发场景下使用线程池创建线程。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>异步调用</title>
    <link href="https://momashanhe.com/posts/20250715/175915/"/>
    <id>https://momashanhe.com/posts/20250715/175915/</id>
    <published>2025-07-15T09:59:15.000Z</published>
    <updated>2025-07-22T09:31:06.527Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了如何使用Future相关接口实现异步调用。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-Callable"><a href="#1-Callable" class="headerlink" title="1 Callable"></a>1 Callable</h2><p>之前学习多线程的时候，可以通过继承Thread类和实现Runnable接口创建线程。</p><p>由于单继承的原因建议使用Runnable接口，需要重写<code>run()</code>方法，因为返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>Callable接口是JDK1.5新增的函数式接口，位于<code>java.util.concurrent</code>包下：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比较使用Runnable接口，使用Callable接口能获取返回值，并且还可以处理异常。</p><p>如果要使用Callable接口，还需要配合支持异步调用的Future相关类。</p><h2 id="2-Future"><a href="#2-Future" class="headerlink" title="2 Future"></a>2 Future</h2><p>Future接口是JDK1.5新增的函数式接口，位于<code>java.util.concurrent</code>包下，用于表示异步计算的结果：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false</span></span><br><span class="line">    <span class="comment">// 参数mayInterruptIfRunning表示是否允许取消正在执行的任务，如果设置true，则表示可以取消正在执行过程中的任务</span></span><br><span class="line">    <span class="comment">// 如果任务已经完成，返回false</span></span><br><span class="line">    <span class="comment">// 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false</span></span><br><span class="line">    <span class="comment">// 如果任务还没有执行，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示正在执行的任务是否被取消成功，如果在完成前被取消成功，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示任务是否已经完成，若任务完成，则返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来获取执行结果，如果在指定时间内，还没获取到结果，就抛出TimeoutException异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3 FutureTask"></a>3 FutureTask</h2><p>FutureTask类间接实现了Runnable接口和Future接口，所以既可以作为Runnable被线程执行，又可以作为Future获取线程执行的结果。</p><p>多个线程创建时，如果使用了相同的FutureTask类，那么只会有一个线程执行<code>call()</code>方法。</p><p>构造方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span>;</span><br></pre></td></tr></table></figure><p>通过实现Callable接口创建：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoCallable</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoCallable</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        FutureTask&lt;Integer&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1, <span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2, <span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(f1.get() + f2.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-CompletableFuture"><a href="#4-CompletableFuture" class="headerlink" title="4 CompletableFuture"></a>4 CompletableFuture</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><p>由于Future接口在获取结果时只能通过阻塞或者轮询的方式，阻塞的方式和异步编程的初衷相违背，轮询的方式会耗费无谓的CPU资源并且不能及时得到结果，因此迫切需要新的方式。</p><p>在JDK1.8中，提供了更加强大的CompletableFuture类，简化了异步编程的复杂性，提供了函数式编程的能力，还可以通过回调的方式处理结果。</p><p>CompletableFuture类实现了Future接口和CompletionStage接口。Future接口代表异步获取结果，CompletionStage接口代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。</p><p>使用CompletableFuture支持使用自定义的线程池，默认使用ForkJoinPool类的<code>commonPool()</code>方法创建的线程池。</p><h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><h4 id="4-2-1-创建任务"><a href="#4-2-1-创建任务" class="headerlink" title="4.2.1 创建任务"></a>4.2.1 创建任务</h4><h5 id="4-2-1-1-runAsync"><a href="#4-2-1-1-runAsync" class="headerlink" title="4.2.1.1 runAsync"></a>4.2.1.1 runAsync</h5><p>使用<code>runAsync()</code>方法创建无返回值的异步任务，默认使用ForkJoinPool线程池里的线程。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-runAsync&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-result-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-9-runAsync</span><br><span class="line">main-result-null</span><br></pre></td></tr></table></figure><h5 id="4-2-1-2-supplyAsync"><a href="#4-2-1-2-supplyAsync" class="headerlink" title="4.2.1.2 supplyAsync"></a>4.2.1.2 supplyAsync</h5><p>使用<code>supplyAsync()</code>方法创建带返回值的异步任务，默认使用ForkJoinPool线程池里的线程。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-result-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">main-result-success</span><br></pre></td></tr></table></figure><h5 id="4-2-1-3-比较"><a href="#4-2-1-3-比较" class="headerlink" title="4.2.1.3 比较"></a>4.2.1.3 比较</h5><p>比较：</p><table>  <thead>    <tr>      <th>维度</th>      <th>runAsync</th>      <th>supplyAsync</th>    </tr>  </thead>  <tbody>    <tr>      <td>是否有返回值</td>      <td>无</td>      <td>有</td>    </tr>  </tbody></table><h4 id="4-2-2-立即返回"><a href="#4-2-2-立即返回" class="headerlink" title="4.2.2 立即返回"></a>4.2.2 立即返回</h4><h5 id="4-2-2-1-complete"><a href="#4-2-2-1-complete" class="headerlink" title="4.2.2.1 complete"></a>4.2.2.1 complete</h5><p>使用<code>complete()</code>方法将入参设置为任务执行结果，将任务标记为成功完成。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-start&quot;</span>);</span><br><span class="line">        future.complete(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-end&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0-start</span><br><span class="line">Thread-0-end</span><br><span class="line">main-return-success</span><br></pre></td></tr></table></figure><h5 id="4-2-2-2-completeExceptionally"><a href="#4-2-2-2-completeExceptionally" class="headerlink" title="4.2.2.2 completeExceptionally"></a>4.2.2.2 completeExceptionally</h5><p>使用<code>completeExceptionally()</code>方法将入参设置为任务抛出异常，将任务标记为异常完成。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-start&quot;</span>);</span><br><span class="line">        future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;exception&quot;</span>));</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-end&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0-start</span><br><span class="line">Thread-0-end</span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.NullPointerException: exception</span><br><span class="line">  at ...</span><br><span class="line">Caused by: java.lang.NullPointerException: exception</span><br><span class="line">  at ...</span><br></pre></td></tr></table></figure><h5 id="4-2-2-3-比较"><a href="#4-2-2-3-比较" class="headerlink" title="4.2.2.3 比较"></a>4.2.2.3 比较</h5><p>比较：</p><table>  <thead>    <tr>      <th>维度</th>      <th>complete</th>      <th>completeExceptionally</th>    </tr>  </thead>  <tbody>    <tr>      <td>后续状态</td>      <td>        <code>isDone() == true</code><br>        <code>isCompletedExceptionally() == false</code><br>      </td>      <td>        <code>isDone() == true</code><br>        <code>isCompletedExceptionally() == true</code><br>      </td>    </tr>    <tr>      <td>对回调链的影响</td>      <td>触发thenApply和thenAccept等正常回调，跳过exceptionally和handle等异常回调。</td>      <td>触发exceptionally和handle等异常回调，跳过thenApply和thenAccept等正常回调。</td>    </tr>    <tr>      <td>返回值</td>      <td>首次调用返回true，重复调用返回false，且不会覆盖已有结果。</td>      <td>首次调用返回true，重复调用返回false，且不会覆盖已有结果。</td>    </tr>  </tbody></table><h4 id="4-2-3-回调处理"><a href="#4-2-3-回调处理" class="headerlink" title="4.2.3 回调处理"></a>4.2.3 回调处理</h4><h5 id="4-2-3-1-thenRun"><a href="#4-2-3-1-thenRun" class="headerlink" title="4.2.3.1 thenRun"></a>4.2.3.1 thenRun</h5><p>使用<code>thenRun()</code>方法在上一个任务结束后，继续执行下一个任务。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-runAsync&quot;</span>);</span><br><span class="line">    &#125;).thenRun(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-thenRun&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-runAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-thenRun</span><br><span class="line">main-return-null</span><br></pre></td></tr></table></figure><h5 id="4-2-3-2-thenAccept"><a href="#4-2-3-2-thenAccept" class="headerlink" title="4.2.3.2 thenAccept"></a>4.2.3.2 thenAccept</h5><p>使用<code>thenApply()</code>方法在上一个任务结束后，接收上一个任务的结果，继续执行下一个任务，不返回结果。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-first&quot;</span>;</span><br><span class="line">    &#125;).thenAccept((result) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-thenAccept&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-result-&quot;</span> + result);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-thenAccept</span><br><span class="line">ForkJoinPool.commonPool-worker-9-result-success-first</span><br><span class="line">main-return-null</span><br></pre></td></tr></table></figure><h5 id="4-2-3-3-thenApply"><a href="#4-2-3-3-thenApply" class="headerlink" title="4.2.3.3 thenApply"></a>4.2.3.3 thenApply</h5><p>使用<code>thenApply()</code>方法在上一个任务结束后，接收上一个任务的结果，继续执行下一个任务，返回下一个任务的结果。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-first&quot;</span>;</span><br><span class="line">    &#125;).thenApply((result) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-thenApply&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-param-&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-second&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-thenApply</span><br><span class="line">ForkJoinPool.commonPool-worker-9-param-success-first</span><br><span class="line">main-return-success-second</span><br></pre></td></tr></table></figure><h5 id="4-2-3-4-whenComplete"><a href="#4-2-3-4-whenComplete" class="headerlink" title="4.2.3.4 whenComplete"></a>4.2.3.4 whenComplete</h5><p>使用<code>whenComplete()</code>方法在上一个任务结束后，接收上一个任务的结果和异常，继续执行下一个任务，返回上一个任务的结果。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-first&quot;</span>;</span><br><span class="line">    &#125;).whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-whenComplete&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-result-&quot;</span> + result);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-exception-&quot;</span> + exception);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-whenComplete</span><br><span class="line">ForkJoinPool.commonPool-worker-9-result-success-first</span><br><span class="line">ForkJoinPool.commonPool-worker-9-exception-null</span><br><span class="line">main-return-success-first</span><br></pre></td></tr></table></figure><h5 id="4-2-3-5-handle"><a href="#4-2-3-5-handle" class="headerlink" title="4.2.3.5 handle"></a>4.2.3.5 handle</h5><p>使用<code>handle()</code>方法在上一个任务结束后，接收上一个任务的结果和异常，继续执行下一个任务，返回下一个任务的结果。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-first&quot;</span>;</span><br><span class="line">    &#125;).handle((result, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-handle&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-result-&quot;</span> + result);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-exception-&quot;</span> + exception);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-second&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-handle</span><br><span class="line">ForkJoinPool.commonPool-worker-9-result-success-first</span><br><span class="line">ForkJoinPool.commonPool-worker-9-exception-null</span><br><span class="line">main-return-success-second</span><br></pre></td></tr></table></figure><h5 id="4-2-3-6-exceptionally"><a href="#4-2-3-6-exceptionally" class="headerlink" title="4.2.3.6 exceptionally"></a>4.2.3.6 exceptionally</h5><p>使用<code>exceptionally()</code>方法在上一个任务结束后，接收上一个任务的异常，继续执行下一个任务，返回下一个任务的结果。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-supplyAsync&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-first&quot;</span> + <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;).exceptionally((exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-exceptionally&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-exception-&quot;</span> + exception);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success-second&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-return-&quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-supplyAsync</span><br><span class="line">// 等待1s</span><br><span class="line">ForkJoinPool.commonPool-worker-9-exceptionally</span><br><span class="line">ForkJoinPool.commonPool-worker-9-exception-java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">main-return-success-second</span><br></pre></td></tr></table></figure><h5 id="4-2-3-7-比较"><a href="#4-2-3-7-比较" class="headerlink" title="4.2.3.7 比较"></a>4.2.3.7 比较</h5><p>比较：</p><table>  <tr>    <td>维度</td>    <td>thenRun</td>    <td>thenAccept</td>    <td>thenApply</td>    <td>whenComplete</td>    <td>handle</td>    <td>exceptionally</td>  </tr>  <tr>    <td>接收</td>    <td>无</td>    <td>仅结果</td>    <td>仅结果</td>    <td>结果和异常</td>    <td>结果和异常</td>    <td>仅异常</td>  </tr>  <tr>    <td>返回</td>    <td>null</td>    <td>null</td>    <td>回调函数</td>    <td>前置结果</td>    <td>回调函数</td>    <td>回调函数</td>  </tr>  <tr>    <td>前置</td>    <td>仅正常</td>    <td>仅正常</td>    <td>仅正常</td>    <td>正常和异常</td>    <td>正常和异常</td>    <td>仅异常</td>  </tr>  <tr>    <td>用途</td>    <td>不接收结果，不返回结果。</td>    <td>接收结果，不返回结果。</td>    <td>接收结果，返回新结果。</td>    <td>接收结果和异常，返回原结果。</td>    <td>接收结果和异常，返回新结果。</td>    <td>接收异常，返回新结果。</td>  </tr></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了如何使用Future相关接口实现异步调用。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程安全集合</title>
    <link href="https://momashanhe.com/posts/20250715/155921/"/>
    <id>https://momashanhe.com/posts/20250715/155921/</id>
    <published>2025-07-15T07:59:21.000Z</published>
    <updated>2025-07-22T01:27:14.286Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了能在高并发场景下使用的线程安全集合。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-集合中的线程安全问题"><a href="#1-集合中的线程安全问题" class="headerlink" title="1 集合中的线程安全问题"></a>1 集合中的线程安全问题</h2><h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1 List"></a>1.1 List</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>说明出现了并发修改异常。</p><h3 id="1-2-Set"><a href="#1-2-Set" class="headerlink" title="1.2 Set"></a>1.2 Set</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(set);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>说明出现了并发修改异常。</p><h3 id="1-3-Map"><a href="#1-3-Map" class="headerlink" title="1.3 Map"></a>1.3 Map</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(key, UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;1&quot; Exception in thread &quot;8&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><p>说明出现了并发修改异常。</p><h2 id="2-线程安全的集合"><a href="#2-线程安全的集合" class="headerlink" title="2 线程安全的集合"></a>2 线程安全的集合</h2><p>JUC下有关Collection的类：</p><ul><li>CopyOnWriteArrayList：实现了List接口，相当于线程安全的ArrayList。</li><li>CopyOnWriteArraySet：继承于AbstractSet类，实现了Set接口，相当于线程安全的HashSet。通过CopyOnWriteArrayList实现。</li><li>ConcurrentSkipListSet：继承于AbstractSet类，实现了NavigableSet接口，相当于线程安全的TreeSet。通过ConcurrentSkipListMap实现。</li><li>ConcurrentLinkedQueue：继承于AbstractQueue类，实现了Queue接口，是单向链表实现的线程安全的无界队列，该队列支持FIFO方式操作元素。</li><li>ConcurrentLinkedDeque：继承于AbstractCollection类，实现了Deque接口，是双向链表实现的线程安全的无界队列，该队列支持FIFO和FILO方式操作元素，相当于线程安全的LinkedList。</li><li>ArrayBlockingQueue：实现了BlockingQueue接口，是数组实现的线程安全的有界阻塞队列。</li><li>LinkedBlockingQueue：实现了BlockingQueue接口，是单向链表实现的线程安全的无界阻塞队列，该队列支持FIFO方式操作元素。</li><li>LinkedBlockingDeque：实现了BlockingDeque接口，是双向链表实现的线程安全的无界阻塞队列，该队列支持FIFO和FILO方式操作元素。</li><li>SynchronousQueue：实现了BlockingQueue接口，是不存储元素的阻塞队列，put操作必须等待take操作，否则不能添加元素并产生中断抛出异常。</li><li>DelayQueue：实现了BlockingQueue接口，是支持延迟获取的阻塞队列。</li></ul><p>JUC下有关Map的类：</p><ul><li>ConcurrentHashMap：继承于AbstractMap类，相当于线程安全的HashMap，是线程安全的哈希表。使用数组加链表加红黑树结构和CAS操作实现。</li><li>ConcurrentSkipListMap：继承于AbstractMap类，相当于线程安全的TreeMap，是线程安全的有序的哈希表。通过跳表实现的。</li></ul><p>Collections工具类下的方法：</p><ul><li>synchronizedList()方法：将普通的List转换为线程安全的List，通过synchronized同步锁保证对集合的访问是线程安全的。</li><li>synchronizedSet()方法：将普通的Set转换为线程安全的Set，通过synchronized同步锁保证对集合的访问是线程安全的。</li><li>synchronizedMap()方法：将普通的Map转换为线程安全的Map，通过synchronized同步锁保证对集合的访问是线程安全的。</li></ul><h2 id="3-典型分析"><a href="#3-典型分析" class="headerlink" title="3 典型分析"></a>3 典型分析</h2><h3 id="2-1-CopyOnWriteArrayList"><a href="#2-1-CopyOnWriteArrayList" class="headerlink" title="2.1 CopyOnWriteArrayList"></a>2.1 CopyOnWriteArrayList</h3><h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><p>CopyOnWriteArrayList使用写时复制技术，其内部有个volatile修饰的数组用于保存数据，在操作数据时会创建新数组，并将更新后的数据拷贝到新数组中，最后再将该数组赋值给原数组。</p><p>通过volatile关键字保证数据修改时的可见性，通过在操作数据前使用Lock互斥锁来保护数据。所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低。</p><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。迭代器支持<code>hasNext()</code>方法和<code>next()</code>方法等不可变操作，但不支持<code>add()</code>方法和<code>remove()</code>方法等可变操作。</p><h4 id="2-1-2-源码"><a href="#2-1-2-源码" class="headerlink" title="2.1.2 源码"></a>2.1.2 源码</h4><h5 id="2-1-2-1-设置元素"><a href="#2-1-2-1-设置元素" class="headerlink" title="2.1.2.1 设置元素"></a>2.1.2.1 设置元素</h5><p>设置元素：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用锁来保证线程安全</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得array指向的引用地址</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取指定位置的旧元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 如果旧元素的引用和新元素的引用不同</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">// 创建新的数组并拷贝array数组的值，替换新数组指定位置的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 将array的引用地址指向新的数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为了确保volatile的语义，任何读操作都应该是写操作的结构，可以去掉</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-2-添加元素"><a href="#2-1-2-2-添加元素" class="headerlink" title="2.1.2.2 添加元素"></a>2.1.2.2 添加元素</h5><p>添加元素：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用锁来保证线程安全</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得array指向的引用地址</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 如果指定位置越界，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">// 如果插入位置是末尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将原数组进行拷贝并扩大一个容量</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是插入到末尾，则创建扩大一个容量的数组</span></span><br><span class="line">            newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 分段复制原数组，并空出指定位置</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置指定位置的指定元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 将array引用的地址指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-3-删除元素"><a href="#2-1-2-3-删除元素" class="headerlink" title="2.1.2.3 删除元素"></a>2.1.2.3 删除元素</h5><p>删除元素：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用锁来保证线程安全</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得array指向的引用地址</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 根据指定的位置获取元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 如果指定的元素是最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将原数组进行拷贝截取并将array的引用地址指向新的数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是最后一个元素，则创建减少一个容量的数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 分段复制原数组，并空出指定位置</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">            <span class="comment">// 将array的引用地址指向新的数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回该位置上的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-ConcurrentHashMap"><a href="#2-2-ConcurrentHashMap" class="headerlink" title="2.2 ConcurrentHashMap"></a>2.2 ConcurrentHashMap</h3><h4 id="2-2-1-说明"><a href="#2-2-1-说明" class="headerlink" title="2.2.1 说明"></a>2.2.1 说明</h4><p>在JDK1.8之前，ConcurrentHashMap使用分段锁机制实现，其最大并发度受Segment的个数限制。</p><p>在JDK1.8之后，ConcurrentHashMap使用与HashMap类似的数组配合链表或红黑树的方式实现，加锁采用CAS自旋锁和synchronized可重入锁等机制实现。</p><h4 id="2-2-2-属性"><a href="#2-2-2-属性" class="headerlink" title="2.2.2 属性"></a>2.2.2 属性</h4><p>使用sizeCtl属性表示标志控制符，这个参数非常重要，出现在ConcurrentHashMap的各个阶段，不同取值的含义：</p><ul><li>负数：表示正在进行初始化或扩容操作：<ul><li>-1表示正在进行初始化操作。</li><li>-N表示正在进行扩容操作：高16位是扩容标识，与数组长度有关，最高位固定为1，低16位减1表示扩容线程数。</li></ul></li><li>0：表示数组还未初始化。</li><li>正数：表示下一次进行扩容的大小，类似于扩容阈值。它的值始终是当前容量的0.75倍，如果数组节点个数大于等于sizeCtl，则进行扩容。</li></ul><p>内部类Node中的hash属性：</p><ul><li>负数：-1表示该节点为转发节点，-2表示该节点为红黑树节点。</li><li>正数：表示根据key计算得到的hash值。</li></ul><h4 id="2-2-3-源码"><a href="#2-2-3-源码" class="headerlink" title="2.2.3 源码"></a>2.2.3 源码</h4><h5 id="2-2-3-1-构造方法"><a href="#2-2-3-1-构造方法" class="headerlink" title="2.2.3.1 构造方法"></a>2.2.3.1 构造方法</h5><p>需要说明的是，在构造方法里并没有对集合进行初始化操作，而是等到了添加节点的时候才进行初始化，属于懒汉式的加载方式。</p><p>另外，loadFactor参数在JDK1.8中不再有加载因子的意义，仅为了兼容以前的版本，加载因子默认为0.75并通过移位运算计算，不支持修改。</p><p>同样，concurrencyLevel参数在JDK1.8中不再有多线程运行的并发度的意义，仅为了兼容以前的版本。</p><p>构造方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数有效性判断</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 提供多余空间，避免初始化后马上扩容，防止初始容量为0，保证最小容量为2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 设置标志控制符</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量，加载因子的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量，加载因子，并发度的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数有效性判断</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 比较初始容量和并发度的大小，取最大值作为初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)</span><br><span class="line">        initialCapacity = concurrencyLevel;</span><br><span class="line">    <span class="comment">// 计算最大容量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="comment">// 设置标志控制符</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含指定Map集合的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置标志控制符</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    <span class="comment">// 放置指定的集合</span></span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-2-初始化方法"><a href="#2-2-3-2-初始化方法" class="headerlink" title="2.2.3.2 初始化方法"></a>2.2.3.2 初始化方法</h5><p>集合并不会在构造方法里进行初始化，而是在用到集合的时候才进行初始化，在初始化的同时会设置集合的阈值sizeCtl。</p><p>在初始化的过程中为了保证线程安全，总共使用了两步操作：</p><ol><li>通过CAS原子更新方法将sizeCtl设置为-1，保证只有一个线程执行初始化。</li><li>线程获取初始化权限后内部进行二次判断，保证只有在未初始化的情况下才能执行初始化。</li></ol><p>初始化集合数组，使用CAS原子更新保证线程安全，使用volatile保证顺序和可见性：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// 死循环以完成初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果sizeCtl小于0则表示正在初始化，当前线程让出CPU</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// 如果需要初始化，并且使用CAS原子更新成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第一个线程初始化之后，第二个线程还会进来所以需要重新判断，类似于线程同步的二次判断</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有指定容量则使用默认容量16</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化一个指定容量的节点数组</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将节点数组指向集合数组</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 扩容阀值，获取容量的0.75倍的值，写法更高端比直接乘高效</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将sizeCtl的值设为阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-3-添加节点"><a href="#2-2-3-3-添加节点" class="headerlink" title="2.2.3.3 添加节点"></a>2.2.3.3 添加节点</h5><p>添加节点的代码逻辑：</p><ol><li>校验数据，判断传入一个key和value是否为空，如果为空就直接报错。ConcurrentHashMap是不可为空的，HashMap是可以为空的。</li><li>初始化数组，判断数组是否为空，如果为空就执行初始化方法。</li><li>插入或更新节点，如果数组插入位置的节点为空就通过CAS操作插入节点，如果数组正在扩容就执行协助扩容方法，如果产生哈希碰撞就找到节点并更新节点或者插入节点。</li><li>插入节点后，链表节点判断是否要转为红黑树节点，并且需要增加容量并判断是否需要扩容。</li></ol><p>添加节点：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 排除null的数据</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算hash，右移16位并同自身异或，高16位不变，低16位增加高16位数据，最后还要保证返回正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 节点个数。0表示未加入新结点，2表示树节点或链表节点的节点数，其它值表示链表节点的节点数。主要用于加入节点后，判断是否要由链表转为红黑树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CAS自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// 声明节点、数组长度、对应的数组下标、节点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果没有初始化则进行初始化。除非构造时指定集合，否则默认构造不初始化，添加时检查是否初始化，属于懒汉式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 如果已经初始化了，并且位置上的节点为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用CAS操作插入节点</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="comment">// 添加成功，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置上的节点不为null，并且节点的hash为-1，表示转发节点，说明数组正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 产生哈希碰撞，并且没有扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 锁住节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 获取节点，判断节点是否发生了变化</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否是链表节点，大于等于0表示链表节点，-1表示转发节点，-2表示红黑树节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 标记链表节点，表示链表节点个数</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 循环添加节点到链表，同时节点个数自增</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 传入参数onlyIfAbsent为false表示找到节点则进行替换</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 遍历到尾节点，没有找到节点，添加并作为尾节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">// 标记红黑树节点</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 尝试添加，如果返回原值非空</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="comment">// 替换节点</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果添加到了链表节点，需要进一步判断是否需要转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表上的节点数大于等于8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 尝试转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 返回原值</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组增加容量并判断是否要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-4-修改容量"><a href="#2-2-3-4-修改容量" class="headerlink" title="2.2.3.4 修改容量"></a>2.2.3.4 修改容量</h5><p>修改容量时，使用的是分散热点机制，借鉴了LongAdder类的<code>add()</code>方法以及Striped64类的<code>longAccumulato()</code>方法。</p><p>修改容量后需要判断是否要执行扩容方法，支持多个线程同时扩容。</p><p>修改容量：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    <span class="comment">// x是要增加的容量。check是插入前节点个数，0表示未加入新结点，2表示树节点或链表节点的节点数，其它值表示链表节点的节点数</span></span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果counterCells不为null，说明产生了并发，继续更新容量</span></span><br><span class="line">    <span class="comment">// 如果counterCells为null，使用baseCount增加容量，如果对baseCount增加失败，说明产生了并发，继续更新容量</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> || !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果counterCells为null，说明对baseCount增加失败，继续通过fullAddCount()方法更新容量</span></span><br><span class="line">        <span class="comment">// 如果counterCells不为null，但是counterCells的个数小于1，说明需要初始化counterCells数组，继续通过fullAddCount()方法更新容量</span></span><br><span class="line">        <span class="comment">// 如果counterCells不为null，并且counterCells的个数大于等于1，但是通过线程的probe值和counterCells数组长度减一相与得到的counterCell为空，说明线程对应counterCells数组上的位置没有counterCell，继续通过fullAddCount()方法更新容量</span></span><br><span class="line">        <span class="comment">// 如果counterCells不为null，并且counterCells的个数大于等于1，并且线程对应counterCells数组上的位置有counterCell，但是用counterCell位置中的值增加容量失败，表示更新容量失败，继续通过fullAddCount()方法更新容量</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 继续更新容量，原理是热点分散机制，类似Striped64类的longAccumulato()方法</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行到这一步，说明通过counterCell位置中的值增加容量成功，如果插入前节点个数小于等于1则不考虑扩容直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 计算数组节点个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明通过baseCount增加容量成功，如果check的值大于等于0，需要检查是否要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果节点个数大于等于阈值，并且数组不为空，并且数组长度小于最大值，执行扩容方法。循环判断，防止多线程同时扩容跳过if判断</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 将长度的二进制位左边连续0的个数同1左移15位进行或运算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果sizeCtl小于0说明有其他线程正在扩容</span></span><br><span class="line">            <span class="comment">// 这里数组已经完成了初始化，每个线程首次判断后都先进入else语句</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果sizeCtl右移16位后不等于rs，说明已经扩容完成</span></span><br><span class="line">                <span class="comment">// 如果sizeCtl右移16位后等于rs加1，说明已经扩容完成</span></span><br><span class="line">                <span class="comment">// 如果sizeCtl右移16位后等于rs加低16位全为1的数字，说明已经扩容完成</span></span><br><span class="line">                <span class="comment">// 如果扩容数组是null，说明已经扩容完成</span></span><br><span class="line">                <span class="comment">// 如果转移索引小于等于0，说明已经扩容完成，无法再分配任务</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||</span><br><span class="line">                    sc == rs + <span class="number">1</span> ||<span class="comment">// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1</span></span><br><span class="line">                    sc == rs + MAX_RESIZERS ||<span class="comment">// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS</span></span><br><span class="line">                    (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 协助扩容，协助扩容时增加sizeCtl的值，结束扩容时减少sizeCtl的值</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果sizeCtl大于或等于0，说明第一次扩容，使用CAS设置sizeCtl为rs左移16位后加2的数字，此时sizeCtl为负数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 进行扩容操作</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 计算数组节点个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-5-协助扩容"><a href="#2-2-3-5-协助扩容" class="headerlink" title="2.2.3.5 协助扩容"></a>2.2.3.5 协助扩容</h5><p>协助扩容的代码逻辑：</p><ol><li>判断集合数组不为空，并且节点是转发节点，并且转发节点的子节点不为空，如果不成立则不需要扩容。</li><li>循环判断是否扩容成功，如果没有就进行协助扩容，并增加sizeCtl的值，扩容结束后会减少sizeCtrl的值。</li></ol><p>协助扩容：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// 如果数组不为null，并且节点是转发节点，并且转发节点的子节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将长度的二进制位左边连续0的个数同1左移15位进行或运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 如果新数组没有被修改，并且原数组也没有被修改，并且sizeCtl小于0说明还在扩容</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果sizeCtl右移16位后不等于rs，说明已经扩容完成</span></span><br><span class="line">            <span class="comment">// 如果sizeCtl右移16位后等于rs加1，说明已经扩容完成</span></span><br><span class="line">            <span class="comment">// 如果sizeCtl右移16位后等于rs加低16位全为1的数字，说明已经扩容完成</span></span><br><span class="line">            <span class="comment">// 如果转移索引小于等于0，说明已经扩容完成，无法再分配任务</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||</span><br><span class="line">                sc == rs + <span class="number">1</span> ||<span class="comment">// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + 1</span></span><br><span class="line">                sc == rs + MAX_RESIZERS ||<span class="comment">// 此处应为(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) == rs + MAX_RESIZERS</span></span><br><span class="line">                transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 协助扩容，协助扩容时增加sizeCtl的值，结束扩容时减少sizeCtl的值</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 扩容</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-6-扩容方法"><a href="#2-2-3-6-扩容方法" class="headerlink" title="2.2.3.6 扩容方法"></a>2.2.3.6 扩容方法</h5><p>扩容方法的核心思路是根据CPU内核数将原数组分成多个区间，每个线程都领取一个区间，对区间内的每个根节点进行扩容：</p><ul><li>计算区间长度，根据CPU核心数平均分配给每个CPU相同大小的区间，如果不够16个，默认就是16个。</li><li>创建扩容后数组，有且只能由一个线程构建一个新数组。</li><li>双层循环完成扩容，外层for循环处理区间节点，内层使用while循环处理扩容区间。</li><li>处理区间节点时，判断如果完成扩容则返回跳出for循环，否则判断节点状态。如果是空节点和处理过的节点则设置为转发节点，否则对要扩容的节点使用高低节点进行拆分。</li><li>处理扩容区间时，线程会循环获取所有待处理区间，直至完成扩容，修改while循环标志位跳出循环。</li><li>当线程完成扩容后，会返回线程并减少sizeCtl的值，但最后一个线程返回时，更新数组和阈值。</li></ul><p>扩容方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">// 根据CPU个数找出扩容时的每个线程处理的区间长度，最小是16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE;</span><br><span class="line">    <span class="comment">// 表示第一次扩容，因为在addCount()方法中，第一次扩容的时候传入的nextTab的值是null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建扩容后的节点数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 将创建的数组赋值给新数组</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 扩容失败，设置sizeCtl为最大值</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新数组赋值给扩容数组</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 转移索引为数组长度，说明区间是逆序迁移，从高位向低位迁移</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置扩容后的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">// 创建一个转发节点，表示节点已处理，转发节点的hash默认为-1</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 如果是false，需要已获取区间，如果是true，说明需要重新获取区间</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果是true，完成扩容，如果是false，继续扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// for循环处理区间节点，i表示上界，bound表示下界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// while循环获取扩容区间</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 如果上界自减后大于等于下界，说明当前区间还未处理完，跳出while循环，继续处理当前区间</span></span><br><span class="line">            <span class="comment">// 如果上界自减后小于下界，并且已完成扩容，跳出while循环，扩容结束</span></span><br><span class="line">            <span class="comment">// 如果上界自减后小于下界，并且未完成扩容，继续获取下个区间</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="comment">// 跳出while循环</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 继续获取下个区间，如果下个区间的上界小于等于0，跳出while循环，扩容结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置区间上界为-1</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 跳出while循环</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果将转移索引修改为下个区间的下界成功，跳出while循环，继续处理下个区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                     nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 设置处理区间的下界</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">// 设置处理区间的上届</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 跳出while循环</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while循环结束，判读是否完成扩容</span></span><br><span class="line">        <span class="comment">// 如果上界小于0，说明扩容结束</span></span><br><span class="line">        <span class="comment">// 如果上界大于等于原容量，表示超过下标最大值，说明扩容结束</span></span><br><span class="line">        <span class="comment">// 如果上界加上原容量大于等于新容量，表示超过下标最大值，说明扩容结束</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 如果完成扩容，执行操作</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 删除成员变量</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 更新集合数组</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 更新阈值</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到此，说明完成扩容，将sizeCtl减1，线程会在协助扩容前将sizeCtl加1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果不是最后一个扩容线程，当前线程返回</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 如果是最后一个扩容线程，扩容结束，但是会再次进入while循环检查一次</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 再次while循环检查一下整张表，并更新数组和阈值</span></span><br><span class="line">                i = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断节点是否存在，如果节点是null，则设为转发节点并进入while循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 设为转发节点并进入while循环，判断区间是否完成扩容</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 判断节点是否需要扩容，如果节点是转发节点，则进入while循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 进入while循环，判断区间是否完成扩容</span></span><br><span class="line">            advance = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 对节点扩容，节点不是转发节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对这个节点上锁，防止扩容节点时其他线程对该节点修改</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 二次校验上界下标处的节点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 声明高位节点和低位节点</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 判断是否是链表节点，大于等于0表示链表节点，-1表示转发节点，-2表示红黑树节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 计算数组节点高低值，将原容量同节点的hash值进行与运算，判断将该节点放到高位还是低位</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        <span class="comment">// 定义尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 遍历这个节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// 计算节点高低值，判断将该节点放到高位还是低位</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 如果该节点的高低值和数组节点的高低值不同</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="comment">// 更新高低值</span></span><br><span class="line">                                runBit = b;</span><br><span class="line">                                <span class="comment">// 更新尾节点</span></span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果最后更新的高低值是0，设置低位节点</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果最后更新的高低值是1，设置高位节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 再次循环，生成两个链表，尾节点作为停止条件，避免无谓的循环</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="comment">// 如果与运算结果是0，那么创建低位节点，倒序插入</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="comment">// 如果与运算结果是1，那么创建高位节点，倒序插入</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 设置低位链表，放在新数组的上界位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 设置高位链表，放在新数组的上界加原长度位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将旧的链表设置成转发节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续处理区间的下一个节点</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="comment">// 与运算结果为0的放在低位</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 与运算结果为1的放在高位</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        <span class="comment">// 如果树的节点数小于等于6，那么转成链表，反之，创建一个新的树</span></span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 设置低位树，放在新数组的i位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 设置高位数，放在新数组的i+n位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将旧的树设置成转发节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 继续处理区间的下一个节点</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-7-获取方法"><a href="#2-2-3-7-获取方法" class="headerlink" title="2.2.3.7 获取方法"></a>2.2.3.7 获取方法</h5><p>根据指定的键，返回对应的键值对，由于是读操作，所以不涉及到并发问题，步骤如下：</p><ol><li>判断key对应数组位置上的节点是否为空，为空则返回空表示没有找到，不为空则继续判断。</li><li>如果位置节点是转发节点或者红黑树节点，执行相应节点的查询方法，如果位置节点是链表节点，遍历链表节点并查询。</li></ol><p>获取节点：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 如果数组不为空，并且数组长度大于0，并且数组位置上的节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果hash相等，继续判断</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了节点则返回值</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正在扩容或者是树节点，执行各自节点的查询方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 尝试查找节点</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果位置节点的子节点不为空，则遍历节点查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-8-删除节点"><a href="#2-2-3-8-删除节点" class="headerlink" title="2.2.3.8 删除节点"></a>2.2.3.8 删除节点</h5><p>删除节点可以看成是替换操作。</p><p>删除节点：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算hash</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// CAS自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组是空，或者数组长度是0，或者数组位置上的节点是空</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> || (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果位置上的节点不为null，并且节点的hash为-1，表示转发节点，说明数组正在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 产生哈希碰撞，并且没有扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 是否进入了同步代码</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 锁住节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 保证位置节点没有被修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 循环查找指定节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="literal">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到节点</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="type">V</span> <span class="variable">ev</span> <span class="operator">=</span> e.val;</span><br><span class="line">                                <span class="comment">// 如果传入的原值为空，或者原值和位置节点的值相同，更新或者删除节点</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == ev || (ev != <span class="literal">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="comment">// 如果新值不为空表示替换</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">// 新值是空表示删除，如果上一节点为空，表示删除位置节点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="comment">// 新值是空表示删除，如果上一节点不为空，表示删除非位置节点</span></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="comment">// 如果没有找到</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// 跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">// 找到节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="literal">null</span> &amp;&amp; (p = r.findTreeNode(hash, key, <span class="literal">null</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="comment">// 如果传入的原值为空，或者原值和位置节点的值相同，更新或者删除节点</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == pv || (pv != <span class="literal">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果进入了同步代码</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="comment">// 如果更新或者删除了节点</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果是删除操作</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">// 将数组长度减一</span></span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-9-统计容量"><a href="#2-2-3-9-统计容量" class="headerlink" title="2.2.3.9 统计容量"></a>2.2.3.9 统计容量</h5><p>ConcurrentHashMap中baseCount用于保存数组中节点个数，但是并不准确，因为多线程同时增删改，会导致baseCount修改失败，此时会将节点个数存储于counterCells数组内。</p><p>当需要统计节点个数的时候，除了要统计baseCount之外，还需要加上counterCells中的每个counterCell的值。</p><p>值得一提的是即使如此，统计出来的依旧不是当前数组中节点的准确值，在多线程环境下统计前后并不能暂停线程操作，因此无法保证准确性。</p><p>统计集合容量：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> : (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计节点数量，即baseCount和counterCells元素个数的总和：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了能在高并发场景下使用的线程安全集合。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Atomic</title>
    <link href="https://momashanhe.com/posts/20250715/103441/"/>
    <id>https://momashanhe.com/posts/20250715/103441/</id>
    <published>2025-07-15T02:34:41.000Z</published>
    <updated>2025-07-23T05:42:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了Atomic原子操作类常用的类和方法。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-原子操作类"><a href="#1-原子操作类" class="headerlink" title="1 原子操作类"></a>1 原子操作类</h2><p>原子操作类指的是<code>java.util.concurrent.atomic</code>包中的类，可以分成六种：</p><ul><li>普通类型原子类：AtomicInteger，AtomicBoolean，AtomicLong，AtomicReference。</li><li>数组类型原子类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray。</li><li>复合类型原子类：AtomicStampedReference，AtomicMarkableReference。</li><li>对象属性原子类：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater。</li><li>累加操作原子类：DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder。</li><li>累加操作基础类：Striped64，Number。</li></ul><h3 id="1-1-普通类型原子类"><a href="#1-1-普通类型原子类" class="headerlink" title="1.1 普通类型原子类"></a>1.1 普通类型原子类</h3><p>AtomicInteger，AtomicBoolean，AtomicLong，AtomicReference是操作标量类型的原子类，其内部实现使用volatile关键字和native方法，从而避免了synchronized的高开销。</p><p>场景：</p><ul><li>AtomicInteger和AtomicLong用于保证整数类型操作的线程安全。</li><li>AtomicBoolean可以作为中断标识，用于停止线程。</li><li>AtomicReference用于保证引用类型操作的线程安全，也可以封装多个共享变量，保证多个共享变量操作的线程安全。</li></ul><p>使用AtomicInteger完成多线程自增操作：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        <span class="comment">// 使用CountDownLatch计数10个线程，等待线程执行结束</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10个线程进行循环累加100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        demo.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">// main获取到的result:1000</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到的result:&quot;</span> + demo.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-数组类型原子类"><a href="#1-2-数组类型原子类" class="headerlink" title="1.2 数组类型原子类"></a>1.2 数组类型原子类</h3><p>AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray是操作数组类型的原子类，对数组提供了支持，其内部没有维持volatile变量，而是全部由native方法实现。</p><p>场景：</p><ul><li>AtomicIntegerArray和AtomicLongArray用于保证整数类型数组操作的线程安全。</li><li>AtomicReferenceArray用于保证引用类型数组操作的不安全问题。</li></ul><h3 id="1-3-复合类型原子类"><a href="#1-3-复合类型原子类" class="headerlink" title="1.3 复合类型原子类"></a>1.3 复合类型原子类</h3><p>AtomicStampedReference，AtomicMarkableReference是复合类型的原子类，将某种值和引用关联起来。</p><p>场景：</p><ul><li>AtomicMarkableReference将单个布尔值与引用关联起来，维护带有标记位的对象引用，可以原子更新带有标记位的引用类型。</li><li>AtomicStampedReference将整数值与引用关联起来，维护带有版本号的对象引用，可以原子更新带有版本号的引用类型，可以解决使用CAS出现的ABA问题。</li></ul><p>使用AtomicStampedReference类进行更新：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程1进入</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入&quot;</span>);</span><br><span class="line">            <span class="comment">// 线程1记录时间戳</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            <span class="comment">// 线程1被挂起，等待其他线程执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线程1更新时发现时间戳不一致，更新失败</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将0更新为1:&quot;</span> +</span><br><span class="line">                    atomicStampedReference.compareAndSet(<span class="number">0</span>, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程2进入</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入&quot;</span>);</span><br><span class="line">            <span class="comment">// 线程2记录时间戳</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            <span class="comment">// 线程2更新成功</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将0更新为1:&quot;</span> +</span><br><span class="line">                    atomicStampedReference.compareAndSet(<span class="number">0</span>, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程3进入</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入&quot;</span>);</span><br><span class="line">            <span class="comment">// 线程3记录时间戳</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            <span class="comment">// 线程3更新成功</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将1更新为0:&quot;</span> +</span><br><span class="line">                    atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">0</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-对象属性原子类"><a href="#1-4-对象属性原子类" class="headerlink" title="1.4 对象属性原子类"></a>1.4 对象属性原子类</h3><p>AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater是操作对象属性的原子类，基于反射的原理，可以提供对关联字段类型的访问，用于对类中的volatile字段进行原子操作。</p><p>场景：</p><ul><li>AtomicIntegerFieldUpdater和AtomicLongFieldUpdater用于解决多线程环境下整数类型属性操作的不安全问题。</li><li>AtomicReferenceArray用于解决多线程环境下引用类型属性操作的不安全问题。</li></ul><p>要求：</p><ul><li>更新的属性必须使用volatile修饰符。</li><li>因为操作对象属性的原子类都是抽象类，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置类和属性。</li></ul><p>优势：</p><ul><li>使用AtomicInteger获取结果值需要调用<code>get()</code>方法，但是AtomicIntegerFieldUpdater获取属性值可以通过对象获取，减少性能消耗。</li><li>使用AtomicIntegerFieldUpdater作为类的静态成员，多个对象可以共同使用，但是AtomicInteger对象不允许多个对象共同使用，造成资源浪费。</li></ul><p>使用AtomicIntegerFieldUpdater完成多线程自增操作：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">atomicIntegerFieldUpdater</span> <span class="operator">=</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Demo.class, <span class="string">&quot;count&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用volatile关键字修饰属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        <span class="comment">// 使用CountDownLatch计数10个线程，等待线程执行结束</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10个线程进行循环累加100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        demo.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">// main获取到的result:1000</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到的result:&quot;</span> + demo.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        atomicIntegerFieldUpdater.incrementAndGet(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-累加操作相关类"><a href="#1-5-累加操作相关类" class="headerlink" title="1.5 累加操作相关类"></a>1.5 累加操作相关类</h3><p>DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder是累加操作的原子类，是JDK1.8引进的并发新技术，可以看做AtomicLong和AtomicDouble的部分加强类型。</p><p>Striped64，Number是累加操作的基础类，是JDK1.8引进的并发新技术，是累加操作原子类的父类。</p><p>对比：</p><ul><li>在低并发的场景下，AtomicLong和LongAdder的性能相似，并且AtomicLong提供了更加丰富的功能。</li><li>在高并发的场景下，多个线程同时进行自旋操作，会出现大量失败并不断自旋的场景，此时AtomicLong的自旋会成为瓶颈，所以LongAdder具有更好的性能，但是代价是消耗更多的内存空间。</li></ul><p>缺点：</p><ul><li>LongAdder只提供了加减法操作，功能过于单一，更多地用于收集统计数据，而不是细粒度的同步控制。</li><li>LongAdder的<code>sum()</code>方法并不精确，所以不能保证强一致性（在任何时刻查询到的都是最近更新的数据），只能保证最终一致性（最终更新的数据都会被查询到）。</li></ul><p>原理：</p><ul><li>LongAdder类和DoubleAdder类都继承自Striped64类，其底层代码调用来自于Striped64类的<code>longAccumulate()</code>方法和<code>doubleAccumulate()</code>方法。</li><li>Striped64类的基本思路是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样发生冲突的概率就小很多。如果要获取整体的value值，只要将各个槽中的变量值累加返回即可。</li></ul><h2 id="2-分散热点"><a href="#2-分散热点" class="headerlink" title="2 分散热点"></a>2 分散热点</h2><p>在多线程高并发的情况下，为了避免自旋锁带来极大的性能开销，在Striped64类中使用了分散热点机制。</p><p>多线程自旋争抢的是value值的修改权，可以将value值看做热点，通过将value值分散到数组中实现热点分散，使用类似于哈希碰撞的机制，让每个线程通过计算得到数组中的位置，各个线程只对自己位置的value值进行CAS操作，降低了自旋发生争抢的概率。</p><p>Striped64类的计数方法在ConcurrentHashMap中也有使用，ConcurrentHashMap中的baseCount对应着Striped64中的base变量，而counterCells则对应着Striped64中的cells数组，他们的实现是一样的。</p><h2 id="3-生产者消费者"><a href="#3-生产者消费者" class="headerlink" title="3 生产者消费者"></a>3 生产者消费者</h2><p>使用原子操作类实现生产者消费者：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        r.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Resource</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span> (state) &#123;</span><br><span class="line">            data = count.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> queue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; product &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; product 超时&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span> (state) &#123;</span><br><span class="line">            data = queue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span> || data.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume 超时&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume &quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        state = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了Atomic原子操作类常用的类和方法。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://momashanhe.com/posts/20250714/131215/"/>
    <id>https://momashanhe.com/posts/20250714/131215/</id>
    <published>2025-07-14T05:12:15.000Z</published>
    <updated>2025-07-15T02:37:45.769Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了CAS相关的原理和操作。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><h3 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h3><p>在并发编程中很容易出现并发安全的问题，比如多个线程执行<code>i++</code>操作。</p><p>最常用的方法是通过加锁操作，但是由于加锁操作采用的是悲观锁策略，并不是特别高效的一种解决方案。</p><p>除此之外，也可以使用<code>java.util.concurrent.atomic</code>包提供的原子类，使用CAS采用类似乐观锁的策略去更新数据，解决并发安全问题。</p><h3 id="1-1-乐观锁和悲观锁"><a href="#1-1-乐观锁和悲观锁" class="headerlink" title="1.1 乐观锁和悲观锁"></a>1.1 乐观锁和悲观锁</h3><p>悲观锁假设对共享资源的访问都会发生冲突，当有一个线程访问资源，其他线程就必须等待，所以采用了加锁的方式解决冲突。</p><p>乐观锁假设对共享资源的访问是没有冲突的，线程可以同时访问资源。如果遇到冲突的话，就使用CAS技术重复检测冲突，直到没有冲突才能访问资源。</p><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2 简介"></a>2 简介</h2><p>CAS（Compare and Swap，比较并交换）技术属于乐观锁技术（又称为无锁技术），指当多个线程同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试更新。</p><h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h2><p>CAS包含了三个参数：</p><ul><li>V：表示要读写的内存位置。</li><li>A：表示旧的预期值。</li><li>B：表示新值。</li></ul><p>在更新时比较V中存储的值和A的值：</p><ul><li>如果二者不同，说明可能是其他线程做了更新，那么当前线程什么都不做，执行返回或者重试。</li><li>如果二者相同，将V中存储的值设为B的值，并返回A的值。</li></ul><p>当多个线程同时使用CAS更新变量时，只有一个线程会成功，其余线程均会失败，但失败的线程不会被挂起，而是不断的再次循环重试，这个过程也称为自旋。</p><p>正是基于这样的原理，CAS即时没有使用锁，也能发现其他线程对当前线程的干扰，从而进行及时的处理。而且因为没有使用锁，也就不会造成死锁。</p><h2 id="4-核心"><a href="#4-核心" class="headerlink" title="4 核心"></a>4 核心</h2><p>Unsafe类是特殊的类，位于<code>sun.misc</code>包中，其内部方法可以像C的指针一样直接操作内存，CAS依赖Unsafe类的方法。</p><p>Unsafe类是CAS的核心类，基于该类可以直接操作特定的内存数据，该类的所有方法都是native修饰的，并且该类提供了底层的CAS机制。</p><h2 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5 缺点"></a>5 缺点</h2><h3 id="5-1-CPU开销较大"><a href="#5-1-CPU开销较大" class="headerlink" title="5.1 CPU开销较大"></a>5.1 CPU开销较大</h3><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p>解决办法目前没有，只能通过让JVM支持处理器提供的PAUSE指令来减轻CPU的压力。</p><h3 id="5-2-多个共享变量不能保证原子性"><a href="#5-2-多个共享变量不能保证原子性" class="headerlink" title="5.2 多个共享变量不能保证原子性"></a>5.2 多个共享变量不能保证原子性</h3><p>CAS所保证的只是一个变量的原子性操作，而不能保证多个共享变量的原子性。</p><p>解决办法是使用锁机制或者使用AtomicReference类封装多个共享变量。</p><h3 id="5-3-ABA问题"><a href="#5-3-ABA问题" class="headerlink" title="5.3 ABA问题"></a>5.3 ABA问题</h3><p>CAS判断变量操作成功的条件是V中存储的值和A的值是一致的，如果V中存储的值原来是A，被改成了B，又被改回为A，经过了两次的修改，但是CAS还是认为该变量从来没被修改过。</p><p>解决办法是使用AtomicStampedReference类通过追加版本号或时间戳同时判断原值是否改变。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了CAS相关的原理和操作。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>内存模型</title>
    <link href="https://momashanhe.com/posts/20250710/091831/"/>
    <id>https://momashanhe.com/posts/20250710/091831/</id>
    <published>2025-07-10T01:18:31.000Z</published>
    <updated>2025-07-22T01:27:10.760Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了内存模型及其相关的知识。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1 内存模型"></a>1 内存模型</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Java内存模型（Java Memory Model，JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过规范定制了程序中各个变量的访问方式。</p><p>内存模型规定：</p><ul><li>所有的变量都存储在主内存（内存条），每条线程都有着自己独立的工作内存（寄存器，L1、L2、L3缓存）。</li><li>线程的工作内存中保存了被该线程使用的变量的主内存副本，简单来说就是把变量从主内存拷到自己的工作内存中。</li><li>线程对变量的所有操作都必须在工作内存中进行，而不能直接操作主内存中的变量。</li><li>不同线程之间无法访问对方的工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成。</li></ul><p>内存模型示例图如下：<br><img src="/@image/D01003/002-20250710092311.jpg" alt="20250710092311-内存模型"></p><p>这里假定一个CPU有多核，一个线程使用一个内核。</p><h3 id="1-2-意义"><a href="#1-2-意义" class="headerlink" title="1.2 意义"></a>1.2 意义</h3><p>在一个计算机系统中，数据存储的位置主要有硬盘和内存，以及多级缓存。因为访问速度的问题，CPU的运行并不是直接操作内存，而是先将内存中的数据读取到缓存，内存的读操作和写操作产生的时间差异就会造成不一致的问题。</p><p>内存模型的主要目的，就是定义程序中各种变量的访问规则，来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="1-3-八种操作"><a href="#1-3-八种操作" class="headerlink" title="1.3 八种操作"></a>1.3 八种操作</h3><p>内存模型定义了八种操作来实现变量在主内存和工作内存之间的拷贝和同步：</p><ol><li>lock（锁定）：作用于主内存的变量，把变量标识为锁定状态。</li><li>unlock（解锁）：作用于主内存的变量，把锁定状态的变量释放，释放的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，把变量值从主内存传输到工作内存，以便随后load操作使用。</li><li>load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存。</li><li>use（使用）：作用于工作内存的变量，把工作内存的变量值传递给执行引擎，执行使用变量的字节码指令时执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，把从执行引擎接收到的值赋给工作内存的变量，执行赋值变量的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把变量值从工作内存传输到主内存，以便随后write操作使用。</li><li>write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存。</li></ol><p>除此之外，内存模型还规定了在执行上诉八种操作时必须满足的规则：</p><ul><li>如果要把变量从主内存中复制到工作内存中，就需要按顺序执行read操作和load操作，必须成对使用read操作和load操作。</li><li>如果要把变量从工作内存中同步到主内存中，就需要按顺序执行store操作和write操作，必须成对使用store操作和write操作。</li><li>不能丢弃最近的assign操作，变量在工作内存中改变之后必须同步回主内存。</li><li>变量在发生assign操作才可以从工作内存同步回主内存。</li><li>新的变量只能在主内存中诞生。</li><li>不允许在工作内存中直接使用未被初始化的变量，执行use操作前必须先执行load操作，执行store操作前必须先执行assign操作。</li><li>变量在同一个时刻只允许一条线程对其进行lock操作，lock操作可以被执行多次，解锁需要执行相同次数的unlock操作，lock操作和unlock操作必须成对出现。</li><li>执行lock操作会清空工作内存中的变量值，在使用变量前需要重新初始化变量值。</li><li>执行unlock操作前必须先同步到主内存中，即执行unlock操作前必须先执行store操作和write操作。</li></ul><h3 id="1-4-三大特性"><a href="#1-4-三大特性" class="headerlink" title="1.4 三大特性"></a>1.4 三大特性</h3><h4 id="1-4-1-可见性"><a href="#1-4-1-可见性" class="headerlink" title="1.4.1 可见性"></a>1.4.1 可见性</h4><p>可见性是指在多线程坏境下，线程在工作内存中修改了某一个共享变量的值，其他线程能够立即获取该共享变量变更后的值。</p><p>一般情况下，共享变量不能保证可见性，因为数据修改后被写入内存的时机是不确定的，而线程间变量值的传递均需要通过主内存来完成。</p><p>可以使用volatile关键字保证共享变量的可见性，也可以使用同步锁。</p><h4 id="1-4-2-原子性"><a href="#1-4-2-原子性" class="headerlink" title="1.4.2 原子性"></a>1.4.2 原子性</h4><p>原子性是指在多线程坏境下，线程对数据的操作要保证全部成功或者全部失败，并且不能被其他线程干扰。</p><p>线程在读取主内存变量、操作变量、写回主内存变量的一系列过程中，其他线程不能对该内存变量进行修改，或者在发现变量被修改后应重新读取该变量。</p><p>一般情况下，共享变量不能保证原子性，因为存在多个线程同时写入共享变量到主内存的情况，这就会导致前一个线程写入的值会被后一个线程写入的值覆盖。</p><p>可以使用自旋锁保证共享变量的原子性，也可以使用同步锁。</p><h4 id="1-4-3-有序性"><a href="#1-4-3-有序性" class="headerlink" title="1.4.3 有序性"></a>1.4.3 有序性</h4><p>有序性是指在多线程环境下，禁止指令重排序，保证结果的一致性。</p><p>指令重排序指的是计算机在执行程序时，为了提高性能，会对指令的执行顺序进行调整，并不是按照代码编写顺序执行。</p><p>指令重排序图示：<br><img src="/@image/D01003/002-20250713113605.jpg" alt="20250713113605-指令重排序"></p><p>指令重排序分为以下三种：</p><ul><li>编译器优化重排序：编译器在不改变程序执行结果的情况下，为了提升效率，会重新安排指令的执行顺序。</li><li>指令级并行重排序：处理器在不影响程序执行结果的情况下，为了提升效率，使用指令级并行技术，将多条机器指令重叠执行。</li><li>内存系统重排序：为了提升性能，在CPU和主内存之间设置了高速缓存，得加载和存储操作看上去可能是在乱序执行。</li></ul><p>指令重排序需要遵守的规则：</p><ul><li>在进行重排序时，必须要考虑指令之间的数据依赖性，即有依赖关系的程序不会发生重排序。</li><li>在进行重排序后，可以保证在单线程环境中执行的结果一致，不能保证在多线程环境中一致。</li></ul><p>可以使用volatile关键字保证共享变量的有序性，也可以使用同步锁。</p><h2 id="2-缓存一致性"><a href="#2-缓存一致性" class="headerlink" title="2 缓存一致性"></a>2 缓存一致性</h2><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h3><p>计算机核心组件：CPU、内存、IO设备（硬盘）。三者在处理速度上存在巨大差异，CPU速度最快，其次是内存，硬盘速度最慢。</p><p>为了提升计算性能，CPU从单核提升到了多核，甚至用到了超线程技术最大化提高CPU处理性能，然而内存和硬盘的发展速度远远不及CPU。</p><p>为了平衡三者之间的速度差异，最大化的利用CPU提升性能，做出了很多优化：</p><ul><li>硬件层面优化：CPU增加高速缓存。</li><li>操作系统层面优化：增加了进程和线程，通过CPU时间片切换最大化提升CPU的使用率。</li><li>编译器层面优化：优化指令，更合理的利用CPU高速缓存。</li></ul><h3 id="2-2-高速缓存"><a href="#2-2-高速缓存" class="headerlink" title="2.2 高速缓存"></a>2.2 高速缓存</h3><p>使用高速缓存作为内存和处理器之间的缓冲，可以很好的解决处理器与内存的速度矛盾。</p><p>高速缓存的工作原理如下：</p><ol><li>加载程序及数据到主内存。</li><li>加载程序及数据到高速缓存。</li><li>处理器执行程序，将结果存储在高速缓存。</li><li>高速缓存将数据写回主内存。</li></ol><p>带有高速缓存的CPU执行流程如下：<br><img src="/@image/D01003/002-20250713113845.jpg" alt="20250713113845-高速缓存"></p><p>由于CPU运算速度超过了普通高速缓存的处理能力，CPU厂商又引入了多级缓存：<br><img src="/@image/D01003/002-20250713113924.jpg" alt="20250713113924-多级缓存"></p><h3 id="2-3-缓存一致性问题"><a href="#2-3-缓存一致性问题" class="headerlink" title="2.3 缓存一致性问题"></a>2.3 缓存一致性问题</h3><p>高速缓存很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，如果CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会产生缓存一致性问题。</p><h3 id="2-4-总线锁和缓存锁"><a href="#2-4-总线锁和缓存锁" class="headerlink" title="2.4 总线锁和缓存锁"></a>2.4 总线锁和缓存锁</h3><h4 id="2-4-1-总线锁（总线控制协议）"><a href="#2-4-1-总线锁（总线控制协议）" class="headerlink" title="2.4.1 总线锁（总线控制协议）"></a>2.4.1 总线锁（总线控制协议）</h4><p>为了解决缓存一致性的问题，操作系统提供了总线锁定的机制。</p><p>总线（Bus）是一组信号线，用来在计算机各种功能部件之间传送信息。</p><p>按照所传输的信息种类，计算机的总线可以划分：</p><ul><li>数据总线（Data Bus）用来在处理器和内存之间传输数据。</li><li>地址总线（Address Bus）用于在内存中存储数据的地址。</li><li>控制总线（Control Bus）用二进制信号对所有连接在系统总线上设备的行为进行同步。</li></ul><p>在多线程环境下，当线程要对共享内存进行操作的时候，在总线上发出一个<code>LOCK#</code>信号，这个信号会使其他线程无法通过总线来访问共享内存中的数据。</p><p>总线锁定把处理器和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，这种机制显然是不合适的，后来的处理器都提供了缓存一致性协议。</p><h4 id="2-4-2-缓存锁（缓存一致性协议）"><a href="#2-4-2-缓存锁（缓存一致性协议）" class="headerlink" title="2.4.2 缓存锁（缓存一致性协议）"></a>2.4.2 缓存锁（缓存一致性协议）</h4><p>相比总线锁，缓存锁即降低了锁的力度，其核心机制是基于缓存一致性协议来实现的。</p><p>常用的缓存一致性协议都是属于窥探协议，各个核能够时刻监控自己和其他核的状态，从而统一管理协调。</p><p>最常见的协议是MESI协议，MESI表示缓存行（缓存存储数据的单元）的四种状态：</p><ul><li>M（Modify）表示缓存行是被修改状态，只在当前CPU中有缓存，并且被修改了，还没有更新到主内存中。</li><li>E（Exclusive）表示缓存行是独占状态，只在当前CPU中有缓存，并且没有被修改。</li><li>S（Shared）表示缓存行是共享状态，在多个CPU中有缓存，并且没有被修改。</li><li>I（Invalid）表示缓存行是无效状态，当前CPU中缓存的数据是无效的。</li></ul><p>在MESI协议中，每个缓存行都需要监听其它缓存行对共享数据的读写操作。</p><p>在多线程环境下，MESI协议的流程如下：</p><ul><li>当线程1读取共享数据到缓存行中存储，会将状态设为E。</li><li>当线程2读取该共享数据到缓存行中存储，会将状态设为S。线程1监听到线程2读取该共享数据后，会将状态由E改为S。</li><li>当线程1修改该共享数据后，会将状态由S改为M，在其他线程读取该共享数据前写回到主内存。线程2监听到线程1修改该共享数据后，会将状态由S改为I。</li><li>当线程2修改该共享数据时，发现状态为I，会重新读取共享数据到缓存行，并将状态由I改为E，修改该共享数据后，会将状态由E改为M，在其他线程读取该共享数据前写回到主内存。</li></ul><p>如果被操作的数据不能被缓存在处理器内部，或者操作的数据跨越多个缓存行（状态无法标识），处理器会使用总线锁。</p><p>另外，当处理器不支持缓存锁时，自然也只能用总线锁了，比如说奔腾486以及更老的处理器。</p><h3 id="2-5-内存操作的原子性"><a href="#2-5-内存操作的原子性" class="headerlink" title="2.5 内存操作的原子性"></a>2.5 内存操作的原子性</h3><p>原子操作是指不可被中断的一个或者一组操作。</p><p>处理器会自动保证基本的内存操作的原子性，也就是一个处理器从内存中读取或者写入一个字节时，其他内存是不能访问这个字节的内存地址。但处理器不能自动保证复杂的内存操作的原子性，比如跨总线宽度、跨多个缓存行或者跨页表的操作。</p><p>总线锁和缓存锁是处理器保证复杂内存操作原子性的两个机制。</p><h3 id="2-6-存储缓存和无效队列"><a href="#2-6-存储缓存和无效队列" class="headerlink" title="2.6 存储缓存和无效队列"></a>2.6 存储缓存和无效队列</h3><h4 id="2-6-1-MESI协议的缺陷"><a href="#2-6-1-MESI协议的缺陷" class="headerlink" title="2.6.1 MESI协议的缺陷"></a>2.6.1 MESI协议的缺陷</h4><p>虽然MESI协议保证了缓存的强一致性，但是实现强一致性还需要对CPU提出两点要求：</p><ul><li>CPU缓存要及时响应总线事件。</li><li>CPU严格按照程序顺序执行内存操作指令。</li></ul><p>只要保证了以上两点，缓存一致性就能得到绝对的保证。但是由于效率的原因，CPU不可能保证以上两点：</p><ul><li>总线事件到来之际，缓存可能正在执行其他的指令，例如向CPU传输数据，那么缓存就无法马上响应总线事件了。</li><li>CPU如果严格按照程序顺序执行内存操作指令，意味着回写数据之前，必须要等到所有其他缓存的失效确认，这个等待的过程严重影响CPU的计算效率。</li></ul><h4 id="2-6-2-存储缓存"><a href="#2-6-2-存储缓存" class="headerlink" title="2.6.2 存储缓存"></a>2.6.2 存储缓存</h4><p>为了在写回数据时，避免等待其他缓存的失效确认，对每个线程都维护了一个存储缓存（Store Buffer）来暂时缓存要回写的数据。</p><p>CPU在将数据写入存储缓存之后就认为写操作已完成，不等待其他缓存返回失效确认继续执行其他指令，等所有的失效确认完成之后，再向存储缓存的数据写回到内存中。</p><p>正是因为使用了存储缓存，导致一些数据的内存写入操作可能会晚于程序中的顺序，也就是重排序。</p><h4 id="2-6-3-无效队列"><a href="#2-6-3-无效队列" class="headerlink" title="2.6.3 无效队列"></a>2.6.3 无效队列</h4><p>因为存储缓存大小是有限制的，并且失效操作比较耗时，于是对每个线程维护了一个失效队列（Invalidation Queue）来存储失效操作。</p><p>对于到来的失效请求，失效确认消息马上发出，同时将失效操作放入失效队列，但并不马上执行。</p><p>由于使用了失效队列，失效操作不会立即执行，读操作就会读取到过时的数据，导致可见性的问题。</p><h3 id="2-7-伪共享"><a href="#2-7-伪共享" class="headerlink" title="2.7 伪共享"></a>2.7 伪共享</h3><h4 id="2-7-1-说明"><a href="#2-7-1-说明" class="headerlink" title="2.7.1 说明"></a>2.7.1 说明</h4><p>伪共享指的是多个线程同时读写同一个缓存行的不同变量时，会导致CPU缓存失效。看起来是并发执行的，但实际在CPU处理的时候，是串行执行的，并发的性能大打折扣。</p><p>伪共享的原因就是CPU在处理失效的时候，是直接废除整个缓存行的操作。</p><p>比如：</p><ul><li>如果变量A和变量B都在同一个缓存行上，线程1和线程2都缓存了这两个变量。</li><li>假如线程1修改了变量A，那么线程2的缓存行就失效了，如果线程2需要修改变量B，就需要等待该缓存行失效后，重新读取主内存中的数据。</li><li>这就意味着对变量A和变量B的操作只能是串行的，频繁的多线程操作会导致CPU缓存彻底失效，降级为CPU和主内存直接交互。</li></ul><h3 id="2-7-2-解决办法"><a href="#2-7-2-解决办法" class="headerlink" title="2.7.2 解决办法"></a>2.7.2 解决办法</h3><p>增大共享变量的内存大小，使得不同线程存取的变量位于不同的缓存行上，典型的空间换时间。</p><p>在JDK1.8中，新增了<code>@sun.misc.Contended</code>注解，来使各个变量在缓存行中分隔开，避免伪共享问题，但使用该注解会增加目标实例大小。</p><p>默认情况下使用注解无效，需要在JVM中添加参数<code>-XX:-RestrictContended</code>才能开启此功能。</p><p>该注解在Thread类、ConcurrentHashMap类、LongAddr类中均有使用。</p><h2 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3 内存屏障"></a>3 内存屏障</h2><h3 id="3-1-乱序访问"><a href="#3-1-乱序访问" class="headerlink" title="3.1 乱序访问"></a>3.1 乱序访问</h3><p>程序在运行时，为了提升程序运行时的性能，内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问。</p><p>乱序访问主要发生在两个阶段：</p><ul><li>运行时，多处理器间交互引起内存乱序访问（MESI协议）。</li><li>编译时，编译器优化导致内存乱序访问（指令重排）。</li></ul><h3 id="3-2-内存屏障"><a href="#3-2-内存屏障" class="headerlink" title="3.2 内存屏障"></a>3.2 内存屏障</h3><p>内存屏障能够让处理器或编译器在内存访问上有序，一个内存屏障之前的内存访问操作必定先于其之后的完成。</p><h4 id="3-2-1-处理器内存屏障"><a href="#3-2-1-处理器内存屏障" class="headerlink" title="3.2.1 处理器内存屏障"></a>3.2.1 处理器内存屏障</h4><p>处理器内存屏障分为两种：</p><ul><li>Store Memory Barrier（ST, SMB, SMP_WMB）：写屏障，CPU在执行屏障之后的指令之前，先执行所有已经在存储缓存中保存的指令。</li><li>Load Memory Barrier（LD, RMB, SMP_RMB）：读屏障，CPU在执行任何的加载指令之前，先执行所有已经在失效队列中的指令。</li></ul><h4 id="3-2-2-编译器内存屏障"><a href="#3-2-2-编译器内存屏障" class="headerlink" title="3.2.2 编译器内存屏障"></a>3.2.2 编译器内存屏障</h4><p>为了提高性能，编译器会对指令重排序，通过插入内存屏障，可以避免编译器对指令进行重排序。</p><p>编译器内存屏障分为四种：</p><ul><li>LoadLoad（LL）屏障：对于语句<code>Load1; LoadLoad; Load2</code>，保证Load1的读操作在Load2的读操作之前执行。</li><li>StoreStore（SS）屏障：对于语句<code>Store1; StoreStore; Store2</code>，保证Load1的写操作在Store2的写操作之前执行。</li><li>LoadStore（LS）屏障：对于语句<code>Load1; LoadStore; Store2</code>，保证Load1的读操作在Load2的写操作之前执行。</li><li>StoreLoad（SL）屏障：对于语句<code>Store1; StoreLoad; Load2</code>，保证Load1的写操作在Store2的读操作之前执行。</li></ul><p>需要注意的是，StoreLoad（SL）屏障同时具备其他三个屏障的效果，因此也称之为全能屏障，是目前大多数处理器所支持的，但是相对其他屏障，该屏障的开销相对昂贵。</p><h3 id="3-3-使用场景"><a href="#3-3-使用场景" class="headerlink" title="3.3 使用场景"></a>3.3 使用场景</h3><h4 id="3-3-1-volatile"><a href="#3-3-1-volatile" class="headerlink" title="3.3.1 volatile"></a>3.3.1 volatile</h4><p>volatile的内存屏障策略非常严格保守：</p><ul><li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</li><li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</li></ul><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序，并且在多线程之间实现了通信，使得volatile表现出了轻量锁的特性。</p><h4 id="3-3-2-final"><a href="#3-3-2-final" class="headerlink" title="3.3.2 final"></a>3.3.2 final</h4><p>对于final域，必需保证一个对象的所有final域被写入完毕后才能引用和读取。</p><h2 id="4-先行发生原则（Happen-Before）"><a href="#4-先行发生原则（Happen-Before）" class="headerlink" title="4 先行发生原则（Happen-Before）"></a>4 先行发生原则（Happen-Before）</h2><p>HappenBefor解决的是可见性问题，即前一个操作的结果对于后续操作是可见的。</p><p>在内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在HappenBefor关系。</p><p>这两个操作可以是同一个线程，也可以是不同的线程。</p><p>八条规则：</p><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支和循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：一个解锁操作先行发生于后面对同一个锁的加锁操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的其他方法。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法。</li><li>传递性规则（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5 volatile"></a>5 volatile</h2><h3 id="5-1-可见性"><a href="#5-1-可见性" class="headerlink" title="5.1 可见性"></a>5.1 可见性</h3><p>可见性是指在多线程坏境下，线程在工作内存中修改了某一个共享变量的值，其他线程能够立即获取该共享变量变更后的值。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DemoThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            thread.setRunning(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunning</span><span class="params">(<span class="type">boolean</span> isRunning)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入方法&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入方法</span><br></pre></td></tr></table></figure><p>线程一直在运行，并没有因为调用了<code>setRunning()</code>方法就停止。</p><p>现在有两个线程，分别是main线程和thread线程，它们都在访问isRunning变量。</p><p>按照内存模型，main线程将isRunning变量读取到本地线程内存空间，修改后再刷新回主内存。</p><p>但是main线程在修改后，还没来得及写入主内存就去做其他事情了，thread线程无法读到main线程改变的isRunning变量，从而出现了死循环，导致thread线程无法终止。</p><p>解决办法就是在isRunning变量上加上volatile关键字修饰，强制main线程将修改后的值写回主内存，强制thread线程从主内存中取值。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入方法</span><br><span class="line">执行完毕</span><br></pre></td></tr></table></figure><h3 id="5-2-原子性"><a href="#5-2-原子性" class="headerlink" title="5.2 原子性"></a>5.2 原子性</h3><p>原子性是指在多线程坏境下，线程对数据的操作要保证全部成功或者全部失败，并且不能被其他线程干扰。</p><p>使用volatile关键字只能保证对单次读写的原子性，不能保证复合操作的原子性。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(thread.count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">972</span><br></pre></td></tr></table></figure><p>在多线程环境下，有两个线程分别将count读取到本地内存。</p><p>线程1抢到CPU执行权，执行自增操作后，在尚未写回到主内存前，线程2抢到CPU执行权，执行自增操作后将结果写回到主存，并通知线程1读取的count失效。</p><p>线程1再次抢到CPU执行权，将自增操作后的结果写回到主内存，此时覆盖了线程2的写操作，最终导致了count的结果不合预期，并非是1000。</p><p>自增操作是由三个指令构成的操作，所以在这三个指令执行期间，线程只会读取一次主内存的数据。</p><p>如果想要在复合类的操作中保证原子性，可用使用synchronized关键字来实现，还可以通过并发包中的循环CAS的方式来实现。</p><h3 id="5-3-有序性"><a href="#5-3-有序性" class="headerlink" title="5.3 有序性"></a>5.3 有序性</h3><p>有序性是指在多线程环境下，禁止指令重排序，保证结果的一致性。</p><p>重排序在单线程模式下是一定会保证最终结果的正确性，不能保证多线程环境下结果的正确性。</p><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        count = <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;demo.write();&#125;);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;demo.read();&#125;);</span><br><span class="line">            write.start();</span><br><span class="line">            read.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后，控制台打印的数据中应该有1出现，但实际情况却只有2出现，并不能看出程序作了重排序，所以这个地方以后还需要补充。</p><p>预测的结果是有1出现，原因是指令进行了重排序，而在<code>write()</code>方法中由于第一步<code>count = 2;</code>和第二步<code>flag = true;</code>不存在数据依赖关系，有可能会被重排序。</p><p>使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了内存模型及其相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程协作</title>
    <link href="https://momashanhe.com/posts/20250703/014854/"/>
    <id>https://momashanhe.com/posts/20250703/014854/</id>
    <published>2025-07-02T17:48:54.000Z</published>
    <updated>2025-07-22T01:27:05.626Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了并发场景下线程协作的新方式。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8</p>              </div>            </details><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><h3 id="1-1-回顾"><a href="#1-1-回顾" class="headerlink" title="1.1 回顾"></a>1.1 回顾</h3><p>之前了解到，在涉及得到线程同步的问题时，可以使用synchronized关键字保证线程安全，还可以使用Object类提供的<code>wait()</code>方法和<code>notify()</code>方法进行线程通信。</p><p>在JDK1.5之后，可以使用Lock相关接口来实现类似的功能，以及其他新增的功能。在1.6之后，JDK对synchronized做了优化，两种方式在性能上的差距就很小了，可以根据场景灵活选择。</p><h3 id="1-2-缺陷"><a href="#1-2-缺陷" class="headerlink" title="1.2 缺陷"></a>1.2 缺陷</h3><p>在使用synchronized关键字时，如果一个线程获取了对应的锁，其他线程便只能一直等待释放锁，如果没有释放则需要无限的等待下去。</p><p>线程只会在两种情况下释放锁：</p><ol><li>线程执行完了代码块，线程释放锁。</li><li>线程执行发生异常，JVM会让线程释放锁。</li></ol><p>由此可以看出以往的方式在释放锁的时候比较笨重，不够灵活，不能满足更加灵活的使用场景。</p><p>如果想更加灵活的控制释放锁的时机，就需要使用新增的并发功能。</p><p>从JDK1.5之后，由Doug Lea大牛编写了JUC模块，将代码放在<code>java.util.concurrent</code>包中，新增了许多在并发场景下使用的工具，用于解决并发场景下的线程安全问题。</p><h2 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2 Lock"></a>2 Lock</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Lock是JUC新增的接口，ReentrantLock类实现了Lock接口，也是Lock接口的主要实现类。</p><p>常用方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待获取锁，获取失败则进行等待</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 等待获取锁，允许在等待时由其它线程调用中断方法结束等待，此时会抛出InterruptedException异常</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 尝试获取锁，如果获取成功则返回true，如果获取失败则返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 尝试获取锁，如果在等待期间内获取成功则返回true，如果在等待期间内获取失败则返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取Condition对象，用于线程通信</span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-比较"><a href="#2-2-比较" class="headerlink" title="2.2 比较"></a>2.2 比较</h3><p>关于synchronized和Lock的比较：</p><ul><li>原始构成：synchronized是关键字，属于JVM层面。Lock是接口，属于API层面。</li><li>是否公平：synchronized是非公平锁，不支持公平锁。Lock支持公平锁和非公平锁，可以在构造方法中指定。</li><li>异常处理：synchronized在发生异常时，自动释放锁，因此不会产生死锁。Lock在发生异常时，需要手动释放锁，否则会产生死锁，因此使用Lock时需要在finally块中释放锁。</li><li>中断处理：synchronized不能响应中断，除非抛出异常或者运行完成。Lock可以响应中断，通过设置超时方法tryLock()以及调用中断方法interrupt()。</li><li>互斥共享：synchronized是互斥锁，不支持共享锁。Lock的子类ReentrantReadWriteLock支持互斥锁WriteLock和共享锁ReadLock。</li><li>精确唤醒：synchronized不支持精确唤醒，只能唤醒一个或者唤醒全部。Lock通过Condition支持精确唤醒，能够对某个线程或者某一种线程进行唤醒。</li></ul><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><h4 id="2-3-1-等待获取锁"><a href="#2-3-1-等待获取锁" class="headerlink" title="2.3.1 等待获取锁"></a>2.3.1 等待获取锁</h4><p>使用<code>lock()</code>方法等待获取锁，这是使用得最多的一个方法。</p><p>获取锁以后必须显示释放锁，即使出现异常时也不会自动释放，因此需要将业务逻辑写在<code>try-catch</code>代码块中，并且将释放逻辑写在<code>finally</code>代码块中，保证锁一定被被释放，防止死锁。</p><p>使用规范：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 等待获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-尝试获取锁"><a href="#2-3-2-尝试获取锁" class="headerlink" title="2.3.2 尝试获取锁"></a>2.3.2 尝试获取锁</h4><p>使用<code>tryLock()</code>方法尝试获取锁，无论是否获取成功都会立即返回结果。</p><p>使用规范：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取失败业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-中断获取锁"><a href="#2-3-3-中断获取锁" class="headerlink" title="2.3.3 中断获取锁"></a>2.3.3 中断获取锁</h4><p>使用<code>lock()</code>方法在等待期间是不能被中断的，但使用<code>lockInterruptibly()</code>方法在等待期间是可以被中断的。</p><p>如果当前线程在获取锁的等待期间被其他线程中断，当前线程会抛出InterruptedException异常，因此需要处理异常。</p><p>使用规范：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 等待获取锁，但可以在等待期间被中断，需要处理异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>interrupt()</code>方法不能中断正在运行的线程，只能中断等待的线程。</p><h4 id="2-3-4-互斥锁"><a href="#2-3-4-互斥锁" class="headerlink" title="2.3.4 互斥锁"></a>2.3.4 互斥锁</h4><p>ReentrantLock类实现了Lock接口，并且ReentrantLock提供了更多的方法。</p><p>模拟窗口买票示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 创建锁对象，需要注意避免重复创建</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 强制当前线程放弃时间片，允许其他线程竞争时间片</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sale &quot;</span> + num--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">窗口1 sale 5</span><br><span class="line">窗口1 sale 4</span><br><span class="line">窗口2 sale 3</span><br><span class="line">窗口1 sale 2</span><br><span class="line">窗口2 sale 1</span><br></pre></td></tr></table></figure><h4 id="2-3-5-读写锁"><a href="#2-3-5-读写锁" class="headerlink" title="2.3.5 读写锁"></a>2.3.5 读写锁</h4><p>使用ReadWriteLock接口定义读写锁，接口里包含读锁和写锁：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock类实现了ReadWriteLock接口，支持多个线程同时进行读操作。</p><p>模拟窗口买票，同一时间只能有一个窗口售卖，允许多个窗口查看：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.show();&#125;, <span class="string">&quot;窗口1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.show();&#125;, <span class="string">&quot;窗口2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.show();&#125;, <span class="string">&quot;窗口3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;窗口4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; show &quot;</span> + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sale &quot;</span> + num--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">窗口2 show 5</span><br><span class="line">窗口3 show 5</span><br><span class="line">窗口1 show 5</span><br><span class="line">窗口4 sale 5</span><br><span class="line">窗口2 show 4</span><br><span class="line">窗口3 show 4</span><br><span class="line">窗口1 show 4</span><br><span class="line">窗口4 sale 4</span><br><span class="line">窗口2 show 3</span><br><span class="line">窗口1 show 3</span><br><span class="line">窗口3 show 3</span><br><span class="line">窗口4 sale 3</span><br><span class="line">窗口1 show 2</span><br><span class="line">窗口3 show 2</span><br><span class="line">窗口4 sale 2</span><br><span class="line">窗口2 show 1</span><br><span class="line">窗口1 show 1</span><br><span class="line">窗口2 show 1</span><br><span class="line">窗口3 show 1</span><br><span class="line">窗口4 sale 1</span><br><span class="line">窗口4 end</span><br><span class="line">窗口1 end</span><br><span class="line">窗口2 end</span><br><span class="line">窗口3 end</span><br></pre></td></tr></table></figure><p>从运行的结果来看，最多有三个线程在同时读，提高了读操作的效率。</p><p>线程占用读写锁的规则：</p><ul><li>当前线程占用读锁后，当前线程占用写锁需要等待，其他线程占用读锁无需等待，其他线程占用写锁需要等待。</li><li>当前线程占用写锁后，当前线程占用读锁无需等待，其他线程占用读锁和写锁需要等待。</li></ul><p>对于当前线程来说，写锁可以降级为读锁，但是读锁不能升级为写锁。</p><p>写锁可以降级为读锁，程序可以正常执行：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="comment">// 锁降级</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读锁不能升级为写锁，程序会等待获取写锁：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取读锁&quot;</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取写锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Condition"><a href="#3-Condition" class="headerlink" title="3 Condition"></a>3 Condition</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>之前在使用synchronized关键字时，可以使用Object对象的<code>wait()</code>方法和<code>notify()</code>方法进行线程通信。</p><p>在使用Lock时，通过<code>newCondition()</code>方法获取Condition对象，可以使用Condition对象的<code>await()</code>方法和<code>signal()</code>方法进行通信，对锁进行更精确的控制。</p><p>同一个Lock对象可以获取多个Condition对象，支持多路控制。</p><p>常用方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使当前线程加入等待队列中并释放当锁，线程可以被唤醒和被中断</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 同await()类似，只是该方法不会被中断</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 同await()类似，如果在指定时间之内没有被通知或者被中断，该方法会返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 当前线程进入等待状态，被通知、中断或者超时之后被唤醒。返回值就是表示剩余的时间，超时返回值是0或者负数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 同awaitNanos(long nanosTimeout)类似，只是参数变成了指定日期</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 唤醒一个在等待队列中的线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 唤醒所有在等待队列中的线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-比较"><a href="#3-2-比较" class="headerlink" title="3.2 比较"></a>3.2 比较</h3><p>使用方式类似：</p><ul><li>Condition中的<code>await()</code>方法相当于Object的<code>wait()</code>方法。</li><li>Condition中的<code>signal()</code>方法相当于Object的<code>notify()</code>方法。</li><li>Condition中的<code>signalAll()</code>相当于Object的<code>notifyAll()</code>方法。</li><li>Condition中的方法需要与Lock捆绑使用，Object中的方法需要与synchronized捆绑使用。</li></ul><p>使用Condition的优势是能够更加精细的控制多线程的休眠与唤醒，同一个Lock可以创建多个Condition，使用不同的Condition管理不同线程的等待与唤醒，实现对线程的精细控制。</p><h3 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h3><h4 id="3-3-1-使用synchronized实现两个线程交替打印"><a href="#3-3-1-使用synchronized实现两个线程交替打印" class="headerlink" title="3.3.1 使用synchronized实现两个线程交替打印"></a>3.3.1 使用synchronized实现两个线程交替打印</h4><p>使用synchronized和Object类的方法实现两个线程交替打印：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Ticket.class) &#123;</span><br><span class="line">                Ticket.class.notify();</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + num--);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Ticket.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程1 &gt;&gt;&gt; 8</span><br><span class="line">线程2 &gt;&gt;&gt; 7</span><br><span class="line">线程1 &gt;&gt;&gt; 6</span><br><span class="line">线程2 &gt;&gt;&gt; 5</span><br><span class="line">线程1 &gt;&gt;&gt; 4</span><br><span class="line">线程2 &gt;&gt;&gt; 3</span><br><span class="line">线程1 &gt;&gt;&gt; 2</span><br><span class="line">线程2 &gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><h4 id="3-3-2-使用Lock实现两个线程交替打印"><a href="#3-3-2-使用Lock实现两个线程交替打印" class="headerlink" title="3.3.2 使用Lock实现两个线程交替打印"></a>3.3.2 使用Lock实现两个线程交替打印</h4><p>使用Lock和Condition类的方法实现两个线程交替打印：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale();&#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + num--);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程1 &gt;&gt;&gt; 8</span><br><span class="line">线程2 &gt;&gt;&gt; 7</span><br><span class="line">线程1 &gt;&gt;&gt; 6</span><br><span class="line">线程2 &gt;&gt;&gt; 5</span><br><span class="line">线程1 &gt;&gt;&gt; 4</span><br><span class="line">线程2 &gt;&gt;&gt; 3</span><br><span class="line">线程1 &gt;&gt;&gt; 2</span><br><span class="line">线程2 &gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><h4 id="3-3-3-使用Lock实现三个线程循环打印"><a href="#3-3-3-使用Lock实现三个线程循环打印" class="headerlink" title="3.3.3 使用Lock实现三个线程循环打印"></a>3.3.3 使用Lock实现三个线程循环打印</h4><p>使用Lock和Condition类的方法实现三个线程按循环打印：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale1();&#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale2();&#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;ticket.sale3();&#125;, <span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale1</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c2.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + num--);</span><br><span class="line">                c1.await();</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    c3.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale2</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c3.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + num--);</span><br><span class="line">                c2.await();</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    c1.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale3</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                c1.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + num--);</span><br><span class="line">                c3.await();</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    c2.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程1 &gt;&gt;&gt; 8</span><br><span class="line">线程2 &gt;&gt;&gt; 7</span><br><span class="line">线程3 &gt;&gt;&gt; 6</span><br><span class="line">线程1 &gt;&gt;&gt; 5</span><br><span class="line">线程2 &gt;&gt;&gt; 4</span><br><span class="line">线程3 &gt;&gt;&gt; 3</span><br><span class="line">线程1 &gt;&gt;&gt; 2</span><br><span class="line">线程2 &gt;&gt;&gt; 1</span><br></pre></td></tr></table></figure><h4 id="3-3-4-使用Lock实现生产者消费者"><a href="#3-3-4-使用Lock实现生产者消费者" class="headerlink" title="3.3.4 使用Lock实现生产者消费者"></a>3.3.4 使用Lock实现生产者消费者</h4><p>生产者消费者交替执行：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                r.product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                r.product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                r.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                r.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; product ...&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume ...&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">生产者1 product ...</span><br><span class="line">消费者1 consume ...</span><br><span class="line">生产者1 product ...</span><br><span class="line">消费者1 consume ...</span><br><span class="line">生产者1 product ...</span><br><span class="line">消费者1 consume ...</span><br><span class="line">生产者2 product ...</span><br><span class="line">消费者2 consume ...</span><br><span class="line">生产者2 product ...</span><br><span class="line">消费者2 consume ...</span><br><span class="line">生产者2 product ...</span><br><span class="line">消费者2 consume ...</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了并发场景下线程协作的新方式。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用连接池</title>
    <link href="https://momashanhe.com/posts/20250702/141755/"/>
    <id>https://momashanhe.com/posts/20250702/141755/</id>
    <published>2025-07-02T06:17:55.000Z</published>
    <updated>2025-08-03T11:32:46.547Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了如何使用连接池管理连接。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8<br>MySQL 5.7.40</p>              </div>            </details><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><h3 id="1-1-现有问题"><a href="#1-1-现有问题" class="headerlink" title="1.1 现有问题"></a>1.1 现有问题</h3><p>每次操作数据库都要建立连接，并将得到的Connection对象加载到内存中，如果短时间有大量建立连接的操作，会导致占用很多系统资源，甚至会导致服务器崩溃。</p><p>每次使用结束都需要手动释放连接，如果忘记释放连接或者程序出现异常未能成功释放，会导致内存泄露。</p><p>不能控制连接的数量，如果连接的人数过多，会导致无限制的创建连接对象，导致内存开销过大，服务器崩溃。</p><h3 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h3><p>连接池就是数据库连接对象的缓冲区，负责创建连接、管理连接、释放连接等操作。</p><p>每次需要连接数据库时，不需要建立连接，而是通过连接池获取。</p><p>在使用完连接后，不需要手动释放连接，而是交由连接池释放。</p><p>可以通过连接池控制连接的数量，在连接池里的连接可多次重复使用，避免了无限制创建连接的问题。</p><h2 id="2-选用"><a href="#2-选用" class="headerlink" title="2 选用"></a>2 选用</h2><h3 id="2-1-使用Druid连接池"><a href="#2-1-使用Druid连接池" class="headerlink" title="2.1 使用Druid连接池"></a>2.1 使用Druid连接池</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>Druid是阿里巴巴开发的一个高性能、可扩展、可监控的开源JDBC连接池。</p><h4 id="2-1-2-使用"><a href="#2-1-2-使用" class="headerlink" title="2.1.2 使用"></a>2.1.2 使用</h4><p>下载Jar包：</p><ul><li><a href="https://mvnrepository.com/">Maven仓库地址</a></li></ul><p>将下载的<code>druid-1.2.20.jar</code>文件复制到lib目录。</p><p>配置文件内容：</p><figure class="highlight properties"><figcaption><span>jdbc.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 初始化连接数</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建连接池</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span>  dataSource.getConnection();</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行查询，获取结果集</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    rs.close();</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用HikariCP连接池"><a href="#2-2-使用HikariCP连接池" class="headerlink" title="2.2 使用HikariCP连接池"></a>2.2 使用HikariCP连接池</h3><h4 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h4><p>HikariCP是一个轻量级、高效的JDBC连接池，具有快速启动和低延迟的特点。</p><h4 id="2-2-2-使用"><a href="#2-2-2-使用" class="headerlink" title="2.2.2 使用"></a>2.2.2 使用</h4><p>下载Jar包：</p><ul><li><a href="https://mvnrepository.com/">Maven仓库地址</a></li></ul><p>将下载的<code>HikariCP-4.0.3.jar</code>文件复制到lib目录。</p><p>因为HikariCP依赖了SLF4J日志，所以还需要下载日志文件并复制到lib目录：</p><ul><li>slf4j-api-1.7.26.jar</li><li>logback-classic-1.2.3.jar</li><li>logback-core-1.2.3.jar</li></ul><p>配置文件内容：</p><figure class="highlight properties"><figcaption><span>jdbc.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 最小空闲连接数</span></span><br><span class="line"><span class="attr">minimumIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maximumPoolSize</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建连接池配置对象</span></span><br><span class="line">    <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>(pros);</span><br><span class="line">    <span class="comment">// 创建连接池</span></span><br><span class="line">    <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span>  dataSource.getConnection();</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行查询，获取结果集</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    rs.close();</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了如何使用连接池管理连接。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
    <category term="JDBC" scheme="https://momashanhe.com/tags/JDBC/"/>
    
    <category term="MySQL" scheme="https://momashanhe.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>连接数据库</title>
    <link href="https://momashanhe.com/posts/20250701/085902/"/>
    <id>https://momashanhe.com/posts/20250701/085902/</id>
    <published>2025-07-01T00:59:02.000Z</published>
    <updated>2025-08-03T11:32:46.447Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文学习了如何使用JDBC连接数据库。</p><span id="more"></span><details ><summary> 环境 </summary>              <div class='content'>              <p>Windows 10 企业版 LTSC 21H2<br>Java 1.8<br>MySQL 5.7.40</p>              </div>            </details><h2 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1 持久化"></a>1 持久化</h2><p>数据持久化就是把数据保存到可掉电式存储设备中以供之后使用，大多数情况下，数据持久化意味着将内存中的数据保存到硬盘上进行存储。</p><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件中，比如XML文件和Excel文件等等。</p><p>持久化的实现主要有两种：</p><ul><li>通过IO流技术将数据存储在本地磁盘，优点是比较简单，缺点是不方便管理和维护。</li><li>通过各种数据库将数据存储在关系型数据库，优点是方便管理和维护，缺点是需要学习相关的方法。</li></ul><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2 简介"></a>2 简介</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>JDBC的全称是Java Database Connectivity，意为Java和数据库的连接，其定义了用来访问数据库的标准Java类库，使用这个类库可以更加方便地访问数据库资源。</p><p>在最开始的时候，程序员使用数据库需要安装数据库驱动，不同厂商的数据库有其各自的驱动程序。</p><p>为了方便开发，Sun公司提供了JDBC接口，让数据库厂商实现JDBC接口，程序员通过JDBC接口就可以操作不同的数据库，不需要关注底层数据库驱动的安装，从而大大简化和加快了开发过程。</p><h3 id="2-2-架构"><a href="#2-2-架构" class="headerlink" title="2.2 架构"></a>2.2 架构</h3><p>JDBC接口包括两个层次：</p><ul><li>JDBC API：即面向应用的API，这是一个抽象的接口，用于给程序员使用，提供了程序到JDBC管理器的连接。</li><li>JDBC Driver API：即面向数据库驱动的API，数据库厂商需要实现这个接口，提供了JDBC管理器到数据库驱动程序的连接。</li></ul><p>架构图：<br><img src="/@image/D01005/001-20250701095527.jpg" alt="20250701095527-架构"></p><h3 id="2-3-规范"><a href="#2-3-规范" class="headerlink" title="2.3 规范"></a>2.3 规范</h3><p>JDBC相关的接口在<code>java.sql</code>包下。</p><p>主要有四个核心对象：</p><ul><li>DriverManager类：用于加载驱动，创建连接对象。</li><li>Connection接口：表示与数据库创建的连接。</li><li>Statement接口：执行数据库SQL语句，并返回相应结果的对象。</li><li>ResultSet接口：结果集或一张虚拟表，用于存储表数据的对象。</li></ul><p>其中，Statement接口还有两个子接口：</p><ul><li>PreparedStatement接口：预编译对象，是Statement接口的子接口，用于解决SQL注入问题。</li><li>CallableStatement接口：支持带参数的SQL操作，支持调用存储过程，是PreparedStatement接口的子接口。</li></ul><h2 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3 建立连接"></a>3 建立连接</h2><p>下面的说明以连接MySQL数据库为例。</p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>安装MySQL数据库，保证配置文件包含如下配置：</p><figure class="highlight ini"><figcaption><span>my.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 客户端连接服务端时默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure><p>创建数据库，字符集和配置文件保持一致：</p><figure class="highlight sql"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `test` <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8mb4_general_ci&#x27;</span>;</span><br></pre></td></tr></table></figure><p>创建数据表并插入数据，字符集和配置文件保持一致：</p><figure class="highlight sql"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  `create_time` datetime COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB COMMENT <span class="operator">=</span> <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;2020-12-17 16:35:23&#x27;</span>, <span class="string">&#x27;2020-12-17 16:35:23&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用IDEA创建Java项目，然后在<code>File | Settings | Editor | File Encodings</code>里修改编码：<br><img src="/@image/D01005/001-20250702100301.jpg" alt="20250702100301-架构"></p><p>在Java项目中创建src目录，在src目录创建<code>JDBCTest</code>类，在类中创建<code>main()</code>方法。</p><h3 id="3-2-导入Jar包"><a href="#3-2-导入Jar包" class="headerlink" title="3.2 导入Jar包"></a>3.2 导入Jar包</h3><p>下载用于连接数据库的驱动Jar包，下载地址：</p><ul><li><a href="https://downloads.mysql.com/archives/c-j/">官网下载地址</a></li><li><a href="https://mvnrepository.com/">Maven仓库地址</a></li></ul><p>本地安装的数据库是5.7.40版本，对应下载5.1.49版本的驱动Jar包即可，将下载后的文件解压，目录中的<code>mysql-connector-java-5.1.49.jar</code>文件就是所需的驱动Jar包。</p><p>创建lib目录，需要先将下载的<code>mysql-connector-java-5.1.49.jar</code>文件复制到lib目录，然后才能在lib目录右键找到<code>Add as Library...</code>选项，将lib目录设置为<code>Project Library</code>并保存。</p><h3 id="3-3-编写代码"><a href="#3-3-编写代码" class="headerlink" title="3.3 编写代码"></a>3.3 编写代码</h3><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 加载驱动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">// 执行增删改查操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>加载驱动，使用数据库对应的驱动名称注册驱动。</li><li>建立连接，通过用户名和密码以及URL协议连接数据库。</li><li>执行增删改查，获取查询的结果集和增删改的更新记录数。</li><li>释放连接，主动关闭连接资源，避免内存泄漏。</li></ol><h3 id="3-4-配置文件"><a href="#3-4-配置文件" class="headerlink" title="3.4 配置文件"></a>3.4 配置文件</h3><p>如果不想将配置文件写在代码中，可以在src目录下创建<code>jdbc.properties</code>配置文件：</p><figure class="highlight properties"><figcaption><span>jdbc.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>通过配置文件建立连接：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载驱动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(pros.getProperty(<span class="string">&quot;driverClass&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">// 执行增删改查操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-核心接口"><a href="#4-核心接口" class="headerlink" title="4 核心接口"></a>4 核心接口</h2><h3 id="4-1-加载驱动"><a href="#4-1-加载驱动" class="headerlink" title="4.1 加载驱动"></a>4.1 加载驱动</h3><p>加载驱动程序的目的是为了注册驱动程序，使得JDBC能够识别并与特定的数据库进行交互。</p><p>在加载驱动时，不同数据库对应不同驱动名称：</p><ul><li>MySQL驱动：com.mysql.jdbc.Drive</li><li>Oracle驱动：oracle.jdbc.driver.OracleDriver</li><li>SQLServer驱动：com.microsoft.sqlserver.jdbc.SQLServerDriver</li><li>PostgreSQL驱动：org.postgresql.Driver</li><li>DB2驱动：com.ibm.db2.jdbc.net.DB2Driver</li><li>Sybase驱动：com.sybase.jdbc.SybDriver</li></ul><p>从1.6开始，不再需要显式地调用加载驱动，只要在类路径中集成了数据库对应的Jar文件，程序会自动在初始化时注册驱动程序。</p><h3 id="4-2-建立连接"><a href="#4-2-建立连接" class="headerlink" title="4.2 建立连接"></a>4.2 建立连接</h3><p>Connection接口是JDBC的重要接口，用于建立与数据库的通信通道。</p><p>在建立连接时，不同的数据库对应不同URL协议：</p><ul><li>MySQL格式：jdbc:mysql:&#x2F;&#x2F;地址或主机名:端口号&#x2F;数据库名</li><li>Oracle格式：jdbc:oracle:thin:@地址或主机名:端口号:数据库名</li><li>SQLServer格式：jdbc:sqlserver:&#x2F;&#x2F;地址或主机名:端口号;databaseName&#x3D;数据库名</li><li>PostgreSQL格式：jdbc:postgresql:&#x2F;&#x2F;地址或主机名:端口号&#x2F;数据库名</li><li>DB2格式：jdbc:db2:地址或主机名:端口号&#x2F;数据库名</li><li>Sybase格式：jdbc:sybase:Tds:地址或主机名:端口号&#x2F;数据库名</li></ul><p>连接MySQL数据库：</p><ul><li>在使用5.x版本的数据库时，需要在URL协议后追加<code>useSSL=false</code>配置，否则会报错。</li><li>在URL协议后追加<code>serverTimezone=GMT%2B8</code>配置将时区设置为东八区，保证时间与当前时间一致。</li></ul><p>Connection接口的作用：</p><ul><li>数据库交互，Connection接口可以创建Statement对象或者PreparedStatement对象，用于执行SQL语句。</li><li>管理事务，Connection接口提供了<code>commit()</code>方法和<code>rollback()</code>方法，用于提交事务和回滚事务。</li></ul><p>在连接使用完毕后，需要手动释放资源和关闭连接，避免资源占用导致内存泄漏。</p><h3 id="4-3-执行SQL语句"><a href="#4-3-执行SQL语句" class="headerlink" title="4.3 执行SQL语句"></a>4.3 执行SQL语句</h3><h4 id="4-3-1-说明"><a href="#4-3-1-说明" class="headerlink" title="4.3.1 说明"></a>4.3.1 说明</h4><p>Statement接口用于执行SQL语句并获取执行结果。</p><p>获取的结果可以是一个或多个：</p><ul><li>查询：返回的是ResultSet结果集。</li><li>增删改：返回的是受影响的行数。</li></ul><p>使用后需要手动关闭。</p><h4 id="4-3-2-增删改查"><a href="#4-3-2-增删改查" class="headerlink" title="4.3.2 增删改查"></a>4.3.2 增删改查</h4><p>执行增删改查示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取执行器</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">// 执行新增</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> st.executeUpdate(<span class="string">&quot;insert into user values (2, &#x27;李四&#x27;, &#x27;123456&#x27;, now(), now())&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;insert=&quot;</span> + insert);</span><br><span class="line">    <span class="comment">// 执行修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> st.executeUpdate(<span class="string">&quot;update user set password = &#x27;666666&#x27; where id = 2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;update=&quot;</span> + update);</span><br><span class="line">    <span class="comment">// 执行删除</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> st.executeUpdate(<span class="string">&quot;delete from user where id = 2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;delete=&quot;</span> + delete);</span><br><span class="line">    <span class="comment">// 执行查询，获取结果集</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(<span class="string">&quot;select * from user where id = 1&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    rs.close();</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    st.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-理解SQL注入问题"><a href="#4-3-3-理解SQL注入问题" class="headerlink" title="4.3.3 理解SQL注入问题"></a>4.3.3 理解SQL注入问题</h4><p>正常情况下，如果用户名和密码输入错误，会查不到数据，返回密码错误。</p><p>假设输入的密码为<code>123456</code>，拼接后的SQL示例：</p><figure class="highlight sql"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure><p>在恶意登录的场景下，可以通过SQL注入规避验证用户名和密码的逻辑，保证始终都能查到数据，不会返回密码错误。</p><p>假设输入的密码为<code>张三&#39; or &#39;1&#39; = &#39;1</code>，拼接后的SQL示例：</p><figure class="highlight sql"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-执行预编译SQL语句"><a href="#4-4-执行预编译SQL语句" class="headerlink" title="4.4 执行预编译SQL语句"></a>4.4 执行预编译SQL语句</h3><h4 id="4-4-1-说明"><a href="#4-4-1-说明" class="headerlink" title="4.4.1 说明"></a>4.4.1 说明</h4><p>PreparedStatement是Statement接口的子接口，用于执行预编译的SQL查询，作用如下：</p><ul><li>预编译SQL语句：在创建PreparedStatement时，会根据模板预编译SQL语句，后续只能填充参数，不能拼接。</li><li>防止SQL注入：在使用PreparedStatement时，会通过<code>?</code>占位符将传入的参数使用单引号包裹起来，有效防止SQL注入问题。</li><li>性能提升：预编译SQL语句在多次执行的情况下可以复用，不必每次重新编译和解析。</li></ul><p>使用后需要手动关闭。</p><h4 id="4-4-2-增删改查"><a href="#4-4-2-增删改查" class="headerlink" title="4.4.2 增删改查"></a>4.4.2 增删改查</h4><p>使用参数新增示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values (null, ?, ?, now(), now())&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    ps.setString(<span class="number">2</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行新增</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;insert=&quot;</span> + insert);</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数新增并返回自增主键示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取预编译执行器，设置需要获取自增主键</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user values (null, ?, ?, now(), now())&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    ps.setString(<span class="number">2</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行新增</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;insert=&quot;</span> + insert);</span><br><span class="line">    <span class="comment">// 获取主键结果集</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.getGeneratedKeys();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + rs.getInt(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    rs.close();</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数修改示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">&quot;666666&quot;</span>);</span><br><span class="line">    ps.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;update=&quot;</span> + update);</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数删除示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行删除</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;delete=&quot;</span> + delete);</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数查询示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行查询，获取结果集</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">2</span>) + <span class="string">&quot;-&quot;</span> + rs.getString(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭结果集</span></span><br><span class="line">    rs.close();</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-解决SQL注入问题"><a href="#4-4-3-解决SQL注入问题" class="headerlink" title="4.4.3 解决SQL注入问题"></a>4.4.3 解决SQL注入问题</h4><p>假设输入的密码为<code>张三&#39; or &#39;1&#39; = &#39;1</code>，经过预编译后的SQL示例：</p><figure class="highlight sql"><figcaption><span>sql</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;张三\&#x27;</span> <span class="keyword">or</span> \<span class="string">&#x27;1\&#x27;</span> <span class="operator">=</span> \<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>在替换参数前会自动对单引号进行转义，从而解决SQL注入的问题。</p><h3 id="4-5-获取结果集"><a href="#4-5-获取结果集" class="headerlink" title="4.5 获取结果集"></a>4.5 获取结果集</h3><p>ResultSet接口用于表示从数据库中执行查询语句所返回的结果集。</p><p>使用后需要手动关闭。</p><h2 id="5-使用事务"><a href="#5-使用事务" class="headerlink" title="5 使用事务"></a>5 使用事务</h2><h3 id="5-1-基础知识"><a href="#5-1-基础知识" class="headerlink" title="5.1 基础知识"></a>5.1 基础知识</h3><p>事务有四种特性：</p><ul><li>原子性（Atomicity）：指事务包含的所有操作要么全部成功提交，要么全部失败回滚。</li><li>一致性（Consistency）：指事务必须使数据库的数据和资源从一个一致性状态变换到另一个一致性状态。</li><li>隔离性（Isolation）：指当多个用户并发访问数据库并且操作同一张表时，数据库为每一个用户开启事务，不会被其他事务的操作干扰，多个并发事务之间相互隔离。</li><li>持久性（Durability）：指一个事务一旦被提交了，对数据的改变就是永久性的，哪怕数据库遇到故障也不会丢失提交的改动。</li></ul><p>涉及事务的几个术语：</p><ul><li>保存点（Savepoint）：指在事务执行前或者事务执行后，数据在数据库里的存储情况，有时也称为状态。</li><li>回退（Rollback）：指撤销事务的操作，事务期间执行的操作都将失效，事务恢复到上个状态。</li><li>提交（Commit）：指提交事务的操作，事务期间执行的操作全部生效，事务进入新的状态。</li></ul><h3 id="5-2-操作事务"><a href="#5-2-操作事务" class="headerlink" title="5.2 操作事务"></a>5.2 操作事务</h3><p>常用方法：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询事务隔离级别</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTransactionIsolation</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setTransactionIsolation</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line"><span class="comment">// 查询自动提交状态</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">getAutoCommit</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 设置自动提交状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAutoCommit</span><span class="params">(<span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line"><span class="comment">// 创建还原点</span></span><br><span class="line">Savepoint <span class="title function_">setSavepoint</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 创建指定名称的还原点</span></span><br><span class="line">Savepoint <span class="title function_">setSavepoint</span><span class="params">(String name)</span>;</span><br><span class="line"><span class="comment">// 删除指定名称的还原点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">releaseSavepoint</span><span class="params">(Savepoint savepoint)</span>;</span><br><span class="line"><span class="comment">// 提交</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 回滚</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 回滚到指定名称的还原点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(Savepoint savepoint)</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码阅读简洁，直接抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(JDBCTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="comment">// 加载驱动，可以省略</span></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">// 取消自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取预编译执行器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">&quot;666666&quot;</span>);</span><br><span class="line">    ps.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;update=&quot;</span> + update);</span><br><span class="line">    <span class="keyword">if</span> (update == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回滚事务</span></span><br><span class="line">        conn.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    ps.close();</span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;摘要：本文学习了如何使用JDBC连接数据库。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://momashanhe.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://momashanhe.com/tags/Java/"/>
    
    <category term="JDBC" scheme="https://momashanhe.com/tags/JDBC/"/>
    
    <category term="MySQL" scheme="https://momashanhe.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
